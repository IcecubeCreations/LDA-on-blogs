Why you should choose RabbitMQ, RabbitMQ overview, Various Message Queue comparison | by Mina Ayoub | MediumGet unlimited accessOpen in appHomeNotificationsListsStoriesWriteMina AyoubFollowJan 15, 2016·11 min readWhy you should choose RabbitMQ, RabbitMQ overview, Various Message Queue comparisonForeword:MQ What is it? What is a queue, MQ we can understand as a message queue, a queue we can understand as a pipeline. Pipeline the way to do messaging.Scenes:1. In fact, when we were in Double 11, when we had a lot of spikes and snapped up goods in the early morning, and then went to checkout, we found that the interface would remind us, let us wait, and some friendly picture text reminders. Rather than the era of the past few years, the page is stuck, the error is reported, etc. to the user.In this business scenario, we can use the mechanism of the queue to deal with, because at the same time, the settlement can only achieve so much.2. Shopping in our usual supermarket is the same. When we are at the time of settlement, we will not flood into the cashier, but queue up for settlement. This is also the queuing mechanism.Yes, it is line up. One after the other, you can’t jump in the queue.Introduction to RabbitMQAMQP, the Advanced Message Queuing Protocol, is an open standard for application layer protocols designed for message-oriented middleware. Message middleware is primarily used for decoupling between components, and the sender of the message does not need to know the existence of the message consumer, and vice versa. The main features of AMQP are message-oriented, queue, routing (including peer-to-peer and publish/subscribe), reliability, and security. RabbitMQ is an open source AMQP implementation. The server is written in Erlang and supports a variety of clients, such as Python, Ruby, .NET, Java, JMS, C, PHP, ActionScript, XMPP, STOMP, etc., supporting AJAX. It is used to store and forward messages in a distributed system and performs well in terms of ease of use, scalability, and high availability. The following sections focus on some of the basic concepts in RabbitMQ. Understanding these concepts is the basis for using RabbitMQ.ConnectionFactory, Connection, ChannelConnectionFactory, Connection, and Channel are the most basic objects in the API provided by RabbitMQ. Connection is the socket link of RabbitMQ, which encapsulates the logic related to the socket protocol. ConnectionFactory is the manufacturing factory of Connection. Channel is the most important interface we deal with RabbitMQ. Most of our business operations are done in the Channel interface, including defining Queue, defining Exchange, binding Queue and Exchange, and publishing messages.QueueThe Queue is an internal object of RabbitMQ that stores messages and is represented by the following figure.Messages in RabbitMQ can only be stored in the Queue. The producer (P in the figure below) produces the message and finally delivers it to the Queue. The consumer (C in the figure below) can get the message from the Queue and consume it.Multiple consumers can subscribe to the same Queue, and the messages in the Queue are evenly distributed to multiple consumers for processing, rather than each consumer receiving all messages and processing.Message acknowledgmentIn practical applications, it may happen that the consumer receives the message in the Queue, but does not process the machine (or other accidents), in which case the message may be lost. In order to avoid this, we can ask the consumer to send a receipt to RabbitMQ after the message is consumed, and RabbitMQ will remove the message from the Queue after receiving the message acknowledgment; if RabbitMQ does not receive the receipt Upon detecting that the consumer’s RabbitMQ connection is broken, RabbitMQ will send the message to other consumers (if there are multiple consumers) for processing. There is no concept of timeout here. A consumer processing a message for a long time will not cause the message to be sent to other consumers unless its RabbitMQ connection is broken. There is another problem here. If our developers forget to send a receipt to RabbitMQ after processing the business logic, this will lead to serious bugs — more and more messages will be accumulated in the Queue; Repeat consumption of these messages and repeat business logic…In addition, the pub message is not ack.Message durabilityIf we want to lose the message even if the RabbitMQ service is restarted, we can set both Queue and Message to be durable, which will ensure that most of our RabbitMQ messages will not be lost in most cases. . But still can’t solve the small probability of loss event (such as the RabbitMQ server has received the producer’s message, but the RabbitMQ server is powered off before the message is persisted), if we need to have such a small probability event Manage it, then we need to use the transaction. Since this is only a brief introduction to RabbitMQ, RabbitMQ related transactions will not be explained here.Prefetch countEarlier we said that if multiple consumers subscribe to messages in the same Queue at the same time, the messages in the Queue will be spread to multiple consumers. At this time, if the processing time of each message is different, it may cause some consumers to be busy all the time, while other consumers will quickly handle the work at hand and remain idle. We can set the prefetchCount to limit the number of messages that the Queue sends to each consumer each time. For example, if we set prefetchCount=1, the Queue will send a message to each consumer every time; after the consumer finishes the message, the Queue will Send a message to the consumer.ExchangeIn the previous section we saw that the producer delivered the message to the Queue. In fact, this would never happen in RabbitMQ. The actual situation is that the producer sends the message to Exchange (switch, X in the figure below), and Exchange routes the message to one or more Queues (or drops).What logic does Exchange use to route messages to the Queue? This will be introduced in the Binding section. There are four types of Exchange in RabbitMQ, and different types have different routing strategies, which will be covered in the Exchange Types section.Routing keyWhen a producer sends a message to Exchange, it usually specifies a routing key to specify the routing rule for the message, and the routing key needs to be used in conjunction with the Exchange Type and the binding key to be effective. In the case that the Exchange Type and the binding key are fixed (usually fixed in normal use), our producers can determine where the message flows by specifying the routing key when sending a message to Exchange. RabbitMQ limits the length of the routing key to 255 bytes.BindingRabbitMQ associates Exchange with the Queue through Binding, so RabbitMQ knows how to properly route messages to the specified Queue.Binding keyBinding Exchange and Queue generally specify a binding key; when a consumer sends a message to Exchange, a routing key is usually specified; when the binding key matches the routing key, the message will be routed. Go to the corresponding Queue. This will be explained in the Exchange Types section with practical examples. These Bindings allow the same binding key to be used when binding multiple Queues to the same Exchange. The binding key does not work in all cases. It relies on the Exchange Type. For example, a fanout type of Exchange ignores the binding key and routes the message to all Queues bound to the Exchange.Exchange TypesRabbitMQ commonly used Exchange Type has four types: fanout, direct, topic, and headers. (The AMQP specification also mentions two Exchange Types, system and customization, which are not described here).FanoutThe fanout type of Exchange routing rules is very simple, it will route all messages sent to the Exchange to all Queues bound to it.In the figure above, all messages sent by the producer (P) to Exchange (X) are routed to the two Queues in the diagram and eventually consumed by two consumers (C1 and C2).DirectThe direct type of Exchange routing rules is also very simple, it will route messages to the Queue that exactly matches the binding key and the routing key.For the configuration of the above figure, we send a message to Exchange with routingKey=”error”, and the message will be routed to Queue1 (amqp.gen-S9b…, which is the Queue name automatically generated by RabbitMQ) and Queue2 (amqp.gen- Agl…); If we send a message with routingKey=”info” or routingKey=”warning”, the message will only be routed to Queue2. If we send a message with another routingKey, the message will not be routed to both Queues.TopicAs mentioned above, the direct type of Exchange routing rules completely match the binding key and the routing key, but this strict matching method can not meet the actual business needs in many cases. The topic type Exchange is extended on the matching rule. It is similar to the direct type Exchage. It also routes the message to the Queue that matches the binding key and the routing key. However, the matching rules here are somewhat different. It stipulates:The routing key is a string separated by a period “.” (we will refer to each separate string separated by a period “.” as a word), such as “stock.usd.nyse”, “nyse. Vmw”, “quick.orange.rabbit”The binding key is the same as the routing key, which is also a string separated by a period “.”.There are two special characters “*” and “#” in the binding key, which are used for fuzzy matching, where “*” is used to match one word and “#” is used to match multiple words (can be zero)For the configuration in the above figure, the message routingKey=”quick.orange.rabbit” will be routed to both Q1 and Q2, and routingKey=”lazy.orange.fox” will be routed to Q1 and Q2, routingKey=”lazy. The message “brown.fox” will be routed to Q2, and the message routing@=”lazy.pink.rabbit” will be routed to Q2 (only will be delivered to Q2 once, although this routingKey matches both binding keys of Q2); routingKey=” Messages for quick.brown.fox”, routingKey=”orange”, routingKey=”quick.orange.male.rabbit” will be discarded because they do not match any bindingKey.HeadersExchanges of the headers type do not rely on the matching rules of routing key and binding key to route messages, but match according to the headers attribute in the content of the sent message. Specify a set of key-value pairs when binding Queue and Exchange; when the message is sent to Exchange, RabbitMQ will get the headers of the message (also a form of key-value pairs), and compare whether the key-value pairs match Queue exactly. The key-value pair specified when Exchange is bound; if it matches exactly, the message will be routed to the Queue, otherwise it will not be routed to the Queue. This type of Exchange has not been used (but it should be useful), so I won’t cover it.RPCMQ itself is based on asynchronous message processing. In the previous example, all producers (P) will not know if the consumer © has succeeded or failed after sending the message to RabbitMQ (even if there is no consumer to process this message). Do not know at all). However, in the actual application scenario, we are likely to need some synchronization processing, and we need to wait for the server to process my message and then proceed to the next step. This is equivalent to RPC (Remote Procedure Call). RPC is also supported in RabbitMQ.RPC The mechanism implemented in RabbitMQ is:When the client sends a request (message), two values ​​are set in the properties of the message ( MessageProperties in the AMQP protocol defined in 14 properties , these properties will be sent along with the message) replyTo (a Queue name that tells the server that the notification will be notified when the processing is complete) My message is sent to this Queue ) and correlationId (the identification number of this request, the property needs to be returned after the server processing is completed, the client will know which request was successfully executed or failed according to this id)The server receives the message and processes it.After the server finishes processing the message, it will generate a reply message to the replyTospecified one Queue , with the correlationId attribute at the same time.The client has subscribed to the replyTo specified one Queue . After receiving the response message from the server, it correlationId analyzes which request is executed according to the attributes, and performs subsequent business processing according to the execution result.To sum upThis article introduces the RabbitMQ concepts that individuals consider to be the most important, and takes advantage RabbitMQ of the capabilities provided to handle most of our asynchronous business.RabbitMQ Selection and Comparison1. From community activityAccording to the current information on the Internet RabbitMQ , activeM and the ZeroMQ three, the overall view RabbitMQ is the first choice.2. Persistent message comparisonZeroMq Not supported, ActiveMq and RabbitMq both are supported. Persistence message mainly refers to the mechanism that our machine hangs under the circumstances of force majeure, and the message will not be lost.3. Comprehensive technology implementationReliability, flexible routing, clustering, transactions, highly available queues, message sequencing, issue tracking, visual management tools, plug-in systems, and more.RabbitMq / Kafka Best, ActiveMq second, ZeroMq worst. Of course, ZeroMq you can do it, but you must manually write the code to achieve it, the amount of code is not small. Especially in reliability: persistence, delivery confirmation, publisher verification and high availability.4. High concurrencyUndoubtedly, the RabbitMQ highest reason is that its implementation language is a language that is naturally high and concurrently available erlang .5. Comparison of concerns, RabbitMQ and KafkaRabbitMq More Kafka mature than in terms of usability, stability, and reliability, RabbitMq is better than Kafka (theoretically).In addition, Kafka the positioning is mainly in the log and so on, because Kafka the original intention of the design is to process the log, it can be regarded as an important component of a log (message) system, and the pertinence is very strong, so if the business aspect is still recommended RabbitMq .Also, Kafka the performance (throughput, TPS ) is RabbitMq much higher than that.Final selection:If we already have Kafka or RabbitMq in our system and can fully satisfy the current business, it is recommended not to repeat and add wheels.You can choose one of Kafka and RabbitMq for your team and business. This is the most important. However, there is no doubt that at this stage, there is no third choice for comprehensive consideration.------More from Mina AyoubFollowI'm enthusiastic about being part of something greater than myself and learning from more experienced people every time I meet them.Love podcasts or audiobooks? Learn on the go with our new app.Try KnowableAboutHelpTermsPrivacyGet the Medium appGet startedMina Ayoub830 FollowersI'm enthusiastic about being part of something greater than myself and learning from more experienced people every time I meet them.FollowMore from MediumAjin SunnyPush CDN vs Pull CDNSujata RegotiAsync Processing APIJosué CarvajalAn overview of message brokersRiker Guevara, Ph.DList Based StackHelpStatusWritersBlogCareersPrivacyTermsAboutKnowable






































