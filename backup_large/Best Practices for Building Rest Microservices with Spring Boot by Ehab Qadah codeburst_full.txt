Best Practices for Building Rest Microservices with Spring Boot | by Ehab Qadah | codeburstOpen in appHomeNotificationsListsStoriesWritePublished incodeburstEhab QadahFollowJul 29, 2020·9 min readSaveBest Practices, Tips, and Practical Tricks: What You Should FollowBest Practices for Building Rest Microservices with Spring BootA collection of best practices and techniques for developing REST-based microservices using Spring Boot.Photo by Clark Tibbs on UnsplashThe goal of this article is to give you a collection of recommended best practices and techniques for building Java REST microservices using Spring Boot. These recommendations are designed to help you create an efficient, maintainable, and effective Spring Boot based microservices. Spring Boot has become the de-facto standard for Java™ microservices, it has many purpose-built features that ease building, running your microservices in production at large scale.This list of best practices is built based on my experience in running microservices-based architecture on Google Kubernetes Engine (GKE). I have seen and applied these approaches in several projects, and over the years, I have formed a pretty strong opinion about them. We will walk through the different factors and guidelines that should be considered when building REST-based microservices using spring-boot, and explaining how they help you to implement more robust, well-founded, and successful microservices.This article assumes that you are familiar with Java, spring-boot concepts such as Spring Data JPA, Spring Data REST, Docker/Kubernetes basic concepts, and general knowledge in microservices architecture. Given that implementing microservices architecture with a foundation of best practices can drastically improve your software architecture. However, we focus only on the REST-based microservices without considering other types like Event-Driven microservices.You may or may not agree with some of the best practices presented here, and that’s absolutely fine as long as it drives you to research and examine these best practices while developing spring-boot based microservices, that will help you to build better microservices as much as possible.Design REST APIs optimallyAs a general best practice, you should group all related APIs in single controller oriented around a use-case (e.g., Aggregator APIs or Domain APIs). While keeping them clean and focused, you should follow the best practices for the REST APIs design such as:Use nouns instead of verbs in the endpoint paths, which represent entities/resources to fetch or manipulate and use consistently plural nouns such as /orders/{id}/products over /order/{id}/product.The operation must be represented by the HTTP request, GET retrieves resources. POST creates a new data record. PUT updates existing data. DELETE removes dataNesting resources for hierarchical objectsProvide filtering, sorting, and paginationConsider API VersioningAPIs should be fully documented.Controllers are not supposed to perform any business logic apart from routing and delegating the action to the proper services. You must enforce separation of concerns by keeping the controllers as light as possible. Let’s take a look at an example of a REST controller considering the above points:OrderControllerThe @RequestMapping annotation provides “routing” information, use the consume and produce annotation to define what the endpoint accepts for the request payload and what it returns as a response, where JSON is used in 99% of cases it for REST APIs. Given Server and Client-sides technologies have libraries that can encode/decode JSON without doing much work.The @Operation & @ApiResponse annotations allow you to add some description to the API documentation with the Open API 3.0 specification. For instance, here is the Swagger UI page for our APIs:OpenAPI 3 documentations with swagger UIIn a nutshell, it is important to design REST APIs properly while at least considering the performance and ease of use for the API clients.EntitiesIt is strongly recommended that you use a base class for entities with manually assigned customized identifiers and common properties, as shown in the following example:BaseEntityBaseIdentifierGeneratorUse Data Transfer Objects (DTOs)While it is also always possible to expose directly the JPA/database entities representation in the REST endpoints to send/receive data from the client. However, this is not the best approach even though it sounds the easy and obvious way, there are several reasons to do not that:It creates high coupling between the persistence models and the API models.The complexity of the hiding or adjusting some field values in the API response based on the user roles and access permissions or some other business rulesPossible vulnerabilities or misuse by when the client is able to override some auto-generated database fields such as primary Id or modified date-time or system fields accessIt exposes the implementation details of the applicationIt makes it harder to add, remove or update any field of the database entities without changing the API or change the data returned by a REST endpoint without changing the internal database structureSupporting multiple versions of an API becomes more challengingThe better approach is conceptually a more simple one, which is defining a separate data transfer object (DTO) that represents the API resource class which is mapped from a database entity or multiple entities, given that they are serialized and deserialized in the API, her is an example of designing a DTO class for an entity:A DTO class for creating a new Order that contains only properties can be set by the API client.On the other hand, You won’t need to map your persistence entities to DTOs and vice versa manually, you can use a library like ModelMapper or MapStruct that handles the conversion automatically. As a summary, Using DTOs enables the REST APIs and the persistence layer to evolve independently of each other.Leverage java bean validationBefore transforming DTO to your API Resource you always want to ensure that the DTO has valid data, where it should be assumed to be bad until it’s been through some kind of validation process.javax.validation is the top-level package for Bean Validation API and it has some predefined annotation-based constraints, so you can annotate the DTO/entity with javax.validation.constraints.* such as @NotNull, @Min, @Max, and @Size, @NotEmpty, and @Email as shown in the OrderIncomingDto class.We should annotate controller input with @Valid to enable bean validation and activate these constraints on the income @RequestBody. If the bean validation is failed, it will trigger aMethodArgumentNotValidException. By default, Spring will send back an HTTP status 400 Bad Request. In the next section, I will describe how to customize the error response for the validation errors.Use global/custom errors handlerBecause there are multiple ways a service can crash or break, we must ensure that any REST APIs handle errors gracefully using standard HTTP codes that help consumers in such cases. It is always recommended to build out meaningful error messages for the client, with the clear goal of giving that client all the info to easily diagnose the problem, the following example shows how to define a general exception handler by extending the ResponseEntityExceptionHandler:GeneralExceptionHandlerTo summarize, a few points to consider for error handling as implemented in the above class:To return a correct status code for each type of exception such as BAD_REQUEST(400) for requests with invalid data.Include all relevant information in the response bodyHandling all exceptions in a standardized wayLog all exceptions message and traces for debugging and monitoring purposesAnd here is an example of the returned response in case of validation errors:Invalid request for creating a new order.Use database migration toolsIt is always easy and simple to start with the auto-generation of the database schema based on the entity definitions when using a relational database with Spring Boot using the DDL generation of Spring Data JPA (by adding schema.sql and data.sqlfiles) or letting Hibernate to automatically create the schema by setting spring.jpa.hibernate.ddl-auto to create or update. However, it is highly recommended to use higher-level migration tools Flyway or Liquibase. Such tools provide us a version control of the database schema and keep track of the current state of the database and determine the required steps to migrate the database schema in a fine-grained way.Properties and configurationAccording to the 12-factor application methodology, Configuration that varies among deployment environments should be updated without changing any code. In practice, they are stored in environment variables.Fortunately, spring-boot makes this relatively straightforward, where you define configurations with placeholders in application.properties. These configuration properties can be set on the command line or by updating environment variables. For example, you can configure the Spring Data JPA including MySQL DataSource and Hibernate properties as follows:For instance, you can define the value of a property through the Kubernetes deployment’s environment variables:Also worth mentioning that spring-boot supports configuration per environment based on the active profile, we can change configuration sources for dev and production profiles by using two files named application-dev.properties and application-prod.properties.Monitoring and availabilityUse the spring-boot-actutor to expose out of the box endpoints to that let you monitor and interact with your application, which can be achieved by adding the pring-boot-starter-actuator starter dependency:<dependency>    <groupId>org.springframework.boot</groupId>    <artifactId>spring-boot-starter-actuator</artifactId></dependency>Under the hood : the /actuator/health endpoint will be then automatically exposed that provides basic health information, we will get the following response when calling it:Health endpoint responseHealth check endpoints let the system know if an instance of your microservice is working and available to serve client requests (alive) or not (dead). Furthermore, you can set up the Liveness and readiness probes for spring boot microservices deployed on Kubernetes, as shown in the following example:Liveness and Readiness setup for Kubernetes deploymentWhere you can configure which Health Indicators are part of the probes as follows:For more detailed information about production-ready features in spring-boot, refer to specification here.Containerize itA Dockerfilefor a spring-boot application could look like:DockerfileThe final Docker image is built using multi-stage builds feature that copies the result from one image to another, where the first image is labeled as “build” and it is used to run Maven and generate the fat jar from the source code, and the second image is used to run the microservice.General guidelines and recommendationsDON’T FORGET to test your code by writing unit and integration tests. It’s not an exaggeration to say that each piece of code and API must be covered by a test!Add monitoring alert for failures and downtimesAutomate build and deployment management (CI/CD pipeline) e.g., using Jenkins or bitbucket pipelinesAlways use the latest releases by regularly upgrading the dependenciesWrite clear and concise logs that are easy to read and parseConsider applying Domain-driven Design (DDD) principlesCache data to improve performanceSecure your APIsFinally, microservices should be kept as small as possible as only one business function per serviceSummaryThis post has covered a list of best practices for spring-boot based microservices, I hope that following these best practices will help you build more robust and successful microservices in spring-boot. These factors do not have to be strictly followed. However, keeping them in mind allows you to build portable applications or services that can be built and maintained in continuous delivery environments.The complete source code of this article is available in the GitHub project.Further reading & references:Spring Boot Reference Documentationpackage com.example.myapplication; import org.springframework.boot.SpringApplication; import…docs.spring.ioBest practices for REST API design - Stack Overflow BlogBest practices on how to design REST APIs to be easy to understand, future-proof, and secure and fast.stackoverflow.blogSpring Boot DockerMany people are using containers to wrap their Spring Boot applications, and building containers is not a simple thing…spring.iospringdoc-openapispringdoc-openapi java library helps automating the generation of API documentation using spring boot projects…springdoc.orgSpring REST Validation Example - Mkyong.comIn this article, we will enhance the previous Spring REST Hello World example, by adding bean validation and custom…mkyong.comBest practices for writing DockerfilesThis document covers recommended best practices and methods for building efficient images. Docker builds images…docs.docker.comSecure Secrets With Spring Cloud Config and VaultIn 2013, GitHub released a search feature that allows users to scan code all public repositories. A day after the…developer.okta.comCreate Data Transfer Objects (DTOs)by Mike Wasson Download Completed Project Right now, our web API exposes the database entities to the client. The…docs.microsoft.comRESTful API Best Practices and Common PitfallsAs a person who spends his day integrating systems, I’ve found that at least half of the APIs I use radically differ…medium.comdomain driven designWhen programming, I often find it's useful to represent things as a compound. A 2D coordinate consists of an x value…martinfowler.combliki: BoundedContextBounded Context is a central pattern in Domain-Driven Design. It is the focus of DDD's strategic design section which…martinfowler.comSpring Security ArchitectureThis guide is a primer for Spring Security, offering insight into the design and basic building blocks of the…spring.ioThanks toYazan Ghandour--2----2More from codeburstFollowBursts of code to power through your day. Web Development articles, tutorials, and news.Read more from codeburstRecommended from MediumSpacely2/Revealed: Why Does The Current E-Learning Ship Is Sinking? (And How To Rescue It)Andreas JanssonHow YC advice helped me build a Coronavirus delivery serviceSébastien Dubois.DeveloPassion’s Newsletter — Midweek Links #3C-NFTAgencyThe Cardanocade NFT ProjectAnish YellaturuCS373 Blog Oct 12- 18Elif GerdanSparkify, why’d you leave?Atul Sharmain47BillionFlutter : How does it worksRachael RayinHackerNoon.com4 Major Reasons To Choose Magento 2 In 2018AboutHelpTermsPrivacyGet the Medium appGet startedEhab Qadah73 FollowersSenior SoftwareEngineer/Lead.FollowMore from MediumLama AlosaimiinDev GeniusSpring Boot Application With Multiple Data sourcesRuby ValappilinJavarevisitedHow to Use Spring Cloud Gateway to Dynamically Discover MicroservicesSouhailYour guide to a MicroService architecture, building your first microservice using spring boot and…Ramakrishna Reddy PoluMicroservices #Circuit BreakerHelpStatusWritersBlogCareersPrivacyTermsAboutKnowable





































