Communication patterns in a Microservice world | by Diogo Lucas | MediumGet unlimited accessOpen in appHomeNotificationsListsStoriesWriteDiogo LucasFollowJan 16, 2017·6 min readCommunication patterns in a Microservice worldOk, so you drank the microservice kool-aid and that’s everything you intend to do from now on. By the time you implement your second service (or even better, refactor an existing one into two smaller pieces), you have to think of communication between MSA modules. At first, things are simple enough, so you pick a weapon of choice (say, REST) and use it. Then again. And yet another time. And before you know it, you have implemented a chatty, reflective and frail set of interfaces.Hardcore fans of a given communication model are probably already shouting (in their heads, I hope, seriously, people, stop it) “THIS IS A PERFECT CASE FOR REST/EVENT-SOURCING/ACTORS/UNICORN-BASED-MESSAGING!” when, in reality, it usually isn’t. These approaches either preconize a very specific way of setting up interfaces or are broad enough that different, inconsistent patterns may arise if no care is given. And that violates an important rule of thumb:While microservices allow easy disposal of modules, they require careful consideration of cross-cutting protocols.So, let’s break that statement into chunks and justify it, shall we?easy disposal of modules: if each service is sufficiently a) small and b) isolated, they should be cheap and fast to create and maintain. This allows a fast-paced delivery of new features while keeping potential technical doubt under control;they require careful consideration of cross-cutting protocols: microservices are no silver bullet against complexity, pushing it outside of service boundaries. Where does it go, then? To the interaction between these modules. Requests to implement something akin to distributed transactional behavior across systems or simply performing calls over diverse syntaxes (eg: payloads, url routes, HTTP verbs) can easily become nightmarish if teams do not reach a consensus in terms of standards (yeah, that ugly word).CommandsA command happens when a client system needs an action to be performed by a given service provider. The client may also need a response (in either a sync or async way) informing about the operation result . The core things to keep in mind are:this promotes some coupling, as client (and potentially provider) are made aware of one another;coupling becomes tighter in case the client needs a response, as this means it will need to a) wait and b) handle all possible outcomes of the operation (including unavailability);coupling becomes tighter in case of synchronous calls, since the provider needs to process the request at the time it is made. For an in-between solution, a common pattern is to provide a simple “accepted” answer synchronously and do the heavy-lifting in an async fashion;time-bound operations increase interaction complexity: if a client issues a command and needs an answer in up to a minute, what should it do after the timeout? What should it do if the provider still processed the request after, say, 2 minutes?A cousin to the this pattern is the query. While a different beast in nature (it shouldn’t be data altering, for example) and potentially something that can be implemented in a radically different way (see CQRS, which, BTW, proposes similar concepts) the bullet points above are still valid for such operations.A part of the popularity of commands is that, at the end of the day they are very easy — no wonder most of us are introduced to programming by relying exclusively on it (yeah, HelloWorld, I am talking about you).Having said all that, this pattern is frequently unavoidable: you will need an answer from the credit card service in your e-commerce before you move forward in the order process, no matter how much you would like to avoid it.EventsAn event refers to an occurrence in the past. That simple statement carries a number of consequences:events are immutable. You can’t say “nonono, that order wasn’t submitted, I won’t have that!”. It’s a done deal, there’s nothing you can change about it. You can, at most, react to it;the emitter can be completely oblivious of the event listeners. Just publish it somewhere and let consumers react to it as they see fit;the listeners may also be oblivious of the emitter — in case the event messages flow through a shared channel (eg: a message queue), this is the only address they need;the overall process is async by nature;therefore, this pattern allows fairly decoupled communication. The event emitter is saying “look, buddy, this is what happened, do what you will”. If well implemented, the provider does not even know who are the clients listening to that event — it simply doesn’t care. Think of it as a news outlet: broadcasting to a large audience is fairly the same process, no matter the audience size.This pattern has been around for ages, especially in UI-focused stacks: old-time languages such as Delphi had events as a first-class citizen and newer, trendy libs such as redux are designed around event-based flows. In the big architecture world, buzzwords such as Event-Driven Architecture, Event Sourcing and others revolve around this concept.In case this is starting to sound like a sales pitch, please beware that it’s not all flowers in the event world:due to its async nature, developers have to worry about correlation: you ask for something (eg: create an order for me) and things start happening (eg: picking, packing, invoicing), in parallel to other people’s requests. To find the events you care about, you need a tracking number of sorts, so you can tie things together;implementing something similar to a distributed transaction becomes a major challenge as each event is a) independent and b) immutable, hence you cannot roll it back. There is no simple answer to that and possible approaches include business process changes, compensating operations and eventual consistency (and quite commonly a mix of them);since processing is so distributed, systems that are sensitive to ordering have a major hard time coping with all the inherent non-determinism of when they receive messages. There are systems out there, such as Kafka, that allow some ordering support, but quite frequently any ordering-bound logic needs some level of revision;in a web world, protocols for this pattern are not as close to consensus as for commands (AKA REST). But in case the server is publishing events, how can they be made easily available for consumers? Web sockets? SSE? Polling (yuck)? Web hooks? The fact that so many methods exist shows that none can be claimed king of the hill;all the points above considered, while this approach may scale and extend better over time, it usually presents a higher ticket to entry, leading teams to defer a push towards events until it’s absolutely required (or, unfortunately, even later);In a nutshellUse commands if:The service client needs the operation response in order to move further with its process;The operation needs to be synchronous;The call is a simple query (long-running ones may require scheduling);Consider using this approach if you are just getting started, as it tends to be simpler at first;Use events if:It is a commonly sought-after message (eg: an order has been invoiced), meaning a single message may be read by multiple clients;The producer of the information does not care about extra processing done by whoever is consuming it — those extraneous operations should have no impact on the original results;Consider introducing this as your architecture grows, as a pure command pattern does not scale well over a larger problem set;Further readingNone of the concepts above is radically new and can be found in seminal text on topics such as:Event-driven Architecture proposes events as a centerpiece kind of message for decoupled communication between different systems.Event sourcing goes one step further and suggests that application state emanates from events, allowing a) a clear separation of both (each kind of data can be stored with different strategies) and b) the composition of events into multiple consolidated visions (financial and fulfillment aggregations on order data);CQRS uses the difference between commands and events to propose models in which write and read operations are asymmetric to one another, so it is a great match with event sourcing;Reactive programming, in many of its flavors, uses events as a core concept.--1----1More from Diogo LucasFollowLove podcasts or audiobooks? Learn on the go with our new app.Try KnowableRecommended from MediumJonathan HsuinCode 85How to Use Mutual Exclusivity in ProgrammingNaveen SrivastavainFlutterDevsExpanded and Flexible in flutterDibya Darshan KhanalThe ‘image’ attribute has no file associated with itAmila HewagamaInstall Flask in virtual environment in windows 10ZuzidyWherever you are in life, and based on who is around you, and based on your current aspirations…Jonathan LangeinWeaveworks BlogWhat is Cortex?Mahesh SamaradiwakaraThe ABC’s of ARKit: An Introduction to ARKit in SwiftLee Martin“Hey There Nostalgia”AboutHelpTermsPrivacyGet the Medium appGet startedDiogo Lucas308 FollowersFollowMore from MediumLuci BroMicroservices did you know this ?Phillip KigenyiinDev Scribbles1. Microservices foundationYasser KarimiEnterprise Application Architect- Part 1AlexgreatdevImplementing Domain-Driven DesignHelpStatusWritersBlogCareersPrivacyTermsAboutKnowable






































