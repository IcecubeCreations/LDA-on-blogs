Go vs Java — JSON serialization and deserialization | by Alin Velican | MediumGet unlimited accessOpen in appHomeNotificationsListsStoriesWriteAlin VelicanFollowDec 28, 2019·4 min readGo vs Java — JSON serialization and deserializationI know there is no link between Go, Java and cats, but who doesn’t like cats? :)Photo by Raul Varzar on UnsplashWhen somebody wants to develop a new web application, no matter what that application will do, for sure there will be a layer where you will need to deal with JSON serialization and deserialization. No matter what your business requirements are, you for sure will need to receive some data, understand it, do your magic, and after that send back. For this, you need to deserialize, apply your business rules, serialize and send back. So for most of the time, your application will do this work, even if you don’t really see it because every language or framework try to hide this from you.What are we going to do?For this test we are going to test just this small part of a web application. So we will just read some JSON, deserialize it and serialize it. There will be no read from files to not involve any other moving parts. Just JSON part. We will KISS.Unexpected resultsWhen I started this test, I admit that I started just to see how good Go will do, and how poor Java is, but when I actually run the code, I was shocked! Not really shocked, but surprised for sure. So let’s see what happend!Java CodeI started with Java deserialization. I have a simple Java class with few fields and the Main class where deserialization happens. For this I use Jackson library.And results: 7.096s for 10000000 iterationsGo codeI have a similar Go struct and main funcAnd results for Go: 34.607s for 10000000(same as for Java) iterations. Again, unexpected results, seems that Go standard library for JSON is about 5 times slower than Jackson library in Java.Serialization testFor Java I have the following codeAnd results: 3.582s for 10000000 iterationsFor Go:And results 8.428s for 10000000 iterations. There is still a big difference between Java and Go, but Go seems to be recovering.EasyJsonIntrigued by the fact that my expectations was unmet, I started to find out what can be improved with Go. After all Go it is a compiled language and at least in theory should be faster. In fact it is a known problem with the poor performance of Go standard Json library. The main problem is that encoding/json library use reflexion, and because of this we have this problem. I find out that there are actually a lot of 3rd party library which deal with Json in Go, and one of the best known is easyjson. Because this one use no reflection, we need to work with generated code. For a detailed tutorial for easyjson you can take a look here: https://github.com/mailru/easyjson. After I install and generate the code, the only one modification was to change json.Marshal with easyjson.Marshal(or Unmarshal)New results: For serialization now I get 3.513s while with standard library I get 8.428s. This result is similar with Java one where I get 3.582s. For deserialization with easyjson I get 12.354s while with standard library I get 34.607s. Still weaker than with Java where for same thing it takes just 7.096s.But Java can do even better if you use jsoniter with dynamic code generation. For more details take a look here http://jsoniter.com/java-features.html The main point is that you need to have all fields public and you have to use javassist. This is the new codeAnd results 4.750s. About 3 times faster than easyjson Go version.Final wordsEven though from that test, an extreme one actually, because 10.000.000 iterations for same thing it is not a real world use case. For example if I run the test for just 100.000, Go version is twice faster, and for smaller number of iterations Go version is even faster. This is happening probably because of JVM cold start-up. The reason for Java getting so fast after a huge number of repetitions is because of its magic JIT optimisations. Of course we have to look also in the memory consumptions. For Java we have 830MB of RAM while working and 24 threads.And for Go we have only 5.7MBIn term of performance this are also very important numbers. And even maybe Go for this specific task is 3 times slower, it takes 150 times lower memory.If you want to see more comparisons between Java and Go take a look in my others stories:Go vs Java.Reading from file and counting words using a map.medium.comGo vs Swift vs Spring Boot vs Spring WebFluxComparing the new with the old.medium.com------More from Alin VelicanFollowLove podcasts or audiobooks? Learn on the go with our new app.Try KnowableRecommended from MediumIMRON EEDKERDGetting Started with the Facebook Unity SDKAnisha ChughDigitally signing a document using DocuSign/dev/colorinThe CompilerReal Talk with Alan JohnsonnightAim Journey ⛰️- Week 5Nipun KaveendraEverything is an  Object !Fatos MorinaHow to change the default new line delimiter in RubyTechnologies In Industry 4.0inDataDrivenInvestorHow to work with MongoDB?shubham jaroliintech@iiit-gwaliorGO- The Programming Language of FutureAboutHelpTermsPrivacyGet the Medium appGet startedAlin Velican65 FollowersFollowMore from MediumA Byte of CodingA Byte of Coding Issue #208Ruby ValappilinCodeXHow to Get Started with GoLang as a Java DeveloperGene ZeinissinGeek CultureThe Three Little Pigs in Go LanguageJayadev RajanGet Set Go(lang).. as a Java ProHelpStatusWritersBlogCareersPrivacyTermsAboutKnowable






































