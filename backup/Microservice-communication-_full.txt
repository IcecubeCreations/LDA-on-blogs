














Microservice communication
        























 














LinkedIn and 3rd parties use essential and non-essential cookies to provide, secure, analyze and improve our Services, and to show you relevant ads (including professional and job ads) on and off LinkedIn. Learn more in our Cookie Policy.Select Accept to consent or Reject to decline non-essential cookies for this use. You can update your choices at any time in your settings.



                Accept
                

                Reject
                


 





LinkedIn






              Arpit Jain
 
Expand search










              Jobs
            



              People
            



              Learning
            












Dismiss






Dismiss

















Dismiss


 











Dismiss


 

















Dismiss














          Join now
        
Sign in





 







 




 




              Microservice communication
            









                  Report this post
                


 







            
          
        Arpit Jain
      
      
          




            
        Arpit Jain
      
          

              
        Senior Engineering Manager at Walmart Global Tech India
      
            


              
        
          Published Jan 12, 2020
      
      
            



          + Follow
        





Nowadays the web is moving towards monolith to microservices. If you have not yet adopted this architectural pattern, you are behind the world. Effective and clear communication among distributed component is essential for microservice architecture to work well for your software organization. Monoliths are broken down into smaller domain-specific applications afford looser coupling of components along network boundaries. Once those components are defined, the following step is to define how those components communicate across the network.I am covering some basic ground before choosing the appropriate communication style for implementing your applicationsWill your application be talking to a Different type of clients like a web browser, mobile client etc. ?Will your APIs are going to be exposed as private or public? Will your application need something that HTTP cannot do? Currently, HTTP/1.1 is widely used and HTTP/2 is gaining adoption. Does your application need persistent or long-lived connections with other applications?How your application will talk to each other synchronous way or asynchronous way?How big your payload data would be over the network? What is the scale you are looking for?In this post, I am going to talk about the most popular approach nowadays - REST, RPC and Event-DrivenIt always depends upon the application to application, where to use REST, RPC and Event-driven. Before getting into it directly let's just quickly understand what those 3 terms mean.REST - REpresentational State TransferREST is an architectural style for APIs. REST insists on uniform interfaces which is fundamentally making a call to a resource. The resource now becomes the domain that has the data. The resource does not concern itself with functionality at all. REST API’s only concern is all the data that belongs to that specific domain. REST is also widely used. A lot of people have experience with it and a lot of other web services (and clients) use REST. Having a REST web service makes it easier for other people to interact with your web service. Communication often happens using a JSON, which is human readable. This makes it easier for developers to determine if the client input is sent correctly to the server, and back. HTTP has become the de facto standard for creating uniform REST APIs. What results is a communication style that inherits the semantics of HTTP. Hypermedia — layered as text, images, audio, video, graphics — are identified, retrieved, and manipulated using CRUD via the operations POST, GET, PUT, and DELETE (we can think of PATCH as a special case of PUT). For more details please refer my previous post - RESTBut one of the main advantages of REST is that it does not need to set up a client. You just make a call to a server address. This even works if you just copy a REST server address (of a GET method) in your web browser. Other techniques, like gRPC, often require you to set up a client.Pros:Simple to understand and implement, doesn’t require huge knowledge to start working with itSoftware Industry “standard” and widely adopted (because everybody is using something a bit differently)Requests and responses are usually human-readableSupported by a huge number of libraries (both for client and server)Cons:Topics like design specific queries, versioning, Search endpoint, etc, there a no standard way to define or implement it.Streaming is often difficultNo standard schema for endpoints — people try to fix this using e.g. Swagger or RAML.RPC - Remote Procedure CallRPC style of communication allows for a more specialized semantics but is also less opinionated about agreeing to a standard protocol of information exchange. Rather, clients and servers are stubbed so that remote procedure call seems like local procedure calls but over a network boundary. Instead of accessing remote services by sending and receiving messages, a client invokes services by making a local procedure call. The local procedure hides the details of the network communication.We call the machine making the procedure call as a client and the machine executing the called procedure as a server. For every procedure being called, there must exist a piece of code which knows which machine to contact for that procedure. Such a piece of code is called a Stub. On the client-side, for every procedure being called we need a unique stub. However, the stub on the server-side can be more general; only one stub can be used to handle more than one proceduresAn RPC endpoint is useful for working with a narrow view of the data. This reduces the bandwidth you use on the network and simplifies the service. You can be as specific or as narrow as you want as long as it does what you need. What is nice about RPC is that you have a way of creating services that do one job well.gRPC by Google and Square represents an incremental step in the progress of scaling RPC for cloud solutions. gRPC can use protocol buffer for data serialization. This makes payloads faster, smaller and simpler. Just like REST, gRPC can be used cross-language which means that if you have written a web service in Golang, a Java written application can still use that web service, which makes gRPC web services very scalable.gRPC runs on top of TCP, which means it outsources the problems of connection management and reliably transmitting the request and reply messages of arbitrary size. Second, gRPC actually runs on top of a secured version of TCP called Transport Layer Security (TLS) means it outsources responsibility for securing the communication channel, gRPC actually, actually runs on top of HTTP/2 (which is itself layered on top of TCP and TLS), meaning gRPC outsources yet two other problems: (1) efficiently encoding/compressing binary data into a message, (2) multiplexing multiple remote procedures calls onto a single TCP connection. It makes use of binary data rather than just text which makes the communication more compact and more efficientIt is also type-safe. This basically means that you can’t give an apple while a banana is expected. When the server expects an integer, gRPC won’t allow you to send a string because these are two different types.Workflow with gRPC is quite simple, first, you need to define .proto file defining services, requests and response formats, and then you copy this file to all projects which will communicate with each other. The only thing you need to do is to convert your domain objects to the generated classes. Protocol buffer is used to define endpoints schemas. Protocol Buffers or protobufs, are a way of defining and serializing structured data into an efficient binary format, also developed by Google. Protocol buffers were one of the main reasons we chose gRPC as the two work very well together. We previously had many issues related to versioning that we wanted to fix. Microservices mean we have to roll changes and updates constantly and so we need interfaces that can adapt and stay forward and backwards compatible, and protobufs are very good for this. Since they are in a binary format, they are also small payloads that are quick to send over the wire.Pros:Fast because of binary formSupported by many languages (you can communicate e.g. Java with Python)Supports streaming, both for method parameters and as responsesProvides generators which based on .proto definition generates serializers and deserializers.Build-in support for API changes —Protobuf schema evolutionCons:Less known, higher learning curve due to learning of Protobuf etc.Not human readable, additional tools are needed e.g. to manually test APIEvent / Message Driven - AsynchronousThis is entirely asynchronous communication where the client after sends the request do not wait for a response and remove the coupling between services altogether. In this case, we are simply raising an event and it depends on the consumer if he will take an action or stay chill. Also a very nice independent solution of internal communication, but again, Implementing this will be complicated and time-consuming.Event-based communication, a microservice publishes an event when something notable happens, such as when it updates a business entity. Other microservices subscribe to those events. When a microservice receives an event, it can update its own business entities, which might lead to more events being published. This is the essence of the eventual consistency concept. This publish/subscribe system is usually performed by using an implementation of an event bus. The event bus can be designed as an interface with the API needed to subscribe and unsubscribe to events and to publish events.Apache Kafka is a popular choice nowadays. It’s a message broker, so it embraces asynchronous message-based communication. Modelling processes with asynchronous communication is more complicated but has its advantages. You don’t depend directly on other services, if they were offline, you can still operate, e.g. post messages to Kafka.Kafka supports various message types. It, of course, supports good old JSON, but also Protobuf. What is more, it integrates with Confluence Schema Registry, so you can keep your message schemas in external service.Kafka can be used also with Even Sourcing, where events are distributed among various topics and dependent services can build current data view from them.Pros:Async communication has its big advantagesSupports different message formats: JSON, Protobuf etc.Cons:Modelling application using messages is more complicatedYou need to set up a Kafka clusterConclusion:For a REST endpoint, you must treat it like a resource that provides domain data. The reward is you are now segregating data into separate domains. This makes it useful for when you have any number of apps requesting data. This approach attempts to decouple data from application or business logic.If you ever need to break up service into two simpler services, but you don't want to completely change how the different parts interact, do not hesitate to reach out for an RPC solution or If performance is paramount and you want the option to use many different languages, go for either gRPC. RPC style endpoints are great when you want only one job done well. This makes it useful for one or two app clients because it is a niche service. RPC endpoints can implement business logic inside the service, given that it only does one thing. This adds simplicity and clarity to the service.However, the loosely coupled, highly scalable nature of asynchronous messaging-based systems fits well with the overall ethos of microservices. More often than not, despite some significant design and implementation hurdles, an event-based messaging approach would be a good choice when deciding upon a default communication mechanism in a microservices-based system.So which communication approach is best when designing your microservices? it depends on the requirements! REST, RPC, and Event/Message driven are not mutually exclusive; they can all work together in your microservice architecture. Every successful cloud-based tech company employs these communication styles effectively to some degree. We have covered the different cases and circumstances in which each style comes into play and where each is appropriate.When choosing either approach or style it is key to know the differences. There is no right or wrong here. What is more important, is to know which approach solves for the job at hand.There are a lot of options! However, you don’t need to make a single choice for communication between all of your services. Generally, what to choose when?If you need to communicate UI (browser) with your service — choose RESTIf you need to provide public API to your service/product — choose RESTIf you need to communicate different internal services — try to model your processes using messages, if not possible then choose gRPC or Event/Message Driven.If you are dealing with high volumes of messages via HTTP, consider adopting RPC. If you find latency or network saturation to be any sort of bottleneck then this advice applies even more so.Again that is my personal opinion which again depends on application to application and their different needs. Hope I was able to explain my views here clearly. If Yes, Please like and share it so it can reach to the larger audience.












            39
        


        
            3 Comments
          
      





Like




Comment




Share













                AliReza Rezazadeh
              


such a nice Article 👌
Thank you 🤍




                  Like
                

        Sign in to like this comment
      



                  Reply
                

        Sign in to reply to this comment
      


                1 Like
              





          

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    

    10mo
  
        









                  Report this comment
                


 














                Ramesh Krishnamurthy
              


Thoughtfully explained Arpit...makes things much clearer on the options that people need to make and when to make what..




                  Like
                

        Sign in to like this comment
      



                  Reply
                

        Sign in to reply to this comment
      

 




          

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    

    2y
  
        









                  Report this comment
                


 













                Arpit Jain
              


Thanks Ramesh




                  Like
                

        Sign in to like this comment
      



                  Reply
                

        Sign in to reply to this comment
      

 




          

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    

    2y
  
        









                  Report this comment
                


 





              See more comments
          




        To view or add a comment, sign in
      
      To view or add a comment, sign in









More articles by this author


              See all
            



 



 









 


          Anti-Patterns: Event Driven Architecture
        

            Feb 23, 2020
          

 






 


          REST - Stop calling your HTTP APIs as RESTful APIs
        

            May 31, 2019
          

 






 


          Primitive Obsession - code smell that hurt people the most
        

            Jan 30, 2019
          

 

























          Others also viewed
        








 


            
        Microservices, in a nutshell.
      
 




Niek de Visscher

          

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    

    2y
  
        









 


            
        How to assert an exception is thrown in JUnit?
      
 




Saurabh Oza

          

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    

    3y
  
        









 


            
        Building a microservice with Golang, Kafka and DynamoDB — Part II
      
 




Pramod Maurya

          

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    

    4y
  
        









 


            
        The 7 Things to Keep in Mind when Presenting
      
 




Benita Bhatia Dua

          

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    

    8y
  
        









 


            
        AUTOSAR Application Software Components - Description levels
      
 




Kaarthick Balakrishnan

          

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    

    1y
  
        









 


            
        AUTOSAR - Implementing the Heating Controller Application Software Component at VFB Level
      
 




Kaarthick Balakrishnan

          

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    

    1y
  
        









 


            
        Port Interfaces in AUTOSAR
      
 




Kaarthick Balakrishnan

          

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    

    1y
  
        









 


            
        Types of Software Components in AUTOSAR
      
 




Kaarthick Balakrishnan

          

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    

    1y
  
        













LinkedIn

© 2022



            About
          



            Accessibility
          



            User Agreement
          



            Privacy Policy
          



            Cookie Policy
          



            Copyright Policy
          



            Brand Policy
          



            Guest Controls
          



            Community Guidelines
          








                العربية (Arabic)
            




                Čeština (Czech)
            




                Dansk (Danish)
            




                Deutsch (German)
            




English (English)





                Español (Spanish)
            




                Français (French)
            




                हिंदी (Hindi)
            




                Bahasa Indonesia (Bahasa Indonesia)
            




                Italiano (Italian)
            




                日本語 (Japanese)
            




                한국어 (Korean)
            




                Bahasa Malaysia (Malay)
            




                Nederlands (Dutch)
            




                Norsk (Norwegian)
            




                Polski (Polish)
            




                Português (Portuguese)
            




                Română (Romanian)
            




                Русский (Russian)
            




                Svenska (Swedish)
            




                ภาษาไทย (Thai)
            




                Tagalog (Tagalog)
            




                Türkçe (Turkish)
            




                简体中文 (Chinese (Simplified))
            




                正體中文 (Chinese (Traditional))
            



Language





 






