Rabbit MQ Vs Active MQ. RabbitMQ - Version:3.6.10–1, java amqp… | by Dhananjay G Devops | MediumGet unlimited accessOpen in appHomeNotificationsListsStoriesWriteDhananjay G DevopsFollowDec 26, 2017·5 min readRabbit MQ Vs Active MQRabbitMQ - Version:3.6.10–1, java amqp client 4.1.1Replication: synchronousRabbitMQ is one of the leading open-source messaging systems. It is written in Erlang, implements AMQP and is a very popular choice when messaging is involved; using RabbitMQ it is possible to define very complex message delivery topologies. It supports both message persistence and replication, with well documented behaviour in case of e.g. partitions.We’ll be testing a 3-node Rabbit cluster. To be sure that sends complete successfully, we’ll be using publisher confirms, a Rabbit extension to AMQP, instead of transactions:“Using standard AMQP 0–9–1, the only way to guarantee that a message isn’t lost is by using transactions — make the channel transactional, publish the message, commit. In this case, transactions are unnecessarily heavyweight and decrease throughput by a factor of 250. To remedy this, a confirmation mechanism was introduced.”The confirmations are cluster-wide (the queue was created with a policy using ha-mode: all, see the ha docs), so this gives us pretty strong guarantees: that messages will be both written to disk, and replicated to the cluster:“When will messages be confirmed? For routable messages, the basic.ack is sent when a message has been accepted by all the queues. For persistent messages routed to durable queues, this means persisting to disk. For mirrored queues, this means that all mirrors have accepted the message.”Such strong guarantees are probably one of the reasons for mediocre performance. A single-thread, single-node gives us 680 msgs/ssent&received, with a processing latency of 184 ms and send latency of 48 ms:This scales nicely as we add threads/nodes, up to 4 330 msgs/s using 4 sending/receiving nodes running 25 threads each, which seems to be the maximum that Rabbit can achieve.Let’s analyze this case more closely; here’s the test dashboard. As you can see, the receive rates are fairly stable between 4 000 and 5 000 msgs/s. Also the processing latency is mostly the same throughout the test, with the 95th percentile at 179 ms. However, the send latency goes up to 504 ms for brief periods of time. Hence in some cases messages are already processed, even before the send completes! However, for most of the time the send latency is between 150–250 ms.Note that messages are always sent and received at the same rate, which would indicate that message sending is the limiting factor when it comes to throughput. Rabbit’s performance is a consequence of some of the features it offers, for a comparison with Kafka see for example this Quora question.The RabbitMq implementation of the Mq interface is again pretty straightforward. We are using the mentioned publisher confirms, and setting the quality-of-service when receiving so that at most 100 messages are delivered unconfirmed (in-flight).Interestingly, sending the messages in larger batches doesn’t affect overall throughput much, with 4 550 msgs/s when using batches of 100 and 5 004 msgs/s when we batch up to 1000 messages.An important side-node: RabbitMQ has a great web-based console, available with almost no setup, which offers some very good insights into how the queue is performing.ActiveMQ - Version :5.14.3Replication:configurable, asynchronous & synchronousActiveMQ is one of the most popular message brokers. In many cases it’s “the” messaging server when using JMS. However, it gained replication features only recently. Until version 5.9.0, it was possible to have a master-slave setup using a shared file system (e.g. SAN) or a shared database; these solutions require either specialised hardware, or are constrained by a relational database (which would have to be clustered separately).Replication can be both synchronous and asynchronous; in fact, there’s a lot of flexibility. By setting the sync configuration option of the storage, we can control how many nodes have to receive the message and whether it should be written to disk or not before considering a request complete:· quorum_mem corresponds to synchronous replication, where a message has to be received by a majority of servers and stored in memory· quorum_disk is even stronger, requires the message to be written to disk· local_mem is asynchronous replication, where a message has to be stored in memory only. Even if disk buffers are flushed, this doesn’t guarantee message delivery in case of a server restart· local_disk is asynchronous replication where a message has to be written to disk on one serverIn the tests we’ll be mainly using quorum_mem, with a cluster of 3 nodes. As we require a quorum of nodes, this setup should be partition tolerant, however there’s no documentation on how partitions are handled and how ActiveMQ behaves in such situations.The ActiveMq implementation uses standard JMS calls using the OpenWire protocol to connect to the ActiveMQ server. For sends, we create a producer with delivery mode set to PERSISTENT, and for receives we create a consumer with CLIENT_ACKNOWLEDGE, as we manually acknowledge message delivery.Performance-wise, ActiveMQ does a bit worse than RabbitMQ, achieving at most 3 857 msgs/s with synchronous replication. This seems to be the maximum and is achieved with 1 node and 25 threads:At the highest throughput, the receive rates are quite stable between 3 700 and 4 100 msg/s. The processing latency is also quite tightly bound and at most 284 ms.Adding more nodes doesn’t improve the results, in fact, they are slightly worse. Interestingly, using the stronger quorum_disk guarantee has no big effect on performance:Same as with RabbitMQ, in all tests sends and receives happen at the same rates, hence the bottleneck in terms of throughput is the sending side.Summary and Conclusion:As always, which message queue to choose depends on specific project requirements. All of the above solutions have some good sides:if you want to have high persistence guarantees, RabbitMQ ensures replication across the cluster and on disk on message send. It’s a very popular choice used in many projects, with full AMQP implementation and support for many messaging topologiesActiveMQ is a popular and widely used messaging broker with moderate performance, wide protocol support------More from Dhananjay G DevopsFollowStart as software developer now Devops. Interested in machine learning and big data and cloud.Love podcasts or audiobooks? Learn on the go with our new app.Try KnowableRecommended from MediumUniqtechinData Science BootcampPandas Data Analysis CheatsheetChris ShortDevOps’ish 039: Cloud Native, Football, Kubernetes, Serverless, and MoreLukas LiesisHow to monitor Redis (or anything else) running on your Linux machine and get an email (or trigger…Eduardo MessutiinStatuspalCustom SSL Domains arrive to Statuspal!Lime1O1Admin has the power cybertalents challenge solving writeupFeli (@kotzendekrabbe)What. An. A-m-a-z-i-n-g. Weekend!Takuya MatsuyamainDev as LifeInkdrop for Mobile now supports extending MarkdownZevsНовости InvArch: 9 марта 2022AboutHelpTermsPrivacyGet the Medium appGet startedDhananjay G Devops14 FollowersStart as software developer now Devops. Interested in machine learning and big data and cloud.FollowMore from MediumSantosh RachakondaDatabases comparison SQL vs No SQL (Cosmos DB,Mongo DB, Cassandra DB)Siddharth GangwarIt’s all about engineering a load balancer: Types, Configuration & AlgorithmsPaula Ortega CancinoConfigure a database version control tool for your Spring-boot projectSachinBest Database Management Software for 2022HelpStatusWritersBlogCareersPrivacyTermsAboutKnowable






































