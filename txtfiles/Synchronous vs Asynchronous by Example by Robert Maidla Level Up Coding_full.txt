Synchronous vs Asynchronous by Example | by Robert Maidla | Level Up CodingOpen in appHomeNotificationsListsStoriesWritePublished inLevel Up CodingRobert MaidlaFollowFeb 25, 2020·13 min readSaveSynchronous vs Asynchronous by ExampleExploring Microservices Communication PatternsA major obstacle when implementing microservices architecture is dealing with inter-service communication. In a traditional, monolithic system, communication between various modules and layers is handled in memory. When an application is split between independent services and information must be exchanged over the network, however, a different approach must be used to cope with the added latency.This article explores the synchronous and asynchronous approaches of inter-service communication. We will use predetermined services and use-cases as an example. In addition to getting a better grasp of the overall system, we will see how analyzing the various approaches leads to a more efficient and cohesive model.Project scope determined in part 1This is part 3 of a series where I am building a software system for a conceptual hedge fund from scratch. In the 2nd part, I used the responsibilities, use-cases and bounded contexts to arrive at specific services for the trading terminal.The current diagrams describe the information flow on a conceptual level. This part focuses on getting more specific and analyzing the pros and cons of various communication approaches.Inter-service communication can be segregated as synchronous and asynchronous, single receiver and multiple receiver patterns. These will be demonstrated using the trading terminal as an example. The following diagram shows what kind of information flow will require orchestrating.Overview of the trading terminal (worked out in part 2)The modelling of diagrams follows The C4 model. This explains the solution on various levels in an organized and unified manner. We are currently working on level 2 — the container diagram. The diagrams are built using an intuitive digital workspace tool called Whimsical.Synchronous communicationThis, a more direct approach, is represented by REST APIs. It essentially involves making HTTP calls, where in order for the information exchange to complete, the counterparty must process the request and get back to the requester with a corresponding response.If you are unfamiliar with REST, you can find out the basics here.Trading terminal’s responsibilities (up) and use cases (down) — focus on Market feedIn the 2nd part, we developed use cases, which first led to bounded contexts and then to services. Let us take some more advantage of the use cases for the illustration of both synchronous and asynchronous communication patterns.We will explore the trading terminal’s two main responsibilities: receiving & distributing quotes and processing order requests (represented by the Market feed and the Executor services, respectively). Firstly, assume that we are dealing with purely synchronous communication, which will be held over API calls between our services.Receiving & distributing quotes, Synchronously (horizontal lines represent the communication being held)This can be categorized as one to many communication, where the same information has to be distributed between multiple receivers.The quotes distributing lifecycle starts with the market feed service receiving a price update from the broker API. In order to transport this information to the necessary services synchronously, the market feed app would need to post to each of those APIs.This is the first smell of this approach — the market feed service would need to know about the other APIs and make direct calls to them. This would make it dependent on other services. In other words, we would be introducing coupling into our system.“If changing one module in a program requires changing another module, then coupling exists.” — Martin FowlerFurthermore, the information would not reach the following service until the previous one has processed the request and responded. In high-frequency traffic, such as price changes on various instruments, latency should be driven as low as possible. We could prioritize the order of the calls, most likely opting to start with the account management service for its mission-critical operations, but a better approach here would be to use callbacks when making the requests.HTTP requests can be handled synchronously (thread is blocked) or asynchronously (thread is not blocked, and the response will reach a callback eventually). Regardless of the client code execution, however, the communication still uses a synchronous protocol (meaning each request requires a response).Receiving & distributing quotes (executed with callbacks)This way, instead of waiting for the response before sending a new request, we could register asynchronous tasks, post the requests all at once and then wait for the responses. This approach would make the system more robust.As mentioned earlier, before we could get a response from the HTTP calls, the receiving service would need to process the request. This could mean directly handling the quote change and making the necessary calculations based on it. To make it more efficient, the receiving party could publish the quote change event internally and let another thread handle the heavy calculations.Whichever way we would process the information, however, the initial requester would still be held up while all the corresponding services were finished with the handling and get back with a response. In our example, the market feed service would have to wait for 3 distinct HTTP calls plus the processing in-between before it could move on to the next quote.Thinking about the application’s context — a single liquid instrument during active trading hours produces well over several price changes per second on average. A terminal should be able to seamlessly subscribe to a whole index worth of symbols simultaneously, which could mean processing hundreds, if not thousands of individual quotes per second.With the high amount of network calls and the dependency on other services while distributing the quotes, the market feed service would quickly turn into a bottleneck in our system. Since receiving price changes is also the logical entry point to our system’s workflow, we would be setting significant limits to our capacity.In short, the synchronous pattern has introduced us to the following potential issues so far through receiving & distributing quotes:the requests would potentially be held up for a long time due to being dependent on other services;this would quickly turn one of the core features of our system into a bottleneck, accounting the latency and numerous request handlings;our services would be tightly coupled (losing one of the key benefits of DDD and the microservices architecture);services dependent on the communication would receive requests with a slight offset, meaning we would have to prioritize information distribution.Trading terminal’s responsibilities (up) and use cases (down) — focus on ExecutorMoving on to processing the order requests which is handled by the executor service. This use case will not be under as frequent request load as the other services in this solution due to not directly handling quotes. Regardless of being idle for most of the time, it needs to be one of the more swiftly operating actions in the system.When distributing quotes was dealing with a single request and response cycles, executing an order requires the cooperation of several services. This would create a chain of sequential HTTP calls when handled synchronously.Handling order requests, SynchronouslyThis can be categorized as one to one communication, where the information is passed on to a single provider.So far during modelling, I have assumed that the connection with the broker will be held via a FIX API. For simplicity’s sake, let us assume that the communication will be held via a REST API.The execution action lifecycle starts with the executor service receiving a new order request, which in this example originates from the user interface. According to the previously determined use case, the executor service will need to process the request by validating its parameters first (let us skip the security layer for now).After parameter validation, the executor needs to ensure that the order complies with the risk management rules. For that, the account management service would be contacted via another HTTP call. Once the corresponding calculations are done and the response is sent back to the executor (assuming all validations have passed so far), the next request would involve the broker API.Before the user interface service could finish the request lifecycle, the executor would also need to direct the order request to the broker (additional processing), a trade would need to be executed and the following responses should be returned to the executor service. In other words, it would mean depending on a series of sequential HTTP calls to complete across three services.In short, in addition to tight coupling, this sort of solution would inevitably lead to low performance due to blocking. Even if the individual services would not fail from time to time (which they will), chaining them through HTTP calls would impact the performance and scalability of the entire system.When any one of the services in the chain fails, the whole chain will (if not handled correctly). A microservices system should be able to withstand partial failures, which in this case would be achieved through retry logic and circuit breakers. However, due to the tangled nature of the HTTP chains, the failure logic would quickly get relatively complex to handle.The final smell in this example is that the executor service would resemble a central orchestrator by involving numerous other services in its work. While this approach is used in SOA (from which the microservices derive), it is considered an anti-pattern in microservices architecture.To summarize, handling communication synchronously would lead to high coupling as the services would need to be aware of each other to make the necessary requests. Moreover, due to distributed responsibilities within a microservice architecture, a complete operation often involves more than 2 services communicating with each other. Creating a chain of HTTP calls, where the initial requester is held up while all of the internal requests complete, is inefficient and prone to failures.What is more, communicating in such a manner closely resembles a monolithic architecture, where instead of intra-process communication, HTTP is used. In other words, we would be creating a distributed monolith, which merges the negative aspects of both patterns (monolith & microservice).Furthermore, adding new services or dependencies to a synchronous chain is relatively painful. Execution wise, it would obviously prolong the requests even more. Development wise, due to the high coupling, it would require significant enhancement of both services involved in the interaction, instead of mainly focusing on the new component.Efficient infrastructure and an elaborate domain model, which matches the code, support refactoring and adding new features. Modifications and additions should get exponentially easier, not the other way around.Asynchronous communicationAsynchronous pattern tackles the shortcomings of synchronous communication by decoupling the two parties and enabling them to work simultaneously, independent of each other. If information is needed to be sent, the provider will be relieved as soon as the message is passed on, without having to wait for the consumer to process it.In a microservices architecture, we can achieve this with a middleman service, whose only task would be to receive the information and pass it on the corresponding parties. The services would only need to be aware of the middleman, who accepts and distributes the information. Furthermore, the message producer thread would be released after passing the message on, without the need to wait for processing on the other end.Let us use the same two trading terminal’s activities (distributing quotes and processing order requests), this time using the AMQP protocol and a message broker to mediate the information.“Messages are published to exchanges, which are often compared to post offices or mailboxes. Exchanges then distribute message copies to queues using rules called bindings. Then the broker either deliver messages to consumers subscribed to queues, or consumers fetch/pull messages from queues on demand.” — AMQP protocol explained by RabbitMQReceiving and distributing quotes, AsynchronouslyWhen the market feed service receives a quote update from the broker, it publishes this information to the message broker. Once that is done, the market feed service is free to accept new incoming quotes without having to wait after unrelated process handling.Furthermore, since the message broker manages the communication with the receiving parties, the market feed service does not need to directly interact with other services. This provides us with a loosely coupled architecture.The message broker knows where to direct the information through subscriptions to specific queues or events. In this example, the account management, autotrader and UI services all subscribe to a market feed queue. We can have as many subscribers to a queue as we need to. This is an example of a one-to-many relationship.This is essentially similar to how webhooks work, where async communication is set up by ‘hooking a server up’ to the events published by another server. This way, information is not requested, but rather ‘pushed’ or published when necessary.In an event-driven communication, the messages that are being exchanged are called events. These can represent all kinds of various actions and changes taking place during the lifecycle of an application. In our example, we would raise PriceChangedEvents, which would hold the necessary data for the counter-parties to know (i.e. the symbol, the new price, the volume).Handling order requests, AsynchronouslyNotice that there are no blocking calls when handling order requests. All of the systems are independent, react to the events which they need to be concerned about and handle their own business — a definition of microservices. This is why asynchronous communication suits the microservices architecture best and is the recommended pattern to be used.A couple of notes here:the actual execution request between the executor and the broker API is synchronous in this example. It is a single HTTP request that does not block any other services. Since the broker API is not part of our internal system, we could not subscribe it to our message broker even if we wanted to.we can make the communication completely async with a FIX API (which I intend to achieve). For these illustrations, however, a REST API on the broker side is perhaps more unifiedly manageable as we have not yet discussed the specifics of FIX communication (which we will in the upcoming posts).As with most any solutions, there are two sides to the coin. Using a middleman to handle the messages has increased the number of times the information is exchanged over the network. Additionally, this sort of back and forth, indirect messaging through a mediator adds another layer, and with it, more complexity, to our system.I am also aware that the communication pattern could be made significantly more direct and less chatty if we were to merge the executor and the account management service. Whilst the bounded contexts determined in part 2 made a relatively clean cut between the service boundaries and nicely segregated the responsibilities, this potential refactoring is worth exploring further.With the current architecture, the executor does not need to handle quotes. It needs to be swift and independent of the heavy load that the processing of quotes might produce. If we were to merge it with the account management service, it might not be as responsive at all times.However, the executor service is highly dependent on the account management service. An important business rule in a trading application is that no execution should be made before its effect on the overall portfolio is assessed. So basically the only one authorized to directly request order execution is the account management service. This sort of tight coupling hints that we should consider merging the two services.Trading terminal container diagram (refactored)I have merged the executor service with account management and added the message broker. Compared to the trading terminal model we started out with, this solution (asynchronous communication via a message broker and merged executor and account management services) has produced the following advantages:the trading terminal solution is loosely coupled (services only need to be aware of their own respective responsibilities and respond to certain events);greater cohesion (strongly related execution and account management responsibilities are modelled closer together);core responsibilities of the solution (distributing quotes & handling order requests) require less communication between different services (reducing network reliability).Handling order requests, Asynchronously (refactored)Before diving deeper into the mechanics of the message broker (modelling the specific queues and events), we should figure out one more important aspect — data management. This will be the final piece to the puzzle on a higher level, as it requires us to determine where and how do we keep the data within the system. Asynchronous communication enables us to use patterns such as eventual consistency or event sourcing.Note: asynchronous communication does not only include message brokers and events. Webhooks, Websockets and Polling are also part of this category, to name a few. To keep the article focused on the matter at hand, however, these examples were not explored at this time.SummaryManaging a microservices solution synchronously would be direct and easy to comprehend, but would quickly tangle and couple the services (with chained HTTP calls) and make the system resemble a distributed monolith.Asynchronous pattern with event-driven communication eliminates these issues and makes the solution more scalable. This does not come without cost however, as a message mediator brings on an additional layer to the communication, and with it, more complexity.Analyzing inter-service communication reveals where the exchange of information might get too chatty, signalling the need for greater cohesion. The model is bound to change (or rather evolve) in light of new information. Refactoring should not be avoided, rather welcomed whenever it leads to a deeper model.Our blueprint has solved yet another piece of the puzzle. There are loads of interesting topics to cover, such as autonomy, resiliency and data consistency. In the next part, we will figure out how data will be managed within the trading terminal, after which we should have quite a clear overview of how the trading terminal is going to function. This enables us to move deeper into our model and design services components. See you there!--1----1More from Level Up CodingFollowCoding tutorials and news. The developer homepage gitconnected.com && skilled.dev && levelup.devRead more from Level Up CodingRecommended from MediumDaniel BacharKubernetes Multi-Cluster monitoring with Prometheus and SubmarinerLiquid OcelotinYoutube TutorialsHow To Make An Epic Discord Server For Your YouTube Channel — Part 7 Of 30 — Creating About Us…Dr Steve BerrymanInstalling and Running an Ethereum 2 PegaSys Teku Validator on the Altona TestnetMark GardnerAvoid CPAN conflicts in your personal Perl modulesRuth BaptistaConfiguration of Oracle Data Guard on GCVEDilith JayakodyMaking a Mouse-less Navigator for a 3D Modelling SoftwareIBM Developer Advocate in Silicon ValleyInto the world of Red Hat OpenShiftPetr MatějinprofiqKinetica: The Next Generation of GPU DatabasesAboutHelpTermsPrivacyGet the Medium appGet startedRobert Maidla1K FollowersRemoving the hassle from travel & exploring with plaanadventures.comFollowMore from MediumRichard AminVE Series: What are Virtual Environments?Love SharmainInterviewNoodleSmoke Basin: Day 9: Advent of Code 2021 — Python SolutionThe Educative TeaminDev Learning DailyLevel up your Python today with open-source contributionsColin ButinDev GeniusCrossing the Chasm to become a Senior Developer/EngineerHelpStatusWritersBlogCareersPrivacyTermsAboutKnowable





































