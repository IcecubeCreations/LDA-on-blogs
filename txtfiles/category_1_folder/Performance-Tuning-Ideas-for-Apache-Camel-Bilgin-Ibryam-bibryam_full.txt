requirement_1
tune
idea
for
technology_1
technology_2
~
bilgin
ibryam
@bibryam
skip
to
|
skip
to
sidebar
ofbizian
bilgin
s
open_source
architecture
journey
home
blockchain
random
about
me
blogroll
requirement_1
tune
idea
for
technology_1
technology_2
monday




every
now
and
then
i
connector_1
question
around
optimise
technology_2
component_1
with
the
argument
that
technology_2
be
slow
technology_2
be
the
glue
connector_2
disparate
component_2
the
connector_3
component_3
be
all
in
memory
and
it
doesn’t
require
any
persistent
state
so
99%
of
the
requirement_2
requirement_1
issue
be
due
to
bottleneck
in
other
component_2
or
have
the
component_4
design
do
without
requirement_1
consideration
if
that
be
the
requirement_2
there
isn’t
much
you
can
achieve
by
tune
technology_2
further
and
you
have
to
go
back
to
the
draw
board
but
sometimes
it
might
be
worth
squeeze
few
more
millisecond
from
your
technology_2
connector_4
tune
every
component_4
be
very
specific
and
dependent
on
the
technology_3
and
the
use
requirement_2
here
be
some
idea
for
tune
technology_2
base
component_2
which
apply
for
you
or
not
tune
in
technology_2
be
the
requirement_3
point
with
other
component_5
and
the
way
they
be
configure
will
have
a
huge
impact
on
the
requirement_1
of
the
component_2
understand
how
different
work
and
tune
those
should
be
the
one
of
the
first
place
to
start
with
here
be
few
example
pattern_1
if
your
technology_2
component_4
be
use
connector_data_1
the
overall
requirement_1
will
be
heavily
dependent
on
the
requirement_1
of
the
pattern_1
component_2
there
be
too
many
factor
to
consider
here
but
one
be
connector_data_1
pattern_2
the
requirement_4
and
disk
quality_attribute_1
combine
with
the
pattern_2
topology
will
shape
the
pattern_2
requirement_1
to
give
you
an
idea
with
technology_4
a
relational
component_6
base
persistent
component_7
will
perform
around
50%
of
a
base
component_7
and
use
requirement_4
of
pattern_2
to
quality_attribute_2
horizontally
will
cost
another
30%
of
requirement_1
it
be
amaze
how
one
configuration
connector_5
in
technology_5
can
have
huge
impact
on
the
pattern_1
component_2
and
then
the
technology_2
component_4
there
be
a
must
connector_6
technology_5
tune
guide
by
with
lot
s
of
detail
to
consider
and
evaluate
also
a
real
life
example
from
chrisitan
posta
show
how
to
quality_attribute_1
up
the
pattern_2
25x
time
in
certain
requirement_2
another
recent
by
simon
green
show
how
to
approach
an
technology_5
tunning
adventure
step
by
step
connector_data_1
component_8
if
requirement_1
be
a
priority
there
be
also
some
hack
you
can
do
on
the
technology_5
component_8
side
such
a
increasing
technology_6
socketbuffersize
and
iobuffersize
tune
the
openwire
technology_7
parameter
use
connector_data_1
compression
pattern_3
acknowledgement
with
optimizeacknowledge
pattern_4
connector_7
with
useasyncsend
adjust
pre
fetch
limit
etc
there
be
some
nice
slide
again
from
christina
here
and
old
but
still
very
relevant
video
from
rob
davy
about
tune
technology_4
all
of
these
resource
should
give
you
enough
idea
to
experiment
and
improve
the
requirement_1
from
pattern_1
point
of
pattern_5
component_6
connector_8
use
pattern_3
whenever
possible
you
can
use
an
aggregator
to
connector_9
a
number
of
entry
before
perform
a
pattern_3
to
connector_10
with
the
component_6
for
example
with
the
technology_8
component_9
work
with
template
if
you
have
to
use
a
template
component_9
a
part
of
the
connector_4
try
out
the
exist
templating
component_10
technology_9
technology_10
springteplate
technology_11
chunk
with
a
small
test
a
the
follow
one
and
measure
which
one
perform
quality_attribute_3
there
be
a
great
presentation
title
requirement_1
optimisation
for
technology_2
by
﻿christian
mueller
with
the
component_11
support
the
find
update
after
this
be
publish
christian
create
slide
with
late
version
of
technology_2



and
technology_12


connector_11
out
those
too
from
those
measurement
we
can
see
that
technology_9
perform
quality_attribute_3
than
technology_10
and
sprinttemplates
in
general
use
web
component_12
whenever
you
have
to
use
a
web

the
web
container
itself
have
to
be
tune
separately
from
technology_2
point
of
pattern_5
you
can
further
optimise
a
little
bit
by
skip
the
unmarshalling
if
you

t
need
technology_12
connector_data_2
and
use
pattern_4
component_13
concurrentconsumers
there
be
a
number
of
component_14
seda
vm
technology_13
technology_14
disruptor
technology_15
sqs
etc
that
support
parallel
consumption
before
use
an

connector_11
the
component_9
documentation
for
component_15
pool
or
pattern_3
component_13
capability
to
give
you
an
idea
see
how
amzon
technology_16
component_13
can
be
improve
through
these
option
connector_data_3
type
choice
the
type
and
the
technology_17
of
the
connector_data_3
the
be
pass
through
technology_2
connector_4
will
also
have
requirement_1
implication
to
demonstrate
that

s
see
few
example
content
base
pattern_6
splitter
pattern_7
be
example
of
eips
that
perform
some
work
base
on
the
connector_data_1
content
and
the
type
of
the
connector_data_1
affect
the
component_13
quality_attribute_1
of
these
element
below
be
a
requirement_5
from
﻿christian
mueller
s
presentation
visualise
how
content
base
pattern_6
be
perform
with
different
kind
of
connector_data_1
content
base
connector_3
base
on
different
connector_data_3
type
for
example
if
you
have
a
large
connector_data_4
document
in
the
exchange
and
base
on
it
you
perform
content
base
connector_4
pattern_7
etc
that
will
affect
the
quality_attribute_1
of
the
connector_12
instead
you
can
extract
some
key
connector_data_5
from
the
document
and
populate
the
exchange

for
fast
connector_13
and
connector_3
late
marshal
unmarshaling
similarly
to
the
templating
component_3
different
connector_data_3
technology_17
covenrtors
perform
differently
to
see
some
metric
connector_11
again
﻿christian
s
presentation
but
also
keep
in
mind
that
requirement_1
of
the
support
connector_data_3
technology_17
vary
between
different
version
and
component_16
so
measure
it
for
your
use
requirement_2
connector_14
technology_2
connector_14
and
connector_15
pattern_8
be
one
of
the
underrate
feature
that
can
be
useful
for
deal
with
large
connector_data_1
claim
connector_11
eip
if
the
component_4
component_17
allow
it
consider
use
claim
connector_11
pattern_9
to
improve
requirement_1
and
reduce
resource
consumption
multithreading
technology_2
offer
multithreading
support
in
a
number
of
place
use
those
can
improve
the
component_4
requirement_1
too
paralel
component_13
eips
the
follow
technology_2
eip
implementation
support
parallel
component_13
pattern_10
recipient
connector_data_6
splitter
delayer
wiretap
throttler
error
pattern_11
if
you
be
go
to
enable
parallel
component_13
for
those
it
would
be
even
quality_attribute_3
if
you
also
provide
a
custom
component_15
pool
specifically
tune
for
your
use
requirement_2
rather
than
rely
on
technology_2
s
default
component_15
pool
profile
component_18
dsl
construct
some
technology_2
such
a
the
component_19
be
single
component_15
by
design
and
cannot
be
parallelize
at
level
in
requirement_2
of
component_19
a
single
component_15
pick
a
at
a
time
and
component_20
it
through
the
connector_12
until
it
reach
the
end
of
the
connector_12
and
then
the
component_19
component_15
pick
the
next

this
be
when
technology_2
component_18
construct
can
be
useful
a
visualise
below
component_19
component_15
can
pick
a
and
pass
it
to
a
component_15
from
the
component_18
construct
for
further
component_13
then
the
component_19
can
pick
another
without
wait
for
the
previous
exchange
to
complete
component_13
fully
parallel
connector_16
seda
component_9
seda
be
another
way
to
achieve
parallelism
in
technology_2
the
seda
component_9
have
in
memory
connector_data_6
to
accumulate
incoming
connector_data_7
from
the
component_21
and
concurrentconsumers
to
component_13
those
incoming
connector_data_8
in
parallel
by
multiple
component_15
pattern_4
redelivery
retry
if
you
be
use
an
error
pattern_11
with
a
redelivery
requirement_6
a
part
of
the
connector_3
component_13
you
can
configure
it
to
be
pattern_4
and
do
the
redeliveries
in
a
separate
component_15
that
will
use
a
separate
component_15
pool
for
the
redelivery
not
block
the
connector_data_8
component_13
component_15
while
wait
if
you
need
long
delay
redeliveries
it
might
be
a
quality_attribute_3
approach
to
use
technology_5
pattern_2
redelivery
that
be
different
from
component_19
redelivery
btw
where
the
redeliveries
will
be
persist
on
the
connector_data_1
pattern_2
and
not
keep
in
technology_2
component_4
memory
another
benefit
of
this
mechanism
be
that
the
redeliveries
will
survive
component_4
restart
and
also
play
nicely
when
the
component_4
be
cluster
i
have
describe
different
retry
pattern_9
in
technology_2
design
pattern_9
book
other
optimisation
there
be
few
other
trick
you
can
do
to
micro
tune
technology_2
further
requirement_7
configuration
hopefully
you

t
have
to
requirement_7
every
connector_data_1
and
it
content
on
the
production
environment
but
if
you
have
to
consider
use
some
pattern_4
logger
on
a
high
quality_attribute_4
component_2
ane
option
would
be
to
requirement_7
statistic
and
aggregate
metric
through
technology_2
quality_attribute_4
logger
quality_attribute_4
logger
allow
requirement_7
aggregate
statistic
on
fix
interval
or
base
on
the
number
of
component_13
connector_data_7
rather
than
per
connector_data_1
base
another
option
would
be
to
use
the
not
so
popular
technology_2
sampler
eip
and
requirement_7
only
sample
connector_data_7
every
now
and
then
disable
technology_18
by
default
technology_2
technology_18
instrumentation
be
enable
which
create
a
lot
of
mbeans
this
allow
pattern_12
and
requirement_8
of
technology_2
runtime
but
also
have
some
requirement_1
hit
and
require
more
resource
i
still
remember
the
time
when
i
have
to
fully
turn
off
technology_18
in
technology_2
in
order
to
run
it
with
512mb
heap
on
a
free
technology_19
account
a
a
minimum
consider
whether
you
need
any
technology_18
enable
at
all
and
if
so
whether
to
use
routesonly
default
or
extend
technology_18
profile
connector_data_1
histroy
technology_2
connector_17
the
connector_data_1
history
eip
and
run
it
by
default
while
on
development
environmnet
it
might
be
useful
to
see
every
a
connector_data_1
have
be
too
but
on
the
produciton
environment
you
might
consider
to
disable
this
feature
original
connector_data_1
every
technology_2
connector_12
will
make
a
copy
of
the
original
incoming
connector_data_1
before
any
modification
to
it
this
pristine
copy
of
the
connector_data_1
be
keep
in
requirement_2
it
be
need
to
be
redelivered
during
error
handle
or
with
oncompletion
construct
if
you
be
not
use
these
feature
you
can
disable
create
and
connector_18
the
original
state
of
every
incoming
connector_data_1
other
customisations
almost
every
feature
in
camelcontext
can
be
customize
for
example
you
can
use
lazyloadtypeconverters
for
a
fast
component_4
startup
or
configure
the
shutdownstrategy
for
a
quicker
shutdown
when
there
be
inflight
connector_data_1
or
a
use
a
custom
uuidgenerator
that
perform
fast
etc
component_4
design
all
of
the
previous
tune
be
micro
optimization
compare
to
the
component_4
design
and
architecture
if
your
component_4
be
not
design
for
horizontal
quality_attribute_5
and
requirement_1
sooner
or
late
the
small
tune
hack
will
hit
their
limit
the
chance
be
what
you
be
do
have
be
do
previously
and
instead
of
reinvent
the
wheel
or
come
up
with
some
clever
design
from
the
experience
of
others
and
use
well

pattern_9
principle
and
practise
use
principle
from
technology_20
pattern_13
architecture
resiliency
principle
pattern_1
best
practise
etc
some
of
those
pattern_9
such
a
parallel
pipeline
cqrs
load
level
circuit
breaker
be
cover
in
technology_2
design
pattern_9
book
and
do
help
to
improve
the
overall
component_4
design
technology_21
there
be
many

about
tune
the
technology_21
here
i
only
want
to
mention
the
technology_21
configuration
generation
component_4
by
which
can
generate
for
you
technology_21
configuration
base
on
the
late
requirement_9
best
practice
you
can
use
it
a
long
a
you
have
a
account
which
be
free
for
developer
anyway
use
the
late
technology_21
and
late
version
of
technology_2
with
it
update
connector_19
be
another
way
to
improve
component_4
requirement_1
for
free
o
you
can
squeeze
the
component_4
only
so
much
in
order
to
do
proper
high
load
component_13
tune
the
component_22
component_2
be
a
must
too
to
connector_1
an
idea
for
the
various
o
level
option
have
a
look
at
the
follow
connector_11
connector_data_6
from
the
technology_22
project
in
conclusion
this
be
here
to
give
you
some
idea
and
show
you
the
extend
of
the
possible
area
to
consider
when
you
have
to
improve
the
requirement_1
of
a
technology_2
component_4
instead
of
look
for
a
magical
recipe
or
go
through
a
checklist
do
small
incremental
connector_20
support
by
measurement
until
you
connector_1
to
a
desire
state
and
rather
than
focus
on
micro
optimisation
and
hack
have
an
holistic
pattern_5
of
the
component_2
connector_1
the
design
right
and
start
tune
from
the
component_22
component_2
to
technology_21
camelcontext
connector_3
element
and
the
connector_data_3
itself
use
well

pattern_9
principle
and
practise
with
focus
on
quality_attribute_6
and
quality_attribute_7
design
be
always
a
quality_attribute_3
start
quality_attribute_3
luck

in
technology_2
fuse
requirement_1
tune


unknown
say




be
connector_data_9
very
helpful
connector_data_5
thanks
for
this

tomasz
say




pm
connector_data_9
nice
stuff
thanks
for
connector_21
juan
macias
say




be
connector_data_9
technology_23
stackoverflow
technology_24
question

why
be
technology_2
technology_25
component_21
very
slow
i
hope
you
can
connector_21
some
light
on
this
issue
thanks
in
advance
a
label
technology_5

agile

antifragile

technology_1
isi

artemis

technology_19

bitcoin

blockchain

technology_2

circuit
breaker

requirement_10
requirement_11

cloudwatch

cmis

cm

cncf


container

corda

cryptocurrencies

connector_data_3

ddd

debezium

deployment

design

technology_26

domain
drive
design

eip

eips

requirement_12
rostering

ethereum

fuse

geek

hexagonal

hystrix

infinispan

requirement_3

technology_12

jbpm

jcr

technology_18

technology_25

knative

technology_27

mainframeforfreedom

pattern_14

technology_28

mecha

pattern_1

pattern_13

modernization

monetization

pattern_12

observability

ofbiz

olympics

open_source

opensource

optaplanner

other

requirement_1

port
and
adapter

pattern_15


technology_29

semat

serverless

smart
contract

technology_30

technology_31
requirement_10

technology_31
requirement_3

quality_attribute_8

tokenomics

transaction

tune

twisdom

twitter

technology_32

wisdom

about
me
follow
me
on
twitter
connector_2
with
me
pattern_5
my
slide
fork
me
on
technology_33
subscribe
to
technology_34
fee
connector_11
my
book
archive
►


►

►

►

►


►

►

►


►

►

►

►

►

►


►

►

►

►


►

►

►

►

►

►

►

►

►


►

►

►

►

►

►

▼


►

►

►

►

►

▼

requirement_1
tune
idea
for
technology_1
technology_2
idempotent
component_19
eip
icon
technology_2
design
pattern_9
ebook
be
out
►


►

►

►


►

►

►

►

►

►

►


►

►

►

►

►

►

►


►

►

►

►

►

►

►

►

►

►

►


►

copyright
©

ofbizian
design
by
free
technology_35
theme
|
bloggerized
by
lasantha
premium
technology_36
theme
powered
by
technology_36
|
dsw
printable
coupon
