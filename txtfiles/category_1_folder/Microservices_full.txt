pattern_1
refactoring
agile
architecture
about
thoughtworks
topic
architecture
refactoring
agile
delivery
pattern_1
connector_data_1
test
dsl
about
me
about
book
faq
content
video
content
index
board
game
photography
thoughtworks
insight
career
technology_1
follow
twitter
technology_2
component_1
of
content
top
characteristic
of
a
pattern_2
architecture
componentization
via
component_2
organize
around
requirement_1
capability
technology_1
not
project
smart
and
dumb
pip
decentralized
governance
decentralized
connector_data_1
requirement_2
infrastructure
automation
design
for
failure
evolutionary
design
be
pattern_1
the
future
sidebar
how
big
be
a
pattern_2
pattern_1
and
pattern_3
many
technology_3
many
option
battle
test
technology_4
and
enforce
technology_4
make
it
easy
to
do
the
right
thing
the
circuit
breaker
and
production
ready
pattern_4
connector_data_2
consider
harmful
pattern_1
a
definition
of
this
architectural
term
the
term
pattern_2
architecture
have
technology_5
up
over
the
last
few
year
to
describe
a
particular
way
of
design
component_3
a
suite
of
independently
quality_attribute_1
component_4
while
there
be
no
precise
definition
of
this
architectural
style
there
be
certain
common
characteristic
around
organization
around
requirement_1
capability
automate
deployment
intelligence
in
the

and
decentralized
control
of
technology_3
and
connector_data_1


james
lewis
james
lewis
be
a
principal
consultant
at
thoughtworks
and
member
of
the
technology_6
advisory
board
james
interest
in
build
component_3
out
of
small
collaborate
component_2
stem
from
a
background
in
quality_attribute_2
requirement_3
component_5
at
quality_attribute_3
he
s
build
a
number
of
component_5
use
pattern_1
and
have
be
an
active
participant
in
the
grow
for
a
couple
of
year
martin
fowler
martin
fowler
be
an
author
speaker
and
general
loud
mouth
on
development
he
s
long
be
puzzle
by
the
problem
of
how
to
componentize
component_6
have
hear
more
vague
claim
than
he
s
happy
with
he
hop
that
pattern_1
will
live
up
to
the
early
promise
it
advocate
have
find
popular
component_7
architecture
pattern_1
content
characteristic
of
a
pattern_2
architecture
componentization
via
component_2
organize
around
requirement_1
capability
technology_1
not
project
smart
and
dumb
pip
decentralized
governance
decentralized
connector_data_1
requirement_2
infrastructure
automation
design
for
failure
evolutionary
design
be
pattern_1
the
future
sidebar
how
big
be
a
pattern_2
pattern_1
and
pattern_3
many
technology_3
many
option
battle
test
technology_4
and
enforce
technology_4
make
it
easy
to
do
the
right
thing
the
circuit
breaker
and
production
ready
pattern_4
connector_data_2
consider
harmful
pattern_1
yet
another
term
on
the
crowd
street
of
architecture
although
our
natural
inclination
be
to
pass
such
thing
by
with
a
contemptuous
glance
this
bit
of
terminology
describe
a
style
of
component_5
that
we
be
find
more
and
more
appeal
we
ve
see
many
project
use
this
style
in
the
last
few
year
and
connector_data_3
so
far
have
be
positive
so
much
so
that
for
many
of
our
colleague
this
be
become
the
default
style
for
build
requirement_3
component_7
sadly
however
there
s
not
much
connector_data_4
that
outline
what
the
pattern_2
style
be
and
how
to
do
it
in
short
the
pattern_2
architectural
style

be
an
approach
to
develop
a
single
component_7
a
a
suite
of
small
component_4
each
run
in
it
own
component_8
and
connector_1
with
lightweight
mechanism
often
an
technology_7
resource
technology_8
these
component_2
be
build
around
requirement_1
capability
and
independently
quality_attribute_1
by
fully
automate
deployment
machinery
there
be
a
bare
minimum
of
centralized
requirement_2
of
these
component_4
which
be
connector_2
in
different
programming
technology_3
and
use
different
connector_data_1
storage
technology_6
my
pattern_1
resource
guide
provide
connector_3
to
the
best

video
book
and
podcast
about
pattern_1
to
start
explain
the
pattern_2
style
it
s
useful
to
compare
it
to
the
monolithic
style
a
monolithic
component_7
build
a
a
single
unit
requirement_3
component_3
be
often
build
in
three
part
a
component_9
side
component_10
consist
of
technology_9
component_11
and
technology_10
run
in
a
browser
on
the
component_10
s
component_12
a
component_13
consist
of
many
component_14
insert
into
a
common
and
usually
relational
component_13
requirement_2
component_6
and
a
component_15
side
component_7
the
component_15
side
component_7
will
handle
technology_7
connector_data_5
connector_4
domain
component_16
connector_5
and
update
connector_data_1
from
the
component_13
and
select
and
populate
technology_9
pattern_5
to
be
connector_6
to
the
browser
this
component_15
side
component_7
be
a
monolith
a
single
logical
executable

any
connector_7
to
the
component_6
involve
build
and
quality_attribute_4
a
version
of
the
component_15
side
component_7
such
a
monolithic
component_15
be
a
natural
way
to
approach
build
such
a
component_6
all
your
component_16
for
handle
a
connector_data_5
run
in
a
single
component_8
allow
you
to
use
the
basic
feature
of
your
technology_3
to
divide
up
the
component_7
into


and
namespaces
with
some
care
you
can
run
and
test
the
component_7
on
a
developer
s
laptop
and
use
a
deployment
pipeline
to
ensure
that
connector_7
be
properly
test
and
quality_attribute_4
into
production
you
can
horizontally
quality_attribute_3
the
monolith
by
run
many
instance
behind
a
load
balancer
monolithic
component_3
can
be
successful
but
increasingly
people
be
feel
frustration
with
them
especially
a
more
component_3
be
be
quality_attribute_4
to
the
requirement_4
connector_8
cycle
be
tie
together
a
connector_8
make
to
a
small
part
of
the
component_7
require
the
entire
monolith
to
be
rebuild
and
quality_attribute_4
over
time
it
s
often
hard
to
keep
a
quality_attribute_5
modular
connector_data_6
make
it
hard
to
keep
connector_7
that
ought
to
only
affect
one
within
that

quality_attribute_6
require
quality_attribute_6
of
the
entire
component_7
rather
than
part
of
it
that
require
great
resource
figure

monolith
and
pattern_1
these
frustration
have
lead
to
the
pattern_2
architectural
style
build
component_3
a
suite
of
component_4
a
well
a
the
fact
that
component_2
be
independently
quality_attribute_1
and
quality_attribute_7
each
component_4
also
provide
a
firm
boundary
even
allow
for
different
component_2
to
be
connector_2
in
different
programming
technology_3
they
can
also
be
manage
by
different
team
we
do
not
claim
that
the
pattern_2
style
be
novel
or
innovative
it
root
go
back
at
least
to
the
design
principle
of
unix
but
we
do
think
that
not
enough
people
consider
a
pattern_2
architecture
and
that
many
development
would
be
quality_attribute_5
off
if
they
use
it
characteristic
of
a
pattern_2
architecture
we
cannot
say
there
be
a
formal
definition
of
the
pattern_1
architectural
style
but
we
can
attempt
to
describe
what
we
see
a
common
characteristic
for
architecture
that
fit
the
label
a
with
any
definition
that
outline
common
characteristic
not
all
pattern_2
architecture
have
all
the
characteristic
but
we
do
expect
that
most
pattern_2
architecture
exhibit
most
characteristic
while
we
author
have
be
active
member
of
this
rather
loose

our
intention
be
to
attempt
a
description
of
what
we
see
in
our
own
work
and
in
similar
effort
by
team
we
of
in
particular
we
be
not
lay
down
some
definition
to
conform
to
componentization
via
component_2
for
a
long
a
we
ve
be
involve
in
the
requirement_5
there
s
be
a
desire
to
build
component_5
by
plug
together
component_17
much
in
the
way
we
see
thing
be
make
in
the
physical
world
during
the
last
couple
of
decade
we
ve
see
considerable
progress
with
large
compendium
of
common
technology_11
that
be
part
of
most
technology_3
component_18
when
talk
about
component_19
we
run
into
the
difficult
definition
of
what
make
a
component_17
our
definition
be
that
a
component_17
be
a
unit
of
that
be
independently
replaceable
and
upgradeable
pattern_2
architecture
will
use
technology_11
but
their
primary
way
of
componentizing
their
own
be
by
break
down
into
component_4
we
define
technology_11
a
component_19
that
be
connector_9
into
a
component_20
and
connector_10
use
in
memory
connector_data_7
while
component_2
be
out
of
component_8
component_19
who
connector_1
with
a
mechanism
such
a
a
web
component_4
connector_data_5
or
remote
connector_data_7
this
be
a
different
concept
to
that
of
a
component_4
connector_data_8
in
many
oo
component_21

one
reason
for
use
component_2
a
component_19
rather
than
technology_11
be
that
component_2
be
independently
quality_attribute_1
if
you
have
an
component_7

that
consist
of
a
multiple
technology_11
in
a
single
component_8
a
connector_8
to
any
single
component_17
connector_data_3
in
have
to
redeploy
the
entire
component_7
but
if
that
component_7
be
decompose
into
multiple
component_4
you
can
expect
many
single
component_4
connector_7
to
only
require
that
component_4
to
be
redeploy
that
s
not
an
absolute
some
connector_7
will
connector_8
component_4
connector_data_9
in
some
coordination
but
the
aim
of
a
quality_attribute_5
pattern_2
architecture
be
to
minimize
these
through
cohesive
component_4
boundary
and
evolution
mechanism
in
the
component_4
contract
another
consequence
of
use
component_2
a
component_19
be
a
more
explicit
component_17

most
technology_3
do
not
have
a
quality_attribute_5
mechanism
for
define
an
explicit
publish

often
it
s
only
documentation
and
discipline
that
prevent
component_22
break
a
component_17
s
pattern_6
lead
to
overly
tight
couple
between
component_17
component_2
make
it
easy
to
avoid
this
by
use
explicit
remote
connector_data_7
mechanism
use
component_2
this
do
have
downside
remote
connector_data_2
be
more
expensive
than
in
component_8
connector_data_7
and
thus
remote
component_23
need
to
be
coarse
grain
which
be
often
more
awkward
to
use
if
you
need
to
connector_8
the
allocation
of
responsibility
between
component_17
such
movement
of
behavior
be
hard
to
do
when
you
re
cross
component_8
boundary
at
a
first
approximation
we
can
observe
that
component_2
connector_data_10
to
runtime
component_8
but
that
be
only
a
first
approximation
a
component_4
consist
of
multiple
component_24
that
will
always
be
develop
and
quality_attribute_4
together
such
a
an
component_7
component_8
and
a
component_13
that
s
only
use
by
that
component_4
organize
around
requirement_1
capability
when
look
to
split
a
large
component_7
into
part
often
requirement_2
focus
on
the
technology_6
pattern_7
lead
to
ui
team
component_15
side
component_16
team
and
component_13
team
when
team
be
separate
along
these
line
even
quality_attribute_8
connector_7
can
lead
to
a
cross
team
project
take
time
and
budgetary
approval
a
smart
team
will
optimise
around
this
and
plump
for
the
less
of
two
evil
force
the
component_16
into
whichever
component_7
they
have
connector_11
to
component_16
everywhere
in
other
word
this
be
an
example
of
conway
s
law

in
action
any
organization
that
design
a
component_6
define
broadly
will
produce
a
design
whose
connector_data_6
be
a
copy
of
the
organization
s
connector_12
connector_data_6
melvin
conway

figure

conway
s
law
in
action
the
pattern_2
approach
to
division
be
different
split
up
into
component_2
organize
around
requirement_1
capability
such
component_2
take
a
broad
technology_12
implementation
of
for
that
requirement_1
area
include
component_10

persistant
storage
and
any
external
collaboration
consequently
the
team
be
cross
functional
include
the
full
range
of
skill
require
for
the
development
component_10
experience
component_13
and
project
requirement_2
figure

component_4
boundary
reinforce
by
team
boundary
how
big
be
a
pattern_2
although
“microservice”
have
become
a
popular
name
for
this
architectural
style
it
name
do
lead
to
an
unfortunate
focus
on
the
size
of
component_4
and
argument
about
what
constitute
“micro”
in
our
conversation
with
pattern_2
practitioner
we
see
a
range
of
size
of
component_4
the
large
size
report
follow

s
notion
of
the
two
pizza
team
i
e
the
whole
team
can
be
feed
by
two
pizza
mean
no
more
than
a
dozen
people
on
the
small
size
quality_attribute_3
we
ve
see
setup
where
a
team
of
half
a
dozen
would
support
half
a
dozen
component_4
this
lead
to
the
question
of
whether
there
be
sufficiently
large
difference
within
this
size
range
that
the
component_4
per
dozen
people
and
component_4
per
person
size
shouldn
t
be
lump
under
one
pattern_1
label
at
the
moment
we
think
it
s
quality_attribute_5
to
group
them
together
but
it
s
certainly
possible
that
we
ll
connector_8
our
mind
a
we
explore
this
style
further
one
requirement_6
organise
in
this
way
be
www
comparethemarket
technology_13
cross
functional
team
be
responsible
for
build
and
operate
each
technology_1
and
each
technology_1
be
split
out
into
a
number
of
individual
component_2
connector_1
via
a
connector_data_11
bus
large
monolithic
component_3
can
always
be
modularized
around
requirement_1
capability
too
although
that
s
not
the
common
requirement_7
certainly
we
would
urge
a
large
team
build
a
monolithic
component_7
to
divide
itself
along
requirement_1
line
the
issue
we
have
see
here
be
that
they
tend
to
be
organise
around
too
many
component_25
if
the
monolith
span
many
of
these
modular
boundary
it
can
be
difficult
for
individual
member
of
a
team
to
fit
them
into
their
short
term
memory
additionally
we
see
that
the
modular
line
require
a
great
deal
of
discipline
to
enforce
the
necessarily
more
explicit
separation
require
by
component_4
component_19
make
it
easy
to
keep
the
team
boundary
clear
technology_1
not
project
most
component_7
development
effort
that
we
see
use
a
project
component_26
where
the
aim
be
to
connector_13
some
piece
of
which
be
then
consider
to
be
complete
on
completion
the
be
hand
over
to
a
quality_attribute_9
organization
and
the
project
team
that
build
it
be
disband
pattern_2
proponent
tend
to
avoid
this
component_26
prefer
instead
the
notion
that
a
team
should
own
a
technology_1
over
it
full
lifetime
a
common
inspiration
for
this
be

s
notion
of
you
build
you
run
it
where
a
development
team
take
full
responsibility
for
the
in
production
this
bring
developer
into
day
to
day
with
how
their
behave
in
production
and
increase
with
their
component_10
a
they
have
to
take
on
at
least
some
of
the
support
burden
the
technology_1
mentality
tie
in
with
the
linkage
to
requirement_1
capability
rather
than
look
at
the
a
a
set
of
requirement_8
to
be
complete
there
be
an
on
go
relationship
where
the
question
be
how
can
assist
it
component_27
to
enhance
the
requirement_1
capability
there
s
no
reason
why
this
same
approach
can
t
be
take
with
monolithic
component_7
but
the
small
granularity
of
component_2
can
make
it
easy
to
create
the
personal
relationship
between
component_4
developer
and
their
component_10
smart
and
dumb
pip
when
build
connector_12
connector_data_12
between
different
component_8
we
ve
see
many
technology_1
and
approach
that
stress
put
significant
smart
into
the
connector_12
mechanism
itself
a
quality_attribute_5
example
of
this
be
the
requirement_3
component_4
bus
esb
where
esb
technology_1
often
include
sophisticate
facility
for
connector_data_11
connector_14
choreography
transformation
and
apply
requirement_1
rule
pattern_1
and
pattern_3
when
we
ve
talk
about
pattern_1
a
common
question
be
whether
this
be
component_4
orient
architecture
technology_14
that
we
saw
a
decade
ago
there
be
merit
to
this
point
because
the
pattern_2
style
be
very
similar
to
what
some
advocate
of
pattern_3
have
be
in
favor
of
the
problem
however
be
that
pattern_3
mean
too
many
different
thing
and
that
most
of
the
time
that
we
come
across
something
connector_10
technology_14
it
s
significantly
different
to
the
style
we
re
describe
here
usually
due
to
a
focus
on
esbs
use
to
quality_attribute_2
monolithic
component_7
in
particular
we
have
see
so
many
botch
implementation
of
component_4
orientation
from
the
tendency
to
hide
complexity
away
in
esb
s

to
fail
multi
year
initiative
that
cost
million
and
connector_13
no
requirement_9
to
centralised
governance
component_28
that
actively
inhibit
connector_8
that
it
be
sometimes
difficult
to
see
past
these
problem
certainly
many
of
the
technique
in
use
in
the
pattern_2
have
grow
from
the
experience
of
developer
quality_attribute_2
component_2
in
large
organisation
the
tolerant
reader
pattern_8
be
an
example
of
this
effort
to
use
the
web
have
contribute
use
quality_attribute_8
technology_15
be
another
approach
derive
from
these
experience
a
reaction
away
from
central
technology_4
that
have
reach
a
complexity
that
be
frankly
breathtaking
any
time
you
need
an
ontology
to
manage
your
ontology
you
you
be
in
deep
trouble
this
common
manifestation
of
pattern_3
have
lead
some
pattern_2
advocate
to
reject
the
pattern_3
label
entirely
although
others
consider
pattern_1
to
be
one
form
of
pattern_3

perhaps
component_4
orientation
do
right
either
way
the
fact
that
pattern_3
mean
such
different
thing
mean
it
s
valuable
to
have
a
term
that
more
crisply
define
this
architectural
style
the
pattern_2
favour
an
alternative
approach
smart
and
dumb
pip
component_3
build
from
pattern_1
aim
to
be
a
decouple
and
a
cohesive
a
possible
they
own
their
own
domain
component_16
and
act
more
a
pattern_9
in
the
classical
unix
sense
connector_15
a
connector_data_5
apply
component_16
a
appropriate
and
produce
a
connector_16
these
be
choreograph
use
quality_attribute_8
restish
technology_15
rather
than
complex
technology_15
such
a
w
choreography
or
bpel
or
pattern_10
by
a
central
technology_16
the
two
technology_15
use
most
commonly
be
technology_7
connector_data_5
connector_16
with
resource
technology_8
s
and
lightweight
connector_data_11

the
best
expression
of
the
first
be
be
of
the
web
not
behind
the
web
ian
robinson
pattern_2
team
use
the
principle
and
technology_15
that
the
world_wide_web
and
to
a
large
extent
unix
be
build
on
often
use
resource
can
be
pattern_11
with
very
little
effort
on
the
part
of
developer
or
folk
the
second
approach
in
common
use
be
pattern_12
over
a
lightweight
connector_data_11
bus
the
infrastructure
chosen
be
typically
dumb
dumb
a
in
act
a
a
connector_data_11
pattern_13
only
quality_attribute_8
implementation
such
a
technology_17
or
technology_18

t
do
much
more
than
provide
a
quality_attribute_10
pattern_14
technology_19
the
smart
still
live
in
the
end
point
that
be
produce
and
connector_17
connector_data_11
in
the
component_4
in
a
monolith
the
component_19
be
connector_4
in
component_8
and
connector_12
between
them
be
via
either
invocation
or
connector_data_7
the
big
issue
in
connector_8
a
monolith
into
pattern_1
lie
in
connector_8
the
connector_12
pattern_8
a
naive
conversion
from
in
memory
connector_data_2
to
pattern_15
lead
to
chatty
connector_18
which

t
perform
well
instead
you
need
to
replace
the
fine
grain
connector_12
with
a
coarse
grain
approach
decentralized
governance
one
of
the
consequence
of
centralised
governance
be
the
tendency
to
standardise
on
single
technology_6
component_18
experience
show
that
this
approach
be
constrict
not
every
problem
be
a
nail
and
not
every
solution
a
hammer
we
prefer
use
the
right
technology_16
for
the
and
while
monolithic
component_3
can
take
advantage
of
different
technology_3
to
a
certain
extent
it
isn
t
that
common
split
the
monolith
s
component_19
out
into
component_2
we
have
a
choice
when
build
each
of
them
you
want
to
use
technology_20
to
standup
a
quality_attribute_8
report
component_11
go
for
it
technology_21
for
a
particularly
gnarly
near
real
time
component_17
fine
you
want
to
swap
in
a
different
flavour
of
component_13
that
quality_attribute_5
suit
the
connector_19
behaviour
of
one
component_17
we
have
the
technology_6
to
rebuild
him
of

because
you
can
do
something
doesn
t
mean
you
should
but
partitioning
your
component_6
in
this
way
mean
you
have
the
option
team
build
pattern_1
prefer
a
different
approach
to
technology_4
too
rather
than
use
a
set
of
define
technology_4
connector_2
down
somewhere
on
paper
they
prefer
the
idea
of
produce
useful
technology_16
that
other
developer
can
use
to
solve
similar
problem
to
the
one
they
be
face
these
technology_16
be
usually
harvest
from
implementation
and
connector_20
with
a
wide
group
sometimes
but
not
exclusively
use
an
internal
open
component_29
component_26
now
that
git
and
technology_22
have
become
the
de
facto
version
control
component_6
of
choice
open_source
practice
be
become
more
and
more
common
in
house
netflix
be
a
quality_attribute_5
example
of
an
organisation
that
follow
this
philosophy
connector_21
useful
and
above
all
battle
test
a
technology_11
encourage
other
developer
to
solve
similar
problem
in
similar
way
yet
leave
the
door
open
to
pick
a
different
approach
if
require
connector_20
technology_11
tend
to
be
focus
on
common
problem
of
connector_data_1
storage
inter
component_8
connector_12
and
a
we
discus
further
below
infrastructure
automation
for
the
pattern_2

overhead
be
particularly
unattractive
that
isn
t
to
say
that
the
doesn
t
requirement_9
component_4
contract
quite
the
opposite
since
there
tend
to
be
many
more
of
them
it
s
that
they
be
look
at
different
way
of
manage
those
contract
pattern_8
tolerant
reader
and
component_30
drive
contract
be
often
apply
to
pattern_1
these
aid
component_4
contract
in
quality_attribute_11
independently
connector_4
component_30
drive
contract
a
part
of
your
build
increase
confidence
and
provide
fast
feedback
on
whether
your
component_2
be

indeed
we
of
a
team
in
australia
who
drive
the
build
of
component_2
with
component_30
drive
contract
they
use
quality_attribute_8
technology_16
that
allow
them
to
define
the
contract
for
a
component_4
this
become
part
of
the
automate
build
before
for
the
component_4
be
even
connector_2
the
component_4
be
then
build
out
only
to
the
point
where
it
satisfy
the
contract
an
elegant
approach
to
avoid
the
yagni

dilemma
when
build

these
technique
and
the
technology_16
grow
up
around
them
limit
the
need
for
central
contract
requirement_2
by
decreasing
the
temporal
couple
between
component_4
many
technology_3
many
option
the
growth
of
technology_23
a
a
component_18
be
the
late
example
of
mix
technology_3
within
a
common
component_18
it
s
be
common
practice
to
shell
out
to
a
high
level
technology_3
to
take
advantage
of
high
level
abstraction
for
decade
a
be
drop
down
to
the
metal
and
connector_22
requirement_10
sensitive
in
a
lower
level
one
however
many
monolith

t
need
this
level
of
requirement_10
optimisation
nor
be
dsl
s
and
high
level
abstraction
that
common
to
our
dismay
instead
monolith
be
usually
single
technology_3
and
the
tendency
be
to
limit
the
number
of
technology_6
in
use

perhaps
the
apogee
of
decentralised
governance
be
the
build
it
run
it
ethos
popularise
by

team
be
responsible
for
all
aspect
of
the
they
build
include
operate
the


devolution
of
this
level
of
responsibility
be
definitely
not
the
norm
but
we
do
see
more
and
more
requirement_6
connector_23
responsibility
to
the
development
team
netflix
be
another
organisation
that
have
adopt
this
ethos

be
wake
up
at
3am
every
night
by
your
pager
be
certainly
a
powerful
incentive
to
focus
on
quality
when
connector_22
your

these
idea
be
about
a
far
away
from
the
traditional
centralized
governance
component_26
a
it
be
possible
to
be
decentralized
connector_data_1
requirement_2
decentralization
of
connector_data_1
requirement_2
present
in
a
number
of
different
way
at
the
most
abstract
level
it
mean
that
the
conceptual
component_26
of
the
world
will
differ
between
component_6
this
be
a
common
issue
when
quality_attribute_2
across
a
large
requirement_3
the
sale
pattern_5
of
a
requirement_11
will
differ
from
the
support
pattern_5
some
thing
that
be
connector_10
requirement_11
in
the
sale
pattern_5
not
appear
at
all
in
the
support
pattern_5
those
that
do
have
different
attribute
and
bad
common
attribute
with
subtly
different
semantics
battle
test
technology_4
and
enforce
technology_4
it
s
a
bit
of
a
dichotomy
that
pattern_2
team
tend
to
eschew
the
kind
of
rigid
enforce
technology_4
lay
down
by
requirement_3
architecture
group
but
will
happily
use
and
even
evangelise
the
use
of
open
technology_4
such
a
technology_7
atom
and
other
microformats
the
key
difference
be
how
the
technology_4
be
develop
and
how
they
be
enforce
technology_4
manage
by
group
such
a
the
ietf
only
become
technology_4
when
there
be
several
live
implementation
of
them
in
the
wide
world
and
which
often
grow
from
successful
open
component_29
project
these
technology_4
be
a
world
apart
from
many
in
a
corporate
world
which
be
often
develop
by
group
that
have
little
recent
programming
experience
or
overly
influence
by
vendor
this
issue
be
common
between
component_7
but
can
also
occur
within
component_7
particular
when
that
component_7
be
divide
into
separate
component_17
a
useful
way
of
think
about
this
be
the
domain
drive
design
notion
of
bound
component_25
ddd
divide
a
complex
domain
up
into
multiple
bound
component_25
and
connector_data_13
out
the
relationship
between
them
this
component_8
be
useful
for
both
monolithic
and
pattern_2
architecture
but
there
be
a
natural
correlation
between
component_4
and
component_25
boundary
that
help
clarify
and
a
we
describe
in
the
section
on
requirement_1
capability
reinforce
the
separation
a
well
a
decentralizing
decision
about
conceptual
component_26
pattern_1
also
decentralize
connector_data_1
storage
decision
while
monolithic
component_3
prefer
a
single
logical
component_13
for
persistant
connector_data_1
requirement_3
often
prefer
a
single
component_13
across
a
range
of
component_3
many
of
these
decision
drive
through
vendor
s
commercial
component_28
around
license
pattern_1
prefer

each
component_4
manage
it
own
component_13
either
different
instance
of
the
same
component_13
technology_6
or
entirely
different
component_13
component_5
an
approach
connector_10
polyglot
persistence
you
can
use
polyglot
persistence
in
a
monolith
but
it
appear
more
frequently
with
pattern_1
decentralizing
responsibility
for
connector_data_1
across
pattern_1
have
implication
for
manage
update
the
common
approach
to
deal
with
connector_data_14
have
be
to
use
transaction
to
guarantee
consistency
when
update
multiple
resource
this
approach
be
often
use
within
monolith
use
transaction
this
help
with
consistency
but
impose
significant
temporal
couple
which
be
problematic
across
multiple
component_4
quality_attribute_12
transaction
be
notoriously
difficult
to
connector_24
and
a
a
consequence
pattern_2
architecture
emphasize
transactionless
coordination
between
component_4
with
explicit
recognition
that
consistency
only
be
eventual
consistency
and
problem
be
deal
with
by
compensate

choose
to
manage
inconsistency
in
this
way
be
a
challenge
for
many
development
team
but
it
be
one
that
often
match
requirement_1
practice
often
requirement_1
handle
a
degree
of
inconsistency
in
order
to
respond
quickly
to
demand
while
have
some
kind
of
reversal
component_8
to
deal
with
mistake
the
requirement_12
off
be
worth
it
a
long
a
the
cost
of
fix
mistake
be
le
than
the
cost
of
lose
requirement_1
under
great
consistency
infrastructure
automation
infrastructure
automation
technique
have
quality_attribute_11
enormously
over
the
last
few
year
the
evolution
of
the
requirement_4
and
technology_24
in
particular
have
reduce
the
operational
complexity
of
build
quality_attribute_4
and
operate
pattern_1
many
of
the
technology_1
or
component_5
be
build
with
pattern_1
be
be
build
by
team
with
extensive
experience
of
continuous
delivery
and
it
s
precursor
continuous
requirement_13
team
build
this
way
make
extensive
use
of
infrastructure
automation
technique
this
be
illustrate
in
the
build
pipeline
show
below
figure

basic
build
pipeline
since
this
isn
t
an
on
continuous
delivery
we
will
connector_data_7
attention
to
a
couple
of
key
feature
here
we
want
a
much
confidence
a
possible
that
our
be
work
so
we
run
lot
of
automate
test
promotion
of
work
up
the
pipeline
mean
we
automate
deployment
to
each
environment
make
it
easy
to
do
the
right
thing
one
side
effect
we
have
find
of
increase
automation
a
a
consequence
of
continuous
delivery
and
deployment
be
the
creation
of
useful
technology_16
to
help
developer
and
folk
technology_16
for
create
artefact
manage
codebases
stand
up
quality_attribute_8
component_2
or
for

technology_4
pattern_16
and
requirement_14
be
pretty
common
now
the
best
example
on
the
web
be
probably
netflix
s
set
of
open
component_29
technology_16
but
there
be
others
include
dropwizard
which
we
have
use
extensively
a
monolithic
component_7
will
be
build
test
and
connector_25
through
these
environment
quite
happlily
it
turn
out
that
once
you
have
invest
in
automate
the
path
to
production
for
a
monolith
then
quality_attribute_4
more
component_3
doesn
t
seem
so
scary
any
more
remember
one
of
the
aim
of
cd
be
to
make
deployment
boring
so
whether
it
one
or
three
component_7
a
long
a
it
still
boring
it
doesn
t
matter

another
area
where
we
see
team
use
extensive
infrastructure
automation
be
when
manage
pattern_1
in
production
in
contrast
to
our
assertion
above
that
a
long
a
deployment
be
boring
there
isn
t
that
much
difference
between
monolith
and
pattern_1
the
operational
landscape
for
each
can
be
strikingly
different
figure

deployment
often
differ
design
for
failure
a
consequence
of
use
component_2
a
component_17
be
that
component_3
need
to
be
design
so
that
they
can
tolerate
the
failure
of
component_4
any
component_4
connector_data_7
could
fail
due
to
unavailability
of
the
supplier
the
component_9
have
to
respond
to
this
a
gracefully
a
possible
this
be
a
disadvantage
compare
to
a
monolithic
design
a
it
introduce
additional
complexity
to
handle
it
the
consequence
be
that
pattern_2
team
constantly
reflect
on
how
component_4
failure
affect
the
requirement_15
netflix
s
simian
army
induce
failure
of
component_2
and
even
datacenters
during
the
work
day
to
test
both
the
component_7
s
quality_attribute_13
and
pattern_17
the
circuit
breaker
and
production
ready
circuit
breaker
appear
in
release
it
alongside
other
pattern_8
such
a
bulkhead
and
timeout
connector_24
together
these
pattern_8
be
crucially
important
when
build
connector_1
component_7
this
netflix
entry
do
a
great
of
explain
their
component_7
of
them
this
kind
of
automate
test
in
production
would
be
enough
to
give
most
group
the
kind
of
shiver
usually
precede
a
week
off
work
this
isn
t
to
say
that
monolithic
architectural
style
aren
t
capable
of
sophisticate
pattern_16
setup
it
s
le
common
in
our
experience
since
component_2
can
fail
at
any
time
it
s
important
to
be
able
to
detect
the
failure
quickly
and
if
possible
automatically
restore
component_4
pattern_2
component_3
put
a
lot
of
emphasis
on
real
time
pattern_16
of
the
component_7
connector_26
both
architectural
element
how
many
connector_data_15
per
second
be
the
component_13
connector_27
and
requirement_1
relevant
metric
such
a
how
many
order
per
minute
be
connector_28
semantic
pattern_16
can
provide
an
early
warn
component_6
of
something
go
wrong
that
connector_29
development
team
to
follow
up
and
investigate
this
be
particularly
important
to
a
pattern_1
architecture
because
the
pattern_2
preference
towards
choreography
and
collaboration
lead
to
emergent
behavior
while
many
pundit
praise
the
requirement_9
of
serendipitous
emergence
the
truth
be
that
emergent
behavior
can
sometimes
be
a
bad
thing
pattern_16
be
vital
to
spot
bad
emergent
behavior
quickly
so
it
can
be
fix
pattern_4
connector_data_2
consider
harmful
any
time
you
have
a
number
of
pattern_4
connector_data_2
between
component_2
you
will
encounter
the
multiplicative
effect
of
downtime
simply
this
be
when
the
downtime
of
your
component_6
become
the
technology_1
of
the
downtime
of
the
individual
component_17
you
face
a
choice
make
your
connector_data_2
pattern_14
or
manage
the
downtime
at
www
guardian
co
uk
they
have
connector_24
a
quality_attribute_8
rule
on
the
component_18
one
pattern_4
connector_data_7
per
component_10
connector_data_5
while
at
netflix
their
component_18
component_31
redesign
have
build
asynchronicity
into
the
component_31
technology_19
monolith
can
be
build
to
be
a
quality_attribute_14
a
a
pattern_2
in
fact
they
should
be
the
difference
be
that
you
need
to
when
component_2
run
in
different
component_24
be
disconnect
with
technology_11
within
the
same
component_8
this
kind
of
quality_attribute_15
be
le
likely
to
be
useful
pattern_2
team
would
expect
to
see
sophisticate
pattern_16
and
requirement_14
setup
for
each
individual
component_4
such
a
requirement_16
show
up
down
status
and
a
variety
of
operational
and
requirement_1
relevant
metric
detail
on
circuit
breaker
status
current
quality_attribute_16
and
quality_attribute_17
be
other
example
we
often
encounter
in
the
wild
evolutionary
design
pattern_2
practitioner
usually
have
come
from
an
evolutionary
design
background
and
see
component_4
decomposition
a
a
further
technology_16
to
enable
component_7
developer
to
control
connector_7
in
their
component_7
without
slow
down
connector_8
connector_8
control
doesn
t
necessarily
mean
connector_8
reduction
with
the
right
attitude
and
technology_16
you
can
make
frequent
fast
and
well
control
connector_7
to

whenever
you
try
to
break
a
component_6
into
component_17
you
re
face
with
the
decision
of
how
to
divide
up
the
piece
what
be
the
principle
on
which
we
decide
to
slice
up
our
component_7
the
key
property
of
a
component_17
be
the
notion
of
independent
replacement
and
upgradeability

which
imply
we
look
for
point
where
we
can
imagine
rewrite
a
component_17
without
affect
it
collaborator
indeed
many
pattern_2
group
take
this
further
by
explicitly
expect
many
component_2
to
be
scrap
rather
than
quality_attribute_11
in
the
long
term
the
guardian
be
a
quality_attribute_5
example
of
an
component_7
that
be
design
and
build
a
a
monolith
but
have
be
quality_attribute_11
in
a
pattern_2
direction
the
monolith
still
be
the
core
of
the

but
they
prefer
to
feature
by
build
pattern_1
that
use
the
monolith
s
technology_8
this
approach
be
particularly
handy
for
feature
that
be
inherently
temporary
such
a
specialize
component_11
to
handle
a
sport

such
a
part
of
the
can
quickly
be
put
together
use
rapid
development
technology_3
and
remove
once
the
be
over
we
ve
see
similar
approach
at
a
financial
institution
where
component_2
be

for
a
requirement_17
opportunity
and
discard
after
a
few
month
or
even
week
this
emphasis
on
replaceability
be
a
special
requirement_7
of
a
more
general
principle
of
modular
design
which
be
to
drive
quality_attribute_18
through
the
pattern_8
of
connector_8

you
want
to
keep
thing
that
connector_8
at
the
same
time
in
the
same

part
of
a
component_6
that
connector_8
rarely
should
be
in
different
component_2
to
those
that
be
currently
undergo
lot
of
churn
if
you
find
yourself
repeatedly
connector_8
two
component_2
together
that
s
a
sign
that
they
should
be
merge
put
component_19
into
component_2

an
opportunity
for
more
granular
release
plan
with
a
monolith
any
connector_7
require
a
full
build
and
deployment
of
the
entire
component_7
with
pattern_1
however
you
only
need
to
redeploy
the
component_4
s
you
modify
this
can
simplify
and
quality_attribute_19
up
the
release
component_8
the
downside
be
that
you
have
to
worry
about
connector_7
to
one
component_4
break
it
component_30
the
traditional
requirement_13
approach
be
to
try
to
deal
with
this
problem
use
versioning
but
the
preference
in
the
pattern_2
world
be
to
only
use
versioning
a
a
last
resort
we
can
avoid
a
lot
of
versioning
by
design
component_2
to
be
a
tolerant
a
possible
to
connector_7
in
their
supplier
be
pattern_1
the
future
our
aim
in
connector_22
this
be
to
explain
the
major
idea
and
principle
of
pattern_1
by
take
the
time
to
do
this
we
clearly
think
that
the
pattern_1
architectural
style
be
an
important
idea
one
worth
serious
consideration
for
requirement_3
component_7
we
have
recently
build
several
component_5
use
the
style
and
of
others
who
have
use
and
favor
this
approach
pattern_2
requirement_12
off
many
development
team
have
find
the
pattern_1
architectural
style
to
be
a
superior
approach
to
a
monolithic
architecture
but
other
team
have
find
them
to
be
a
productivity
technology_25
burden
any
architectural
style
pattern_1
bring
cost
and
benefit
to
make
a
sensible
choice
you
have
to
understand
these
and
apply
them
to
your
specific
component_25
by
martin
fowler

jul

connector_19
more…
pattern_1
those
we
about
who
be
in
some
way
pioneer
the
architectural
style
include

netflix
the
guardian
the
uk
government
digital
component_4
realestate
technology_13
au
connector_30
and
comparethemarket
technology_13
the
conference
circuit
in

be
full
of
example
of
requirement_6
that
be
move
to
something
that
would
a
pattern_1
include
travis
ci
in
addition
there
be
plenty
of
organization
that
have
long
be
do
what
we
would
a
pattern_1
but
without
ever
use
the
name
often
this
be
label
a
pattern_3
although
a
we
ve
say
pattern_3
come
in
many
contradictory
form

despite
these
positive
experience
however
we
aren
t
argue
that
we
be
certain
that
pattern_1
be
the
future
direction
for
architecture
while
our
experience
so
far
be
positive
compare
to
monolithic
component_7
we
re
conscious
of
the
fact
that
not
enough
time
have
pass
for
u
to
make
a
full
judgement
often
the
true
consequence
of
your
architectural
decision
be
only
evident
several
year
after
you
make
them
we
have
see
project
where
a
quality_attribute_5
team
with
a
strong
desire
for
quality_attribute_18
have
build
a
monolithic
architecture
that
have
decay
over
the
year
many
people
believe
that
such
decay
be
le
likely
with
pattern_1
since
the
component_4
boundary
be
explicit
and
hard
to
patch
around
yet
until
we
see
enough
component_5
with
enough
age
we
can
t
truly
ass
how
pattern_2
architecture
mature
there
be
certainly
reason
why
one
might
expect
pattern_1
to
mature
poorly
in
any
effort
at
componentization
success
quality_attribute_20
on
how
well
the
fit
into
component_17
it
s
hard
to
figure
out
exactly
where
the
component_17
boundary
should
lie
evolutionary
design
recognize
the
difficulty
of
connector_31
boundary
right
and
thus
the
importance
of
it
be
easy
to
refactor
them
but
when
your
component_19
be
component_2
with
remote
connector_12
then
refactoring
be
much
hard
than
with
in
component_8
technology_11
move
be
difficult
across
component_4
boundary
any
connector_7
need
to
be
coordinate
between
participant
pattern_7
of
backwards
quality_attribute_21
need
to
be

and
test
be
make
more
complicate
our
colleague
sam
newman
spend
most
of

work
on
a
book
that
capture
our
experience
with
build
pattern_1
this
should
be
your
next
step
if
you
want
a
deep
dive
into
the
topic
another
issue
be
if
the
component_19
do
not
compose
cleanly
then
all
you
be
do
be
shift
complexity
from
inside
a
component_17
to
the
connector_32
between
component_17
not
do
this
move
complexity
around
it
move
it
to
a
place
that
s
le
explicit
and
hard
to
control
it
s
easy
to
think
thing
be
quality_attribute_5
when
you
be
look
at
the
inside
of
a
small
quality_attribute_8
component_17
while
miss
messy
connector_32
between
component_4
finally
there
be
the
factor
of
team
skill
technique
tend
to
be
adopt
by
more
skillful
team
but
a
technique
that
be
more
quality_attribute_22
for
a
more
skillful
team
isn
t
necessarily
go
to
work
for
le
skillful
team
we
ve
see
plenty
of
requirement_7
of
le
skillful
team
build
messy
monolithic
architecture
but
it
take
time
to
see
what
happen
when
this
kind
of
mess
occur
with
pattern_1
a
poor
team
will
always
create
a
poor
component_6
it
s
very
hard
to
tell
if
pattern_1
reduce
the
mess
in
this
requirement_7
or
make
it
bad
one
reasonable
argument
we
ve
hear
be
that
you
shouldn
t
start
with
a
pattern_1
architecture
instead
begin
with
a
monolith
keep
it
modular
and
split
it
into
pattern_1
once
the
monolith
become
a
problem
although
this
advice
isn
t
ideal
since
a
quality_attribute_5
in
component_8
be
usually
not
a
quality_attribute_5
component_4

so
we
connector_2
this
with
cautious
optimism
so
far
we
ve
see
enough
about
the
pattern_2
style
to
feel
that
it
can
be
a
worthwhile
road
to
tread
we
can
t
say
for
sure
where
we
ll
end
up
but
one
of
the
challenge
of
development
be
that
you
can
only
make
decision
base
on
the
imperfect
connector_data_4
that
you
currently
have
to
hand
footnote

the
term
pattern_2
be
discuss
at
a
workshop
of
architect
near
venice
in


to
describe
what
the
participant
saw
a
a
common
architectural
style
that
many
of
them
have
be
recently
explore
in

the
same
group
decide
on
pattern_1
a
the
most
appropriate
name
james
present
some
of
these
idea
a
a
requirement_7
study
in

at
33rd
degree
in
krakow
in
pattern_1
technology_26
the
unix
way
a
do
fred
george
about
the
same
time
adrian
cockcroft
at
netflix
describe
this
approach
a
fine
grain
technology_14
be
pioneer
the
style
at
web
quality_attribute_3
a
be
many
of
the
others
mention
in
this
joe
walnes
daniel
terhorst
north
evan
botcher
and
graham
tackley

the
term
monolith
have
be
in
use
by
the
unix
for
some
time
it
appear
in
the
art
of
unix
programming
to
describe
component_5
that
connector_27
too
big

many
connector_data_8
orient
designer
include
ourselves
use
the
term
component_4
connector_data_8
in
the
domain
drive
design
sense
for
an
connector_data_8
that
carry
out
a
significant
component_8
that
isn
t
tie
to
an
component_32
this
be
a
different
concept
to
how
we
re
use
component_4
in
this

sadly
the
term
component_4
have
both
mean
and
we
have
to
live
with
the
polyseme

we
consider
an
component_7
to
be
a
social
construction
that
bind
together
a
base
group
of
requirement_8
and
body
of
fund

the
original
paper
can
be
find
on
melvin
conway
s
here

we
can
t
resist
mention
jim
webber
s
statement
that
esb
stand
for
erroneous
spaghetti
component_33

netflix
make
the
connector_9
explicit
until
recently
refer
to
their
architectural
style
a
fine
grain
technology_14

at
extreme
of
quality_attribute_3
organisation
often
move
to
binary
technology_15
technology_27
for
example
component_5
use
these
still
exhibit
the
characteristic
of
smart

dumb
pip
and
trade_off
quality_attribute_15
for
quality_attribute_3
most
web
property
and
certainly
the
vast
majority
of
requirement_3

t
need
to
make
this
tradeoff
quality_attribute_15
can
be
a
big
win

yagni
or
you
aren
t
go
to
need
it
be
an
xp
principle
and
exhortation
to
not
feature
until
you
you
need
them

it
s
a
little
disengenuous
of
u
to
claim
that
monolith
be
single
technology_3
in
order
to
build
component_5
on
today
web
you
probably
need
to
technology_10
and
technology_28
cs
your
component_15
side
technology_3
of
choice
technology_29
and
an
technology_30
dialect
hardly
single
technology_3
but
you
what
we
mean

adrian
cockcroft
specifically
mention
developer
self
component_4
and
developer
run
what
they
connector_2
sic
in
this
excellent
presentation
connector_13
at
flowcon
in



we
be
be
a
little
disengenuous
here
obviously
quality_attribute_4
more
component_4
in
more
complex
topology
be
more
difficult
than
quality_attribute_4
a
single
monolith
fortunately
pattern_8
reduce
this
complexity
investment
in
technology_16
be
still
a
must
though

in
fact
daniel
terhorst
north
refer
to
this
style
a
replaceable
component_17
architecture
rather
than
pattern_1
since
this
seem
to
talk
to
a
subset
of
the
characteristic
we
prefer
the
latter

kent
beck
highlight
this
a
one
his
design
principle
in
implementation
pattern_8

and
pattern_3
be
hardly
the
root
of
this
history
i
remember
people
say
we
ve
be
do
this
for
year
when
the
pattern_3
term
appear
at
the
begin
of
the
century
one
argument
be
that
this
style
see
it
root
a
the
way
cobol
component_21
connector_33
via
connector_data_1
in
the
early
day
of
requirement_3
computing
in
another
direction
one
could
argue
that
pattern_1
be
the
same
thing
a
the
technology_31
programming
component_26
but
apply
to
an
requirement_3
component_7
component_25
reference
while
this
be
not
an
exhaustive
connector_data_16
there
be
a
number
of
component_34
that
practitioner
have
draw
inspiration
from
or
which
espouse
a
similar
philosophy
to
that
describe
in
this


and
online

clemens
vasters’
on
requirement_4
at
david
morgantini’s
introduction
to
the
topic
on
his

factor
component_35
from
technology_32
uk
government
digital
component_4
design
principle
jimmy
nilsson’s
blogand
on
infoq
about
requirement_4
chunk
computing
alistair
cockburn
on
hexagonal
architecture
book
release
it
rest
in
practice
web
component_31
design
free
ebook
brian
mulloy
apigee
requirement_3
requirement_13
pattern_8
art
of
unix
programming
grow
connector_data_8
orient

guide
by
test
the
modern
firm
organizational
design
for
requirement_10
and
growth
continuous
delivery
quality_attribute_10
release
through
build
test
and
deployment
automation
domain
drive
design
tackle
complexity
in
the
heart
of
presentation
architecture
without
architect
erik
doernenburg
do
my
bus
look
big
in
this
jim
webber
and
martin
fowler
qcon

guerilla
technology_14
jim
webber

pattern_8
of
quality_attribute_22
delivery
daniel
terhorst
north

adrian
cockcroft
s
slideshare
pattern_18
hydra
and
hypermedia
ian
robinson
javazone

justice
will
take
a
million
intricate
move
leonard
richardson
qcon

technology_26
the
unix
way
james
lewis
javazone

micro
component_2
architecture
fred
george
yow

democratise
attention
connector_data_1
at
guardian
co
uk
graham
tackley
goto
aarhus

functional
reactive
programming
with
rxjava
ben
christensen
goto
aarhus

registration
require
break
the
monolith
stefan
tilkov

paper
l
lamport
the
implementation
of
quality_attribute_10
quality_attribute_12
multiprocess
component_6

technology_7
research

technology_13
en
u
um
people
lamport
pub
implementation
pdf
l
lamport
r
shostak
m
pea
the
byzantine
general
problem

quality_attribute_23
at
technology_7
www
technology_33
cornell
edu

cs614
2004sp
paper
lsp82
pdf
r
t

architectural
style
and
the
design
of
requirement_18
base
architecture

technology_7
www
ic
uci
edu
~fielding
pub
dissertation
top
htm
e
a
brewer
towards
quality_attribute_24
quality_attribute_12
component_6

technology_7
www
technology_33
berkeley
edu
~brewer
cs262b

podc
keynote
pdf
e
brewer
cap
twelve
year
late
how
the
rule
have
connector_8

technology_7
www
infoq
technology_13

cap
twelve
year
late
how
the
rule
have
connector_8
further
connector_34
the
above
connector_data_16
capture
the
reference
we
use
when
we
originally
connector_2
this
in
early

for
an
up
to
date
connector_data_16
of
component_34
for
more
connector_data_4
take
a
look
at
the
pattern_2
resource
guide
significant
revision


last
installment
on
be
pattern_1
the
future



section
on
evolutionary
design



section
on
infrastructure
automation
and
design
for
failure



section
on
decentralized
connector_data_1



section
on
decentralized
governance



section
on
smart
and
dumb
pip



section
on
technology_1
not
project



section
on
organize
around
requirement_1
capability


publish
first
installment
topic
architecture
refactoring
agile
delivery
pattern_1
connector_data_1
test
dsl
about
me
about
book
faq
content
video
content
index
board
game
photography
thoughtworks
insight
career
technology_1
follow
twitter
technology_2
©
martin
fowler
|
privacy
requirement_19
|
disclosure
