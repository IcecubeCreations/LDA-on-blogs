pattern_1
couple
with
pattern_2
requirement_1
·
hossam
barakat
hossam
barakat
consultant
interest
in
web
development
pattern_1
serverless
and
agile
methodology
home
about
talk

nov

pattern_1
couple
with
pattern_2
requirement_1
pattern_1
a
lot
of
requirement_2
have
start
the
journey
of
split
their
current
monolithic
component_1
into
pattern_1
to
gain
all
the
benefit
from
pattern_1
such
a
strong
boundary
independent
deployment
hybrid
technologies…
which
be
fine
but
what
i
be
concern
about
the
assumption
of
split
monolothic
component_2
to
pattern_3
will
automatically
lead
to
a
loosely
couple
component_3
let’s
start
with
a
quality_attribute_1
piece
of
handle
purchasing
command
that
include
create
an
order
then
start
the
ship
component_4
purchasecommand
{
connector_data_1
orderitem
connector_data_2
{
connector_1
set
}
connector_2
shippingaddress
{
connector_1
set
}
rest
of
command
property
}
purchasecommandhandler
{
handle
purchasecommand
command
{
use
var
transactionscope
=
transactionscope
{
saveorderindb
command
saveshippingindb
command
}
}
}
now
we
decide
that
this
should
be
split
into
two
pattern_1
“orders”
and
“shipping”
and
each
one
will
be
component_5
in
a
separate
component_4
but
how
the
two
pattern_1
will
connector_3
to
each
other
pattern_4
usually
the
answer
be
use
pattern_4
for
requirement_1
between
component_3
so
the
“shipping”
component_3
will
connector_4
an
end
point
that
could
be
connector_5
by
“orders”
component_3
ship
component_3
startshippingcommand
{
guid
orderid
{
connector_1
set
}
connector_data_1
orderitem
connector_data_2
{
connector_1
set
}
}
startshippingcommandhandler
{
handle
startshippingcommand
command
{
saveshippingindb
command
}
}
the
order
component_3
will
be
update
to
make
a
connector_data_3
to
the
ship

order
component_3
purchasecommandhandler
{
handle
purchasecommand
command
{
saveorderindb
command
var
shippingserviceproxy
=
shippingserviceproxy
shippingserviceproxy
startshipping

startshippingcommand
{}
}
}
so
we
manage
to
split
the
into
two
separate
component_6
that
could
be
quality_attribute_2
independently…but
be
the
component_6
loosely
couple
autonomous
pattern_3
be
a
component_3
that
can
respond
to
component_7
connector_data_4
regardless
of
the
availablity
of
other
services…to
an
extent
what
will
happen
if
the
ship
component_3
be
not
quality_attribute_3
the
order
component_3
will
connector_6
the
order
in
the
db
but
will
fail
while
connector_7
the
ship
and
the
whole
purchase
will
fail
moreover
our
component_8
will
be
leave
with
connector_data_5
inconsistency
so
although
the
“orders”
and
“shipping”
component_6
be
now
component_5
in
two
separate
component_9
they
be
still
couple
because
the
“orders”
component_3
will
not
be
able
to
serve
the
component_7
connector_data_6
unless
the
“shipping”
component_3
be
quality_attribute_3
so
how
could
we
remove
the
couple
pattern_5
requirement_1
pattern_5
requirement_1
mean
the
connector_8
between
component_6
do
though

component_3
will
publish
an
when
something
notable
happen
and
then
other
component_6
could
subscribe
to
the
and
do
it
own
component_10
which
could
connector_data_7
in
publish
more

so
in
our
scenario
pattern_5
requirement_1
mean
that
“orders”
component_3
will
connector_6
the
order
in
the
component_8
then
an
orderaccepted
the
“shipping”
component_3
will
subscribe
to
orderaccepted
and
will
connector_6
the
ship
connector_data_8
in
the
component_8
order
component_3
orderaccepted
{
guid
orderid
{
connector_1
set
}
connector_data_1
orderitem
connector_data_2
{
connector_1
set
}
}
purchasecommandhandler
{
handle
purchasecommand
command
{
saveorderindb
command
bus
publish

orderaccepted
{
orderid
=
orderid
connector_data_2
=
connector_data_1
orderitem
command
item
}
}
}
ship
component_3
startshippingcommandhandler
{
handle
orderaccepted
@event
{
saveshippingindb
@event
}
}
the
“shipping”
component_3
could
publish
another
connector_5
shippingstarted
so
“orders”
component_3
could
update
the
the
order
status
again
what
will
happen
if
the
“shipping”
component_3
unavailable
the
“orders”
component_3
now
can
serve
the
connector_data_4
while
“shipping”
component_3
be
down
because
it
can
connector_6
the
connector_data_5
in
component_8
then
publish
an
and
respond
immediately
to
the
component_7
the
publish
ordeaccepted
will
be
component_4
by
the
“shipping”
component_3
whenever
it
be
quality_attribute_3
ofcourse
that
be
assume
that
the
have
be
publish
successfully
inside
the
bus
component_11
summary
decompose
a
monolithic
component_2
into
a
set
of
component_6
component_5
in
different
component_9
doesn’t
guarantee
have
a
loosely
couple
pattern_1
pattern_2
connector_8
between
pattern_1
will
lead
to
a
more
couple
pattern_1
however
use
pattern_6
pattern_5
connector_8
will
help
in
lead
to
more
autonomous
loosely
couple
pattern_1
please
enable
technology_1
to
pattern_7
the

powered
by
disqus

powered
by
disqus
