monolithic
decomposition
and
connector_1
pattern_1
architecture
pattern_1
pattern_1
zone
thanks
for
visit
today
edit
profile
manage
subscription
how
to
to
submission
guideline
sign
out
pattern_2
profile
an
manage
my
draft
over

million
developer
have
join

requirement_1
in
join
refcardz
trend
report
webinars
zone
|
agile
requirement_2
requirement_3
requirement_4
component_1
devops
requirement_5
iot
technology_1
pattern_1
open_source
requirement_6
quality_attribute_1
web
dev
pattern_1
zone
monolithic
decomposition
and
connector_1
pattern_1
architecture
monolithic
decomposition
and
connector_1
pattern_1
architecture
the
decomposition
of
an
component_2
into
pattern_1
play
a
key
role
in
pattern_1
architecture
implementation
deployment
and
ci
cd
by
chandani
patel
·
jul


·
pattern_1
zone
·

connector_2
tweet

73k
pattern_2
join
the
and
connector_3
the
full
member
experience
join
for
free
pattern_1
be
one
of
the
most
popular
buzz
word
in
the
of
architecture
while
our
first
talk
about
the
fundamental
and
benefit
of
pattern_1
in
this
we
will
explain
how
requirement_7
can
connector_4
pattern_1
in
real
world
use
requirement_8
by
leverage
key
architectural
principle
how
to
start
with
design
pattern_1
base
requirement_4
solution
architecture
pattern_1
base
solution
architecture
be
not
always
the
best
fit
for
all
use
requirement_8
and
use
a
one
size
fit
all
approach
have
several
drawback
before
design
a
pattern_1
base
solution
architecture
requirement_7
solution
architect
must
connector_5
the
follow
question
be
pattern_1
architecture
a
quality_attribute_2
fit
for
the
solution
how
should
one
define
the
pattern_1
architecture
while
build
pattern_1
architecture
for
the
first
version
of
an
component_2
we
suggest
go
for
a
“monolithic”
approach
this
mean
you
build
your
component_2
in
a
quality_attribute_3
way
to
validate
your
idea
first
then
you
apply
the
principle
include
in
this
to
quality_attribute_4
and
quality_attribute_5
your
initial
monolith
into
a
pattern_1
base
solution
architecture
there
be
no
requirement_9
in
create
architecturally
pure
pattern_1
that
do
not
offer
requirement_9
back
to
the
requirement_10
monolithic
architecture
pattern_3
will
help
you
to
understand
several
issue
and
limitation
about
large
and
complex
component_3
that
can
possibly
occur
with
pattern_1
architecture
once
you
have
connector_4
your
component_2
use
monolithic
architecture
you
need
to
consider
the
follow
development
and
pattern_3
that
you
can
apply
in
undertake
a
pattern_1
transformation

decomposition
of
the
component_2
into
component_4
pattern_1
architecture
be
a
set
of
loosely
couple
component_4
and
decomposition
of
the
component_2
into
component_4
play
a
key
role
in
pattern_1
architecture
implementation
deployment
and
ci
cd
solution
architect
can
define
the
decomposition
base
on
need
&
solution
there
be
no
“best”
for
decomposition
but
there
be
common

which
can
help
you
to
decompose
your
solution
in
several
component_4
a
mention
below
to
apply
decomposition
you
need
to
understand
the
need
&
role
of
each
component_5
weight
connector_6
between
several
component_5
and
more
factor
for
each
component_5
of
the
entire
solution
decomposition
strategy
decompose
by

requirement_10
capability
this
suggest
define
each
component_5
for
each
or
feature
i
e
connector_data_1
requirement_1
component_6
connector_7
component_7
requirement_11
this
help
you
to
assign
an
entire
feature

to
separate
team
where
respective
team
will
be
responsible
for
a

feature
decompose
by
domain
this
suggest
define
the
region
where
your
solution
be
go
to
be
quality_attribute_6
and
further
define
the
component_4
to
that
region
define
component_4
correspond
to
domain
drive
design
ddd
subdomains
ddd
refer
to
the
application’s
problem
space
the
requirement_10
a
the
domain
a
domain
consist
of
multiple
subdomains
each
subdomain
correspond
to
a
different
part
of
the
requirement_10
e
g
component_7
requirement_11
component_6
requirement_11
component_6
connector_7
thing
to
consider
while
decomposition
find
boundary
for
each
component_8
and
align
them
with
requirement_10
capability
stay
focus
on
define
the
scope
of
the
pattern_4
and
not
shrink
the
component_8
the
right
size
of
the
component_8
should
be
the
require
size
to
facilitate
a
give
requirement_10
capability
the
component_8
should
have
very
few

requirement_12
and
a
quality_attribute_3
connector_data_1
technology_2
make
sure
the
pattern_1
design
ensure
the
agile
independent
development
and
deployment
of
the
component_8
each
component_8
must
be
quality_attribute_7
and
quality_attribute_8
individually
component_4
must
be
cohesive
a
component_8
should
connector_4
a
small
set
of
strongly
relate

each
component_8
should
be
small
enough
so
that
it
can
be
develop
by
a
small
team
of

member
the
component_2
must
be
easy
to
understand
and
modify
the
component_8
must
be
quality_attribute_9
in
load
balancer
infrastructure
elb

pattern_1
discovery
and
registration
the
pattern_4
architecture
us
the
component_8
registry
to
maintain
the
location
of
component_8
to
connector_8
connector_data_2
and
this
registry
can
be
manage
on
the
component_9
side
or
component_10
side
the
component_8
can
register
itself
or
via
a
third
party
deployment
script
can
register
the
component_8
each
component_8
should
register
itself
on
the
registry
on
component_8
bootup
with
a
health
connector_9

health
connector_9
help
the
registry
connector_9
for
component_8
quality_attribute_10
while
define
the
component_8
registry
you
must
connector_4
a
mechanism
that
enable
the
component_11
of
the
component_8
to
make
connector_data_3
to
a
dynamically
connector_10
set
of
ephemeral
component_8
instance

pattern_1
connector_7
for
this
the
architecture
must
allow
each
component_8
to
connector_11
with
each
other
here
be
multiple
way
to
define
inter
component_8
connector_7
remote
component_12
invocation
remote
invocation
apply
the
principle
of
pattern_5
to
quality_attribute_11
component_8
if
an
component_2
need
to
modify
the
connector_data_4
of
another
then
it
do
so
by
make
a
connector_data_5
to
another
each
component_8
can
maintain
the
quality_attribute_12
of
the
connector_data_4
it
own
furthermore
each
component_8
can
alter
it
internal
connector_data_4
without
have
every
other
component_2
be
affect
you
can
use
grpc
technology_3
technology_4
and
pattern_6
for
such
connector_7
connector_data_1
use
pattern_7
pattern_8
within
inter
component_8
connector_7
use
technology_5
such
a
technology_6
technology_7
etc
this
will
work
when
each
connector_data_2
be
independent
and
do
not
require
any
pattern_9
domain
specific
connector_data_5
use
domain
specific
technology_8
for
inter
component_8
connector_data_6
e
g
technology_9
or
technology_10
for

technology_11
rtmp
hl
or
technology_12
for

connector_12

pattern_1
observation
observation
be
another
key
point
for
pattern_1
technology_13
this
allow
you
to
debug
&
pattern_10
each
component_8
there
be
several
aspect
that
need
to
be
connector_5
while
design
pattern_1
requirement_1
aggregation
use
centralized
requirement_1
from
each
component_8
instance
the
component_7
reviewer
can
search
&
analyze
the
requirement_1
they
can
configure
alert
on
several
critical
error
and
connector_9
the
number
of
error
by
category
this
can
be
achieve
by
quality_attribute_11
logstash
a
the
central
requirement_1
component_9
health
connector_9
health
connector_9
help
the
component_7
reviewer
to
connector_9
whether
a
component_8
be
quality_attribute_13
or
not
this
can
be
achieve
by
create
a
pattern_6
with
a
connector_13
and
quality_attribute_11
a
load
balancer
which
periodically
connector_14
the
health
of
component_13
and
connector_data_7
the
status
of
component_8
component_2
metric
it
provide
component_8
status
metric
include
connector_data_8
for
example
how
many
connector_data_6
per
technology_14
where
be
the
maximum
connector_data_3
originate
from
this
component_8
run
in
the
background
and
connector_15
with
each
of
the
component_9
so
the
component_8
you
choose
should
take
minimal
runtime
overhead
e
g
appmetrics
for
a
technology_15
coda
hale
for
technology_1
requirement_1
deployment
&
connector_10
it
be
useful
to
see
when
deployment
and
other
connector_16
occur
since
issue
usually
occur
immediately
after
a
connector_10
e
g
enable
connector_data_9
for
deployment
status
enable
connector_data_9
on
component_2
crash

pattern_1
component_1
requirement_11
most
component_4
need
to
have
persistent
connector_data_4
in
a
component_1
for
example
the
component_6
component_8
connector_17
connector_data_8
about
component_6
and
the
component_7
component_8
connector_17
connector_data_8
about
component_7
component_1
requirement_11
strategy
there
be
multiple
way
to
manage
component_1
in
pattern_4
technology_13
component_1
per
component_8
keep
each
microservice’s
persistent
connector_data_4
private
to
that
component_8
and
quality_attribute_14
only
via
it
technology_14
connector_18
component_1
for
solution
use
a
single
component_1
that
be
connector_18
by
multiple
component_8
each
component_8
freely
connector_19
connector_data_4
owned
by
other
component_4
use
local
acid
transaction
hybrid
component_1
create
common
connector_18
component_1
and
component_8
specific
component_1
separately
for
e
g
in
a
typical
iot
requirement_4
component_14
a
a
component_8
architect
choose
to
component_15
connector_data_2
timeout
wait
period
for
each
component_8
in
a
common
component_1
and
component_15
component_7
component_6
and
other

specific
connector_data_8
in
a
specific
component_1
which
will
be
quality_attribute_14
only
through
specific
component_8
connector_20
for
that

thing
to
consider
while
manage
component_1
some
requirement_10
transaction
must
enforce
invariant
that
span
multiple
component_8
some
requirement_10
transaction
need
to
query
connector_data_4
that
be
owned
by
multiple
component_8
for
example
to
connector_21
component_7
component_6
it
will
connector_data_2
detail
from
component_7
component_8
and
component_6
component_8
some
connector_22
must
join
connector_data_4
that
be
owned
by
multiple
component_4
component_1
must
sometimes
be
replicate
and
sharded
in
order
to
quality_attribute_4
different
component_4
have
different
connector_data_4
storage
requirement
e
g
requirement_1
component_8
will
use
logstash
component_7
component_8
and
component_6
requirement_11
will
use
technology_16

pattern_1
external
technology_14
gateway
an
external
be
a
gate
from
where
component_7
component_2
connector_23
with
pattern_1
connector_4
component_13
gateway
to
enable
a
single
entry
point
for
all
component_8
connector_data_3
from
component_10
component_13
gateway
will
pattern_11
connector_data_3
and
pattern_12
connector_24
to
actual
component_8
component_13
gateway
connector_25
quality_attribute_1
include
connector_19
connector_data_10
in
or
query
parameter
for
quality_attribute_15

requirement_7
architect
should
design
component_13
gateway
to
take
care
of
quality_attribute_1
component_16
connector_data_4
protection
and
a
number
of
connector_data_2
limit
per
component_7
per
ip
or
per
component_2
to
prevent
ddos
attack

pattern_1
test
when
try
to
test
an
component_2
that
connector_26
with
other
component_8
one
could
do
one
of
two
thing
quality_attribute_6
all
pattern_1
and
perform
end
to
end
test
simulate
production
in
your
test
environment
and
run
end
to
end
test
before
deployment
this
will
test
real
use
requirement_8
and
ensure
component_8
quality
the
disadvantage
of
such
test
be
that
they
be
time
connector_27
and
debug
be
extremely
difficult
mock
other
pattern_1
in
unit
requirement_5
test
mock
the
external
component_4
and
run
unit
and
requirement_5
test
this
approach
be
very
fast
but
it
cannot
guarantee
that
production
be
quality_attribute_16
common
advice
for
test
pattern_1
be
to
use
combine
requirement_5
test
&
unit
test
run
some
of
the
test
unit
test
and
some
of
them
a
requirement_5
test
that
can
ensure
the
require
quality
within
the
solution
while
plan
the
test
you
must
include
component_8
component_5
test
&
component_8
requirement_5
contract
test
a
part
of
the
test
component_12
you
can
use
several
test
technology_5
technology_13
in
development
such
a
junit
technology_17
requirement_4
contract
for
technology_1
&
mocha
chai
sinon
proxyquire
etc
for
nodejs
you
can
generate
technology_18
report
by
connector_9
style
to
validate
the
test
report
&
coverage
ideally
80%
of
coverage
be
recommend
for
any
component_17


pattern_1
continuous
requirement_5
&
deployment
each
component_8
be
quality_attribute_6
a
a
set
of
component_8
instance
for
quality_attribute_17
&
quality_attribute_10
ci
cd
strategy
multiple
component_4
per
instance
run
multiple
component_4
in
the
same
component_18
physical
or
virtual
e
g
quality_attribute_6
all
nodejs
component_4
on
an
technology_19
instance
a
separate
component_8
this
will
work
when
you
be
in
development
or
you
have
a
small
number
of
component_19
connector_28
your
component_2
a
component_19
grow
this
lead
to
problem
resource
conflict
memory
&
cpu
utilization
issue
and
insufficient
pattern_13
of
component_8
behavior
component_8
instance
per
component_18
quality_attribute_6
a
single
component_8
on
each
component_18
this
overcome
issue
of
multiple
component_4
per
instance
with
an
quality_attribute_18
way
to
balance
the
load
such
a
when
a
load
be
high
for
a
particular
component_8
in
such
requirement_8
you
can
quality_attribute_4
your
deployment
to
multiple
instance
for
a
single
component_8
this
pattern_3
also
have
one
drawback
consider
you
have
one
component_8
which
do
not
have
frequent
usage
i
e
dispute
of
order
still
this
will
be
quality_attribute_6
on
one
instance
and
you
can’t
utilize
cpu
&
memory
resource
from
here
for
another
component_8
serverless
deployment
use
deployment
component_4
that
remove
component_9
and
infrastructure
requirement_11
it
allow
you
to
zip
your
package
quality_attribute_6
it
on
component_2
component_8
and
charge
you
on
a
connector_data_2
basis
in
this

you
need
not
worry
about
resource
requirement_11
and
load
requirement_11
design
your
component_8
to
run
without
the
component_9
use
resource
technology_20
or
technology_21
storage
for
storage
technology_22
or
technology_21
component_1
a
a
component_1
sn
or
grid
for
connector_11
between
two
component_8
s
a
component_8
popular
technology_13
component_20
include
technology_23
lambda
requirement_4

technology_21
thing
to
consider
during
ci
cd
while
define
the
deployment
pattern_4
architecture
it
be
ideal
to
connector_9
the
follow
thing
technology_24
technology_13
&
technology_13
version
use
in
the
development
each
component_8
be
work
and
be
individually
quality_attribute_8
&
quality_attribute_9
e
g
quality_attribute_6

component_4
for
component_6
requirement_11
each
component_8
be
isolate
from
another
constraint
for
cpu
&
memory
for
each
component_8
pattern_13
for
each
component_8
connector_9
the
cost
of
deployment

pattern_1
deployment
component_14
you
can
also
use
a
deployment
component_14
to
automate
the
deployment
of
your
pattern_1
for
both
serverless
and
component_9
base
component_21
if
you
have
a
huge
component_22
with
multiple
quality_attribute_11
component_4
that
self
manage
component_9
instance
and
component_8
be
generally
a
cost
quality_attribute_18
solution
you
can
use
technology_23
requirement_4
formation
&
connector_data_11
definition
with
technology_25
swarm
mode
&
technology_26
to
automate
deployment
quality_attribute_19
&
manage
all
component_16
centrally
technology_23
requirement_4
formation
allow
you
to
use
a
single
to
component_21
&
provision
infrastructure
and
connector_data_11
definition
allow
you
to
define
several
technology_25
image
for
your
environment
once
the
environment
be
up
the
connector_data_11
definition
take
care
of
all
component_4
i
e
if
your
component_8
crash
it
would
launch
a
technology_25
instance
automatically
if
your
requirement_4
solution
be
small
but
require
a
component_8
then
you
can
quality_attribute_6
your
component_4
to
paas
component_23
technology_23
elastic
beanstalk
which
allow
you
to
quality_attribute_6
and
quality_attribute_4
web
component_16
and
component_4
develop
with
technology_1
net
technology_27
technology_15
j
technology_28
technology_29
go
and
technology_25
on
familiar
component_24
such
a
technology_3
technology_30
technology_31
and
ii
it
charge
base
on
the
resource
you
use
to
quality_attribute_6
serverless

one
can
use
a
technology_5
claudia
j
to
automate
technology_23
lambda
and
technology_14
gateway
deployment
pattern_4
web
component_8
architecture
decomposition
component_25
science
component_2
component_1
test
ci
cd
technology_17
requirement_4
connector_data_3
opinion
express
by
contributor
be
their
own
popular
on
usage
of
technology_1
connector_29
and
lambda
in
technology_32
webdriver
a
quality_attribute_3
guide
to
heap
technology_33
reference
and
requirement_9
in
technology_34
suspicious
sorting
in
unity
technology_35
core
and
more
unit
vs
requirement_5
test
what
s
the
difference

pattern_1
partner
resource
x
about
u
about
connector_8
feedback
career
sitemap
advertise
advertise
with
contribute
on
submission
guideline
mvb
component_26
become
a
contributor
visit
the
writer
zone
legal
term
of
component_8
privacy
requirement_13
u

park
office
drive
suite

durham
nc

support@dzone
technology_36
+1




s
be
friend

technology_36
be
powered
by
