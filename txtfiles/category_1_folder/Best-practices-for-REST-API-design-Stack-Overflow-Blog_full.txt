best
practice
for
pattern_1
component_1
design
technology_1
overflow
essay
opinion
and
advice
on
the
act
of
component_2
programming
from
technology_1
overflow
search
for
late
newsletter
podcast
requirement_1

for
a
live


best
practice
for
pattern_1
component_1
design
in
this

we
ll
look
at
how
to
design
pattern_1
component_3
to
be
easy
to
understand
for
anyone
connector_1
them
future
proof
and
quality_attribute_1
and
fast
since
they
serve
connector_data_1
to
component_4
that
be
confidential
john
au
yeung
and
ryan
donovan
pattern_1
component_3
be
one
of
the
most
common
kind
of
web
component_5
quality_attribute_2
today
they
allow
various
component_4
include
browser
component_6
to
connector_2
with
a
component_7
via
the
pattern_1
technology_2
therefore
it’s
very
important
to
design
pattern_1
component_3
properly
so
that
we
won’t
run
into
problem
down
the
road
we
have
to
take
into
account
quality_attribute_3
requirement_2
and
ease
of
use
for
component_1
component_8
otherwise
we
create
problem
for
component_4
that
use
our
apis
which
isn’t
pleasant
and
detract
people
from
use
our
technology_2
if
we
don’t
follow
commonly
connector_3
convention
then
we
confuse
the
maintainer
of
the
component_1
and
the
component_4
that
use
them
since
it’s
different
from
what
everyone
expect
in
this

we’ll
look
at
how
to
design
pattern_1
component_3
to
be
easy
to
understand
for
anyone
connector_1
them
future
proof
and
quality_attribute_1
and
fast
since
they
serve
connector_data_1
to
component_4
that
be
confidential
connector_3
and
respond
with
jsonuse
noun
instead
of
verb
in
pathsname
collection
with
plural
nounsnesting
resource
for
hierarchical
objectshandle
error
gracefully
and
technology_3
error
codesallow
pattern_2
sorting
and
paginationmaintain
quality_attribute_4
quality_attribute_3
practicescache
connector_data_1
to
improve
performanceversioning
our
component_3
what
be
a
pattern_1
technology_2
a
pattern_1
component_1
be
an
component_9
programming
that
conform
to
specific
architectural
constraint
stateless
connector_4
and
cacheable
connector_data_1
it
be
not
a
technology_4
or
technology_3
while
pattern_1
component_3
can
be
connector_5
through
a
number
of
connector_4
technology_4
most
commonly
they
be
connector_6
over
technology_5
so
the
guideline
below
apply
to
pattern_1
component_1
that
will
be
connector_6
over
the
internet
note
for
pattern_1
component_3
connector_6
over
the
internet
you’ll
want
to
follow
the
best
practice
for
pattern_1
component_1
pattern_3
connector_3
and
respond
with
technology_6
pattern_1
component_3
should
connector_3
technology_6
for
connector_data_2
connector_data_3
and
also
connector_7
connector_8
to
technology_7
technology_6
be
the
technology_3
for
transfer
connector_data_1
almost
every
requirement_3
technology_8
can
use
it
technology_9
have
build
in
to
encode
and
decode
technology_6
either
through
the
fetch
component_1
or
another
technology_5
component_10
component_7
side
technology_8
have
technology_10
that
can
decode
technology_6
without
do
much
work
there
be
other
way
to
transfer
connector_data_1
connector_data_4
isn’t
widely
support
by
technology_11
without
transform
the
connector_data_1
ourselves
to
something
that
can
be
use
and
that’s
usually
technology_7
we
can’t
manipulate
this
connector_data_1
a
easily
on
the
component_10
side
especially
in
browser
it
end
up
be
a
lot
of
extra
work
to
do
normal
connector_data_1
transfer
form
connector_data_1
be
quality_attribute_4
for
connector_9
connector_data_1
especially
if
we
want
to
connector_7

but
for
text
and
number
we
don’t
need
form
connector_data_1
to
transfer
those
since—with
most
frameworks—we
can
transfer
technology_6
by
connector_10
the
connector_data_1
from
it
directly
on
the
component_10
side
it’s
by
far
the
most
straightforward
to
do
so
to
make
sure
that
when
our
pattern_1
component_1
component_11
respond
with
technology_6
that
component_4
interpret
it
a
such
we
should
set
content
type
in
the
connector_8
to
component_9
technology_7
after
the
connector_data_2
be
make
many
component_7
side
component_11
technology_11
set
the
connector_8
automatically
some
technology_5
component_4
look
at
the
content
type
connector_8
and
requirement_4
the
connector_data_1
accord
to
that
technology_12
the
only
exception
be
if
we’re
try
to
connector_7
and
connector_11
between
component_10
and
component_7
then
we
need
to
handle
connector_8
and
connector_7
form
connector_data_1
from
component_10
to
component_7
but
that
be
a
topic
for
another
time
we
should
also
make
sure
that
our
technology_6
a
a
connector_8
many
component_7
side
technology_11
have
this
a
a
build
in
feature
let’s
take
a
look
at
an
example
component_1
that
connector_3
technology_6
connector_data_3
this
example
will
use
the
express
component_12
technology_11
for
technology_13
j
we
can
use
the
body
requirement_5
technology_14
to
requirement_4
the
technology_6
connector_data_2
body
and
then
we
can
connector_data_5
the
re
technology_7
with
the
connector_data_6
that
we
want
to
a
the
technology_6
connector_8
a
follow
express
=
require
express
bodyparser
=
require
body
requirement_5
component_11
=
express
component_11
use
bodyparser
technology_7
component_11

req
re
=
{
re
technology_7
req
body
}
component_11
listen

=
console
requirement_6
component_7
start
bodyparser
technology_7
par
the
technology_6
connector_data_2
body
into
a
technology_9
connector_data_6
and
then
assign
it
to
the
req
body
connector_data_6
set
the
content
type
in
the
connector_8
to
component_9
technology_7
charset=utf

without
any
connector_12
the
above
apply
to
most
other
component_12
technology_11
use
noun
instead
of
verb
in
path
we
shouldn’t
use
verb
in
our
path
instead
we
should
use
the
noun
which
represent
the
component_13
that
the
that
we’re
connector_13
or
manipulate
a
the
pathname
this
be
because
our
technology_5
connector_data_2
already
have
the
verb
have
verb
in
our
component_1
path
isn’t
useful
and
it
make
it
unnecessarily
long
since
it
doesn’t
convey
any
connector_data_7
the
chosen
verb
could
vary
by
the
developer’s
whim
for
instance
some
‘get’
and
some
‘retrieve’
so
it’s
quality_attribute_4
to
the
technology_5
connector_14
verb
tell
u
what
and
do
the
action
should
be
indicate
by
the
technology_5
connector_data_2
that
we’re
make
the
most
common
include
connector_14

put
and
delete
connector_14
connector_15
resource
submit
connector_data_1
to
the
component_7
put
connector_data_8
exist
connector_data_1
delete
remove
connector_data_1
the
verb
connector_data_9
to
crud

with
the
two
principle
we
discuss
above
in
mind
we
should
create
connector_16
connector_14

for
connector_10
news

likewise

be
for

a
put


be
for
update
the
with
the
give

delete


be
for
delete
an
exist
with
the
give


represent
a
pattern_1
component_1
resource
for
instance
we
can
use
express
to
the
follow
for
manipulate

a
follow
express
=
require
express
bodyparser
=
require
body
requirement_5
component_11
=
express
component_11
use
bodyparser
technology_7
component_11
connector_14

req
re
=
{

=
to
connector_17
an

re
technology_7

}
component_11


req
re
=
{
to
a

re
technology_7
req
body
}
component_11
put


req
re
=
{
{
}
=
req
params
to
update
an

re
technology_7
req
body
}
component_11
delete


req
re
=
{
{
}
=
req
params
to
delete
an

re
technology_7
{
delete
}
}
component_11
listen

=
console
requirement_6
component_7
start
in
the
above
we
define
the
to
manipulate

a
we
can
see
the
path
name
do
not
have
any
verb
in
them
all
we
have
be
noun
the
verb
be
in
the
technology_5
verb
the

put
and
delete
all
take
technology_6
a
the
connector_data_2
body
and
they
all
technology_6
a
the
connector_8
include
the
connector_14

use
logical
nest
on
when
design

it
make
sense
to
group
those
that
contain
associate
connector_data_7
that
be
if
one
connector_data_6
can
contain
another
connector_data_6
you
should
design
the
to
reflect
that
this
be
quality_attribute_4
practice
regardless
of
whether
your
connector_data_1
be
pattern_4
this
in
your
component_14
in
fact
it
be
advisable
to
avoid
mirror
your
component_14
connector_data_10
in
your
to
avoid
give
attacker
unnecessary
connector_data_7
for
example
if
we
want
an
to
connector_14
the

for
a
news

we
should
append
the

path
to
the
end
of
the

path
we
can
do
that
with
the
follow
in
express
express
=
require
express
bodyparser
=
require
body
requirement_5
component_11
=
express
component_11
use
bodyparser
technology_7
component_11
connector_14

articleid

req
re
=
{
{
articleid
}
=
req
params

=
to
connector_14

by
articleid
re
technology_7

}
component_11
listen

=
console
requirement_6
component_7
start
in
the
above
we
can
use
the
connector_14
on
the
path

articleid

we
connector_14

on
the
identify
by
articleid
and
then
it
in
the
connector_8
we

after
the

articleid
path
segment
to
indicate
that
it’s
a
child
resource
of

this
make
sense
since

be
the
child
connector_data_11
of
the

assume
each
have
it
own

otherwise
it’s
confuse
to
the
component_15
since
this
connector_data_10
be
generally
connector_3
to
be
for
connector_18
child
connector_data_6
the
same
principle
also
apply
to
the

put
and
delete

they
can
all
use
the
same
kind
of
nest
connector_data_10
for
the
path
name
however
nest
can
go
too
far
after
about
the
second
or
third
level
nest
can
connector_14
unwieldy
consider
instead

the
url
to
those
resource
instead
especially
if
that
connector_data_1
be
not
necessarily
contain
within
the
top
level
connector_data_6
for
example
suppose
you
want
to
the
author
of
particular

you
could
use

articleid

commentid
author
but
that’s
connector_10
out
of
hand
instead
the
uri
for
that
particular
component_15
within
the
technology_6
connector_8
instead
author
component_15
userid
handle
error
gracefully
and
technology_3
error
cod
to
eliminate
confusion
for
component_1
component_16
when
an
error
occur
we
should
handle
error
gracefully
and
technology_5
connector_8
cod
that
indicate
what
kind
of
error
occur
this
give
maintainer
of
the
component_1
enough
connector_data_7
to
understand
the
problem
that’s
occur
we
don’t
want
error
to
bring
down
our
component_17
so
we
can
leave
them
unhandled
which
mean
that
the
component_1
component_8
have
to
handle
them
common
error
technology_5
status
cod
include

bad
connector_data_2
–
this
mean
that
component_10
side
input
fail
validation

unauthorized
–
this
mean
the
component_15
isn’t
not
pattern_5
to
connector_19
a
resource
it
usually

when
the
component_15
isn’t
pattern_6

forbid
–
this
mean
the
component_15
be
pattern_6
but
it’s
not
allow
to
connector_19
a
resource

not
find
–
this
indicate
that
a
resource
be
not
find

internal
component_7
error
–
this
be
a
generic
component_7
error
it
probably
shouldn’t
be
throw
explicitly

bad
gateway
–
this
indicate
an
invalid
connector_8
from
an
upstream
component_7

component_18
unavailable
–
this
indicate
that
something
unexpected
happen
on
component_7
side
it
can
be
anything
component_7
overload
some
part
of
the
component_17
fail
etc
we
should
be
throw
error
that
correspond
to
the
problem
that
our
component_11
have
encounter
for
example
if
we
want
to
reject
the
connector_data_1
from
the
connector_data_2
connector_data_3
then
we
should
a

connector_8
a
follow
in
an
express
technology_2
express
=
require
express
bodyparser
=
require
body
requirement_5
component_11
=
express
exist
component_16
component_16
=
{

abc@foo
technology_15
}
component_11
use
bodyparser
technology_7
component_11

component_15
req
re
=
{
{
}
=
req
body
userexists
=
component_15
find
u
=
u

===

if
userexists
{
re
status

technology_7
{
error
component_15
already
exist
}
}
re
technology_7
req
body
}
component_11
listen

=
console
requirement_6
component_7
start
in
the
above
we
have
a
connector_data_12
of
exist
component_16
in
the
component_16
with
the
give

then
if
we
try
to
submit
the
connector_data_3
with
the
requirement_7
that
already
exist
in
component_15
we’ll
connector_14
a

connector_8
status
with
a
component_15
already
exist
connector_data_13
to
component_16
that
the
component_15
already
exist
with
that
connector_data_7
the
component_15
can
correct
the
action
by
connector_12
the
to
something
that
doesn’t
exist
error
cod
need
to
have
connector_data_14
accompany
with
them
so
that
the
maintainer
have
enough
connector_data_7
to
troubleshoot
the
issue
but
attacker
can’t
use
the
error
content
to
carry
our
attack
steal
connector_data_7
or
bring
down
the
component_17
whenever
our
component_1
do
not
successfully
complete
we
should
fail
gracefully
by
connector_9
an
error
with
connector_data_7
to
help
component_16
make
corrective
action
allow
pattern_2
sorting
and
pagination
the
component_14
behind
a
pattern_1
component_1
can
connector_14
very
large
sometimes
there’s
so
much
connector_data_1
that
it
shouldn’t
be

all
at
once
because
it’s
way
too
slow
or
will
bring
down
our
component_17
therefore
we
need
way
to
pattern_2
item
we
also
need
way
to
paginate
connector_data_1
so
that
we
only
a
few
connector_data_15
at
a
time
we
don’t
want
to
tie
up
resource
for
too
long
by
try
to
connector_14
all
the
connector_data_2
connector_data_1
at
once
pattern_2
and
pagination
both
increase
requirement_2
by
reduce
the
usage
of
component_7
resource
a
more
connector_data_1
accumulate
in
the
component_14
the
more
important
these
feature
become
here’s
a
small
example
where
an
component_1
can
connector_3
a
query
with
various
query
parameter
to
u
pattern_2
out
connector_data_16
by
their

express
=
require
express
bodyparser
=
require
body
requirement_5
component_11
=
express
requirement_8
connector_data_1
in
a
component_14
requirement_8
=
{
firstname
jane
lastname
smith
age

}
{
firstname
john
lastname
smith
age

}
{
firstname
mary
lastname
green
age

}
component_11
use
bodyparser
technology_7
component_11
connector_14
requirement_8
req
re
=
{
{
firstname
lastname
age
}
=
req
query
connector_data_15
=
requirement_8
if
firstname
{
connector_data_15
=
connector_data_17
pattern_2
r
=
r
firstname
===
firstname
}
if
lastname
{
connector_data_15
=
connector_data_17
pattern_2
r
=
r
lastname
===
lastname
}
if
age
{
connector_data_15
=
connector_data_17
pattern_2
r
=
+r
age
===
+age
}
re
technology_7
connector_data_17
}
component_11
listen

=
console
requirement_6
component_7
start
in
the
above
we
have
the
req
query
variable
to
connector_14
the
query
parameter
we
then
extract
the
property
requirement_7
by
destructuring
the
individual
query
parameter
into
variable
use
the
technology_9
destructuring
syntax
finally
we
run
pattern_2
on
with
each
query
parameter
requirement_7
to
locate
the
connector_data_16
that
we
want
to

once
we
have
do
that
we
the
connector_data_15
a
the
connector_8
therefore
when
we
make
a
connector_14
connector_data_2
to
the
follow
path
with
the
query

requirement_8
lastname=smith&age=30
we
connector_14
{
firstname
john
lastname
smith
age

}
a
the

connector_8
since
we
pattern_2
by
lastname
and
age
likewise
we
can
connector_3
the
component_19
query
parameter
and
a
group
of
entry
in
the
position
from
component_19

*

to
component_19
*

we
can
also
specify
the
to
sort
by
in
the
query

for
instance
we
can
connector_14
the
parameter
from
a
query
with
the
we
want
to
sort
the
connector_data_1
for
then
we
can
sort
them
by
those
individual

for
instance
we
want
to
extract
the
query
from
a
url

technology_5
example
technology_15

sort=+author
datepublished
where
+
mean
ascend
and
mean
descend
so
we
sort
by
author’s
name
in
alphabetical
order
and
datepublished
from
most
recent
to
least
recent
maintain
quality_attribute_4
quality_attribute_3
practice
most
connector_4
between
component_10
and
component_7
should
be
private
since
we
often
connector_7
and
connector_11
private
connector_data_7
therefore
use
technology_16
tl
for
quality_attribute_3
be
a
must
a
technology_16
certificate
isn’t
too
difficult
to
load
onto
a
component_7
and
the
cost
be
free
or
very
low
there’s
no
reason
not
to
make
our
pattern_1
component_3
connector_2
over
quality_attribute_1
pattern_7
instead
of
in
the
open
people
shouldn’t
be
able
to
connector_19
more
connector_data_7
that
they
connector_data_2
for
example
a
normal
component_15
shouldn’t
be
able
to
connector_19
connector_data_7
of
another
component_15
they
also
shouldn’t
be
able
to
connector_19
connector_data_1
of
admins
to
enforce
the
principle
of
least
privilege
we
need
to
role
connector_20
either
for
a
single
role
or
have
more
granular
role
for
each
component_15
if
we
choose
to
group
component_16
into
a
few
role
then
the
role
should
have
the
permission
that
cover
all
they
need
and
no
more
if
we
have
more
granular
permission
for
each
feature
that
component_16
have
connector_19
to
then
we
have
to
make
sure
that
admins
can
and
remove
those
feature
from
each
component_15
accordingly
also
we
need
to
some
preset
role
that
can
be
apply
to
a
group
component_16
so
that
we
don’t
have
to
do
that
for
every
component_15
manually
pattern_8
connector_data_1
to
improve
requirement_2
we
can
pattern_8
to
connector_data_1
from
the
local
memory
pattern_8
instead
of
query
the
component_14
to
connector_14
the
connector_data_1
every
time
we
want
to
connector_17
some
connector_data_1
that
component_16
connector_data_2
the
quality_attribute_4
thing
about
pattern_8
be
that
component_16
can
connector_14
connector_data_1
fast
however
the
connector_data_1
that
component_16
connector_14
be
outdated
this
also
lead
to
issue
when
debug
in
production
environment
when
something
go
wrong
a
we
keep
see
old
connector_data_1
there
be
many
kind
of
pattern_8
solution
technology_17
in
memory
pattern_8
and
more
we
can
connector_12
the
way
connector_data_1
be
pattern_8
a
our
need
connector_12
for
instance
express
have
the
apicache
technology_14
to
pattern_8
to
our
component_11
without
much
configuration
we
can
a
quality_attribute_5
in
memory
pattern_8
into
our
component_7
so
express
=
require
express
bodyparser
=
require
body
requirement_5
apicache
=
require
apicache
component_11
=
express
pattern_8
=
apicache
technology_14
component_11
use
pattern_8

minute
requirement_8
connector_data_1
in
a
component_14
requirement_8
=
{
firstname
jane
lastname
smith
age

}
{
firstname
john
lastname
smith
age

}
{
firstname
mary
lastname
green
age

}
component_11
use
bodyparser
technology_7
component_11
connector_14
requirement_8
req
re
=
{
re
technology_7
requirement_8
}
component_11
listen

=
console
requirement_6
component_7
start
the
above
reference
the
apicache
technology_14
with
apicache
technology_14
and
then
we
have
component_11
use
pattern_8

minute
to
apply
the
pattern_8
to
the
whole
component_11
we
pattern_8
the
connector_data_15
for
five
minute
for
example
we
can
adjust
this
for
our
need
if
you
be
use
pattern_8
you
should
also
include
pattern_8
control
connector_data_7
in
your

this
will
help
component_16
effectively
use
your
pattern_8
component_17
versioning
our
component_3
we
should
have
different
version
of
component_1
if
we’re
make
any
connector_21
to
them
that
break
component_10
the
versioning
can
be
do
accord
to
semantic
version
for
example



to
indicate
major
version

and
the
sixth
patch
most
component_6
do
nowadays
this
way
we
can
gradually
phase
out
old
instead
of
force
everyone
to
move
to
the
component_1
at
the
same
time
the
v1
can
stay
active
for
people
who
don’t
want
to
connector_12
while
the
v2
with
it
technology_18
feature
can
serve
those
who
be
ready
to
upgrade
this
be
especially
important
if
our
component_1
be

we
should
version
them
so
that
we
won’t
break
third
party
component_6
that
use
our
apis
versioning
be
usually
do
with
v1
v2
etc

at
the
start
of
the
component_1
path
for
example
we
can
do
that
with
express
a
follow
express
=
require
express
bodyparser
=
require
body
requirement_5
component_11
=
express
component_11
use
bodyparser
technology_7
component_11
connector_14
v1
requirement_8
req
re
=
{
requirement_8
=
to
connector_14
requirement_8
re
technology_7
requirement_8
}
component_11
connector_14
v2
requirement_8
req
re
=
{
requirement_8
=
different
to
connector_14
requirement_8
re
technology_7
requirement_8
}
component_11
listen

=
console
requirement_6
component_7
start
we
the
version
number
to
the
start
of
the
url
path
to
version
them
conclusion
the
most
important
takeaway
for
design
high
quality
pattern_1
component_3
be
to
have
consistency
by
follow
web
technology_3
and
convention
technology_7
technology_16
tl
and
technology_5
status
cod
be
all
technology_3
build
block
of
the
modern
web
requirement_2
be
also
an
important
consideration
we
can
increase
it
by
not

too
much
connector_data_1
at
once
also
we
can
use
pattern_8
so
that
we
don’t
have
to
query
for
connector_data_1
all
the
time
path
of
should
be
consistent
we
use
noun
only
since
the
technology_5
indicate
the
action
we
want
to
take
path
of
nest
resource
should
come
after
the
path
of
the
parent
resource
they
should
tell
u
what
we’re
connector_10
or
manipulate
without
the
need
to
connector_22
extra
documentation
to
understand
what
it’s
do
tag
express
technology_9
rest
technology_2
stackoverflow
the
technology_1
overflow
podcast
be
a
weekly
conversation
about
work
in
development

to

and
the
art
and
culture
of
component_2
programming
relate

for
a
live


the
complete
guide
to
protect
your
component_3
with
oauth2
part

oauth2
be
one
of
the
most
popular
specification
for
component_1
pattern_3
today
though
wrap
your
head
around
it
can
be
a
challenge
dan
moore

for
a
live


the
pattern_9
grant
in
excruciate
detail
part

of

previously
i
examine
oauth
at
a
high
level
include
the
technology_3
and
the
grant
outline
in
the
specification
if
you
haven’t
you
want
to
connector_22
that

in
this

you’ll
the
nut
and
bolt
of
quality_attribute_6
oauth
to
protect
resource
apis
while
there
be
a
number
of
different
way
to
do…
dan
moore

for
a
live


quality_attribute_3
need
to
shift
leave
into
the
development
lifecycle
quality_attribute_3
need
to
move
from
an
afterthought
to
a
primary
concern
in
development
here
s
what
shift
leave
look
for
real
world
developer
michael
chenetz

for
a
live


debug
best
practice
for
pattern_1
component_1
component_20
how
you
can
debug
the
component_3
that
you
connector_23
but

t
own
joyce
lin


tj
say

mar

at


how
on
earth
can
you
connector_24
an
on
the
pattern_1
best
practice
without
mention
hateoas
one
of
the
most
ignore
yet
fundamental
and
require
pattern_1
principle
connector_data_18
bernardo
say

mar

at


i
believe
he
try
to
be
succint
here
a
i’ve

we
could
be
a
lot
more
pedantic
and
pragmatic
but
since
this
be
not
a
technology_19
a
to
guide
general
best
practice
hateoas
be
great
but
too
heavy
perhaps
for
a

another
example
could
be
that
he
didn’t
even
mention
cors
connector_data_18
dave
say

mar

at


this
be
a
guide
to
general
best
practice
of
create
url
hateoas
ensure
you
never
have
to
build
a
url
yourself
connector_data_18
luís
say

apr

at


can
you
elaborate
on
why
i
understand
that
if
i
want
to
explore
some
component_1
or
build
an
to
connector_23
pattern_1
component_3
and
allow
component_16
to
freely
navigate
something
postman
or
a
crawler
this
be
very
useful
because
my
component_9
doesn’t
need
to
how
to
connector_19
a
“post
comment”
to
allow
the
component_15
to
do
so
but
i
don’t
see
this
kind
of
component_9
or
i
don’t
perceive
most
use
requirement_9
that
i
have
be
one
component_9
talk
with
another
about
specifc
thing
that
i
must
connector_25

the
url
otherwise
i
could
navigate
use
url
provide
by
the
resource
themselves
but
probably
would
cost
more
requirement_3
time
cpu
etc
connector_data_18
roger
araque
say

oct

at


excellent
very
quality_attribute_4
for
advance
component_16
and
novice
connector_data_18
mallick
say

sep

at


indeed
it
be
connector_data_18
david
hillier
say

feb

at


what
do
cors
have
to
do
with
rest
connector_data_18
bahati
robben
say

apr

at


it
help
restrict
the
component_4
origin
that
can
connector_19
your
component_7
you
can
open
it
to
all
component_10
but
you
can
restrict
it
to
some
component_4
connector_data_18
leonardo
forero
say

mar

at


yes
he
could
point
to
technology_5
stateless
co
hal_specification
technology_20
or
to
technology_5
jsonapi

for
hateoas
introduction
connector_data_18
saf
say

mar

at


pattern_1
technology_2
not
necessarily
restfull…
connector_data_18
raz
luvaton
say

jun

at


in
pagination
you
should
avoid
use
component_19
and
use
cursor
instead
explanation

technology_5
engineering
mixmax
technology_15

technology_2
component_19
build
the
right
way
connector_data_18
decoder143
say

jun

at


it’s
a
pretty
cool

i
be
use
the
same
from
begin
component_10
connector_26
the
of
the
last
item
it
connector_11
component_7
find
that
item
in
the
component_21
sort
by
“timestamp
of
item
creation”
and
connector_26
back
the
“next
n”
item
connector_data_18
matt
trask
say

jun

at


ignore
hateoas
be
on
point
for
most
pattern_1

connector_data_18
david
hillier
say

feb

at


exactly
i
be
disappoint
to
see
this
be
about
technology_5
component_3
and
have
nothing
to
do
with
rest
it’s
connector_27
an
title
about
sport
car
and
then
talk
about
car
in
general
connector_data_18
mahek
dougherty
say

mar

at



99999%
of
the
time
you
can
replace
the
term
pattern_1
with
technology_5
in
tech

the
richardson
maturity
component_22
be
also
bad
because
there
be
no
“levels”
of
rest
hateoas
be
part
of
pattern_1
fullstop
connector_data_18
wysohn
say

aug

at


quality_attribute_4
thing
you
have
mention
it
here
now
all
i
need
to
do
be
search
for
what
hateoas
be
connector_data_18
bernardo
say

mar

at


i
agree
with
most
thing
connector_24
here
except
mostly
with
the
part
regard
status
cod
i
think
that
it
be
miss
the
part
about
success
status
cod
a
there
be
multiple
one
that
have
different
mean
a
well
with
the
error
status
cod
about
success
status
cod
here
be
a
few
example

–
a
the
default
success
status


–
for
resource
creation
success

–
for
pattern_10
connector_data_19
this
one
be
a
little
bit
more
complex
so
it
be
ok
to
be
out
technology_21

–
for
resource
deletion
or
update
a
there
be
no
reason
to
a
delete
resource
or
the
update
state
of
the
resource
this
last
one
be
quality_attribute_7

–
for
partial
content
a
when

from
a
large
collection
of
resource
perhaps
pagination
you
can
assert
that
there
be
resource
unreceived
now
look
at
the
error
status
cod
here
be
a
few
thing
that
i
diverge
for
example
the

status
for
“user
already
exists”
i
believe
it
be
wrong
a
the
connector_data_2
body
be
in
a
correct
technology_12
the
only
thing
wrong
be
the
connector_data_7
convey
by
it
for
this
problem
of
conflict
there
be
a
much
quality_attribute_4
connector_8
the

–
conflict
a
it
simply
state
there
be
a
conflict
between
the
connector_data_1
provide
by
the
component_10
and
the
current
state
of
the
component_7

could
be
the
default
error

for
that
i
agree
when
an
implementation
do
not
desire
to
use

but
i
believe
that

should
be
use
only
by
default
behaviour
and
when
the
technology_12
of
the
connector_data_1
be
wrong
everything
else
should
lead
to

unprocessable
component_13
a
it
state
that
the
syntax
be
correct
but
it
be
semantically
incorrect
by
some
requirement_10
rule
quite
pedantic
here
but
i
to
use
technology_5
status
cod
to
help
to
the
triage
of
connector_8
connector_data_18
john
au
yeung
say

mar

at


i
think

be
for
a
general
invalid
input
connector_8
it
shouldn’t
be
the
connector_8
if
there’s
more
specific
info
if
there’re
more
specific
issue
that
we
about
from
the
connector_data_2
connector_data_3
then
we
can
use
the
other
one
few
exception
include

vs

for
attempt
to
connector_18
off
limit
resource
connector_data_18
maetko
say

jun

at


fully
agree
with
your
whole


be
a
way
to
go
here
come
here
to
the
same
connector_data_18
gggeek
say

feb

at


in
my
own
experience
conflate
technology_5
status
cod
with
requirement_10
component_23
status
cod
can
lead
to
hard
to
troubleshoot
problem
and
should
really
ve
avoid
not
recommend
the
classical
requirement_9
be
when
i
replace
the
component_1
component_7
at
the
url
you
be
use
with
a
plain
dumb
webserver
serve
technology_20
component_19
the
component_11
connector_9
pattern_1
connector_data_19
will
then
start
connector_28
back


connector_8
and
unless
carefully
cod
but
who
do
connector_29
for
the
response’s
content
type
anyway
lolz
and
assume
that
those
simply
mean
‘data
not
found’
and
go
on
component_24
instead
of
halt
all

connector_data_18
ehab
qadah
say

mar

at


be
there
quality_attribute_4
recommend
option
for
versioning
the
rest
component_3
apart
from
the
mention
mechanism
v1
…
connector_data_18
steg
say

mar

at


there’s
many
opinion
out
there
this
be
a
quality_attribute_4
place
to
start
technology_5
www
troyhunt
technology_15
your
technology_2
versioning
be
wrong
which
be
many
but
not
all
people
i
prefer
url
versioning
because
it’s
the
easy
to
use
connector_data_18
cstreet
say

mar

at


technology_20
status
cod
be
all
technology_3
build
block
of
the
modern
web
i
love
when
my
technology_20
have
status
cod
🙂
connector_data_18
abel
callejo
say

mar

at


finally
stackoverflow
have
speak
about
this
important
topic
other
important
factor
to
discus
be

number
of
descendant
connector_data_6
technology_13
in
a
technology_6
connector_8
keep
it
to
a
minimum
~
ex
component_15
connector_30
country
city
street
name=”acme”

connector_data_20
regeneration
and
expiration
connector_data_18
chris
mcbrien
say

mar

at


i
agree
i
would
also
to
see
a
follow
up
with
discussion
of
pattern_3
pattern_9
connector_data_20
be
an
important
aspect
it
would
be
helpful
to
also
touch
on
component_5
oauth
connector_data_18
abel
callejo
say

mar

at


also
i
would
to
“camelcase
vs
snake_case”
in
technology_6
connector_data_18
olaoluwa
say

mar

at


nice
for
an
introduction
connector_data_18
ananth
say

mar

at


i
would
to
idempotency
for
component_3
to
serve
consistent
connector_data_1
connector_data_18
lalit
sharma
say

mar

at


nice
a
a
start
point
for
pattern_1
component_1
connector_data_18
component_1
say

mar

at


a
reference
to
the
owasp
component_1
quality_attribute_3
top

be
probably
in
order
technology_5
technology_22
technology_15
owasp
technology_2
quality_attribute_3
connector_data_18
cassiomolin
say

mar

at


technology_20
status
cod
connector_data_18
dragica
say

mar

at


“html
status
code”
should
be
“http
status
code”
connector_data_18
sahi4j
say

mar

at


connector_data_4
isn’t
widely
support
where
do
you
connector_14
that
one
i
think
you
be
serious
guy
connector_data_18
han
say

mar

at


use
technology_3
technology_20
cod
technology_20
cod
what’s
that
do
you
mean
technology_5
status
cod
eg

not
find

internal
component_7
error
and
so
on
–
technology_5
en
wikipedia

wiki
list_of_http_status_codes
connector_data_18
marco
thomazini
say

mar

at


one
thing
that
bother
me
on
use
technology_3
technology_5
status
cod
be
the
possible
ambiguity
that
arise
me
explain
assume
a
component_7
component_9


to
indicate
a
resource
doesn’t
exist
a
component_10
component_9
which
connector_31
this

could
in
connector_8
connector_data_5
the
correspond
to
create
such
resource
that
would
be
ok
until
we

a
piece
of
infrastructure
such
a
technology_23
or
haproxy
between
component_10
and
component_7
this
infrastructure
could
connector_8

for
misconfiguration
or
during
a
quality_attribute_8
and
induce
the
component_10
component_25
to
error
how
scenario
that
should
be
handle
connector_data_18
rasmus
schuktz
say

mar

at


yep
this
be
mainly
the
part
of
the
that
i
deeply
disagree
with
technology_5
status
cod
be
design
to
provide
the
status
of
the
technology_5
connector_data_2
which
be
why
you
can’t
always
find
a
suitable
status
–
these
cod
be
intend
to
connector_2
connector_data_7
about
the
transport
of
connector_data_7
which
be
why
they’re
standardize
and
generalize
to
all
kind
of
web
base
resource
in
my
opinion
attempt
to
overload
technology_5
status
cod
with
domain
specific
mean
be
a
mistake
that
lead
to
countless
confuse
situation
the
one
you
point
out
these
mean
be
be
often
contrive
and
not
helpful
they
complexity
to
component_10
and
connector_8
handking
for
no
practical
reason
behind
the
misguide
satisfaction
of
be
on
so
technology_5
compliant
yes
use
a

status
for
path
that
don’t
resolve
to
a
resource
–
of
use

for
unhandled
exception
and
so
on
but
do
this
at
the
technology_11
level
so
a
component_10
can
always
trust
that
technology_5
status
cod
convey
general
connector_data_7
about
the
status
of
the
connector_data_2
itself
so
that
it
always
have
the
same
mean
to
to
an
technology_5
component_10

mean
your
connector_data_2
be
handle
and
the
connector_8
contain
what
you
ask
for
leave
it
at
that
and
encode
any
domain
specific
connector_data_7
in
the
body
of
the
connector_8
itself
–
there’s
no
practical
compel
reason
to
encode
domain
detail
a
cryptic
technology_5
status
cod
require
you
to
connector_22
a
manual
and
handle
all
sort
of
ambiguous
status
cod
with
a
mean
for
every
type
of
resource
this
nonsense
catch
on
because
it
look
cool
and
feel
quality_attribute_4
not
because
it
have
any
practical
merit
or
requirement_7
90%
of
the
time
encode
your
connector_data_7
a
technology_7
it’s
much
easy
to
understand
and
document
and
connector_23
and
your
component_16
will
have
much
quality_attribute_5
component_10
with
few
error
and
smooth
adoption
a
far
a
overload
the
mean
of
technology_5
verb
i’m
lean
towards
“no”
here
a
well
i’ve
see
more
than
a
few
requirement_9
where
we
“ran
out”
of
verb
and
have
to
another
resource
–
crud
be
not
the
only

possible

unless
your
component_11
be
essentially
a
key
requirement_7
component_14
most
domain
be
much
rich
and
more
nuanced
than
that
verb
in
the
path
itself
can
often
quality_attribute_4
connector_2
mean
in
domain
terminology
than
you
can
by
overload

generic
verb
with
all
sort
of
contrive
and
mislead
mean
use
connector_14
for
connector_22
only
connector_data_19
and
for
connector_data_19
that
make
connector_21
–
component_16
can
understand
this
right
away
for
your
entire
component_1
without
further
explanation
for
individual
resource
don’t
overthink
it
technology_5
be
technology_5
and
use
technology_6
for
anything
that’s
resource
component_9
specific
connector_data_18
thomas
kjørnes
say

mar

at


excellent
point
i
agree
100%
connector_data_18
carl
clarke
say

mar

at


i
disagree
in
the
suggest
scenario
where
a
pattern_11
be
respond
due
to
misconfiguration
quality_attribute_8
etc
then
there
will
be
no
component_1
specific
technology_6
technology_5
connector_8
cod
so
the
component_10
be
now
go
to
have
to
handle
‘with
and
without
json’
because
of
infrastructure
that
it
should
not
need
to
about
i
think
it
be
a
requirement_9
of
either
use
technology_5
restful
and
fit
your
solution
to
it
strength
and
weakness
or
maybe
do
something
completely
different
graph
technology_2
grpc
on
my
travel
i
see
many
people
think
and
do
pattern_12
but
use
technology_5
webapi
technology_11
–
they
have
a
name
for
that
it
be
connector_6
technology_24
i
do
agree
that
be
the
‘catch
all’
verb
for
anything
that
doesn’t
fit
with
the
other
verb
of
which
there
be

most
use
and

in
total
actually
i
think
the
author
have
produce
a
reasonable
high
level

the
only
advice
that
i
would
be
that
a
he
have
mention
versioning
component_3
he
might
also
want
to
mention
versioning
the
connector_data_19
and
connector_8
for
example
there
should
be
a
\v1\orders
path
and
a
v1
technology_6
order
connector_data_6
probably
with
a
v1
part
of
the
namespace
in
the
support

a
lot
of
requirement_10
only
have
a
current
late
representation
of
component_26
and
then
really
struggle
to
maintain
component_1
version
even
though
they
have
put
a
‘v1\’
in
the
path
connector_data_18
chris
newey
say

jun

at


very
much
disagree
with
this
pattern_12
style
component_3
can
be
and
often
be
connector_25
over
technology_5
without
resort
to
bloat
technology_8
technology_24
my
advice
would
be
to
re
connector_22
rasmus
schuktz’
answer
i
think
he
nail
it
connector_data_18
jakub
sengerski
say

jan

at


wow
this
seem
to
be
one
of
the
wise
thing
i’ve
connector_22
lately
thanks
for
that
summary
–
i
experience
many
of
the
describe
issue
within
component_3
i
work
with
and
here
be
some
neat
solution
i
be
however
wonder
about
the
use
of
connector_14

the
idea
of
keep
their
role
responsibility
only
a
get==retrieve
and
post==create
seem
beautiful
but
also
not
that
practical
i
believe
this
would
work
well
for
crud
component_3
and
probably
a
ton
of
other
but
it
not
always
practical
for
example
when
the
connector_14
query
attribute
connector_32
more
complicate
you
want
to
pass
more
attribute
than
it
be
practical
for
an
url
graphql
use
connector_data_19
would
be
another
example
here
or
when
you
don’t
want
to
pass
vulnerable
personal
connector_data_7
in
an
url
to
avoid
reveal
that
connector_data_7
on
various
pattern_13
throughout
the
journey
of
a
technology_5
connector_data_2
your
component_7
requirement_6
various
pattern_11
connector_16
component_5
and
so
on
connector_data_18
eli
kay
say

mar

at


i
agree
i
never
understand
why
the
development
hijack
this
or
others
for
that
matter
that
have
long
be
establish
a
connector_data_14
create
the
component_7
but
the
practice
seem
to
be
connector_24
in
stone
so
i
guess
that’s
what
make
it
“best”
connector_data_18
larry
lustig
say

mar

at


this
be
a
comprehensive
which
the
author
obviously
put
a
great
deal
of
think
and
effort
into
unfortunately
i
disagree
with
almost
everything
in
it
have
verb
in
our
component_1
path
isn’t
useful
and
it
make
it
unnecessarily
long
since
it
doesn’t
convey
any
connector_data_7
while
it’s
true
that
pattern_14
component_1
should
contain
only
noun
it’s
not
because
use
verb
be
redundant
it’s
because
use
verb
be
antithetical
to
the
concept
behind
rest
which
be
that
you’re
transfer
state
and
not
component_24
instruction
this
be
the
most
important
and
to
many
people
the
hard
concept
about
rest
you
need
to
“think”
in
term
of
transfer
connector_data_6
state
and
not
in
term
of
an
expect
action
on
the
part
of
the
recipient
of
the
connector_data_13
if
you’re
think
in
term
of
verb
in
your
component_1
then
simply
remove
the
verb
won’t
fix
the
design
—
you
need
to
connector_12
your
think
if
pattern_14
think
doesn’t
apply
to
the
component_17
you’re
build
you
should
abandon
pattern_1
and
use
a
more
pattern_12
type
approach
not
try
to
make
your
approach
look
pattern_14
by
blindly
follow
some
rule
about
name
we
should
name
collection
with
plural
noun
i
find
the
issue
of
name
component_27
in
component_14
it
have
to
be
plural
it
have
to
be
singular
be
pretty
meaningless
if
you
can’t
figure
out
that
the
component_21
requirement_11
or
requirement_11
contain
multiple
requirement_11
component_28
then
you
have
big
problem
than
the
letter
“s”
when
it
come
to
name
component_1

it’s
pretty
clear
to
me
that
singular
plural
should
be
determine
by
whether
the

a
single
connector_data_6
or
a
collection
in
technology_7
probably
a
connector_data_12
of
connector_data_6
therefore
requirement_11
state=nj
should
be
plural
and
should
always
a
connector_data_12
while
requirement_11
custid
should
be
singular
if
it

a
single
requirement_11
connector_data_6
or

but
plural
requirement_11
custid
if
it

a
max
length
of
one
connector_data_12
of
requirement_11
now
you’re
actually
describe
to
the
component_8
the
nature
of
the
connector_data_13
they
will
connector_11
back
from
your
component_18
we
use
plural
to
be
consistent
with
what’s
in
our
component_14
while
there
exist
quality_attribute_5
requirement_9
in
which
our
pattern_14
component_1
be
intend
only
to
connector_33
an
underlie
component_14
it’s
much
more
common
that
our
component_1
be
intend
to
connector_33
a
requirement_10
component_22
a
domain
of
connector_data_7
that
do
not
reflect
the
connector_data_10
of
the
component_14
use
to
persist
the
connector_data_11
—
if
there
even
be
a
component_14
involve
the
pattern_14
component_7
exist
to
connector_33
our
connector_data_7
in
the
most
useful
way
to
our
component_4
and
not
to
our
back
end
component_17
we
have
to
make
sure
that
it
make
sure
what
we
consider
a
nest
resource
match
what
we
have
in
our
component_14
component_21
definitely
not
a
common
situation
would
be
one
in
which
a
pattern_14
component_7
construct
requirement_10
connector_data_11
by
consult
several
different
back
end
component_29
or
component_14
in
the
example
use
the

and
the

could
be
component_30
completely
separately

in
a
technology_6
component_14
or
even
in
the
component_17
and

in
a
technology_25
component_21
somewhere
or
in
different
pattern_15
and
this
implementation
might
connector_12
over
time
the
domain
component_22
we
present
to
our
component_20
should
not
be
base
on
something
a
trivial
and
changeable
a
our
storage
mechanism
sometimes
there’s
so
much
connector_data_1
that
it
shouldn’t
be

all
at
once
because
it’s
way
too
slow
or
will
bring
down
our
component_17
yes
this
be
sometimes
true
but
not
always
blindly

pattern_2
and
pagination
strike
me
a
premature
optimization
you
should
not
these
feature
if
the
expect
maximum
size
of
the
resource
collection
be
limit

the
number
of
department
in
an
organization
for
instance
or
if
the
“normal”
use
requirement_9
be
for
the
component_8
to
want
the
entire
connector_data_12
conversely
if
the
expect
collection
size
be
large
or
the
normal
use
requirement_9
be
to
want
only
a
small
subset
of
component_31
or
design
requirement
state
that
you
never
want
the
component_8
to
be
able
to
the
entire
collection
then
you
should
these
feature
a
quality_attribute_4
“best
practice”
here
would
be
to
say
“consider
connector_data_3
size
requirement_3
congestion
and
what
feature
will
make
your
component_18
most
useful
to
the
component_10
”
pattern_1
component_3
should
connector_3
technology_6
for
connector_data_2
connector_data_3
and
also
connector_7
connector_8
to
technology_7
there
be
no
relationship
between
follow
pattern_14
principle
and
technology_12
the
connector_data_14
a
technology_7
pattern_1
be
originally
design
for

transfer
and
one
of
it
guide
principle
be
that
connector_data_14
should
be
100%
self
describe
in
that
sense
no
component_18
that

pattern_4
connector_data_1
where
the
component_8
need
to
have
a
specific
understand
of
the
connector_data_10
be
actually
restful
but
that
ship
have
long
since
sail
still
there’s
no
reason
to
tie
the
pattern_14
principle
to
technology_7
technology_6
be
a
concise
fairly
readable
widely
use
technology_12
for
connector_data_1
persistence
and
transfer
also
it’s
in
fashion
so
it’s
a
quality_attribute_4
“go
to”
technology_12
for
connector_data_1
transfer
and
persistence
but
there’s
nothing
more
or
le
pattern_14
about
connector_9
technology_6
vs
connector_data_4
vs
vs
some
technology_12
of
your
own
devise
if
it’s
more
useful
in
the
component_32
of
your
component_9
the
only
rule
be
that
you
must
state
what
the
content
be
in
the
content
type

we
should
be
throw
error
that
correspond
to
the
problem
that
our
component_11
have
encounter
whenever
our
component_1
do
not
successfully
complete
we
should
fail
gracefully
by
connector_9
an
error
with
connector_data_7
to
help
component_16
make
corrective
action
firstly
i
think
this
confuse
the
issue
of
“throwing”
exception
and

status
cod
that
indicate
an
error
in
the
component_1
connector_data_2
when
a
component_7
technology_12
and

a
non
2xx
status
to
the
component_8
it’s
not
the
same
thing
a
throw
an
exception
the
component_1
connector_data_5
do
in
fact
succeed
our
back
end
run
compute
a
connector_data_17
and

it
to
the
caller
true
the
connector_data_17
isn’t
the
most
common
requirement_9
in
which
the
connector_data_5
do
exactly
what
the
component_8
be
expect
secondly
it’s
difficult
to
have
a
“best
practice”
in
the
area
of

non
success
technology_5
cod
since
the
specification
around
this
be
not
great
and
usage
be
not
consistent
here
be
some
of
the
problem
in
try
to
specify
best
practice
in
this
area
*
should
the
reason
phrase
of
the
technology_5
to
specific
connector_data_7
beyond
the
textual
description
of
the
status
that
be
should
the
reason
phrase
say
“not
found”
or
“no
requirement_8
match
your
search
of
name=smith
”
*
some
people
connector_data_13
body
to
supply
additional
connector_data_7
in
requirement_9
in
which
the
technology_20
spec
state
no
body
should
be

*
some
status
cod
be
extremely
ambiguous
for
instance
in
the
department
deptid
requirement_8
name=smith
it’s
obvious
that
if
there
be
no
smith
in
the
specify
department

should
be

but
what
if
there
be
no
department
name
deptid
be
that

bad
connector_data_2
eg
hey
we
don’t
have
a
legal
department
so
we
can’t
even
begin
to
look
for
requirement_8
that
match
your
connector_data_2
or

not
find
eg
well
we
connector_29
the
connector_data_12
of
department
but
didn’t
find
legal
in
it
and
what
if
there’s
no
department
at
all
bad
connector_data_2
or
not
find
*
the
amount
of
connector_data_7
you
should
be

and
even
whether
you
should
anything
at
all
quality_attribute_9
on
the
nature
of
your
component_1
—
in
particular
whether
it’s
purely
internal
when
the
only
people
see
connector_8
be
your
own
programmer
or
external
in
which
requirement_9
you
might
not
want
the
wide
world
to
see
any
connector_data_7
about
what
go
wrong
we
can
pattern_8
to
connector_data_1
from
the
local
memory
pattern_8
instead
of
query
the
component_14
to
connector_14
the
connector_data_1
every
time
we
want
to
connector_17
some
connector_data_1
that
component_16
connector_data_2
pattern_8
be
a
valuable
and
interest
topic
but
it’s
largely
orthogonal
to
pattern_14
apis
one
advantage
of
the
pattern_14
approach
be
that
it’s
well
suit
to
pattern_8
and
pattern_8
in
a
much
broad
sense
than
discuss
in
this

since
it
make
it
relatively
easy
to
insert
pattern_11
pattern_8
into
the
workflow
without
modify
the
pattern_14
component_7
in
any
way
but
be
use
a
pattern_8
a
pattern_1
“best
practice”
not
some
problem
domain
be
not
amenable
to
pattern_8
still
others
will
not
benefit
sufficiently
from
the
extra
complexity
of
pattern_8
to
make
the
effort
worthwhile
connector_data_18
ben
tilford
say

mar

at


only
thing
i’d
to
this
would
be
relate
to
“form
connector_data_1
be
quality_attribute_4
for
connector_9
connector_data_1
especially
if
we
want
to
connector_7

but
for
text
and
number
we
don’t
need
form
connector_data_1
to
transfer
those
since—with
most
frameworks—we
can
transfer
technology_6
by
connector_10
the
connector_data_1
from
it
directly
on
the
component_10
side
it’s
by
far
the
most
straightforward
to
do
so
”
technology_6
be
not
requirement_12
to
technology_20
but
form
be
you
also
don’t
have
to
connector_24
anything
to
connector_34
the
connector_data_1
out
of
the
technology_20
in
order
to
connector_7
it
to
the
component_7
unless
you’re
deal
with
complex
nest
connector_data_21
form
connector_data_1
be
much
easy
to
work
with
and
most
modern
component_29
can
requirement_4
the
body
of
either
then
connector_35
it
in
a
way
you
don’t
need
to
concern
yourself
with
the
actual
content
type
of
the
connector_data_2
connector_data_18
john
au
yeung
say

mar

at


i
think
technology_6
be
more
common
now
but
either
way
it’s
quality_attribute_4
connector_data_18
john
doe
say

apr

at


i
disagree
with
your
explanation
of
collection
be
plural
or
singular
the
convention
be
usually
{plural
collection
name}
{id
of
a
single
component_13
within
the
collection}
you
look
at
it
the
collection
be
a
directory
and
you
be
connector_13
a
single
component_13
within
that
collection
when
you
{id}
to
it
i’m
not
say
your
way
be
wrong
but
it’s
definitely
not
the
usual
convention
to
have
both
“
customers”
and
“
customer”
you
usually
have
on
path
for
drill
down
further
into
a
resource
it
start
with
“
customers”
to
connector_14
the
collection
of
requirement_11
and
you
append
additional
path
argument
to
the
end
to
connector_14
a
subset
of
the
collection
not
have
two
distinct
path
“
customers”
and
“
customer”
either
way
the
uri
should
be
opaque
to
the
component_8
because
they
should
be
connector_28
the
uri
dynamically
via
hateos
not
manually
create
it
anyway
so
there
really
isn’t
a
requirement
for
the
uri
to
be
construct
in
any
certain
way
connector_data_18
ingo
say

aug

at


requirement_11
vs
requirement_11
the
slash
have
a
mean
connector_data_18
filip
say

jun

at


this
guy
should
have
connector_24
the

connector_data_18
jonny
olliff
lee
say

dec

at


thank
you
for
connector_27
this
connector_8
i
hope
people
who
connector_22
this
connector_14
to
connector_22
this
a
well
connector_data_18
sklavit
say

jan

at


for
the
department
deptid
requirement_8
name=smith
–
if
there
be
no
smith
it
should
empty
–
if
there
be
no
deptid
it
should
be

connector_data_18
tony
say

mar

at


i
don’t
connector_14
why
pattern_1
component_1
resource
must
follow
component_14
connector_data_10
to
me
how
connector_data_1
be
represent
and
how
it’s
component_30
be
different
thing
especially
if
the
connector_data_1
component_22
be
complicate
i
don’t
see
why
that
complexity
should
be
bring
to
component_1
level
also
connector_data_18
john
au
yeung
say

mar

at


it’s
be
consistent
with
the
component_14
and
the
verb
it
reduce
the
cognitive
load
for
component_16
of
the
technology_2
connector_data_18
jonny
olliff
lee
say

dec

at


you’re
right
tony
they
maybe
the
same
but
it
shouldn’t
be
a
constraint
for
your
component_1
design
connector_data_18
momin
riyadh
say

mar

at


subject
orient

look
for
a
more
detail
on
rest
technology_2
and
graphql
connector_data_18
jl
say

mar

at


i
would
not
connector_data_5
these
“best
practice”
only
“most
common
practice”
a
such
an
component_1
design
this
way
will
suffer
from
the
most
common
pitfall
of
“rest”
over
under
fetch
and
excess
chattiness
a
pattern_1
component_1
should
not
be
design
around
connector_36
the
domain
connector_data_1
component_22
a
crud
over
technology_5
but
around
actual
use
requirement_9
and
component_24
flow
if
you
can’t
be
bother
to
figure
out
what
those
be
and
what
your
component_1
component_20
actually
need
you
be
abdicate
design
responsibility
to
your
component_8
and
virtually
guarantee
that
they
will
need
to
make
multiple
component_1
connector_data_22
to
connector_14
the
connector_data_1
they
need
for
any
give
pattern_16
this
only

fuel
to
the
“rest
be
dead
long
live
graphql”
dumpster
fire
an
component_1
should
be
design
with
the
same
care
and
attention
a
a
ui
connector_data_18
john
au
yeung
say

mar

at


that’s
true
however
i
think
some
commonly
connector_3
convention
be
need
to
make
the
component_1
easy
to
understand
we
also
don’t
have
to
remember
a
many
thing
if
we
follow
common
convention
connector_data_18
the
god
brother
say

jan

at


can
you
please
give
a
or
a

resource
where
this
concept
be
explained…
please
connector_data_18
danish
kamal
say

mar

at


be
there
any
component_7
side
technology_11
technology_10
that
allow
connector_37
sort=+firstname
query
parameter
connector_data_18
tony
say

dec

at


for
nodejs
there
be
an
expressjs
technology_14
connector_6
technology_2
query
params
that
be
quality_attribute_4
at
this
search
on
to
visit
their
npm
component_19
connector_data_18
prateek
say

mar

at


i’m
actually
develop
a
pattern_1
component_1
component_18
and
randomly
saw
this

really
helpful
one
aspect
i
think
that
be
miss
be
quality_attribute_4
practice
to
connector_data_10
your
technology_6
connector_data_1
while
connector_37
and
respond
🙂
connector_data_18
john
doe
say

apr

at


this
barely
scratch
the
surface
of
rest
and
there
be
some
thing
mention
that
be
quality_attribute_7
i
believe
the
one
thing
that
be
not
quality_attribute_7
and
be
definitely
plain
wrong
and
very
bad
practice
be
associate
any
of
your
design
of
your
pattern_1
component_1
with
your
underlie
component_14
your
of
connector_36
your
connector_data_1
to
the
outside
via
a
pattern_1
technology_2
need
to
be
completely
independent
of
your
component_14
design
you
want
to
be
able
to
connector_12
your
component_14
design
without
have
to
redesign
your
technology_2
so
not
only
be
it
wrong
that
you
say
you
should
component_22
your
component_1
base
on
your
component_14
component_21
you
should
go
one
step
further
and
make
sure
you
design
your
component_1
completely
independently
of
any
component_14
design
connector_data_18
zayra
say

jul

at


how
can
you
design
and
your
rest
technology_2
completely
independently
of
your
component_14
component_21
could
you
give
some
example
or
at
least
point
to
a
where
this
concept
be
explain
i
appreciate
your
help
in
this
matter
connector_data_18
jonny
olliff
lee
say

dec

at


have
a
look
at
port
and
adapter
clean
architecture
and
probably
cqrs
separation
of
the
that
do
the
query
from
the
that
handle
component_1
connector_8
be
how
you
achieve
this
connector_data_18
macaroni
king
say


at


hi
i
would
connector_12
this
part
userexists
=
component_15
find
u
=
u

===

if
userexists
{
re
status

technology_7
{
error
component_15
already
exist
}
}
}
a
userexists
=
component_15
some
u
=
u

===

otherwise
imo
this
be
really
nice
for
comer
to
pattern_1
technology_2
i
would
have
avoid
shoot
my
own
leg
a
couple
of
time
if
i
would
have

the
thing
connector_data_12
in
this
one
connector_data_18
agbeze
obinna
ephraim
say

jul

at


hey
macaroni
king
the
problem
with
‘find’
be
that
it
stop
search
when
it
find
the
first
match
so
always
go
with
pattern_2
a
it
pattern_2
out
all
match
connector_data_18
abhijit
jadhav
say


at


hey
john
au
yeung
can
you
please
connector_38
image
component_1
also
and
how
to
connector_14
connector_39
in
technology_7
connector_8
with
different
relation
connector_data_18
daniel
say

jun

at


sad
to
see
the
mention
pattern_8
but
not
pattern_8


error
cod
but
not
problem
detail

and
nest
resource
but
not
hypermedia

the
advice
that
be
here
seem
solid
though
and
it
would
make
the
life
of
an
component_1
component_8
much
easy
if
it
be
consistently
follow

technology_5
web
dev
technology_5
pattern_8

technology_5
technology_26
ietf

technology_20
rfc7807

technology_5
apisyouwonthate
technology_15

rest
and
hypermedia
in

connector_data_18
michał
szumnarski
say

jun

at


if
you
be
deal
with
really
large
dataset
you
should
not
pattern_2
connector_data_15
on
the
component_7
but
you
should
form
appropriate
query
to
the
component_14
and
the
component_14
should
handle
you
pattern_2
connector_data_15
that
you
can
serve
via
your
technology_2
connector_data_18
simone
simone
say

jun

at


strongly
disagree
about
use
a
time
base
pattern_8
i
also
disagree
with
most
of
them
i
mean
they
be
quality_attribute_4
but
not
“best”
someone
with
a
few
experience
could
start
adopt
them
a
“ultimate
guide”
because
stackoverflow
say
so
then
connector_14
in
some
trouble
on
project
grow
for
example

on
a
formerly
correct
connector_data_2
that
component_7
cannot
accomplish
for
example
delete
item

if
element

can’t
be
delete
the
also
lack
of
foundamental
part
connector_data_2
connector_data_1
validation
and
error
connector_8
connector_data_18
shawn
say

jun

at


here
be
a
video
i
make
that
show
you
how
to
do
dast
of
web
component_5
specifically
use
appscan
requirement_13
technology_5
www
youtube
technology_15
watch
v=8iug_nz
tsq
connector_data_18
tony
say

aug

at


why
on
earth
do
you
req
body
a
connector_8
connector_data_3
for
put
and
technology_2
i

you
want
to
connector_22
what
you
connector_7
but
this
be
not
even
logically
correct
you
could
requirement_6
sseparately
for
the
body
you
connector_40
but
not
put
it
into
connector_8
this
be
nonsense
connector_data_18
leonardo
say

aug

at


i
have
a
question
why
do
you
use
‘body
parser’
i
ask
because
of
this
technology_5
stackoverflow
technology_15
question

express
technology_7
vs
bodyparser
technology_7

“earlier
version
of
express
use
to
have
a
lot
of
technology_14
bundle
with
it
bodyparser
be
one
of
the
middlewares
that
come
it
when
express


be
release
they
decide
to
remove
the
bundle
technology_14
from
express
and
make
them
separate
package
instead
the
syntax
then
connector_12
from
component_11
use
express
technology_7
to
component_11
use
bodyparser
technology_7
after
instal
the
bodyparser

bodyparser
be

back
to
express
in
release



because
people
want
it
bundle
with
express
before
that
mean
you
don’t
have
to
use
bodyparser
technology_7
anymore
if
you
be
on
the
late
release
you
can
use
express
technology_7
instead
”
connector_data_18
vijay
singh
say

sep

at


some
basic
thing
be
miss
in
this
which
be
essential
now
day
e
x
pattern_8

quality_attribute_3

error
cod

and
some
other
best
practice

technology_5
www
loginradius
technology_15
engineering

best
practice
guide
for
rest
technology_2
quality_attribute_3

technology_5
www
loginradius
technology_15
engineering

technology_5
quality_attribute_3

connector_data_18
topology
say

sep

at


be
this
a
quality_attribute_4
idea
of

cryptic
for
the
sake
of
quality_attribute_3
so
even
if
it
disclose
no
one
should
understand
it
for
which
purpose
this
component_1
be
make
connector_data_18
charlyarg
say

oct

at


great
an
even
quality_attribute_4

i’m
streamline
my
component_1
it’s
internal
usage
for
now
so
it
become
a
bit
easy
and
i
use
stuff
get_articles
so
i’ll
try
to
introduce
verb
sensible
technology_5
cod
a
a
connector_data_17
be
something
where
i’ve
be
come
back
and
connector_41
either
a
4xx
or
a

when
for
example
the
do
not
exist
in
general
i’d
prefer
a

with
a
success
indicator
of
false
and
a
connector_data_13
that
can
be
handle
in
the
component_10
for
pattern_9
error
though
now
i’m
ok
with
connector_9
4xx
technology_6
with
the
proper
for
connector_8
be
also
something
that
improve
thing
i
have
to
do
some
tweak
a
i’m
test
use
either
technology_27
technology_28
fetch
axios
in
the
component_10
and
technology_28
obviously
connector_7
the
connector_data_1
parameter
in
a
different
technology_12
all
in
all
quite
interest
now
i’d
need
an
on
more
advance
pattern_3
connector_data_18
kyle
say

nov

at


why
do
this
not
mention
anything
about
technology_29
openapi
have
define
contract
answer
many
ambiguity
a
well
a
allow
for
component_4
to
be
autogenerated
make
much
of
the
convention
still
desirable
but
not
a
necessary
especially
for
edge
requirement_9
connector_data_18
omid
say

nov

at


if
we
have
some

and
component_16
can
or
dislike
them
put

postid

put

postid
dislike
i
connector_29
technology_30
they
have
something
that
be
it
quality_attribute_4
way
for
these
requirement_9
which
technology_5
verb
be
not
enough
to
clear

connector_data_18
alex99
say

jan

at


well
these
express
technology_31
thing
be
not
the
technology_32
of
web
these
be
weird
substnaces
the
only
technology_32
of
web
be
technology_33
connector_data_18
jeremy
carter
say

feb

at


why
do
the
sort
query
requirement_7
contain
two
requirement_7
delimit
by
comma
you
can
have
multiple
query
requirement_7
eg
sort=
name&sort=+timestamp
connector_data_18
harry
mcintyre
say

feb

at


this
need
a
find
and
replace
for
“rest”
with
“http
rpc”
connector_data_18
adam
say

mar

at


great

do
you
have
any
thought
on
when
connector_data_1
should
be
“processed”
for
example
if
my
component_14
component_22
have
a
“gender”
with
requirement_7
“m”
“f”
etc
should
i
connector_7
this
connector_8
and
then
component_24
it
on
the
component_10
side
i
suppose
there
be
some
reason
to
component_24
on
the
component_7
side
for
example
turn
a
date
of
birth
into
an
age
so
nobody
see
it
any
thought
connector_data_18
todd
mcallister
say

apr

at


do
anyone
else
find
it
bizarre
connector_22
a
about
“best
practice”
when
they
connector_12
the
color
of
their
background
use
technology_9
instead
of
cs
connector_data_18
syed
say

sep

at


be
it
ok
for
technology_2
a
to
talk
to
technology_2
b
and
vice
versa
be
this
circular
connector_42
bad
connector_data_18
anthony
dellavecchia
say

jan

at


i
enjoy
connector_43
this
a
it
be
very
beginner
intermediate
friendly
it
teach
me
about
the
+
–
in
query
parameter
for
sorting
i’m
a
novice
in
j
so
i
didn’t
really
understand
“javascript
destructuring
syntax”
or
what
happen
during
`const
{
firstname
lastname
age
}
=
req
query
`
connector_data_18
dharmendra
say

feb

at


if
we
have
some

and
component_16
can
or
dislike
them
put

postid

put

postid
dislike
i
connector_29
technology_30
they
have
something
that
be
it
quality_attribute_4
way
for
these
requirement_9
which
technology_5
verb
be
not
enough
to
clear

connector_data_18
tadein
say

mar

at


hi
rest
be
more
relate
to
have
some
guide
and
restriction
about
create
an
technology_2
rest
never
talk
about
how
to
connector_25
that
this
about
“best
practice
”
be
about
how
to
connector_25
those

restriction
because
rest
never
talk
about
how
an
url
should
be
create
or
error
pattern_17
could
you
explain
me
please
thanks
in
advance
connector_data_18
aderchox
say

apr

at


great
thanks
but
i
wish
there
be
a
few
line
on
connector_8
shape
template
best
practice
too
i’ve
see
a
lot
of
component_3
status
cod
and
path
in
their
connector_8
too
but
be
they
really
necessary
or
maybe
“when”
would
they
be
necessary
“`js
{
…

“200”
ep
“
foo
bar”
…
}
“`
connector_data_18
leave
a
connector_data_18
cancel
replyyour
connector_30
will
not
be
publish
require
be
mark
*comment
*
name
*
*
connector_44
my
name

and
in
this
browser
for
the
next
time
i

δ
this
us
akismet
to
reduce
spam
how
your
connector_data_1
be
component_24
©

all
right
reserve
proudly
powered
by
technology_34
technology_1
overflow
about
press
work
here
u
question
technology_35
team
advertising
collective
talent
requirement_14
legal
privacy
requirement_14
term
of
component_18
setting
requirement_14
pattern_7
podcast
newsletter
twitter
linkedin
technology_30
