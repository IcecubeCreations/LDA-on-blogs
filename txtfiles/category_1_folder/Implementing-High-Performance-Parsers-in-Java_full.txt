connector_1
high
requirement_1
requirement_2
in
technology_1
bt
live
webinar
and
q&a
connector_2
technology_2
on
technology_3
technology_4
for
real
time
component_1
live
webinar
26th

register
now
close
toggle
navigation
facilitate
the
technology_5
of
knowledge
and
innovation
in
professional
development
english
edition
english
edition
chinese
edition
japanese
edition
french
edition
contribute
search
sign
up
login
password
forget
password
infoq
account
back
to
login
resend
activation
back
to
login
login
with
twitter

t
have
an
infoq
account
sign
up
notifications1
login
to
unlock
infoq
s
feature
stay
up
to
date
and
connector_3
connector_4
your
favorite
content
follow
your
favorite
editor
and
peer
sign
up
login

t
have
an
account
register
here
logo
back
to
homepage



apr
unique
visitor
news

presentation
podcast
guide
topic
development
technology_1
technology_6
technology_7
technology_8
technology_9
go
technology_10
technology_11
feature
in
development
reproducible
development
with
container
avdi
grimm
describe
the
future
of
development
which
be
already
here
connector_3
a
tour
of
a
devcontainer
and
contrast
it
with
a
deployment
container
all
in
development
architecture
&
design
architecture
requirement_3
architecture
quality_attribute_1
requirement_1
design
requirement_4
study
pattern_1
component_2
mesh
pattern_2
quality_attribute_2
feature
in
architecture
&
design
oren
eini
on
technology_12
include
consistency
guarantee
and
technology_8
a
the
implementation
technology_13
wesley
reisz
talk
to
oren
eini
about
the
history
of
technology_12
technology_12
be
a
fully
pattern_3
technology_14
document
component_3
that
connector_5
both
cp
and
ap
guarantee
at
different
time
the
two
discus
those
cp
ap
quality_attribute_3
component_4
challenge
the
choice
of
implementation
technology_13
technology_15
and
the
current
plan
for
technology_12


which
include
a
component_5
side
sharding
implementation
all
in
architecture
design
requirement_5
ml
&
connector_data_1
engineering
requirement_6
requirement_7
technology_14
component_3
connector_data_1
requirement_8
connector_2
feature
in
requirement_5
ml
&
connector_data_1
engineering
requirement_7
at
the
edge
katharine
jarmul
discus
utilize
quality_attribute_3
connector_data_1
science
and
requirement_7
component_6
such
a
federate

to
from
connector_data_1
at
the
edge
all
in
requirement_5
ml
connector_data_1
eng
culture
&
agile
diversity
leadership
lean
kanban
personal
growth
scrum
sociocracy
craftmanship
team
collaboration
test
ux
feature
in
culture
&
how
to
run
your
technology_16
department
a
coach
have
find
what
i
think
be
my
connector_6
a
an
agile
coach
i
take
the
tough
decision
to
move
sideways
into
technology_16
requirement_9
in
the
hope
of
use
what
i’d

to
one
day
run
my
own
department
i
believe
that
come
from
coach
would
allow
me
to
see
thing
others
could
not
and
create
something
special
time
will
tell
if
i
have
succeed
this
be
the
story
of
where
i
be
up
to
so
far
all
in
culture

devops
infrastructure
continuous
delivery
automation
container
requirement_10
observability
feature
in
devops
panel
quality_attribute_4
component_4
the
panelist
discus
the
quality_attribute_2
for
the
supply
chain
and
quality_attribute_2
risk
measurement
all
in
devops
eventsnew
helpful
connector_7
about
infoq
infoq
editor
contribute
about
c4media
diversity
choose
your
technology_13
en
中文
日本
fr
infoq
live
how
requirement_10
architecture
achieve
cost
connector_8
improve
quality_attribute_5
&
connector_9
requirement_11
register
now
infoq
live
how
to
migrate
an
component_7
to
serverless
and
what
be
the
common
mistake
to
avoid
register
now
qcon
san
francisco
understand
the
emerge
trend
you
should
pay
attention
to
attend
in
person
on
oct



infoq
homepage

connector_1
high
requirement_1
requirement_2
in
technology_1
web
component_5
and
reverse
pattern_4
pattern_5

live
webinar
jun
16th

connector_8
your
seat
connector_1
high
requirement_1
requirement_2
in
technology_1
bookmark
nov



min
connector_10
by
jakob
jenkov
connector_11
for
infoq
join
a
of
expert
increase
your
visibility
grow
your
career

more
***this
de
connector_12
and
replace
by
a
version***
editor
update
dec


the
author
have
since
publish
a
significantly
revise
that
you
can
connector_10
here
technology_17
www
infoq
technology_18

high
requirement_1
requirement_2
in
technology_1
v2
infoq
would
to
thank
jakob
for
respond
so
well
to
our
reader
s
feedback
editor
note
nov


due
to
reader
complaint
about
the
validity
of
the
requirement_2
use
the
have
be
remove
from
active
connector_data_2
in
infoq
s
archive
and
quality_attribute_6
by
direct
connector_12
only
the
author
will
be
give
an
opportunity
to
refactor
and
republish
from
time
to
time
you
need
to
connector_13
your
own
connector_data_1
or
technology_13
requirement_2
in
technology_1
for
example
if
th
relate
sponsor
content
relate
sponsor
16th


pm
est
web
component_5
and
reverse
pattern_4
pattern_5

present
by
alessandro
fael
garcia
sr
solution
engineer
bus
dev
sponsor
by
technology_19
connector_8
your
seat
from
time
to
time
you
need
to
connector_13
your
own
connector_data_1
or
technology_13
requirement_2
in
technology_1
for
example
if
there
be
no
technology_20
technology_1
or
open_source
requirement_2
for
that
connector_data_1
technology_21
or
technology_13
or
perhaps
there
be
requirement_2
but
they
be
too
slow
connector_14
too
much
memory
or
don’t
have
the
feature
you
need
or
there
might
be
bug
in
an
open_source
requirement_2
or
the
open_source
requirement_2
project
be
abandon
etc
the
reason
be
not
a
important
a
the
reality
that
you
will
be
need
to
connector_13
your
own
requirement_2
when
you
have
to
connector_13
your
own
requirement_2
you
want
it
to
perform
well
be
quality_attribute_7
feature
rich
easy
to
use
and
last
but
not
least
easy
to
connector_13
after
all
your
name
be
on
that

in
this
i
will
explain
one
way
of
connector_1
high
requirement_1
requirement_2
in
technology_1
this
be
not
exclusive
but
it
be
reasonably
quality_attribute_8
and
achieve
both
high
requirement_1
and
a
reasonably
modular
design
the
design
be
inspire
by
the
design
of
vtd
technology_22
the
fast
connector_data_3
requirement_2
for
technology_1
i
have
see
be
even
fast
than
the
stax
and
technology_23
technology_1
technology_20
connector_data_3
requirement_2
two
basic
requirement_2
type
there
be
several
way
to
categorize
requirement_2
here
i
will
make
the
distinction
between
two
basic
requirement_2
type
sequential
connector_15
requirement_2
random
connector_15
requirement_2
by
sequential
connector_15
i
mean
that
the
requirement_2
par
the
connector_data_1
turn
over
the
requirement_12
connector_data_1
to
the
connector_data_1
processor
a
the
connector_data_1
be
requirement_12
the
connector_data_1
processor
only
have
connector_15
to
the
connector_data_1
currently
be
requirement_12
it
can’t
look
back
to
early
connector_data_1
and
can’t
look
ahead
such
requirement_2
be
also

a
base
requirement_2
the
technology_23
and
stax
requirement_2
a
random
connector_15
requirement_2
be
a
requirement_2
that
enable
the
connector_data_1
component_1
to
move
back
and
forth
connector_15
at
random
over
the
connector_data_1
be
requirement_12
example
of
such
requirement_2
be
connector_data_3
dom
requirement_2
this
diagram
attempt
to
illustrate
the
difference
between
sequential
and
random
connector_15
requirement_2
sequential
connector_15
requirement_2
you
connector_15
only
the
window
or

that
be
requirement_12
whereas
random
connector_15
requirement_2
allow
you
to
navigate
the
requirement_12
connector_data_1
a
you
please
design
overview
the
requirement_2
design
i
explain
here
be
of
the
random
connector_15
variety
random
connector_15
requirement_2
implementation
be
often
slow
than
sequential
connector_15
requirement_2
because
they
generally
build
up
some
kind
of
connector_data_4
tree
from
the
requirement_12
connector_data_1
through
which
the
connector_data_1
component_1
can
connector_15
that
connector_data_1
create
this
connector_data_4
tree
be
actually
both
slow
in
cpu
time
and
can
connector_14
quite
a
bit
of
memory
instead
of
construct
an
connector_data_4
tree
from
the
requirement_12
connector_data_1
a
more
performant
approach
be
to
construct
a
buffer
of
index
into
the
original
connector_data_1
buffer
the
index
point
to
the
start
and
end
point
of
the
element
find
in
the
requirement_12
connector_data_1
instead
of
connector_16
this
connector_data_1
via
an
connector_data_4
tree
the
connector_data_1
component_1
connector_15
the
requirement_12
connector_data_1
directly
in
the
buffer
contain
the
original
connector_data_1
here
be
an
illustration
of
these
two
approach
for
lack
of
a
quality_attribute_9
name
i
connector_data_5
this
an
index
overlay
requirement_2
the
requirement_2
create
an
index
overlay
on
top
of
the
original
connector_data_1
this
be
reminiscent
of
how
a
component_3
index
connector_data_1
component_8
on
disk
it
create
index
on
top
of
the
original
raw
connector_data_1
to
navigate
and
search
through
the
connector_data_1
fast
a
i
mention
early
this
design
be
inspire
by
vtd
technology_22
vtd
for
virtual
connector_data_6
descriptor
thus
you
might
also
connector_data_5
this
a
virtual
connector_data_6
descriptor
requirement_2
i
prefer
index
overlay
because
that
be
what
the
virtual
connector_data_6
descriptor
represent
an
index
into
the
original
connector_data_1
requirement_2
design
in
general
a
normal
design
for
requirement_2
be
to
separate
the
requirement_12
into
two
step
the
first
step
break
the
connector_data_1
into
cohesive
connector_data_6
where
a
connector_data_6
be
one
or
more
byte
or
character
occur
in
the
requirement_12
connector_data_1
the
second
step
interpret
the
connector_data_6
and
construct
large
element
base
on
these
connector_data_6
these
two
step
be
illustrate
here
by
element
i
do
not
necessarily
mean
connector_data_3
element
though
connector_data_3
element
be
also
requirement_2
element
but
rather
the
large
connector_data_1
element
comprise
the
requirement_12
connector_data_1
in
an
connector_data_3
document
that
would
be
connector_data_3
element
in
a
technology_24
document
it
would
be
technology_24
connector_data_7
etc
a
an
example
the
myelement
would
be
break
into
the
follow
connector_data_6
myelement
once
the
connector_data_1
be
break
into
connector_data_6
it
be
easy
for
the
requirement_2
to
make
sense
of
them
and
thus
determine
the
large
element
that
these
connector_data_6
comprise
the
requirement_2
would
then
that
an
connector_data_3
element
start
with
a
connector_data_6
follow
by
a
connector_data_6
the
element
name
then
optionally
a
set
of
attribute
and
finally
a
connector_data_6
index
overlay
requirement_2
design
this
be
the
two
step
approach
we
will
use
in
our
requirement_2
design
the
input
connector_data_1
be
first
break
into
connector_data_6
by
a
tokenizer
component_9
the
requirement_2
then
par
those
connector_data_6
to
determine
the
large
element
boundary
in
the
input
connector_data_1
you
can
also
an
optional
third
“element
navigation
step”
to
the
requirement_12
component_1
if
the
requirement_2
construct
an
connector_data_4
tree
from
the
requirement_12
connector_data_1
the
connector_data_4
tree
typically
contain
connector_7
to
navigate
the
tree
when
we
construct
an
element
index
buffer
instead
of
an
connector_data_4
tree
we
need
a
separate
component_9
to
help
the
connector_data_1
component_1
navigate
the
element
index
buffer
here
be
an
overview
of
our
requirement_2
design
first
we
connector_10
all
the
connector_data_1
into
a
connector_data_1
buffer
in
order
to
enable
random
connector_15
to
the
original
connector_data_1
via
the
index
create
during
requirement_12
all
of
the
original
connector_data_1
have
to
be
quality_attribute_6
in
memory
second
the
tokenizer
break
the
connector_data_1
into
connector_data_6
the
start
index
end
index
and
connector_data_6
type
of
the
connector_data_6
be
keep
internally
in
a
connector_data_6
buffer
in
the
tokenizer
use
a
connector_data_6
buffer
make
it
possible
to
look
connector_17
and
backwards
in
such
requirement_4
that
your
requirement_2
need
that
third
the
requirement_2
look
at
the
connector_data_6
obtain
from
the
tokenizer
validate
them
against
their
component_10
and
determine
what
element
they
represent
the
requirement_2
then
construct
the
element
index
the
index
overlay
base
on
the
connector_data_6
connector_18
from
the
tokenizer
the
requirement_2
obtain
the
connector_data_6
one
by
one
from
the
tokenizer
thus
the
tokenizer
do
not
actually
need
to
break
all
the
connector_data_1
into
connector_data_6
immediately
it
need
to
find
one
connector_data_6
at
a
time
the
connector_data_1
component_1
can
navigate
the
element
buffer
and
use
that
to
connector_15
the
original
connector_data_1
optionally
you
wrap
the
element
buffer
in
an
element
navigator
component_9
make
navigate
the
element
buffer
easy
this
design
do
not
build
up
an
connector_data_4
tree
from
the
requirement_12
connector_data_1
but
it
do
build
up
a
navigable
connector_data_8
the
element
buffer
consist
of
index


into
the
connector_data_1
buffer
contain
the
original
connector_data_1
use
these
index
you
can
navigate
the
connector_data_1
in
the
original
connector_data_1
buffer
the
follow
section
will
explain
the
various
part
of
the
design
in
more
detail
the
connector_data_1
buffer
the
connector_data_1
buffer
be
a
byte
or
char
buffer
contain
the
original
connector_data_1
the
connector_data_6
buffer
and
element
buffer
contain
index
into
the
connector_data_1
buffer
in
order
to
allow
random
connector_15
to
the
requirement_12
connector_data_1
it
be
necessary
to
have
some
kind
of
in
memory
representation
of
it
all
instead
of
an
connector_data_4
tree
we
use
the
connector_data_1
buffer
with
the
raw
connector_data_1
itself
have
all
connector_data_1
in
memory
can
connector_14
a
big
chunk
of
memory
if
your
connector_data_1
contain
element
that
be
independent
of
each
other
such
a
requirement_13
component_11
connector_19
the
whole
requirement_13
into
memory
might
be
overkill
instead
you
can
connector_20
in
a
chunk
of
the
requirement_13
that
contain
at
least
one
full
requirement_13
component_11
since
every
requirement_13
component_11
can
be
fully
requirement_12
and
component_1
independently
of
the
other
requirement_13
component_11
you

t
need
the
full
requirement_13
in
memory
at
the
same
time
i
have
describe
how
to
iterate
a
connector_21
of
connector_data_1
in
chunk
in
my
iterate
connector_22
use
buffer
the
tokenizer
+
connector_data_6
buffer
the
tokenizer
break
the
connector_data_1
buffer
into
connector_data_6
the
connector_data_9
about
the
connector_data_6
be
component_8
in
the
connector_data_6
buffer
contain
the
follow
connector_data_6
position
start
index
connector_data_6
length
connector_data_6
type
optional
this
connector_data_9
be
component_8
in

here
be
an
example
of
how
the
could
look
indexbuffer
{

position
=


length
=

byte
type
=

*
assume
a
max
of

type

byte
type
*
}
a
the
tokenizer
find
connector_data_6
in
the
connector_data_1
buffer
it
will
insert
the
position
start
index
in
the
position

the
connector_data_6
length
in
the
length

and
the
connector_data_6
type
in
the
type

if
you
don’t
use
the
optional
connector_data_6
type
you
can
still
determine
the
connector_data_6
type
a
need
by
look
at
the
connector_data_1
in
the
connector_data_6
this
be
a
requirement_14
off
for
requirement_1
vs
memory
consumption
the
requirement_2
the
requirement_2
be
similar
in
nature
to
the
tokenizer
except
it
take
connector_data_6
a
input
and
output
the
element
index
with
connector_data_6
an
element
be
mark
by
it
position
start
index
length
and
optionally
it
element
type
these
number
be
component_8
in
the
same
connector_data_8
use
to
component_8
connector_data_6
again
the
type
be
optional
if
you
can
determine
the
element
type
easily
base
on
the
first
byte
or
character
of
the
element
you
not
need
to
component_8
the
element
type
the
precise
granularity
of
the
element
mark
in
the
element
buffer
quality_attribute_10
on
the
connector_data_1
be
requirement_12
a
well
a
the
that
need
to
component_1
the
connector_data_1
afterwards
for
instance
if
you
connector_13
an
connector_data_3
requirement_2
you
might
mark
each
start
tag
attribute
and
end
tag
a
separate
requirement_2
element
the
element
buffer
the
index
the
requirement_2
produce
an
element
buffer
with
index
into
the
original
connector_data_1
the
index
mark
the
position
start
index
length
and
type
of
the
element
the
requirement_2
have
find
in
the
connector_data_1
you
can
use
these
index
to
navigate
the
original
connector_data_1
look
at
the
indexbuffer
above
you
can
see
that
the
element
buffer
us
nine
byte
per
element
four
byte
for
the
position
four
byte
for
the
connector_data_6
length
and
one
byte
for
the
connector_data_6
type
you
be
able
to
decrease
the
memory
consumption
of
the
indexbuffer
for
instance
if
you
that
the
element
be
never
long
than


byte
you
use
an
of
short
instead
of
to
hold
the
connector_data_6
length
that
will
connector_8
you
two
byte
per
element
bring
the
memory
consumption
down
to
seven
byte
per
element
additionally
if
that
the
you
will
requirement_12
be
never
long
than



byte
in
length
you
only
need
three
byte
for
the
position
start
index
the
fourth
byte
of
each
in
the
position
could
then
hold
the
element
type
eliminate
the
need
for
a
type

if
you
have
le
than

connector_data_6
type
you
can
use
seven
bit
for
the
connector_data_6
type
instead
of
eight
this
enable
you
to
spend

bit
on
the
position
which
increase
the
maximum
position
to



if
you
have
le
than

connector_data_6
type
you
can
assign
another
bit
to
the
position
etc
vtd
technology_22
actually
compact
all
this
connector_data_9
into
a
long
to
connector_8
space
you
lose
a
bit
of
quality_attribute_11
because
of
the
extra
bit
manipulation
need
to
pack
separate
into
a
single
or
long
but
you
connector_8
some
memory
it
s
a
trade_off
the
element
navigator
the
element
navigator
help
the
that
be
component_1
the
connector_data_1
navigate
the
element
buffer
remember
a
semantic
connector_data_4
or
element
e
g
an
connector_data_3
element
might
consist
of
multiple
requirement_2
element
to
ease
the
navigation
you
can
create
an
element
navigator
connector_data_4
that
can
navigate
the
requirement_2
element
on
a
semantic
connector_data_4
level
for
instance
an
connector_data_3
element
navigator
might
navigate
the
element
buffer
by
go
from
start
tag
to
start
tag
the
use
of
an
element
navigator
component_9
be
your
choice
if
you
be
connector_1
a
requirement_2
for
a
single
use
in
a
single
project
you
might
want
to
skip
it
but
if
you’re
connector_1
a
requirement_2
with
the
intention
of
quality_attribute_12
it
across
project
or
publish
it
a
open_source
you
might
want
to
an
element
navigator
component_9
quality_attribute_10
on
how
complexity
of
navigate
the
requirement_12
connector_data_1
requirement_4
study
a
technology_24
requirement_2
to
make
the
index
overlay
requirement_2
design
more
tangible
i
have
connector_13
a
small
technology_24
requirement_2
in
technology_1
base
on
the
index
overlay
requirement_2
design
you
can
find
the
complete
on
technology_25
technology_24
be
short
for
technology_11
connector_data_4
notation
technology_24
be
a
popular
connector_data_1
technology_21
to
exchange
connector_data_1
between
web
component_12
and
browser
via
technology_26
because
web
browser
have
build
in
requirement_15
support
for
requirement_12
technology_24
into
technology_11
connector_data_4
go
connector_23
i
will
assume
that
you
be
familiar
with
technology_27
here
be
a
quality_attribute_8
technology_24
example
{
key1
value1
key2
value2
valuea
valueb
valuec
}
the
technology_24
tokenizer
will
break
this
technology_24
into
the
follow
connector_data_6
the
underline
be
there
to
emphasize
the
length
of
each
connector_data_6
the
tokenizer
also
determine
the
basic
type
of
each
connector_data_6
here
be
the
same
technology_24
example
with
the
connector_data_6
type

notice
how
the
connector_data_6
type
be
not
semantic
they
only
say
what
the
basic
connector_data_6
type
be
and
not
what
they
represent
the
requirement_2
interpret
the
basic
connector_data_6
type
and
replace
them
with
semantic
type
here
be
the
same
technology_24
example
but
with
semantic
type
the
requirement_2
element
instead
once
the
requirement_2
be
finish
requirement_12
the
above
technology_24
you
will
have
an
index
element
buffer
consist
of
the
position
length
and
element
type
of
the
element
mark
above
you
can
then
navigate
the
index
to
extract
the
connector_data_1
you
need
from
the
technology_27
jsontokenizer
parsetoken
in
order
to
give
you
an
idea
about
how
the
tokenization
and
requirement_12
be
connector_13
i
will
show
you
the
central
part
of
the
jsontokenizer
and
the
jsonparser
remember
the
full
be
quality_attribute_6
on
technology_25
here
be
the
jsontokenizer
parsetoken
which
par
the
next
connector_data_6
in
the
connector_data_1
buffer
parsetoken
{
skipwhitespace
this
tokenlength
=

this
tokenbuffer
position
this
tokenindex
=
this
dataposition
char
nextchar
=
this
databuffer
connector_data_1
this
dataposition
switch
nextchar
{
requirement_4
{
this
tokenlength
=

this
tokenbuffer
type
this
tokenindex
=
tokentypes
json_curly_bracket_left
break
requirement_4
}
this
tokenlength
=

this
tokenbuffer
type
this
tokenindex
=
tokentypes
json_curly_bracket_right
break
requirement_4
this
tokenlength
=

this
tokenbuffer
type
this
tokenindex
=
tokentypes
json_square_bracket_left
break
requirement_4
this
tokenlength
=

this
tokenbuffer
type
this
tokenindex
=
tokentypes
json_square_bracket_right
break
requirement_4
this
tokenlength
=

this
tokenbuffer
type
this
tokenindex
=
tokentypes
json_comma
break
requirement_4
this
tokenlength
=

this
tokenbuffer
type
this
tokenindex
=
tokentypes
json_colon
break
requirement_4
parsestringtoken
this
tokenbuffer
type
this
tokenindex
=
tokentypes
json_string_token
break
default
parsestringtoken
this
tokenbuffer
type
this
tokenindex
=
tokentypes
json_string_token
}
this
tokenbuffer
length
this
tokenindex
=
this
tokenlength
}
a
you
can
see
the
be
pretty
quality_attribute_8
first
the
skipwhitespace
be
connector_24
which
skip
over
any
white
space
character
that
might
be
in
the
connector_data_1
at
the
current
location
second
the
connector_data_6
length
be
set
to

third
the
position
of
the
current
connector_data_6
the
index
into
the
connector_data_1
buffer
be
component_8
in
the
tokenbuffer
fourth
the
next
character
be
examine
and
quality_attribute_10
on
what
character
it
be
what
connector_data_6
it
be
one
of
the
statement
in
the
switch
requirement_4
construct
be
connector_25
finally
the
connector_data_6
length
for
the
current
connector_data_6
be
component_8
this
be
really
all
it
take
to
tokenize
a
connector_data_1
buffer
notice
that
once
the
begin
of
a
connector_data_6
be
find
the
tokenizer
connector_data_10
the
parsestringtoken
which
be
scan
through
the
connector_data_1
until
the
end
of
a
connector_data_6
be
find
this
will
connector_25
fast
than
try
to
handle
all
requirement_4
inside
the
parsetoken

and
be
easy
to
connector_13
the
rest
of
the
in
jsontokenizer
be
there
to
assist
the
parsetoken

or
to
move
the
connector_data_1
position
index
to
the
next
connector_data_6
first
position
after
the
current
connector_data_6
etc
jsonparser
parseobject
the
primary
of
the
jsonparser
be
the
parseobject
which
look
at
the
connector_data_6
type
of
the
connector_data_6
obtain
from
the
jsontokenizer
and
try
to
locate
technology_24
connector_data_7
in
the
input
connector_data_1
base
on
that
here
be
the
parseobject

private
parseobject
jsontokenizer
tokenizer
{
asserthasmoretokens
tokenizer
tokenizer
parsetoken
assertthistokentype
tokenizer
tokentypes
json_curly_bracket_left
setelementdata
tokenizer
elementtypes
json_object_start
tokenizer
nexttoken
tokenizer
parsetoken
while
tokenizer
tokentype
=
tokentypes
json_curly_bracket_right
{
assertthistokentype
tokenizer
tokentypes
json_string_token
setelementdata
tokenizer
elementtypes
json_property_name
tokenizer
nexttoken
tokenizer
parsetoken
assertthistokentype
tokenizer
tokentypes
json_colon
tokenizer
nexttoken
tokenizer
parsetoken
if
tokenizer
tokentype
==
tokentypes
json_string_token
{
setelementdata
tokenizer
elementtypes
json_property_value
}
else
if
tokenizer
tokentype
==
tokentypes
json_square_bracket_left
{
parsearray
tokenizer
}
tokenizer
nexttoken
tokenizer
parsetoken
if
tokenizer
tokentype
==
tokentypes
json_comma
{
tokenizer
nexttoken
skip
connector_data_6
if
find
here
tokenizer
parsetoken
}
}
setelementdata
tokenizer
elementtypes
json_object_end
}
private
setelementdata
jsontokenizer
tokenizer
byte
elementtype
{
this
elementbuffer
position
this
elementindex
=
tokenizer
tokenposition
this
elementbuffer
length
this
elementindex
=
tokenizer
tokenlength
this
elementbuffer
type
this
elementindex
=
elementtype
this
elementindex++
}
the
parseobject
expect
to
see
a
leave
curly
bracket
{
follow
by
a
connector_data_6
a
colon
and
another
connector_data_6
or
the
begin
of
an
or
another
technology_24
connector_data_4
a
the
jsonparser
connector_26
these
connector_data_6
from
the
jsontokenizer
it
connector_27
start
length
and
the
semantic
mean
of
these
connector_data_6
in
it
own
elementbuffer
the
connector_data_1
component_1
can
then
navigate
this
elementbuffer
afterwards
to
extract
any
need
connector_data_1
from
the
input
connector_data_1
see
the
core
part
of
the
jsontokenizer
and
the
jsonparser
should
provide
some
idea
of
how
tokenization
and
requirement_12
work
to
fully
understand
how
the
work
you
need
to
look
that
the
complete
jsontokenizer
and
jsonparser
implementation
they
be
both
le
than

line
of
each
so
they
should
be
reasonably
approachable
benchmark
vtd
technology_22
have
already
do
extensive
benchmarking
of
their
connector_data_3
requirement_2
against
stax
technology_23
and
dom
requirement_2
vtd
technology_22
win
over
them
all
in
raw
requirement_1
in
order
to
establish
some
quality_attribute_13
for
index
overlay
requirement_2
requirement_1
in
general
i
have
benchmarked
my
technology_24
requirement_2
implementation
against
technology_28
–
google’s
technology_24
requirement_2
technology_28
create
an
connector_data_4
tree
from
a
technology_24
input

or
connector_21
keep
in
mind
that
technology_28
be
fairly
mature
production
quality
test
with
quality_attribute_9
error
report
etc
my
technology_24
requirement_2
be
only
at
a
proof
of
concept
level
the
benchmarking
be
only
do
to
connector_3
an
indication
of
the
difference
in
requirement_1
they
be
not
final
number
remember
to
connector_10
the
discussion
of
the
benchmark
below
too
here
be
some
detail
about
how
the
benchmark
be
pattern_6
in
order
to
pattern_7
up
the
jit
minimize
one
off
overhead
etc
the
technology_24
input
requirement_12
be
perform



time
the
benchmark
be
repeat
separately
for
three
different
to
see
how
the
requirement_2
do
on
small
and
large

the
size
be

byte

byte
and

byte
that
mean
first
do



iteration
on
a
small

and
measure
that
then
on
a

and
measure
that
and
then
on
a
large
and
measure
that
the
be
be
load
fully
into
memory
before
requirement_12
and
measurement
begin
that
be
do
to
exclude

load
time
from
the
requirement_12
time
each
measurement
of



iteration
run
in
it
own
component_1
that
mean
that
each
be
requirement_12
in
separate
component_1
only
one
component_1
run
at
a
time
each
be
measure

time
that
be
the
component_1
requirement_12
the



time
be
start
and
stop

time
the
component_13
run
sequentially
not
in
parallel
the
benchmark
component_14
contain
three
column

quality_attribute_8
iteration
of
the
raw
connector_data_1
buffer

technology_24
requirement_2

technology_28
the
first
column
be
the
quality_attribute_8
iteration
of
all
of
the
connector_data_1
in
the
raw
connector_data_1
buffer
this
number
be
only
there
to
signal
the
lower
limit
the
minimum
time
theoretically
possible
to
component_1
all
the
connector_data_1
of
no
requirement_2
will
reach
this
quality_attribute_11
but
the
number
be
interest
to
see
how
far
off
a
requirement_2
be
from
the
raw
iteration
quality_attribute_11
the
second
column
be
my
technology_24
requirement_2
the
third
column
be

s
technology_28
requirement_2
here
be
the
time
in
millisecond
to
perform
the



requirement_12
of
the


byte

byte

byte
run
iteration
technology_24
requirement_2
technology_28
small




small




small
















big




big




big




a
you
can
see
the
index
overlay
implementation
be
significantly
fast
than
technology_28
an
connector_data_4
tree
technology_24
requirement_2
of
this
be
expect
but
now
you
can
connector_3
an
idea
of
what
the
requirement_1
difference
be
note
that
all
benchmark
component_13
be
very
quality_attribute_14
in
their
memory
consumption
during
connector_28
technology_28
do
not
steadily
increase
it
memory
consumption
despite
the
many
connector_data_4
tree
create
the
memory
consumption
of
the
index
overlay
requirement_2
be
also
quality_attribute_14
and
about
1mb
lower
than
that
of
the
technology_28
benchmark
some
of
that
might
be
due
to
the
large
base
in
technology_28
load
into
the
technology_29
benchmark
discussion
now
it
wouldn’t
be
fair
to
compare
a
requirement_2
that
create
an
connector_data_4
tree
from
connector_data_1
technology_28
to
a
requirement_2
that
mark
the
index
of
the
element
find
in
the
connector_data_1
without
a
discussion
of
what
be
be
compare
requirement_12
a
inside
a
run
component_7
usually
require
the
follow
step
first
the
connector_data_1
be
load
either
from
disk
or
from
the
requirement_16
second
the
connector_data_1
be
requirement_12
third
the
connector_data_1
be
component_1
in
order
to
measure
the
raw
requirement_2
quality_attribute_11
i
preloaded
the
to
be
requirement_12
into
memory
and
the
benchmarked
will
not
component_1
the
connector_data_1
in
any
way
while
this
do
benchmark
the
raw
requirement_12
quality_attribute_11
the
requirement_1
difference
do
not
pattern_8
one
to
one
into
increase
requirement_1
in
a
run
component_7
here
be
why
a
connector_2
requirement_2
be
often
able
to
start
requirement_12
the
incoming
connector_data_1
before
all
of
the
connector_data_1
be
load
into
memory
my
technology_24
requirement_2
cannot
do
that
the
way
it
be
connector_13
now
that
mean
that
even
though
it
be
fast
in
raw
requirement_12
benchmark
in
a
real
life
run
component_7
where
my
requirement_2
would
have
to
wait
for
the
connector_data_1
to
load
it
not
be
a
fast
in
total
this
be
illustrate
in
the
diagram
below
you
could
probably
modify
my
requirement_2
to
be
able
to
requirement_2
connector_data_1
a
it
be
be
load
in
order
to
quality_attribute_11
up
the
total
requirement_12
time
but
that
would
probably
decrease
raw
requirement_2
requirement_1
a
bit
the
total
quality_attribute_11
might
still
be
quality_attribute_9
though
similarly
my
technology_24
requirement_2
do
not
do
anything
with
the
requirement_12
connector_data_1
if
you
need
to
extract
a
lot
of
that
connector_data_1
into

then
technology_28
will
have
do
some
of
the
work
for
you
already
since
it
create
an
connector_data_4
tree
from
the
requirement_12
connector_data_1
this
be
illustrate
in
the
diagram
below
when
use
technology_28
some
of
the
connector_data_1
extraction
need
during
connector_data_1
component_1
might
already
have
be
do
for
you
mean
that
the
connector_data_1
component_1
step
might
be
fast
than
if
it
also
have
to
include
connector_data_1
extraction
e
g
into
connector_data_4
so
to
really
measure
the
impact
on
your
component_7
you
have
to
measure
the
use
of
different
requirement_2
in
your
component_7
i
be
sure
you
will
see
a
speedup
from
use
an
index
overlay
requirement_2
but
exactly
how
much
it
will
be
be
hard
to
say
discussion
of
index
overlay
requirement_2
in
general
one
argument
i
have
hear
against
index
overlay
requirement_2
be
that
to
be
able
to
point
into
the
original
connector_data_1
rather
than
extract
it
into
an
connector_data_4
tree
it
be
necessary
to
keep
all
of
the
connector_data_1
in
memory
while
requirement_12
it
this
be
can
produce
a
memory
hit
when
component_1
big

in
general
the
argument
be
that
a
connector_2
requirement_2

technology_23
or
stax
can
requirement_12
huge
without
ever
have
the
whole
in
memory
however
this
be
only
true
if
the
connector_data_1
in
the
can
be
requirement_12
and
component_1
in
small
chunk
where
each
chunk
can
be
requirement_12
and
component_1
independently
from
other
chunk
for
instance
a
big
connector_data_3
contain
a
connector_data_2
of
element
each
of
which
can
be
requirement_12
and
component_1
individually

a
connector_data_2
of
requirement_13
component_11
but
if
your
connector_data_1
can
be
requirement_12
separately
in
independent
chunk
you
can
connector_13
an
index
overlay
requirement_2
that
be
capable
of
that
a
well
if
the
cannot
be
requirement_12
in
independent
chunk
you
will
anyways
have
to
extract
the
necessary
connector_data_9
into
some
connector_data_8
which
can
be
connector_29
by
the
component_1
late
chunk
but
if
you
can
do
that
with
a
connector_2
requirement_2
you
can
also
do
it
with
an
index
overlay
requirement_2
requirement_2
that
create
connector_data_4
tree
from
input
connector_data_1
often
connector_14
much
large
amount
of
memory
with
the
connector_data_4
tree
than
the
original
connector_data_1
size
this
be
due
to
the
memory
overhead
associate
with
an
connector_data_4
instance
plus
extra
connector_data_1
need
to
keep
reference
between
connector_data_4
additionally
since
all
connector_data_1
need
to
be
in
memory
at
one
time
you
need
to
allocate
a
connector_data_1
buffer
ahead
of
requirement_12
that
be
big
enough
to
hold
all
the
connector_data_1
but
what
if
you

t
how
big
the
be
when
you
start
requirement_12
them
imagine
you
have
a
web
component_7
or
web
component_2
or
other
component_5
component_7
where
the
component_15
can
connector_30

you
not
how
big
the
be
so
how
can
you
allocate
a
suitable
buffer
for
them
before
the
requirement_12
start
well
for
quality_attribute_2
reason
you
should
always
have
a
maximum
allow
size
otherwise
component_15
be
able
to
crash
your
component_16
by
connector_31
very
large

or
they
even
connector_11
a
component_17
that
pretend
to
be
a
browser
connector_31
a

and
have
that
component_17
never
stop
connector_32
connector_data_1
to
your
component_5
you
can
allocate
a
buffer
fit
the
maximum
allow
size
that
way
your
buffer
will
not
run
out
of
space
for
valid

if
it
do
run
out
of
space
your
component_18
have
connector_33
an
excessively
large
anyway
about
the
author
jakob
jenkov
be
an
entrepreneur
writer
and
developer
currently
locate
in
barcelona
spain
jakob

technology_1
in

and
have
work
with
technology_1
professionally
since

he
be
currently
focus
on
the
concept
of
quality_attribute_15
across
a
variety
of
domain

component_1
requirement_17
etc
he
hold
a
master
of
science
in
it
from
the
it
university
in
copenhagen
you
can
connector_10
more
about
his
work
on
his

inspire
by
this
content
connector_11
for
infoq
become
an
editor
for
infoq
be
one
of
the
best
decision
of
my
career
it
have
challenge
me
and
help
me
grow
in
so
many
way
we
technology_30
love
to
have
more
people
join
our
team
thomas
bettslead
editor
architecture
and
design
@infoq
senior
principal
engineer
connector_11
for
infoq
rate
this
adoption
style
author

this
content
be
in
the
technology_1
topic
relate
topic
development
technology_1
requirement_12
requirement_1
relate
editorial
popular
across
infoq
go
requirement_15
with
technology_31
and
graalvm
why
you
should
care
about
architecture
technology_1
news
roundup
jeps
for
jdk

project
lilliput
milestone
technology_31
technology_32
quarkus



state
of
the
technology_1
ecosystem
report
from
relic
ml
technology_33
to
accelerate
your
work
with
cassie
breviu
release
technology_34
dns
private
resolver
in
preview
relate
content
level
up
your
technology_1
requirement_1
with
tornadovm
jep

component_11
to
extend
pattern_2
match
in
technology_1
technology_1
news
roundup
openjdk
technology_31
connector_data_11
and
cf
payara
component_19
technology_3
technology_35
connector_data_11
state
of
the
technology_1
ecosystem
report
from
relic
+
technology_1
=
♡
a
story
tell
by
martijn
verburg
at
devoxx
uk
technology_1
news
roundup
jeps
for
jdk

project
lilliput
milestone
technology_31
technology_32
quarkus



the
future
of
technology_1
a
see
by
mark
little
at
devoxx
uk

requirement_15
technology_1
adoptium
and
fast
pace

puzzle
from
jdk11
hanno
embregts
on
technology_1
certification
at
devoxx
uk
jep

technology_1
virtual
component_20
to
connector_9
improve
quality_attribute_16
technology_1
news
roundup
jeps
for
project
loom
and
panama
jobrunr



technology_6



preview
technology_1
current
state
compile
requirement_15
executables
for
startup
quality_attribute_11
and
small
footprint
technology_1
news
roundup
jep
connector_data_11
for
jdk

project
loom
microstream


relic
technology_1
survey
series
requirement_15
compilation
technology_36
technology_1
requirement_10
requirement_15
technology_1
with
the
micronaut
technology_32
requirement_15
technology_1
in
the
real
world
technology_37
requirement_15
technology_1
with
quarkus
revolutionize
technology_1
with
graalvm
requirement_15
image
technology_1
infoq
trend
report—december

technology_1
&
technology_29
panel
six
feature
from
technology_1

to

to
connector_3
excite
about
kalix
build
serverless
requirement_10
requirement_15
requirement_17
crtical
component_21
with
no
component_3
microstream


connector_34
support
for
technology_38
quarkus



introduce
fine
grain
transaction
component_22
jetbrains
intellij
idea


introduce
connector_35
analysis
technology_6
pattern_9
technology_32
ktor


release
with
plugins
feature
go
requirement_15
with
technology_31
and
graalvm
jobrunr



connector_34
improve
technology_32
support
connector_36
start
to
quarkus
reactive
pattern_10
with
technology_3
technology_4
two
must
have
technology_33
for
jakarta
ee
developer
the
angular
mini
book


lightweight
external
requirement_17
rule
raft
component_23
a
requirement_13
pattern_6
embed
storage
component_23
for
multi
raft
requirement_13
in
tikv
how
to
fight
climate
connector_37
a
a
engineer
quality_attribute_17
continuous
load
test
into
slack
pipeline
how
psychological
quality_attribute_18
at
work
create
quality_attribute_19
tech
team
that
and
grow
hashicorp
vault
improve
eventual
consistency
with
component_5
side
consistent
connector_data_6
announce
the
general
quality_attribute_20
of
technology_34
container
component_24
at
build

requirement_7
at
the
edge
how
connector_36
feedback
from
angry
component_15
help
to
develop
quality_attribute_9
technology_16
cloudflare
d1
provide
quality_attribute_3
technology_39
for
cloudflare
component_25
the
infoq
newsletter
a
round
up
of
last
week’s
content
on
infoq
connector_38
out
every
tuesday
join
a
of
over


senior
developer
pattern_11
an
example
enter
your
e
mail
connector_39
select
your
country
select
a
country
i
to
infoq
technology_18
handle
my
connector_data_1
a
explain
in
this
privacy
notice
we
protect
your
privacy
hello
stranger
you
need
to
register
an
infoq
account
or
login
or
login
to

but
there
s
so
much
more
behind
be
register
connector_3
the
most
out
of
the
infoq
experience
tell
u
what
you
think
allow
technology_40
a
b
br
blockquote
i
li
pre
u
ul
p
me
connector_data_12
to
any
of
my
connector_data_13
in
this
component_26

watch
component_26
requirement_2
generator
by
brian
oxley
re
requirement_2
generator
by
russell
leggett
reinvent
the
wheel
by
sila
kayo

s
not
forget
that
functional
technology_13
be
ideally
suit
for
connector_40
requirement_2
by
faisal
waris
requirement_2
generator
by
gong
gara
if
you
have
a
little
more
leeway
by
prasan
samtani
your
requirement_2
be
break
by
richard
hightower
vtd
technology_22
be
brilliant
for
requirement_1
le
so
for
readability
by
chris
melikian
some
more
feedback
by
richard
hightower
re
some
more
feedback
by
faisal
waris
re
some
more
feedback
by
richard
hightower
re
some
more
feedback
by
richard
hightower
sorry
for
the
late
connector_41
by
jakob
jenkov
technology_27

example
should
work
now
by
jakob
jenkov
the

use
in
the
benchmark
be

to
the
technology_41
pattern_12
by
jakob
jenkov
how
do
regex
deteriorate
the
requirement_1
by
tarun
saha
requirement_2
generator
by
brian
oxley
your
connector_data_14
be
await
moderation
thank
you
for
participate
in
the
discussion
quality_attribute_9
particle
would
you
follow
up
with
a
discussion
of
requirement_2
generator
the
last
time
i
connector_11
a
requirement_2
by
hand
be
a
an
exercise
in
the
early
90
since
i
have
use
requirement_2
generator
for
any
regular
syntax
technology_1
have
several
fine
generator
such
a
javacc
technology_42
technology_43
do
in
a
pinch
a
reference
en
wikipedia

wiki
comparison_of_parser_gene
connector_data_15
back
to
top
re
requirement_2
generator
by
russell
leggett
your
connector_data_14
be
await
moderation
thank
you
for
participate
in
the
discussion
yeah
one
more
vote
for
requirement_2
generator
i
ve
use
technology_44
for
several
small
technology_13
and
find
it
to
be
pretty
easy
to
do
some
powerful
thing
combine
with
antlrworks
i
have
a
hard
time
imagine
a
much
quality_attribute_9
experience
if
you
re
connector_36
start
that
say
i
can
see
how
the
technique
here
might
connector_3
you
some
quality_attribute_9
requirement_1
in
exchange
for
put
in
a
lot
more
work
connector_data_15
back
to
top
reinvent
the
wheel
by
sila
kayo
your
connector_data_14
be
await
moderation
thank
you
for
participate
in
the
discussion
another
vote
for
requirement_2
generator
i
mean
nice
but
i
still

t
understand
why
someone
need
to
connector_11
a
requirement_2
nowadays
with
exist
requirement_2
generator
technology_44
for
example
connector_40
your
own
requirement_2
be
imho
a
waste
of
time
in
requirement_4
where
quality_attribute_11
be
critical
use
a
combination
of
technology_44
and
stringtemplate
for
offline
requirement_12
+
generation
into
target
technology_13
connector_data_15
back
to
top

s
not
forget
that
functional
technology_13
be
ideally
suit
for
connector_40
requirement_2
by
faisal
waris
your
connector_data_14
be
await
moderation
thank
you
for
participate
in
the
discussion
connector_40
requirement_2
for
mini
technology_13
be
par
for
the
in
development
technology_45
s
parsec
www
technology_45

haskellwiki
parsec
and
it
s
derivative
allow
one
to
component_6
the
grammar
with
in
the
component_27
technology_13
itself
you

t
need
a
separate
technology_13
do
describe
the
grammar
technology_46
have
active
pattern_2
in
addition
to
a
parsec
derivative
which
be
an
innovative
way
of
match
pattern_2
and
bind
requirement_11
you
can
also
see
the
grammar
in
the

here
be
an
technology_40
requirement_2
base
on
active
pattern_2
in
only

line
of

fshtml
codeplex
technology_18
and
a
technology_27

include
a
requirement_2
base
on
active
pattern_2
fsjson
codeplex
technology_18
many
more
example
a
technology_46
snippet

www
fssnip
net
category
requirement_12
connector_data_15
back
to
top
requirement_2
generator
by
gong
gara
your
connector_data_14
be
await
moderation
thank
you
for
participate
in
the
discussion
this
be
a
nice
particle
i
think
that
we
dont
need
to
develope
the
requirement_2
gernerator
because
in
the
fast
develop
world
there
be
many
high
requirement_1
flexable
quality_attribute_9
requirement_2
for
example
javacc
technology_44
connector_data_15
back
to
top
if
you
have
a
little
more
leeway
by
prasan
samtani
your
connector_data_14
be
await
moderation
thank
you
for
participate
in
the
discussion
i
technology_30
urge
a
look
at
requirement_2
combinators
in
technology_47
a
well
it
make
connector_1
a
technology_13
dead
quality_attribute_8
connector_data_15
back
to
top
your
requirement_2
be
break
by
richard
hightower
your
connector_data_14
be
await
moderation
thank
you
for
participate
in
the
discussion
you
say
you

t
extract
the
connector_data_1
or
requirement_12
the
number
or
you
also
do
not
properly
encode
the

or
the
key
you
leave
in
\n
\t
\b
etc
also
your
requirement_2
fail
on
many
of
the
sample
on
technology_27

if
you
encode
the

properly
you
would
loose
to
technology_28
i

i
benchmarked
it
then
if
actually
extract
the
connector_data_1
from
that
unusable
technology_48
your
requirement_1
be
3x
bad
than
technology_28
connector_data_15
back
to
top
vtd
technology_22
be
brilliant
for
requirement_1
le
so
for
readability
by
chris
melikian
your
connector_data_14
be
await
moderation
thank
you
for
participate
in
the
discussion
vtd
be
a
great
piece
of

we
reduce
a
that
take


hr
use
a
technology_23
requirement_2
down
to
under

minute
use
vtd
on
a
250mb
connector_data_3

it
s
very
memory
quality_attribute_21
too
the
isn
t
particularly
nice
to
work
with
and
unit
test
can
be
hard
there
be
some
final
and
variable
in
the
which
we
have
to
fork
to
connector_3
mock
to
work
correctly
but
all
in
all
very
please
with
it
connector_data_15
back
to
top
some
more
feedback
by
richard
hightower
your
connector_data_14
be
await
moderation
thank
you
for
participate
in
the
discussion
you
do
not
include
the
technology_24
on
technology_25
that
you
use
for
the
benchmark
when
i
download
some
sample
technology_27
from
technology_25
your
requirement_2
could
not
requirement_12
them
but
to
be
fair
neither
do
technology_28
and
to
more
than
fair
my
requirement_2
which
i
connector_11
for
fun
be
able
to
requirement_12
more
technology_24
than
technology_28
and
yours
but
also
fail
on
some
of
the
technology_24

i
would
have
be
devastate
by
this
because
unlike
your
requirement_2
i
have
hundred
of
compliance
test
that
test
for
all
sort
of
edge
requirement_4
and
since
i
have
use
mine
in
production
i
have
a
few
bug
test
requirement_4
to
put
it
plainly
it
handle
technology_24
quality_attribute_9
than
technology_28
which
be
much
old
and
much
more
mature
yet
i
would
never
publish
benchmark
until
mine
work
against
all
of
the
sample
technology_24
on
technology_27

your
requirement_2
do
not
encode
the
technology_24

which
would
immediately
give
your
requirement_2
an
unfair
advantage
it
be
not
about
compare
apple
to
apple
or
apple
to
orange
it
be
compare
a
football
stadium
to
a
wood
tick
it
do
not
even
make
sense
you
also
use
the
part
of
technology_28
that
us
pattern_13
to
populate
an
connector_data_4
so
not
only
do
it
actually
not
turn
the
number
into
number
but
you
compare
yours
which
merely
track
the
index
of
where
stuff
be
to
technology_28
which
be
take
a
technology_24
connector_21
and
turn
it
into
a
technology_1
connector_data_4
this
be
a
lot
le
than
fair
i
then
create
a
very
very
quality_attribute_8
technology_24

and
your
requirement_2
fail
i
have
to
keep
tweak
the
technology_24
until
your
requirement_2
be
able
to
handle
something
then
should
i
stop
now
then
i
actually
try
to
use
your
requirement_2
to
connector_15
the
connector_data_1
that
it
requirement_12
holy
h3ll
be
you
kid
me
you
be
compare
this
to
technology_28
really
you
make
some
quality_attribute_9
point
in
the

but
way
to
early
to
publish
a
benchmark
connector_data_15
back
to
top
re
some
more
feedback
by
faisal
waris
your
connector_data_14
be
await
moderation
thank
you
for
participate
in
the
discussion
i
have
the
same
experience
both
this
requirement_2
and
technology_28

t
requirement_12
some
common
technology_24
which
be
surprise
i
look
at
the
and
the
technique
use
this
requirement_2
be
indeed
very
fast
it
can
be
correct
to
handle
the
technology_27
quality_attribute_9
without
really
slow
it
down
much
there
be
requirement_11
in
understand
the
technique
use
however
i
will
have
to
connector_data_5
it
a
half
requirement_2
a
much
of
the
work
of
obtain
useful
requirement_11
from
the
requirement_12
connector_data_1
be
still
to
be
do
infer
hierarchical
connector_data_8
and
obtain
quality_attribute_22
requirement_11
for

and
number
be
leave
for
late
connector_data_15
back
to
top
re
some
more
feedback
by
richard
hightower
your
connector_data_14
be
await
moderation
thank
you
for
participate
in
the
discussion
of
the
three
requirement_2
his
technology_28
mine
and
mine
after
i
refactored
it
to
beat
technology_28
here
be
the
score




milisecondsgson


milisecondsboon
v2


milisecondsboon
v1


milisecondsnow
keep
in
mind
that
his
requirement_2
be
not
actually
do
real
technology_24
requirement_12
because
it
be
not
encoding
the
technology_24

it
be

percent
slow
than
my
boon
requirement_2
and
if
you

t
deliberately
hamstring
technology_28
by
make
it
do
pattern_13
into
an
connector_data_4
technology_28
be
fast
too
i
refactored
my
requirement_2
to
run
fast
after
this

i
be
plan
on
refactoring
it
but
this
make
me
both
refactor
it
and
improve
the
test
technology_27
compliance
my
early
complaint
about
technology_28
be
an
error
it
seem
i
create
a
compliance
test
base
on
the
example
at
technology_27

here
be
the
connector_data_16
test
component_18
rick
technology_25
requirement_2
in
technology_1
connector_data_1
actionlabel
technology_27
boon

pass
component_18
rick
technology_25
requirement_2
in
technology_1
connector_data_1
actionlabel
technology_27
boon

pass
component_18
rick
technology_25
requirement_2
in
technology_1
connector_data_1
actionlabel
technology_27
technology_28
#
pass
component_18
rick
technology_25
requirement_2
in
technology_1
connector_data_1
actionlabel
technology_27
info
component_28
fail
component_18
rick
technology_25
requirement_2
in
technology_1
connector_data_1
actionlabel
technology_27
test
component_18
rick
technology_25
requirement_2
in
technology_1
connector_data_1

technology_27
boon

pass
component_18
rick
technology_25
requirement_2
in
technology_1
connector_data_1

technology_27
boon

pass
component_18
rick
technology_25
requirement_2
in
technology_1
connector_data_1

technology_27
technology_28
#
pass
component_18
rick
technology_25
requirement_2
in
technology_1
connector_data_1

technology_27
info
component_28
fail
component_18
rick
technology_25
requirement_2
in
technology_1
connector_data_1

technology_27
test
component_18
rick
technology_25
requirement_2
in
technology_1
connector_data_1
sgml
technology_27
boon

pass
component_18
rick
technology_25
requirement_2
in
technology_1
connector_data_1
sgml
technology_27
boon

pass
component_18
rick
technology_25
requirement_2
in
technology_1
connector_data_1
sgml
technology_27
technology_28
#
pass
component_18
rick
technology_25
requirement_2
in
technology_1
connector_data_1
sgml
technology_27
info
component_28
fail
component_18
rick
technology_25
requirement_2
in
technology_1
connector_data_1
sgml
technology_27
test
component_18
rick
technology_25
requirement_2
in
technology_1
connector_data_1
webxml
technology_27
boon

pass
component_18
rick
technology_25
requirement_2
in
technology_1
connector_data_1
webxml
technology_27
boon

pass
component_18
rick
technology_25
requirement_2
in
technology_1
connector_data_1
webxml
technology_27
technology_28
#
pass
component_18
rick
technology_25
requirement_2
in
technology_1
connector_data_1
webxml
technology_27
info
component_28
fail
component_18
rick
technology_25
requirement_2
in
technology_1
connector_data_1
webxml
technology_27
test
component_18
rick
technology_25
requirement_2
in
technology_1
connector_data_1
widget
technology_27
boon

pass
component_18
rick
technology_25
requirement_2
in
technology_1
connector_data_1
widget
technology_27
boon

pass
component_18
rick
technology_25
requirement_2
in
technology_1
connector_data_1
widget
technology_27
technology_28
#
pass
component_18
rick
technology_25
requirement_2
in
technology_1
connector_data_1
widget
technology_27
info
component_28
fail
component_18
rick
technology_25
requirement_2
in
technology_1
connector_data_1
widget
technology_27
the
from
this
could
not
requirement_12
a
single
technology_24
example
form
technology_27

not
one
anyway
if
you
create
a
technology_24
quality_attribute_8
enough
you
can
connector_3
it
to
requirement_12
something
the
have
some
quality_attribute_9
idea
but
it
be
a
bit
le
than
bake
technology_27

example
connector_data_15
back
to
top
re
some
more
feedback
by
richard
hightower
your
connector_data_14
be
await
moderation
thank
you
for
participate
in
the
discussion
technology_25
technology_18
richardhightower
requirement_2
in
javai
fork
it

technology_49
to
the
mix
technology_28


mili
secondjackson

156boon


645boon


799infoq

431parse
time
for
large
technology_27



run
boon



mili
secondboon


967jackson

985infoq
parserexceptiongson

870anyway
it
be
a
quality_attribute_9
exercise
i
connector_3
very
familiar
with
my
profiler
jvisualvm
i
improve
the
hell
out
of
the
boon
technology_24
compliance
i

some
experimental
thing
to
the
boon

technology_24
requirement_2
so
now
it
be
3x
fast
than
technology_49
and
technology_28
well
for
the
sample
technology_24
form
technology_27

it
be
much
slow
i
think
it
be
fast
until
this
inspire
me
to
test
it
quality_attribute_11
now
it
be
pretty
fast
i
think
the
boon
requirement_2
would
do
much
quality_attribute_9
than
it
initially
do
and
this
inspire
me
to
tune
it
and
there
be
some
thing
in
this
some
idea
that
i
be
already
think
about

but
in
a
more
useable
fashion
rick
hightower
blogspot
technology_18


benchmark
f
now
i
be
leave
wonder
why
be
his
requirement_2
this
slow
it
shouldn
t
be
i
almost
want
to
tune
it
and
fix
it
connector_data_15
back
to
top
sorry
for
the
late
connector_41
by
jakob
jenkov
your
connector_data_14
be
await
moderation
thank
you
for
participate
in
the
discussion
hi
everyone
i
have
be
pretty
occupy
with
move
from
one
apartment
to
another
and
i
have
not
connector_18
any
connector_data_17
about
the
late

until
i
connector_3
an
summary
late
friday
so
i
haven
t
have
a
chance
to
respond
to
them
i
will
do
that
over
the
weekend
though
i
be
the
author
of
the

connector_data_15
back
to
top
technology_27

example
should
work
now
by
jakob
jenkov
your
connector_data_14
be
await
moderation
thank
you
for
participate
in
the
discussion
the
late
version
of
the
requirement_2
on
technology_41
early
should
be
able
to
requirement_12
all

example
from
technology_27

example
this
version
also
support
requirement_12
number
and
booleans

be
still
not
connector_42
i
have

a
very
quality_attribute_8
jsonorgexamplestest
that
par
all

without
throw
any
exception
the
test
do
not
verify
that
the
requirement_2
also
find
the
correct
connector_data_6
it
merely
connector_43
that
the
requirement_12
do
not
throw
exception
i
have
also

the

example
from
technology_27

example
to
the
technology_41
pattern_12
in
the
connector_data_1
technology_27

directory
connector_data_15
back
to
top
the

use
in
the
benchmark
be

to
the
technology_41
pattern_12
by
jakob
jenkov
your
connector_data_14
be
await
moderation
thank
you
for
participate
in
the
discussion
i
have
now

the

i
use
in
the
benchmark
to
the
connector_data_1
directory
in
the
technology_41
pattern_12
the

only
contain
connector_data_4

and
requirement_11
there
be
no
number
requirement_11
or
boolean
requirement_11
of
it
would
make
sense
to
that
to
the
benchmark
but
find
the
start
and
end
of
number
and
booleans
should
not
be
significantly
fast
or
slow
than
find
the
start
and
end
of
a
quote

ala
be
should
be
pretty
easy
to
some
number
and
booleans
to
the
benchmark
to
verify
it
i
will
respond
to
the
rest
of
the

tomorrow
there
be
still
a
lot
of
point
to
respond
to
connector_data_15
back
to
top
how
do
regex
deteriorate
the
requirement_1
by
tarun
saha
your
connector_data_14
be
await
moderation
thank
you
for
participate
in
the
discussion
hi
i
be
wonder
to
use
regex
to
requirement_12
the
connector_data_3
input
please
me
how
use
regex
would
be
beneficial
or
loss
connector_data_15
back
to
top
close
your
connector_data_15
quote
original
connector_data_14
allow
technology_40
a
b
br
blockquote
i
li
pre
u
ul
p
me
connector_data_12
to
any
of
my
connector_data_13
in
this
component_26
cancel
close
your
connector_data_15
allow
technology_40
a
b
br
blockquote
i
li
pre
u
ul
p
me
connector_data_12
to
any
of
my
connector_data_13
in
this
component_26
cancel
close
ok

development
how
to
prepare
for
the
unexpected
an
influxdata
outage
story
tell
at
kubeconeu

reproducible
development
with
container
green
development
terminology
and
climate
commitment
explain
by
at
devoxx
uk
architecture
&
design
oren
eini
on
technology_12
include
consistency
guarantee
and
technology_8
a
the
implementation
technology_13
kalix
build
serverless
requirement_10
requirement_15
requirement_17
crtical
component_21
with
no
component_3
architecting
for
the
edge
culture
&
how
connector_36
feedback
from
angry
component_15
help
to
develop
quality_attribute_9
technology_16
how
to
run
your
technology_16
department
a
coach
build
a
culture
of
quality_attribute_23
and
curiosity
requirement_5
ml
&
connector_data_1
engineering
requirement_7
at
the
edge
release

technology_13
requirement_5
train
dataset
massive
requirement_5
for
developer
a
future
or
a
reality
devops
hashicorp
vault
improve
eventual
consistency
with
component_5
side
consistent
connector_data_6
cloudflare
d1
provide
quality_attribute_3
technology_39
for
cloudflare
component_25
effectively
pattern_14
your
pattern_14
miedwar
meshbesher
on
use
vigilance
control
the
infoq
newsletter
a
round
up
of
last
week’s
content
on
infoq
connector_38
out
every
tuesday
join
a
of
over


senior
developer
pattern_11
an
example
connector_3
a
quick
overview
of
content
publish
on
a
variety
of
innovator
and
early
adopter
technology_50
what
you
don’t
that
you
don’t
stay
up
to
date
with
the
late
connector_data_9
from
the
topic
you
be
interest
in
enter
your
e
mail
connector_39
select
your
country
select
a
country
i
to
infoq
technology_18
handle
my
connector_data_1
a
explain
in
this
privacy
notice
we
protect
your
privacy
qcon
development
conference
real
world
technical
talk
no
technology_16
pitch
practical
idea
to
inspire
you
and
your
team
qcon
san
francisco
oct


in
person
qcon
san
francisco
bring
together
the
world
s
most
innovative
senior
engineer
across
multiple
domain
to
connector_44
their
real
world
implementation
of
emerge
trend
and
practice
uncover
emerge
trend
and
practice
to
solve
your
complex
engineering
challenge
without
the
technology_16
pitch
connector_8
your
spot
now
home
create
account
login
qcon
conference
contribute
infoq
editor
about
infoq
about
c4media

technology_51
infoq
developer
requirement_18
diversity
infoq
live


infoq
live


infoq
live


qcon
san
francisco



qcon
plus



follow
u
on
youtube212k
follower
linkedin18k
follower
rss19k
reader
twitter50k
follower
facebook20k

alexanew
stay
in
the
the
infoq
podcast
engineering
culture
podcast
the
architect
newsletter
general
feedback
feedback@infoq
technology_18
advertising
sales@infoq
technology_18
editorial
editors@infoq
technology_18
requirement_18
marketing@infoq
technology_18
infoq
technology_18
and
all
content
copyright
©


c4media
inc
infoq
technology_18
component_27
at
contegix
the
best
isp
we
ve
ever
work
with
privacy
notice
term
and
condition
requirement_19
bt
