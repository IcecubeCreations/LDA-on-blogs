here’s
why
you
probably
shouldn’t
be
use
the
technology_1
technology_2
in

|
by
danny
damsky
|
mediumget
unlimited
accessopen
in
apphomenotificationslistsstorieswritedanny
damskyfollowaug

2018·3
min
readhere’s
why
you
probably
shouldn’t
be
use
the
technology_1
technology_2
in
2018prefacegson
be
the
most
popular
technology_3
requirement_1
technology_2
on
technology_4
it
have
over


star
and
the
number
be
only
grow
people
include
myself
love
it
for
it
quality_attribute_1
and
how
type
a
single
line
of
convert
your
technology_3
to
an
connector_data_1
and
vice
versa
but
do
you
that
this
quality_attribute_1
come
at
a
cost
i
begin
to
wonder
how
different
these
technology_3
requirement_1
solution
can
be
and
how
much
of
a
difference
there
be
between
a
modern
solution
technology_1
compare
to
something

after
realize
that
most
of
the
connector_data_2
on
the
web
be
outdated
i
decide
to
test
out
some
of
these
solution
myself
the
component_1
of
test
technology_3
requirement_1
solutionsi
decide
to
test
the

most
popular
technology_2
for
requirement_1
jsons
technology_1
technology_5
and
moshi
and
compare
them
against

in
my
comparison
the
requirement_1
solution
would
be
compare
base
on

factor
the
time
it
take
to
serialize
an
connector_data_1
in
millisecond
the
time
it
take
to
deserialize
a
technology_3
in
millisecond
the
length
of
the
technology_3
the
amount
of
character
in
the
json’s

the
count
of
each
of
the
technology_2
i
build

heavy
connector_data_1
instance
with
similar
requirement_2
in
them
to
test
the
requirement_3
of
the
technology_2
and
to
make
sure
that
they
can’t
use
pattern_1
to
their
advantage
i
also
test
it
out
with
the
same
connector_data_1
instance
and
the
connector_data_3
be
similar
i
run
the
test
a
few
time
to
see
how
each
round
affect
the
behavior
of
the
technology_2
here’s
what
i
find
the
resultson
the
leave
be
the
first
run
of
the
benchmark
and
on
the
right
be
the
second
run
and
every
run
after
that
these
connector_data_3
show
how
well
each
technology_3
requirement_1
technology_2
do
in
accordance
to
the
first

of
the

decide
factor
in
my
comparison
that
be
mention
above
you
can
ignore
“object
length”
that
one
simply
represent
how
many
character
there
be
in
my
deserialized
object’s
tostring

look
at
these
connector_data_3
we
can
see
that
at
the
first
run
all
of
the
solution
seem
to
perform
rather
slowly
which
be
probably
due
to
some
behind
the
scene
memory
allocation
look
at
the
connector_data_3
of
the
second
run
we
see
a
clear
picture
of
how
these
solution
will
perform
for
most
of
the
application’s
run
time
and
that
be
where
we
see
the
problem
present
with
use
technology_1
a
our
technology_3
requirement_1
technology_2
technology_1
be
the
slow
at
deserializing
jsons
it’s
almost
twice
a
slow
a
moshi
and
and
slow
than
technology_5
by
more
than
twice
in
that
regard
another
thing
to
take
note
at
be
technology_1
be
the
only
technology_2
produce
large
technology_3

than
the
other
solution
this
be
because
technology_1
insert
a
bunch
of
escape
character
whereas
the
other
solution
serialize
the
connector_data_1
a
be
one
thing
that
could
be
use
to
gson’s
advantage
though
be
that
it
indeed
do
serialize
connector_data_4
relatively
fast
but
you
should
also
take
into
consideration
that
because
the
actual
technology_3
be
big
in
this
requirement_4
by
24%
it
will
take
up
more
of
your
component_2
memory
when
component_3
in
a
and
it
will
take
long
to
connector_1
in
an
technology_6
connector_data_5
for
example
the
fourth
decide
factor
—
countjackson
count

197gson
count

036moshi
count
534moshi
+
okio
count

140conclusionjackson
be
by
far
the
heavy
technology_2
of
them
all
but
it
be
also
the
fast
one
another
great
aspect
of
use
technology_5
be
consistency
when
build
a
technology_7
component_4
side
component_5
alongside
your
technology_8
component_5
since
all
technology_9
implementation
and
the
technology_10
technology_11
use
technology_5
a
their
technology_3
requirement_1
technology_2
and
we
can
see
why
moshi
on
the
other
hand
be
a
very
small
technology_2
if
you
don’t
take
into
consideration
the
bundle
okio
technology_2
which
if
you’re
use
other
popular
technology_2
from
square
which
you
probably
be
be
bundle
in
anyway
and
it
perform
similarly
to

to
conclude
i
recommend
use
either
technology_5
or
moshi
for
work
with
jsons
and
avoid
use
technology_1
in
your
next
project
a
it
be
much
slow
for
deserialization
and
while
marginally
fast
than
moshi
at
serialize
connector_data_1
the
connector_data_6
technology_3
might
be
large
due
to
the
technology_12
quality_attribute_2
escape
character
that
technology_1
insert
into
it
pattern_2
project
on
bitbucket

6more
from
danny
damskyfollowfull
technology_13
web
+
technology_8
developer
always
look
to
and
develop
thing
and
stay
up
to
date
with
the
late
innovation
in
technology_14
love
podcast
or
audiobooks
on
the
go
with
our
component_6
try
knowableabouthelptermsprivacyget
the
appget
starteddanny
damsky20
followersfull
technology_13
web
+
technology_8
developer
always
look
to
and
develop
thing
and
stay
up
to
date
with
the
late
innovation
in
technology_14
followmore
from
mediumyash
mangrulkarcomparison
between
inheritance
and
polymorphismdavid
mwangicreating
a
deep
vs
shallow
copy
of
an
connector_data_1
in
javajorge
tovarpragmatic
programmerlena
tysonwhy
development
be
a
never
ending
component_1
helpstatuswritersblogcareersprivacytermsaboutknowable
