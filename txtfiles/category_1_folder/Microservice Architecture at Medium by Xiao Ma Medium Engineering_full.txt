pattern_1
architecture
at
|
by
xiao
ma
|
engineeringopen
in
apphomenotificationslistsstorieswritepublished
inmedium
engineeringxiao
mafollowoct
2018·16
min
readsave“a
drone
shoot
of
technology_1
of
large
ship
container
in
a
port”
by
chuttersnap
on
unsplashmicroservice
architecture
at
mediumthe
goal
of
microservice¹
architecture
be
to
help
engineering
team
ship
technology_2
fast
quality_attribute_1
and
with
high
quality
decouple
component_1
allow
team
to
iterate
quickly
and
with
minimal
impact
to
the
rest
of
the
component_2
at
our
technical
technology_1
start
with
a
monolithic
technology_3
component_3
back
in
we
have
build
a
couple
of
satellite
component_4
but
we
haven’t
create
a
strategy
to
adopt
the
pattern_1
architecture
systematically
a
the
component_2
become
more
complex
and
the
team
grow
we
move
to
a
pattern_1
architecture
in
early
in
this
we
want
to
connector_1
our
experience
of
do
it
effectively
and
avoid
pattern_1
syndrome
what
be
pattern_1
architecture
first
of
all
let’s
take
a
moment
to
think
about
what
pattern_1
architecture
be
and
be
not
“microservice”
be
one
of
those
overload
and
confuse
engineering
trend
this
be
what
we
at
think
what
it
be
in
pattern_1
architecture
multiple
loosely
couple
component_1
work
together
each
component_4
focus
on
a
single
purpose
and
have
a
high
pattern_2
of
relate
behavior
and
connector_data_1
this
definition
include
three
pattern_1
design
principle
single
purpose
—
each
component_4
should
focus
on
one
single
purpose
and
do
it
well
loose
couple
—
component_1
little
about
each
other
a
connector_2
to
one
component_4
should
not
require
connector_2
the
others
connector_3
between
component_1
should
happen
only
through
component_4
high
pattern_2
—
each
component_4
pattern_3
all
relate
behavior
and
connector_data_1
together
if
we
need
to
build
a
feature
all
the
connector_4
should
be
localize
to
one
single
component_4
three
principle
of
component_5
microserviceswhen
we
component_5
pattern_4
we
should
be
discipline
across
all
three
design
principle
it
be
the
only
way
to
achieve
the
full
potential
of
the
pattern_1
architecture
miss
any
one
of
them
would
become
an
anti
pattern_5
without
a
single
purpose
each
pattern_1
would
end
up
do
too
many
thing
grow
a
multiple
“monolithic”
component_4
we
will
not
connector_5
the
full
benefit
of
the
pattern_1
architecture
and
we
pay
the
operational
cost
without
loose
couple
connector_4
to
one
component_4
affect
other
component_4
so
we
would
not
be
able
to
release
connector_4
fast
and
safely
which
be
the
core
benefit
of
pattern_1
architecture
more
importantly
issue
cause
by
tight
couple
could
be
disastrous
e
g
connector_data_1
inconsistency
or
even
connector_data_1
loss
without
high
pattern_2
we
will
end
up
with
a
quality_attribute_2
monolithic
component_2
—
a
messy
set
of
component_1
that
have
to
be
connector_2
and
quality_attribute_3
at
the
same
time
in
order
to
build
a
single
feature
a
quality_attribute_2
monolithic
component_2
be
often
much
bad
than
a
centralized
monolithic
component_2
because
of
the
complexity
and
cost
of
coordination
of
multiple
component_4
sometimes
across
multiple
team
in
the
meantime
it’s
also
important
to
realize
what
a
pattern_1
be
not
a
pattern_1
be
not
a
component_4
that
have
a
small
number
of
line
of
or
do
“micro”
connector_data_2
this
misconception
come
from
the
name
“microservice”
the
goal
of
the
pattern_1
architecture
be
not
to
have
a
many
small
component_1
a
possible
component_1
could
be
complex
and
substantial
a
long
a
they
meet
the
above
three
principle
a
pattern_1
be
not
a
component_4
that
be
build
with
technology_4
all
the
time
even
though
the
pattern_1
architecture
allow
team
to
test
technology_4
more
easily
it
be
not
the
primary
goal
of
pattern_1
architecture
it
be
totally
fine
to
build
component_1
with
the
exact
same
technology_4
technology_1
a
long
a
the
team
benefit
from
decouple
component_4
a
pattern_1
be
not
a
component_4
that
have
to
be
build
from
scratch
when
you
have
a
well
architected
monolithic
component_3
already
avoid
connector_6
into
the
habit
to
build
every
component_4
from
scratch
there
might
be
opportunity
to
extract
the
component_6
from
the
monolithic
component_4
directly
again
the
above
three
principle
should
still
hold
why
now
at
we
always
ask
the
question
of
“why
now
”
when
make
big
technology_2
or
engineering
decision
“why
”
be
an
obvious
question
to
ask
but
it
assume
we
have
unlimited
people
time
and
resource
which
be
a
dangerous
assumption
when
you
think
about
“why
now
”
you
suddenly
have
a
lot
more
constraint
—
impact
to
the
current
work
opportunity
cost
overhead
of
distraction
etc
this
question
help
u
prioritize
quality_attribute_4
the
reason
why
we
need
to
adopt
pattern_1
now
be
that
our
technology_3
monolithic
component_3
have
become
a
bottleneck
in
multiple
way
first
of
all
the
most
urgent
and
important
bottleneck
be
it
requirement_1
certain
connector_data_3
that
be
computational
heavy
and
i
o
heavy
be
not
a
quality_attribute_4
fit
for
technology_5
j
we
have
be
incrementally
improve
the
monolithic
component_3
but
it
have
prove
to
be
ineffective
it
inferior
requirement_1
prevent
u
from
connector_7
quality_attribute_4
technology_2
without
make
the
already
very
slow
component_3
a
lot
slow
secondly
an
important
and
somewhat
urgent
bottleneck
of
the
monolithic
component_3
be
that
it
slow
down
the
technology_2
development
since
all
the
engineer
build
feature
in
the
single
component_3
they
be
often
tightly
couple
we
can’t
make
nimble
move
to
connector_2
one
part
of
the
component_2
because
it
affect
other
part
a
well
we
be
also
afraid
of
make
big
connector_4
because
the
impact
be
too
big
and
sometimes
hard
to
predict
the
entire
component_3
be
quality_attribute_3
a
a
whole
so
if
deployment
be
stall
because
of
one
bad
connector_8
all
the
other
connector_2
even
if
they
work
perfectly
fine
cannot
go
out
in
contrast
a
pattern_1
architecture
allow
team
to
ship
and
iterate
much
fast
they
can
focus
on
the
feature
they
be
build
that
be
decouple
from
the
rest
of
the
complex
component_2
connector_4
can
connector_5
to
production
much
fast
they
have
the
quality_attribute_5
to
try
out
big
connector_4
safely
in
our
pattern_1
architecture
connector_4
go
out
to
production
within
an
hour
and
engineer
don’t
worry
about
how
it
affect
other
part
of
the
component_2
the
team
also
explore
way
to
safely
use
production
connector_data_1
in
development²
which
have
be
a
daydream
for
many
year
all
of
these
be
especially
important
a
our
engineering
team
grow
thirdly
the
monolithic
component_3
make
it
difficult
to
quality_attribute_6
up
the
component_2
for
particular
connector_data_3
or
isolate
resource
concern
for
different
type
of
connector_data_2
with
the
single
monolithic
component_3
we
have
to
quality_attribute_6
up
and
down
the
entire
component_2
for
the
more
resource
hungry
connector_data_3
even
though
it
mean
the
component_2
be
over
provision
for
other
much
quality_attribute_7
connector_data_2
to
alleviate
these
issue
we
shard
different
type
of
connector_data_4
to
separate
technology_3
component_7
they
work
to
a
certain
extent
but
won’t
quality_attribute_6
because
again
these
micro
version
of
the
monolithic
component_4
be
tightly
couple
last
but
not
least
an
important
and
soon
to
be
urgent
bottleneck
be
that
it
prevent
u
from
try
out
technology_4
one
major
advantage
of
the
pattern_1
architecture
be
that
each
component_4
can
be
build
with
different
tech
technology_1
and
quality_attribute_8
with
different
technology_4
this
allow
u
to
pick
the
best
technology_6
for
the
and
more
importantly
do
so
in
a
fast
and
quality_attribute_1
way
pattern_1
strategiesadopting
the
pattern_1
architecture
be
not
trivial
it
could
go
awry
and
actually
hurt
engineering
productivity
in
this
section
we
will
connector_1
seven
strategy
that
help
u
in
the
early
stage
of
adoption
build
component_1
with
clear
valuemonolithic
persistent
storage
consider
harmfuldecouple
“building
a
service”
and
“running
services”thorough
and
consistent
observabilitynot
every
component_4
need
to
be
build
from
scratchrespect
failure
because
they
will
happenavoid
“microservice
syndromes”
from
day
onebuild
component_1
with
clear
valueone
think
adopt
a
component_8
architecture
mean
a
long
pause
of
technology_2
development
and
a
massive
rewrite
of
everything
this
be
the
wrong
approach
we
should
never
build
component_1
for
the
sake
of
build
component_4
every
time
we
build
a
component_4
or
adopt
a
technology_4
there
must
be
clear
technology_2
requirement_2
and
or
engineering
requirement_2
technology_2
requirement_2
should
be
represent
by
benefit
we
can
connector_9
to
our
component_9
a
component_4
be
require
to
make
it
possible
to
connector_9
the
requirement_2
or
make
it
fast
to
connector_9
the
requirement_2
compare
to
build
it
in
the
monolithic
technology_3
component_3
engineering
requirement_2
should
make
the
engineering
team
quality_attribute_4
and
fast
if
build
a
component_4
do
not
have
either
technology_2
requirement_2
or
engineering
requirement_2
we
leave
it
in
the
monolithic
component_3
it
be
totally
fine
if
in
ten
year
still
have
a
monolithic
technology_3
component_3
that
support
some
surface
start
with
a
monolithic
component_3
actually
help
u
component_5
the
pattern_4
strategically
monolithic
persistent
storage
consider
harmfula
big
part
of
component_5
pattern_4
be
to
component_5
their
persistent
connector_data_1
storage
e
g
component_10
connector_10
persistent
connector_data_1
storage
across
component_1
often
appear
to
be
the
easy
way
to
quality_attribute_8
pattern_4
together
however
it
be
actually
detrimental
and
we
should
avoid
it
at
all
cost
here
be
why
first
of
all
persistent
connector_data_1
storage
be
about
implementation
detail
connector_10
connector_data_1
storage
across
component_1
connector_11
the
implementation
detail
of
one
component_4
to
the
entire
component_2
if
that
component_4
connector_4
the
technology_7
of
the
connector_data_1
or
pattern_6
pattern_7
or
switch
to
different
type
of
component_10
many
other
component_1
have
to
be
connector_2
accordingly
a
well
this
violate
the
principle
of
loose
couple
secondly
persistent
connector_data_1
storage
be
not
component_4
behavior
i
e
how
to
modify
interpret
and
use
the
connector_data_1
if
we
connector_1
connector_data_1
storage
across
component_4
it
mean
other
component_1
also
have
to
replicate
component_4
behavior
this
violate
the
principle
of
high
pattern_2
—
behavior
in
a
give
domain
be
leak
to
multiple
component_4
if
we
modify
one
behavior
we
will
have
to
modify
all
of
these
component_1
together
in
pattern_1
architecture
only
one
component_4
should
be
responsible
for
a
specific
type
of
connector_data_1
all
the
other
component_1
should
either
connector_data_5
the
connector_data_1
through
the
component_11
of
the
responsible
component_4
or
keep
a
connector_12
only
non
canonical
maybe
materialize
copy
of
the
connector_data_1
this
sound
abstract
so
here
be
a
concrete
example
say
we
be
build
a
recommendation
component_4
and
it
need
some
connector_data_1
from
the
canonical
component_12
currently
in
technology_8
technology_9
we
could
make
the
connector_data_1
quality_attribute_9
for
the
recommendation
component_4
in
one
of
two
way
in
the
monolithic
storage
component_5
the
recommendation
component_4
have
direct
connector_13
to
the
same
persistent
storage
that
the
monolithic
component_3
do
this
be
a
bad
idea
because
pattern_6
can
be
tricky
if
the
recommendation
component_4
connector_14
the
same
pattern_6
a
the
monolithic
component_3
we
will
have
to
duplicate
the
pattern_6
implementation
detail
in
the
recommendation
component_4
a
well
if
the
recommendation
component_4
u
it
own
pattern_6
we
won’t
when
to
invalidate
it
pattern_6
when
the
monolithic
component_3
connector_data_6
the
connector_data_1
if
the
monolithic
component_3
decide
to
connector_2
to
use
rds
instead
of
technology_9
to
component_13
connector_data_1
we
will
have
to
reimplement
the
component_6
in
the
recommendation
component_4
and
all
other
component_1
that
connector_13
the
connector_data_1
a
well
the
monolithic
component_3
have
complex
component_6
to
interpret
the
connector_data_1
e
g
how
to
decide
if
a
should
not
be
viewable
to
a
give
component_9
we
have
to
reimplement
those
component_6
in
the
recommendation
component_4
once
the
monolithic
component_3
connector_4
or
component_6
we
need
to
make
the
same
connector_4
everywhere
a
well
the
recommendation
component_4
be
stick
with
technology_9
even
if
it
be
the
wrong
option
for
it
own
connector_data_1
connector_13
pattern_5
in
the
decouple
storage
component_5
the
recommendation
component_4
do
not
have
direct
connector_13
to
the
connector_data_1
neither
do
any
other
component_4
the
implementation
detail
of
connector_data_1
be
retain
in
only
one
component_4
there
be
different
way
of
achieve
this
ideally
there
should
be
a
component_4
that
own
the
connector_data_1
and
other
component_1
can
only
connector_13
connector_data_1
through
the
service’s
apis
however
it
could
be
an
expensive
upfront
investment
to
build
component_1
for
all
core
connector_data_1
component_5
there
be
a
couple
of
more
pragmatic
way
when
staff
be
limit
they
could
be
actually
quality_attribute_4
way
quality_attribute_10
on
the
connector_data_1
connector_13
pattern_5
in
option
b
the
monolithic
component_3
the
recommendation
component_1
when
relevant
connector_data_1
be
update
usually
this
doesn’t
have
to
happen
immediately
so
we
can
offload
it
to
the
pattern_8
component_2
in
option
technology_10
an
technology_11
pipeline
generate
a
connector_12
only
copy
of
the
connector_data_1
for
the
recommendation
component_4
plus
potentially
other
connector_data_1
that
be
useful
for
recommendation
a
well
in
both
option
the
recommendation
component_4
own
it
connector_data_1
completely
so
it
have
the
quality_attribute_5
to
pattern_6
the
connector_data_1
or
use
whatever
component_10
technology_4
that
fit
the
best
decouple
“building
a
service”
and
“running
services”if
build
pattern_4
be
hard
run
component_1
be
often
even
hard
it
slow
the
engineering
team
down
when
run
component_1
be
couple
with
build
each
component_4
and
team
have
to
keep
reinvent
the
way
of
do
it
we
want
to
each
component_4
focus
on
it
own
work
and
not
worry
about
the
complex
matter
of
how
to
run
component_4
include
requirement_3
connector_3
technology_12
deployment
observability
etc
the
component_4
requirement_4
should
be
completely
decouple
from
each
individual
service’s
implementation
the
strategy
of
decouple
“building
a
service”
and
“running
services”
be
to
make
run
component_4
connector_data_3
component_4
technology_4
agnostic
and
opinionated
so
that
component_3
engineer
can
fully
focus
on
each
service’s
own
requirement_5
component_6
thanks
to
the
recent
technology_4
advancement
in
containerization
container
pattern_9
component_4
mesh
component_14
requirement_1
pattern_10
etc
the
decouple
of
“running
service”
become
more
achievable
than
ever
requirement_3
requirement_3
e
g
component_4
discovery
connector_15
load
balance
traffic
connector_15
etc
be
a
critical
part
of
run
component_4
the
traditional
approach
be
to
provide
technology_13
for
every
component_15
technology_14
it
work
but
be
not
ideal
because
component_16
still
need
a
non
trivial
amount
of
work
to
quality_attribute_8
and
maintain
the
technology_13
more
often
than
not
component_16
still
need
to
connector_16
some
of
the
component_6
separately
the
modern
solution
be
to
run
component_1
in
a
component_4
mesh
at
we
use
istio
and
envoy
a
sidecar
pattern_11
component_14
engineer
who
build
component_1
don’t
need
to
worry
about
the
requirement_3
at
all
connector_3
technology_12
no
matter
which
tech
technology_1
or
technology_14
you
choose
to
build
pattern_4
it
be
extremely
important
to
start
with
a
mature
pattern_12
solution
that
be
quality_attribute_11
type
cross
component_15
and
require
the
minimum
amount
of
development
overhead
pattern_12
solution
that
support
backward
quality_attribute_12
also
make
it
quality_attribute_1
to
quality_attribute_3
component_1
even
with
connector_17
among
them
at
we
choose
grpc
a
common
alternative
be
rest+json
over
technology_15
which
have
be
the
bless
solution
for
component_8
connector_3
for
a
long
time
however
although
that
technology_1
be
great
for
the
browser
to
talk
to
component_8
it
be
inefficient
for
component_8
to
component_8
connector_3
especially
when
we
need
to
connector_18
a
large
number
of
connector_data_5
without
automatically
generate
stub
and
boilerplate
we
will
have
to
manually
connector_16
the
component_8
component_17
quality_attribute_13
pattern_12
implementation
be
more
than
wrap
a
requirement_3
component_17
in
addition
pattern_13
be
“opinionated”
but
it
can
be
difficult
to
always
connector_5
everyone
to
agree
on
every
detail
e
g
be
this
connector_data_7
really
rest
or
an
pattern_12
be
this
thing
a
resource
or
be
it
an
etc
deployment
have
a
consistent
way
to
build
test
package
quality_attribute_3
and
manage
component_1
be
very
important
all
of
medium’s
pattern_4
run
in
container
currently
our
pattern_9
component_2
be
a
mix
of
technology_8
ec
and
technology_16
but
move
towards
technology_16
only
we
build
our
own
component_2
to
build
test
package
and
quality_attribute_3
component_4
connector_19
bbfd
it
strike
a
balance
between
work
consistently
across
component_1
and
give
individual
component_4
the
quality_attribute_5
of
adopt
different
technology_4
technology_1
the
way
it
work
be
it
each
component_4
provide
the
basic
connector_data_8
e
g
the
port
to
listen
to
the
command
to
build
test
start
the
component_4
etc
and
bbfd
will
take
care
of
the
rest
thorough
and
consistent
observabilityobservability
include
the
component_7
convention
and
technology_6
that
u
understand
how
the
component_2
be
work
and
triage
issue
when
it
isn’t
work
observability
include
requirement_6
requirement_1
track
metric
requirement_7
alerting
and
be
super
critical
for
the
pattern_1
architecture
to
succeed
when
we
move
from
one
single
component_4
to
a
quality_attribute_2
component_2
with
many
component_4
two
thing
can
happen
we
lose
observability
because
it
become
hard
to
do
or
easy
to
be
overlook
different
team
reinvent
the
wheel
and
we
end
up
with
fragment
observability
which
be
essentially
low
observability
because
it
be
hard
to
use
fragment
connector_data_1
to
connector_20
the
dot
or
triage
any
issue
it
be
very
important
to
have
quality_attribute_4
and
consistent
observability
from
the
begin
so
our
devops
team
come
up
with
a
strategy
for
consistent
observability
and
build
technology_6
in
support
of
achieve
that
every
component_4
connector_21
detail
datadog
requirement_7
alert
and
requirement_6
search
automatically
which
be
also
consistent
across
all
component_4
we
also
heavily
use
lightstep
to
understand
the
requirement_1
of
the
component_2
not
every
component_4
need
to
be
build
from
scratchin
pattern_1
architecture
each
component_4
do
one
thing
and
do
it
really
well
notice
that
it
have
nothing
to
do
with
how
to
build
a
component_4
if
you
migrate
from
a
monolithic
component_4
keep
in
mind
that
a
pattern_1
doesn’t
always
have
to
be
build
from
scratch
if
you
can
peel
it
off
from
the
monolithic
component_3
here
we
take
a
pragmatic
approach
whether
we
should
build
a
component_4
from
scratch
quality_attribute_10
on
two
factor
how
well
technology_3
be
suit
for
the
connector_data_2
and
how
much
it
cost
to
reimplement
in
a
different
tech
technology_1
if
technology_3
be
a
quality_attribute_4
technical
option
and
the
exist
implementation
be
in
a
quality_attribute_4
shape
we
peel
the
off
from
the
monolithic
component_3
and
create
a
pattern_1
with
it
even
with
the
same
implementation
we
will
still
connector_5
all
the
benefit
of
pattern_1
architecture
our
monolithic
technology_3
monolithic
component_3
be
architected
in
a
way
that
make
it
relatively
easy
for
u
to
build
separate
component_1
with
the
exist
implementation
we
will
discus
how
to
properly
architect
a
monolithic
late
in
this
respect
failure
because
they
will
happenin
a
quality_attribute_2
environment
more
thing
can
fail
and
they
will
failure
of
mission
critical
component_4
when
not
handle
well
could
be
catastrophic
we
should
always
think
about
how
to
test
failure
and
gracefully
handle
failure
first
and
foremost
we
should
expect
everything
will
fail
at
some
point
for
pattern_12
connector_data_7
put
extra
effort
to
handle
failure
requirement_8
make
sure
we
have
quality_attribute_4
observability
mention
above
to
failure
when
they
happen
always
test
failure
when
bring
a
component_4
online
it
should
be
part
of
the
component_4
connector_22
connector_data_9
build
auto
recovery
if
possible
avoid
pattern_1
syndrome
from
day
onemicroservice
be
not
a
panacea
—
it
solve
some
problem
but
create
some
others
which
we
connector_data_7
“microservice
syndromes”
if
we
don’t
think
about
them
from
day
one
thing
can
connector_5
messy
fast
and
it
cost
more
if
we
take
care
of
them
late
here
be
some
of
the
common
symptom
poorly
component_5
pattern_4
cause
more
harm
than
quality_attribute_4
especially
when
you
have
more
than
a
couple
of
them
allow
too
many
different
choice
of
technology_14
technology_4
which
increase
the
operational
cost
and
fragment
the
engineering
organization
couple
run
component_1
with
build
component_4
which
dramatically
increase
the
complexity
of
each
component_4
and
slow
the
team
down
overlook
connector_data_1
component_5
and
end
up
with
pattern_4
with
monolithic
connector_data_1
storage
lack
of
observability
which
make
it
difficult
to
triage
requirement_1
issue
or
failure
when
face
a
problem
team
tend
to
create
a
component_4
instead
of
fix
the
exist
one
even
though
the
latter
be
a
quality_attribute_4
option
even
though
the
component_1
be
loosely
couple
lack
of
a
holistic
picture
of
the
whole
component_2
could
be
problematic
should
we
stop
build
monolithic
component_4
with
recent
technology_4
innovation
it
be
a
lot
easy
to
adopt
the
pattern_1
architecture
do
it
mean
that
we
should
all
stop
build
monolithic
component_4
no
even
though
it
be
much
quality_attribute_4
support
by
technology_4
pattern_1
architecture
still
involve
a
high
level
of
complexity
and
complication
for
small
team
to
start
a
monolithic
component_3
be
still
often
a
quality_attribute_4
option
however
do
spend
the
time
to
architect
the
monolithic
component_3
in
a
way
that
be
easy
to
migrate
to
a
pattern_1
architecture
late
when
the
component_2
and
the
team
grow
it
be
fine
to
start
with
a
monolithic
architecture
but
make
sure
to
modularize
it
and
architect
it
with
the
above
three
pattern_1
principle
single
purpose
loose
couple
and
high
pattern_2
except
that
the
“services”
be
connector_16
in
the
same
tech
technology_1
quality_attribute_3
together
and
run
in
the
same
component_7
at
we
make
some
quality_attribute_4
architecture
decision
early
on
for
the
monolithic
component_3
our
monolithic
component_3
be
highly
modularized
by
component_18
even
though
it
have
grow
into
a
very
complex
component_3
with
the
web
component_8
backend
component_4
and
an
offline
processor
the
offline
processor
run
separately
but
with
the
exact
same
this
make
it
relatively
easy
to
peel
off
a
chunk
of
requirement_5
component_6
to
a
separate
component_4
a
long
a
the
component_4
provide
the
same
high
level
a
the
original
implementation
our
monolithic
component_3
pattern_3
connector_data_1
storage
detail
at
the
lower
level
each
connector_data_1
type
e
g
a
component_10
component_12
have
two
pattern_7
of
implementation
connector_data_1
pattern_7
and
component_4
pattern_7
the
connector_data_1
pattern_7
handle
crud
to
one
specific
type
of
connector_data_1
the
component_4
pattern_7
handle
the
high
level
component_6
of
one
specific
type
of
connector_data_1
and
provide
component_19
to
the
rest
of
the
component_2
component_1
don’t
connector_1
connector_data_1
component_13
between
them
this
help
u
adopt
pattern_1
architecture
because
implementation
detail
of
one
type
of
connector_data_1
be
completely
hide
from
the
rest
of
the
base
create
a
component_4
to
handle
certain
type
of
connector_data_1
be
relatively
easy
and
quality_attribute_1
the
monolithic
component_3
also
help
u
component_5
pattern_4
and
give
u
the
quality_attribute_5
to
focus
on
the
most
important
part
of
the
component_2
instead
of
component_5
all
the
pattern_4
for
everything
from
the
grind
up
conclusionthe
monolithic
technology_3
component_3
serve
u
well
for
several
year
but
it
start
slow
u
down
from
ship
great
project
and
iterate
quickly
we
start
to
systematically
and
strategically
adopt
the
pattern_1
architecture
we
be
still
in
the
early
stage
of
this
journey
but
we
have
already
see
it
benefit
and
potential
—
it
dramatically
increase
the
development
productivity
allow
u
to
think
big
and
make
substantial
technology_2
improvement
and
unlock
the
engineering
team
to
safely
test
technology_4
it
be
an
excite
time
to
join
medium’s
engineering
team
if
this
sound
interest
to
you
please
take
a
look
at
our
component_20
—
work
at
if
you’re
particularly
passionate
about
pattern_1
architecture
you
want
to
take
a
look
at
these
two
opening
first
senior
full
technology_1
engineer
and
senior
component_15
engineer
thanks
for
connector_12
drop
u
a
connector_data_10
if
you
have
question
or
want
to
discus
more
how
we
start
adopt
the
pattern_1
architecture
the
original
version
of
this
be
publish
on
hatch
our
internal
version
of
thanks
to
kyle
mahan
eduardo
ramirez
victor
alor
sachee
lyra
naeseth
dan
benson
bob
corsaro
julie
russell
and
alaina
kafkes
for
their
feedback
to
the
draft
¹
in
this
we
will
use
the
word
“microservice”
in
two
way
refer
to
pattern_1
architecture
and
refer
to
one
component_4
in
pattern_1
architecture
²
connector_23
production
connector_data_1
in
development
be
a
double
edge
sword
it
be
definitely
quality_attribute_14
but
it
be
very
powerful
if
we
can
do
it
safely
to
be
clear
we
don’t
test
with
other
users’
connector_data_1
engineer
only
use
their
own
account
we
take
user’s
privacy
very
seriously
at
thanks
toalaina
kafkes
julie
russell
kyle
mahan
and
dan
benson
53more
from
engineeringfollowstories
from
the
team
build
connector_12
more
from
engineeringrecommended
from
mediumshishir
khandelwalfault
tolerance
concept
&
analysismatthew
harperintrimble
connector_data_11
engineering
bloghow
to
build
an
alexa
skill
with
technology_17
core
and
technology_8
lambdadaniel
okwufuluezeinthe
andela
waywhat
technical
debt
be
and
how
it’s
measuredanca
trifif
nothing
else
work
let’s
be
agile
david
morainbetter
programmingthe
superpower
and
struggle
of
great
startup
engineerskamalov
otashnode
j
frameworksnadav
goldenberginthe
startupci
cd
it’s
a
culture
not
a
featureandrew
scottinthe
startupblack
be
the
wayabouthelptermsprivacyget
the
appget
startedxiao
ma4
1k
followerschief
architect
@medium
serve
engineer
teaching
component_21
the
ultimate
goal
of
tech
be
to
help
u
live
quality_attribute_4
build
@patterninsight
phd
@illinoiscs
ucsdfollowmore
from
mediumaditya
ranawhy
be
connector_data_10
component_22
so
important
in
engineering
and
pizza
shop
tzafrir
ben
amiinwix
engineeringredis
a
a
databaseweverson
nascimentostarting
the
journey
with
quality_attribute_15
horizontally
quality_attribute_16
with
load
balancingshenbagarest
vs
graphql
vs
grpchelpstatuswritersblogcareersprivacytermsaboutknowable
