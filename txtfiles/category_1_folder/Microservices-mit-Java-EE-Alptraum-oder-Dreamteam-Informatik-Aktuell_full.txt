pattern_1
mit
technology_1
ee
alptraum
oder
dreamteam
|
informatik
aktuell
über
un
|
|
kontakt
|
impressum
entwicklungmethodenprogrammiersprachenbetriebdatenbankenserversicherheitspeichernetzwerkevirtualisierungverfügbarkeitkünstliche
intelligenzmanagement
und
rechtprojektmanagementdigitalisierungit
rechtit
selbständigenewstermineit
jobsit
bücher
künstliche
intelligenzdigitalisierungagilenachhaltigkeitdevopsmicroservicescloudiotit
securitydatenbankenjava
☰entwicklungbetriebmanagement
und
rechtnewsit
jobsit
büchernewsletter
autorlars
röwekamplars
röwekamp
gründer
de
it
beratungs
und
entwicklungsunternehmens
open
knowledge
gmbh
beschäftigt
sich
im
rahmen
seiner
tätigkeit
als…
weiterlesen
publikationenjava
ee
ein
ausblickvon
monolithen
und
pattern_1
newsletterunser
newsletter
informiert
sie
regelmäßig
und
kostenlos
über
neuigkeiten
artikel
und
veranstaltungen
zu
aktuellen
it
themen
nachrichten28
2022osad
–
connector_data_1
for
paper
der
hybrid
veranstaltung
ist
eröffnetopen
component_1
automation
day
die
herstellerunabhängige
open_source
konferenz
findet
vom
pattern_2
vor
ort
und
virtuell
statt
weiterlesen21
2022it
tage
–
konferenz
connector_data_1
for
paper
cfp
jetzt
vortragsvorschläge
für
die
jahres
konferenz
de
fachmagazins
informatik
aktuell
einreichen
sub
konferenzen
entwicklung
…
weiterlesen09
2022von
technology_1
nach
technology_2
migrieren
einführung
mit
praxis
beispielenkotlin
hat
sich
al
moderne
technology_1
alternative
mit
vielen
vorzügen
etabliert
und
deshalb
überlegen
viele
entwickler
zu
technology_2
zu
wechseln
ist…
weiterlesen
»
entwicklung
»
programmiersprachen
lars
röwekamp
februar
pattern_1
mit
technology_1
ee
alptraum
oder
dreamteam
©
deagreez
fotolia
technology_3
auf
den
ersten
blick
scheinen
technology_1
ee
und
pattern_1
nicht
wirklich
gut
zueinander
zu
passen
auf
der
einen
seite
ein
technologisches
urgestein
welch
seit
mehr
al
jahren
dafür
berühmt
berüchtigt
ist
einer
trägen
evolution
zu
unterliegen
auf
der
anderen
seite
eine
von
modernen
firmen
wie
netflix
twitter
und
co
in
schnellen
schritten
getriebene
revolution
dabei
würden
doch
auch
die
technology_1
ee
entwickler
so
gerne
in
der
neuen
wunderwelt
der
pattern_1
mitspielen
auch
wenn
der
technology_1
requirement_1
technology_4
technology_1
ee
eigentlich
alles
mitbringt
be
e
braucht
um
eine
pattern_3
basierte
anwendung
zu
implementieren
hält
sich
in
der
requirement_1
hartnäckig
da
gerücht
da
die
nur
mit
dem
proprietären
technology_5
technology_6
boot
und
requirement_2
sinnvoll
möglich
ist
dabei
spricht
in
der
praxis
eigentlich
nichts
gegen
die
verwendung
von
technology_1
ee
ganz
im
gegenteil
gerade
für
team
die
bereits
erfahrungen
mit
technology_1
ee
gesammelt
haben
bietet
sich
dessen
verwendung
an
die
möglichkeit
etablierte
und
bekannte
component_2
anwenden
zu
können
ist
ein
nicht
zu
unterschätzender
vorteil
die
migration
hin
zu
pattern_1
bringt
schon
mehr
al
genug
technische
und
organisatorische
herausforderungen
mit
sich
da
freut
man
sich
über
alte
bekannte
warum
aber
besitzt
dann
technology_1
ee
bei
vielen
requirement_1
entwicklern
und
architekten
nach
wie
vor
einen
eher
schlechten
ruf
wenn
e
um
da
thema
pattern_1
geht
machen
wir
un
auf
die
suche
pattern_1
in
a
nutshellmicroservices
sind
fachlich
in
sich
geschlossene
einheiten
–
im
ddd
jargon
auch
bind
component_3
genannt
–
die
von
entsprechend
fachlich
orientierten
team
separat
entwickelt
getestet
und
quality_attribute_1
werden
können
jeder
component_4
läuft
in
einem
eigenen
prozess
die
verhindert
da
sich
im
falle
eines
laufzeitproblems
negative
effekte
für
die
anderen
component_5
ergeben
können
da
jeder
component_4
zunächst
einmal
für
sich
zu
betrachten
ist
kann
eine
skalierung
bedarfsgerecht
also
je
fachlichkeit
bzw
je
component_4
erfolgen
zum
austausch
mit
anderen
component_5
wird
eine
technologieneutrale
häufig
auf
technology_7
connector_data_2
basierende
schnittstelle
verwendet
diese
kapselt
die
implementierungsdetails
de
component_4
und
versteckt
sie
so
vor
der
außenwelt
optimierungen
oder
anpassungen
innerhalb
de
component_5
sind
solange
problemlos
möglich
solange
sie
nicht
zu
einer
inkompatibilität
der
component_4
schnittstelle
führen
die
kommunikation
der
component_5
untereinander
erfolgt
in
der
regel
über
leichtgewichtige
protokolle
wie
zum
beispiel
pattern_4
over
technology_8
synchron
oder
pattern_5
asynchron
die
entwicklung
de
component_5
selbst
kann
in
einer
beliebigen
programmiersprache
erfolgen
solange
diese
in
der
lage
ist
die
oben
beschriebene
schnittstelle
und
die
zugehörigen
protokolle
zu
bedienen
technology_1
ee
technology_9
ein
blick
auf
die
component_2
von
technology_1
ee
zeigt
da
die
eben
skizzierten
charakteristika
von
pattern_1
problemlos
mit
dem
technology_1
requirement_1
technology_4
erfüllt
werden
können
mit
hilfe
von
technology_10
lassen
sich
pattern_6
erstellen
deren
eingehende
connector_data_3
via
component_6
validation
auf
korrektheit
geprüft
werden
können
alternativ
kann
technology_11
zur
realisierung
eines
anderen
typs
verwendet
werden
die
requirement_3
und
bind
apis
technology_12
jaxp
und
technology_7
p
können
im
anschluss
zum
automatischen
marshal
bzw
unmarshalling
der
übertragenen
connector_data_2
hin
zu
technology_1
objekten
–
vice
versa
–
herangezogen
werden
für
die
realisierung
der
fachlichen
logik
innerhalb
de
component_4
inkl
potentieller
datenhaltung
kommen
technology_13
oder
technology_14
sowie
technology_15
inkl
connector_1
injection
zum
einsatz
sollen
die
component_5
nicht
synchron
via
pattern_4
sondern
asynchron
via
pattern_5
kommunizieren
steht
die
technology_16
component_7
zur
verfügung
soweit
so
gut
wenn
die
technology_1
ee
component_2
aber
alles
erfüllen
be
da
entwicklerherz
begehrt
wo
bitte
liegt
dann
da
problem
da
leid
mit
der
runtime
da
eigentliche
problem
von
technology_1
ee
im
zusammenspiel
mit
pattern_1
zeigt
sich
nicht
während
der
entwicklung
sondern
erst
im
deployment
und
zur
laufzeit
gemäß
spezifikation
wird
eine
technology_1
ee
anwendung
al
war
oder
ear
artefakt
verpackt
und
in
einem
component_8
component_9
quality_attribute_1
der
component_9
stellt
die
notwendige
infrastruktur
für
quality_attribute_2
datenbankanbindung
pattern_5
pattern_7
und
vieles
mehr
ein
erster
naive
ansatz
könnte
also
so
aussehen
da
die
verschiedenen
pattern_1
einer
anwendung
al
separate
war
gepackt
und
anschließend
in
einem
component_8
component_9
quality_attribute_1
werden
die
hätte
den
vorteil
da
sich
die
component_5
die
durch
den
component_9
zur
verfügung
gestellte
infrastruktur
problemlos
teilen
könnten
s
abb
abb
pattern_1
via
war
ein
component_9
©
lars
röwekamp
be
sich
zunächst
erst
einmal
recht
attraktiv
anhört
ist
aber
gleichzeitig
auch
der
große
nachteil
de
szenarios
zur
erinnerung
pattern_1
sind
fachlich
in
sich
geschlossene
einheiten
die
separat
entwickelt
getestet
und
quality_attribute_1
werden
können
jeder
component_4
läuft
in
einem
eigenen
prozess
ziel
ist
e
also
eine
größtmögliche
unabhängigkeit
der
component_5
untereinander
zur
entwicklungs
quality_attribute_1
und
laufzeit
herzustellen
genau
die
ist
aber
nicht
gegeben
wenn
alle
component_5
in
einem
component_9
bzw
einen
component_9
cluster
quality_attribute_1
werden
zum
einen
beeinflusst
da
deployment
oder
genauer
gesagt
der
damit
verbundene
ressourcenverbrauch
eines
component_5
da
laufzeitverhalten
all
anderen
component_4
zum
anderen
kann
der
ausfall
eines
einzelnen
component_5
dafür
sorgen
da
der
component_9
hängt
und
somit
die
anderen
component_5
ebenfalls
nicht
mehr
angesprochen
werden
können
weniger
ist
mehr
–
variante
1um
da
eben
beschriebene
problem
zu
umgehen
könnte
man
natürlich
hergehen
und
je
war
–
also
je
component_4
–
einen
eigenen
component_9
aufsetzen
so
würde
man
die
gewünschte
unabhängigkeit
der
component_5
erreichen
und
gleichzeitig
den
vorteil
der
manage
infrastruktur
durch
den
component_9
nicht
verlieren
s
abb
abb
pattern_1
via
war
mehrere
component_9
©
lars
röwekamp
in
einer
anwendung
mit
zweistelligen
oder
gar
dreistelligen
component_4
instanzen
bedingt
die
allerdings
einen
nicht
zu
unterschätzenden
operativen
aufwand
für
component_10
konfiguration
deployment
requirement_4
und
pattern_8
der
vielen
vielen
component_9
component_4
da
szenario
ist
somit
nur
dann
realistisch
umzusetzen
wenn
man
e
weitestgehend
automatisiert
indem
zum
beispiel
die
einzelnen
component_9
al
technology_17
image
vorliegen
zur
entwicklungszeit
wirkt
sich
da
beschriebene
vorgehen
extrem
positiv
au
nach
änderungen
an
einem
component_4
wird
dieser
bzw
da
zugehörige
war
zunächst
neu
gebaut
be
in
der
regel
nur
einige
wenige
sekunden
dauern
dürfte
im
anschluss
wird
da
technology_17
image
basierend
auf
einem
dedizierten
jdk
einem
technology_1
ee
component_9
basis
image
ein
wenig
health
connector_2
infrastruktur
und
dem
neuen
war
erstellt
auch
die
sollte
nicht
länger
al
einige
wenige
sekunden
dauern
da
–
mit
ausnahme
von
dem
war
–
immer
wieder
auf
bereits
bekannte
nicht
veränderte
komponenten
zurückgegriffen
werden
kann
dem
vorteil
zur
entwicklungszeit
steht
allerdings
ein
nachteil
zur
laufzeit
entgegen
die
größe
der
image
bzw
der
damit
verbundene
ressourcenverbrauch
da
wir
je
technology_17
image
einen
vollständigen
spezifikationskonformen
technology_1
ee
component_9
–
full
profile
oder
web
profile
–
gestartet
haben
ist
die
last
auf
den
servern
entsprechend
groß
die
gilt
auch
dann
wenn
wir
eigentlich
nur
einen
bruchteil
der
funktionalität
de
technology_1
ee
component_11
für
unseren
pattern_3
benötigen
weniger
ist
mehr
–
variante
2was
aber
wäre
wenn
wir
für
unseren
component_4
nur
diejenigen
bestandteile
de
component_11
nutzen
bzw
bundeln
würden
die
wir
tatsächlich
benötigen
und
somit
eine
art
flexibles
micro
technology_1
ee
nutzen
könnten
stellt
unser
component_4
zum
beispiel
eine
restful
schnittstelle
nach
außen
bereit
macht
e
sicherlich
keinen
sinn
schwergewichtige
technology_18
wie
technology_19
oder
technology_20
mit
zu
deployen
natürlich
wäre
da
in
summe
dann
nicht
mehr
spezifikationskonform
die
verwendeten
component_2
selbst
wären
e
aber
schon
genau
die
haben
auch
etliche
technology_1
ee
component_8
component_9
hersteller
erkannt
und
bieten
verschiedenste
proprietäre
lösungen
zur
umsetzung
de
eben
beschriebenen
mechanismus
an
unabhängig
vom
jeweiligen
technologischen
ansatz
ist
da
prinzip
bei
allen
herstellern
mehr
oder
minder
identisch
die
für
den
pattern_3
notwendigen
sever
komponenten
werden
mit
dem
de
component_5
und
einem
component_9
spezifischen
bootstrapping
kombiniert
und
al
jar
–
also
al
ausführbares
technology_1
programm
–
gebundelt
abb
standalone
pattern_1
via
jar
©
lars
röwekamp
der
vorteil
die
ansatzes
liegt
klar
auf
der
hand
der
resultierende
pattern_3
beinhaltet
genau
die
bestandteile
die
er
zur
laufzeit
benötigt
nicht
mehr
und
nicht
weniger
so
zumindest
die
theorie
je
nach
component_9
hersteller
können
sich
nämlich
die
granularität
der
auswählbaren
komponenten
sowie
die
möglichkeiten
zum
eingriff
in
da
bootstrapping
und
da
damit
verbundene
classloading
stark
unterscheiden
auch
scheint
bei
fast
allen
herstellern
da
abhängigkeitsmanagement
der
component_9
komponenten
untereinander
noch
nicht
zu
prozent
optimiert
zu
sein
soda
auch
bei
eigentlich
kleinen
component_5
be
ende
doch
recht
große
artefakte
entstehen
weitere
unterschiede
finden
sich
bei
den
angebotenen
zusatzfunktionalitäten
jenseits
der
technology_1
ee
spezifikation
gemeint
sind
hierbei
die
für
pattern_1
essentiellen
aspekte
wie
zum
beispiel
health
connector_2
quality_attribute_3
quality_attribute_2
component_4
registry
&
discovery
pattern_8
oder
configuration
requirement_4
zu
den
bekanntesten
vertretern
de
flexiblen
micro
technology_1
ee
zählen
derzeit
technology_21
swarm
payara
micro
kumuluzee
tomee
shade
und
technology_22
liberty
profile
e
soll
an
dieser
stelle
nicht
verschwiegen
werden
da
mit
hilfe
der
eben
beschriebenen
zweiten
variante
zwar
kleinere
laufzeitartefakte
entstehen
al
bei
der
ersten
variante
da
builden
der
jar
sowie
der
technology_17
image
allerdings
durch
da
fortwährende
einbinden
der
component_9
komponenten
in
den
build
prozess
entsprechend
länger
dauert
ein
neuer
technology_4
microprofile
io
be
haben
wir
bisher
erreicht
dank
micro
technology_1
ee
sind
wir
in
der
lage
eigenständige
pattern_1
umzusetzen
welche
die
zur
laufzeit
benötigten
component_9
komponenten
–
und
nur
genau
diese
–
in
sich
tragen
je
nach
gewähltem
hersteller
ist
dabei
die
anbindung
zusätzlich
benötigter
infrastruktur
mehr
oder
minder
trivial
da
hört
sich
doch
schon
einmal
gut
an
verloren
haben
wir
allerdings
die
bisher
an
technology_1
ee
geschätzte
herstellerunabhängigkeit
da
jeder
hersteller
sein
eigenes
bootstrap
sowie
eine
proprietäre
anbindung
an
die
infrastruktur
mitbringt
lässt
sich
ein
pattern_3
nicht
mehr
einfach
so
mit
component_9
komponenten
unterschiedlicher
technology_1
ee
hersteller
bundeln
natürlich
lassen
sich
die
entsprechenden
und
konfigurations
teile
sauber
kapseln
e
bleibt
aber
immer
ein
nicht
unerheblicher
teil
de
component_4
der
bei
einem
wechsel
auf
einen
anderen
hersteller
ausgetauscht
werden
müsste
die
dilemma
ist
natürlich
auch
den
herstellern
bewusst
und
e
liegt
daher
nahe
einen
entsprechenden
technology_4
–
a
k
a
microprofile
–
zu
entwickeln
gegen
eine
standardisierung
im
rahmen
von
technology_1
ee
mit
hilfe
eines
entsprechenden
technology_1
specification
connector_data_3
kurz
jsr
und
dem
zugehörigen
technology_1
component_12
kurz
jcp
spricht
allerdings
der
marktdruck
die
erfahrung
zeigt
da
ein
neuer
jsr
im
umfeld
von
technology_1
ee
drei
jahre
und
mehr
in
anspruch
nimmt
gehen
wir
einmal
davon
au
da
die
entscheidenden
änderungen
nicht
schon
mit
technology_1
ee
sondern
erst
mit
technology_1
ee
eintreten
würden
hieße
die
da
erst
mit
resultaten
zu
rechnen
ist
eine
derart
späte
reaktion
auf
die
aktuellen
marktbedürfnisse
wäre
gleichzusetzen
mit
dem
ende
von
technology_1
ee
im
pattern_1
umfeld
genau
au
diesem
grund
haben
sich
einige
key
player
der
szene
al
initiative
namens
microprofile
io
zusammengeschlossen
und
vereinbart
einen
de
facto
technology_4
zu
entwickeln
an
open
forum
to
optimize
requirement_1
technology_1
for
a
pattern_1
architecture
by
innovate
across
multiple
implementation
and
collaborate
on
common
area
of
interest
with
a
goal
of
standardization
mission
von
microprofile
io
der
technology_4
soll
auf
etablierten
technology_1
ee
component_2
aufsetzen
und
themen
wie
bootstrapping
oder
anbindung
von
infrastruktur
vereinheitlichen
um
da
vorhaben
von
anfang
an
in
geregelte
bahnen
zu
lenken
wurde
da
projekt
ende
in
die
eclipse
foundation
überführt
al
lizenzmodell
ist
technology_23
licence
version
geplant
ein
wesentliches
ziel
der
initiative
ist
e
in
sehr
kleinen
schnellen
schritten
agil
auf
die
wünsche
der
einzugehen
daher
besteht
die
erste
version
der
spezifikation
baseline
auch
lediglich
au
drei
apis
technology_10
technology_13
und
technology_7
p
wie
e
zukünftig
mit
der
spezifikation
weitergeht
soll
die
bestimmen
so
findet
man
auf
der
webseite
von
microprofile
io
entsprechende
umfragen
ziel
ist
e
die
vielen
vorhandenen
ideen
gemäß
den
entwicklerwünschen
zu
priorisieren
asynchronität
reactive
pattern_1
quality_attribute_2
component_4
discovery
und
die
anbindung
einiger
komponenten
au
dem
netflixoss
technology_6
stehen
derzeit
ganz
oben
auf
der
liste
wer
da
microprofile
gerne
selbst
einmal
ausprobieren
möchte
kann
die
mit
einem
der
vielen
beispielanwendungen
tun
einfach
runterladen
und
mit
einer
der
bisher
implementierungen
technology_21
swarm
liberty
profile
technology_23
tomee
payara
micro
und
hammock
laufen
lassen
fazitjava
ee
genießt
nicht
gerade
den
besten
ruf
wenn
e
um
die
realisierung
pattern_3
basierter
anwendungen
geht
dabei
bringt
der
standardisierte
technology_1
requirement_1
technology_6
alles
mit
be
e
technologisch
braucht
da
eigentliche
problem
findet
sich
weniger
in
der
entwicklung
al
zur
laufzeit
da
modell
de
schwergewichtigen
monolithisch
angehauchten
component_8
component_11
ist
in
zeiten
von
pattern_1
schlichtweg
überholt
eine
mögliche
lösung
stellt
eine
eins
zu
eins
kopplung
zwischen
component_9
und
component_4
also
de
deployment
lediglich
eines
pattern_1
je
component_8
component_9
dar
die
aber
erzeugt
einen
unnötig
hohen
ressourcenverbrauch
zur
laufzeit
eine
zweite
lösung
de
problem
ist
da
gezielte
bundeln
de
component_5
mit
lediglich
denjenigen
component_9
komponenten
die
der
component_4
zur
laufzeit
tatsächlich
benötigt
auf
diesem
weg
entsteht
ein
schlanker
lauffähiger
component_4
mit
entsprechend
optimiertem
ressourcenverbrauch
nahezu
alle
modernen
technology_1
ee
component_8
component_9
hersteller
bieten
entsprechende
möglichkeiten
zum
bundeln
nutzt
man
diese
verliert
man
allerdings
die
vielbeschworene
herstellerneutralität
die
technology_1
ee
normalerweise
mit
sich
bringt
möchte
man
weiterhin
auf
technology_1
ee
setzen
und
dabei
nicht
auf
die
herstellerunabhängigkeit
verzichten
lohnt
sich
ein
blick
auf
microprofile
io
aktuell
mit
lediglich
drei
component_2
noch
relativ
schlank
hat
dieser
neue
de
facto
technology_4
da
zeug
dazu
in
kürzester
zeit
eine
echte
alternative
zu
technology_5
requirement_2
und
co
zu
werden
so
können
zukünftig
auch
technology_1
ee
entwickler
in
der
wunderwelt
der
pattern_1
mitspielen
quellenjava
ee
apiswildfly
swarmpayara
microkumuluzeetomee
shadeswebsphere
liberty
profile
microprofile
iomicroprofile
eclipsefoundationmicroprofile
sample
autorlars
röwekamplars
röwekamp
gründer
de
it
beratungs
und
entwicklungsunternehmens
open
knowledge
gmbh
beschäftigt
sich
im
rahmen
seiner
tätigkeit
al
cio
technology_24
mit
der
eingehenden
analyse
und
bewertung
neuer
und…
weiterlesen
publikationenjava
ee
ein
ausblickvon
monolithen
und
pattern_1
da
könnte
sie
auch
interessieren
ist
technology_2
da
erfolgreichere
technology_25
der
raspberry
pi
pico
technology_26
eine
schicke
oberfläche
für
intelligente
skripte
weshalb
infrastruktur
nicht
nur
konfiguration
ist
technology_23
cxfs
unterschätzte
stärke
rad
für
webbasierte
requirement_5
anwendungen
mit
technology_1
kommentare
andreas
be
antworten
danke
war
auch
jahre
später
sehr
hilfreich
mu
noch
herausfinden
wie
der
stand
heute
ist
und
wie
da
z
b
mit
micronaut
io
zusammenspielt
neuen
kommentar
schreiben
name
e
mail
adresse
nicht
ausfüllen
kommentar
ich
verstehe
und
akzeptiere
die
datenschutzbestimmungen
newsletter►
aktuelle
artikel
►
aktuelle
nachrichten
►
aktuelle
konferenztermine
kategorienstartseitemanagemententwicklungbetrieb
serviceaktuelle
meldungenkonferenzkalenderit
jobssitemap
informationimpressumüber
unsmediadatenschutznutzungsbedingungenkontakt
folgen
sie
un
partner
©
alkmene
verlag
gmbh
