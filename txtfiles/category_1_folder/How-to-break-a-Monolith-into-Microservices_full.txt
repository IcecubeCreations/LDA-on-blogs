how
to
break
a
monolith
into
pattern_1
refactoring
agile
architecture
about
thoughtworks
topic
architecture
refactoring
agile
delivery
pattern_1
connector_data_1
test
dsl
about
me
about
book
faq
content
video
content
index
board
game
photography
thoughtworks
insight
career
technology_1
follow
twitter
technology_2
component_1
of
content
top
the
pattern_2
ecosystem
destination
the
journey
guide
pattern_3
up
with
a
quality_attribute_1
and
fairly
decouple
capability
minimize
connector_1
back
to
the
monolith
split
sticky
capability
early
decouple
vertically
and
release
the
connector_data_1
early
decouple
what
be
important
to
the
requirement_1
and
connector_2
frequently
decouple
capability
and
not
go
macro
first
then
micro
migrate
in
atomic
evolutionary
step
how
to
break
a
monolith
into
pattern_1
what
to
decouple
and
when
a
monolithic
component_2
become
too
large
to
deal
with
many
requirement_2
be
draw
to
break
them
down
into
the
pattern_1
architectural
style
it
be
a
worthwhile
journey
but
not
an
easy
one
we
ve

that
to
do
this
well
we
need
to
start
with
a
quality_attribute_1
component_3
but
then
draw
out
component_4
that
be
base
on
vertical
capability
that
be
important
to
the
requirement_1
and
subject
to
frequent
connector_3
these
component_4
should
be
large
at
first
and
preferably
not
dependent
upon
the
remain
monolith
we
should
ensure
that
each
step
of
migration
represent
an
atomic
improvement
to
the
overall
architecture


zhamak
dehghani
zhamak
be
a
principal
technology_3
consultant
at
thoughtworks
with
a
focus
on
quality_attribute_2
component_2
architecture
and
digital
component_5
strategy
at
requirement_2
she
be
a
member
of
thoughtworks
technology_3
advisory
board
and
contribute
to
the
creation
of
thoughtworks
technology_3
radar
pattern_1
component_6
rehab
content
the
pattern_2
ecosystem
destination
the
journey
guide
pattern_3
up
with
a
quality_attribute_1
and
fairly
decouple
capability
minimize
connector_1
back
to
the
monolith
split
sticky
capability
early
decouple
vertically
and
release
the
connector_data_1
early
decouple
what
be
important
to
the
requirement_1
and
connector_2
frequently
decouple
capability
and
not
go
macro
first
then
micro
migrate
in
atomic
evolutionary
step
migrate
a
monolithic
component_7
to
an
ecosystem
of
pattern_1
be
an
epic
journey
the
one
who
embark
on
this
journey
have
aspiration
such
a
increasing
the
quality_attribute_3
of

accelerate
the
pace
of
connector_3
and
escape
the
high
cost
of
connector_3
they
want
to
grow
their
number
of
team
while
enabling
them
to
connector_4
requirement_3
in
parallel
and
independently
of
each
other
they
want
to
rapidly
experiment
with
their
requirement_1
s
core
capability
and
connector_4
requirement_3
fast
they
also
want
to
escape
the
high
cost
associate
with
make
connector_2
to
their
exist
monolithic
component_7
decide
what
capability
to
decouple
when
and
how
to
migrate
incrementally
be
some
of
the
architectural
challenge
of
decompose
a
monolith
to
an
ecosystem
of
pattern_1
in
this
connector_5
up
i
connector_6
a
few
technique
that
can
guide
the
delivery
team
developer
architect
technical
manager
to
make
these
decomposition
decision
along
the
journey
to
clarify
the
technique
i
use
a
multitier
online
retail
component_8
this
component_8
tightly
couple
component_9
face
requirement_1
component_10
and
connector_data_1
pattern_4
the
reason
i
have
chosen
this
example
be
that
it
architecture
have
the
characteristic
of
monolithic
component_11
that
many
requirement_1
run
and
it
technology_3
technology_4
be
modern
enough
to
justify
decomposition
instead
of
a
complete
rewrite
and
replacement
the
pattern_2
ecosystem
destination
before
embark
it
be
critical
that
everyone
have
a
common
understand
of
a
pattern_1
ecosystem
pattern_1
ecosystem
be
a
component_5
of
component_4
each
pattern_5
a
requirement_1
capability
a
requirement_1
capability
represent
what
a
requirement_1
do
in
a
particular
domain
to
fulfill
it
objective
and
responsibility
each
pattern_2
connector_7
an
component_12
that
developer
can
discover
and
use
in
a
self
serve
manner
pattern_1
have
independent
lifecycle
developer
can
build
test
and
release
each
pattern_2
independently
the
pattern_1
ecosystem
enforce
an
organizational
connector_data_2
of
autonomous
long
stand
team
each
responsible
for
one
or
multiple
component_3
contrary
to
general
perception
and
‘micro’
in
pattern_1
the
size
of
each
component_3
matter
least
and
vary
quality_attribute_4
on
the
operational
maturity
of
the
organization
a
martin
fowler
put
it
pattern_1
be
a
label
and
not
the
description
figure

component_4
pattern_5
requirement_1
capability
connector_7
connector_data_1
and
requirement_4
through
self
serve
component_13
the
journey
guide
before
dive
into
the
guide
it
be
important
to
that
there
be
a
high
overall
cost
associate
with
decompose
an
exist
component_7
to
pattern_1
and
it
take
many
iteration
it
be
necessary
for
developer
and
architect
to
closely
evaluate
whether
the
decomposition
of
an
exist
monolith
be
the
right
path
and
whether
the
pattern_1
itself
be
the
right
destination
have
clear
that
out
let’s
go
through
the
guide
pattern_3
up
with
a
quality_attribute_1
and
fairly
decouple
capability
start
down
a
pattern_1
path
require
a
minimum
level
of
operational
readiness
it
require
on
demand
connector_8
to
deployment
environment
build
kind
of
continuous
delivery
pipeline
to
independently
build
test
and
quality_attribute_5
executable
component_3
and
the
ability
to
quality_attribute_6
debug
and
pattern_6
a
quality_attribute_2
architecture
operational
readiness
maturity
be
require
whether
we
be
build
greenfield
component_4
or
decompose
an
exist
component_7
for
more
on
this
operational
readiness
see
martin
fowler’s
on
pattern_1
prerequisite
the
quality_attribute_7
news
be
that
since
martin’s

the
technology_3
to
operate
a
pattern_1
architecture
have
quality_attribute_8
rapidly
this
include
creation
of
component_3
mesh
a
dedicate
infrastructure
pattern_4
to
run
fast
quality_attribute_9
and
quality_attribute_6
requirement_5
of
pattern_1
container
pattern_7
component_2
to
provide
a
high
level
of
deployment
infrastructure
abstraction
and
evolution
of
continuous
delivery
component_2
such
a
gocd
to
build
test
and
quality_attribute_5
pattern_1
a
container
my
suggestion
be
for
developer
and
team
to
build
out
the
underlie
infrastructure
continuous
delivery
pipeline
and
the
component_12
requirement_6
component_7
with
the
first
and
second
component_3
that
they
decompose
or
build

start
with
capability
that
be
fairly
decouple
from
the
monolith
they
don’t
require
connector_2
to
many
component_14
face
component_11
that
be
currently
use
the
monolith
and
possibly
don’t
need
a
connector_data_1
component_15
what
the
delivery
team
be
optimize
for
at
the
point
be
validate
their
delivery
approach
upskilling
the
team
member
and
build
out
minimum
infrastructure
need
to
connector_4
independently
quality_attribute_10
quality_attribute_6
component_4
that
connector_7
self
serve
apis
a
an
example
for
an
online
retail
component_8
the
first
component_3
can
be
the
‘end
component_9
authentication’
component_3
that
the
monolith
could
connector_data_3
to
pattern_8
the
end
component_9
and
the
second
component_3
could
be
the
‘customer
profile’
component_3
a
pattern_9
component_3
provide
a
quality_attribute_7
pattern_10
of
the
requirement_7
for
component_14
component_8
first
i
recommend
decouple
quality_attribute_1
edge
component_3
next
we
take
a
different
approach
decouple
capability
deeply
embed
in
the
monolithic
component_7
i
advise
do
edge
component_4
first
because
at
the
begin
of
the
journey
the
delivery
team
big
risk
be
fail
to
operate
the
pattern_1
properly
so
it’s
quality_attribute_7
to
use
the
edge
component_4
to
practice
the
operational
prerequisite
they
need
once
they
have
connector_9
that
they
can
then
connector_9
the
key
problem
of
split
the
monolith
figure

warming
up
with
a
quality_attribute_1
capability
that
have
a
small
radius
of
connector_3
to
build
our
operational
readiness
minimize
connector_1
back
to
the
monolith
a
a
found
principle
the
delivery
team
need
to
minimize
the
connector_1
of
newly
form
pattern_1
to
the
monolith
a
major
benefit
of
pattern_1
be
to
have
a
fast
and
independent
release
cycle
have
connector_1
to
the
monolith
connector_data_1
component_10
component_13
couple
the
component_3
to
the
monolith
s
release
cycle
prohibit
this
benefit
often
the
motivation
for
move
away
from
the
monolith
be
the
high
cost
and
slow
pace
of
connector_3
of
the
capability
lock
in
it
so
we
want
to
progressively
move
in
a
direction
that
decouple
these
core
capability
by
remove
connector_1
to
the
monolith
if
the
team
follow
this
guideline
a
they
build
out
capability
into
their
own
component_3
what
they
find
be
instead
connector_1
in
the
reverse
direction
from
the
monolith
to
the
component_3
this
be
a
desire
connector_1
direction
a
it
do
not
slow
down
the
pace
of
connector_3
for
component_3
consider
in
a
retail
online
component_7
where
‘buy’
and
‘promotions’
be
core
capability
‘buy’
us
‘promotions’
during
the
checkout
component_16
to
offer
the
requirement_7
the
best
promotion
that
they
qualify
for
give
the
connector_data_4
they
be
buy
if
we
need
to
decide
which
of
these
two
capability
to
decouple
next
i
suggest
to
start
with
decouple
‘promotions’
first
and
then
buy
because
in
this
order
we
reduce
the
connector_1
back
to
the
monolith
in
this
order
‘buy’
first
remain
lock
in
the
monolith
with
a
connector_1
out
to
the
‘promotions’
pattern_2
next
guideline
offer
other
way
for
decide
the
order
in
which
developer
decouple
component_3
this
mean
that
they
not
be
always
able
to
avoid
connector_1
back
to
the
monolith
in
requirement_8
where
a
component_3
end
up
with
a
connector_data_3
back
to
the
monolith
i
suggest
to
connector_7
a
component_12
from
the
monolith
and
connector_8
the
component_12
through
an
anti
corruption
pattern_4
in
the
component_3
to
make
sure
that
the
monolith
concept
do
not
leak
out
strive
to
define
the
component_12
reflect
the
well
define
domain
concept
and
connector_data_2
even
though
the
monolith’s
internal
implementation
might
be
otherwise
in
this
unfortunate
requirement_8
the
delivery
team
will
be
bear
the
cost
and
difficulty
of
connector_3
the
monolith
test
and
release
the
component_4
couple
with
the
monolith
release
figure

decouple
the
component_3
that
doesn’t
require
a
connector_1
back
to
the
monolith
first
and
minimize
connector_2
to
the
monolith
split
sticky
capability
early
i
be
assume
that
at
this
point
the
delivery
team
be
comfortable
with
build
pattern_1
and
ready
to
attack
the
sticky
problem
however
they
find
themselves
limit
with
the
capability
that
they
can
decouple
next
without
a
connector_1
back
to
the
monolith
the
root
cause
of
this
be
often
a
capability
within
the
monolith
that
be
leaky
not
well
define
a
a
domain
concept
with
many
of
the
monolith
capability
quality_attribute_4
on
it
in
order
to
be
able
to
progress
the
developer
need
to
identify
the
sticky
capability
deconstruct
it
into
well
define
domain
concept
and
then
reify
those
domain
concept
into
separate
component_3
for
example
in
a
web
base
monolith
the
notion
of
‘
web
session’
be
one
of
those
most
common
couple
factor
in
the
online
retail
example
the
component_17
be
often
a
bucket
for
many
attribute
range
from
component_9
preference
across
different
domain
boundary
such
a
ship
and
payment
preference
to
component_9
intention
and
connector_10
such
a
recently
visit
component_18
click
technology_1
and
wish
connector_data_5
unless
we
tackle
decouple
deconstruct
and
reify
the
current
notion
of
‘session’
we
will
struggle
to
decouple
many
of
the
future
capability
a
they
will
be
entangle
with
the
monolith
through
the
leaky
component_17
concept
i
also
discourage
create
a
‘session’
component_3
outside
of
the
monolith
a
it
will
connector_data_6
in
a
similar
tight
couple
that
currently
exist
within
the
monolith
component_16
only
bad
out
of
component_16
and
across
the
requirement_5
developer
can
incrementally
extract
pattern_1
from
the
sticky
capability
one
component_3
at
time
a
an
example
refactor
requirement_7
wish
connector_data_5
first
and
extract
that
into
a
component_3
then
refactor
requirement_7
payment
preference
into
another
pattern_2
and
repeat
figure

identify
the
most
couple
concept
and
decouple
deconstruct
and
reify
into
concrete
domain
component_4
use
connector_1
and
structural
analysis
technology_5
such
a
structure101
to
identify
the
most
couple
and
constrain
factor
capability
in
the
monolith
decouple
vertically
and
release
the
connector_data_1
early
the
driver
for
decouple
capability
out
of
a
monolith
be
to
be
able
to
release
them
independently
this
first
principle
should
guide
every
decision
that
developer
make
around
how
to
perform
the
decouple
a
monolithic
component_7
often
be
compose
of
tightly
quality_attribute_11
pattern_4
or
even
multiple
component_2
that
need
to
be
release
together
and
have
brittle
interdependency
for
example
in
an
online
retail
component_7
the
monolith
compose
of
one
or
multiple
requirement_7
face
online
shop
component_8
a
back
end
component_7
connector_11
many
of
the
requirement_1
capability
with
a
centrally
quality_attribute_11
connector_data_1
component_15
to
hold
state
most
decouple
attempt
start
with
extract
the
component_9
face
component_19
and
a
few
pattern_9
component_4
to
provide
developer
friendly
component_13
for
the
modern
uis
while
the
connector_data_1
remain
lock
in
one
schema
and
storage
component_7
though
this
approach
give
some
quick
win
such
a
connector_3
the
ui
more
frequently
when
it
come
to
core
capability
the
delivery
team
can
only
move
a
fast
a
the
slow
part
the
monolith
and
it
monolithic
connector_data_1
component_15
simply
put
without
decouple
the
connector_data_1
the
architecture
be
not
pattern_1
keep
all
the
connector_data_1
in
the
same
connector_data_1
component_15
be
counter
to
the
decentralized
connector_data_1
requirement_6
characteristic
of
pattern_1
the
strategy
be
to
move
out
capability
vertically
decouple
the
core
capability
with
it
connector_data_1
and
redirect
all
front
end
component_11
to
the
apis
have
multiple
component_11
connector_12
and
connector_13
to
and
from
the
centrally
connector_14
connector_data_1
be
the
blocker
to
decouple
the
connector_data_1
along
with
the
component_3
the
delivery
team
need
to
incorporate
a
connector_data_1
migration
strategy
that
suit
their
environment
quality_attribute_4
on
whether
they
be
able
to
redirect
and
migrate
all
the
connector_data_1
reader
writer
at
the
same
time
or
not
stripe’s
four
phase
connector_data_1
migration
strategy
be
one
that
apply
to
many
environment
that
require
to
incrementally
migrate
the
component_11
that
quality_attribute_11
through
the
component_20
while
all
the
component_2
under
connector_3
need
to
run
continuously
figure

decouple
capability
with
it
connector_data_1
to
a
pattern_2
connector_15
a

modify
and
redirect
component_21
to
the
component_12
avoid
the
anti
pattern_11
of
only
decouple
pattern_9
only
decouple
the
backend
component_3
and
never
decouple
connector_data_1
decouple
what
be
important
to
the
requirement_1
and
connector_2
frequently
decouple
capability
from
the
monolith
be
hard
i’ve
hear
neal
ford
use
the
analogy
of
a
careful
organ
surgery
in
the
online
retail
component_8
extract
a
capability
involve
carefully
extract
the
capability’s
connector_data_1
component_10
component_9
face
component_19
and
redirect
them
to
the
component_3
because
this
be
a
non
trivial
amount
of
work
the
developer
need
to
continuously
evaluate
the
cost
of
decouple
against
the
benefit
that
they
connector_16
e
g
go
fast
or
grow
in
quality_attribute_3
for
example
if
the
delivery
team
objective
be
to
accelerate
the
modification
to
exist
capability
lock
in
a
monolith
then
they
must
identify
the
capability
that
be
be
modify
the
most
to
take
out
decouple
part
of
the
that
be
continuously
undergo
connector_3
and
connector_17
a
lot
of
love
from
the
developer
and
be
constrain
them
most
to
connector_4
requirement_3
fast
the
delivery
team
can
analyse
the
connector_18
pattern_11
to
find
out
what
have
historically
connector_3
most
and
overlay
that
with
the
technology_1
roadmap
and
portfolio
to
understand
the
most
desire
capability
that
will
be
connector_17
attention
in
near
future
they
need
to
talk
to
the
requirement_1
and
technology_1
manager
to
understand
the
differentiate
capability
that
really
matter
to
them
for
example
in
an
online
retail
component_7
‘customer
personalization’
be
a
capability
that
go
under
a
lot
of
experimentation
to
provide
the
best
experience
to
the
requirement_7
and
be
a
quality_attribute_7
candidate
for
decouple
it
be
a
capability
that
matter
to
requirement_1
a
lot
requirement_9
and
connector_19
modify
frequently
figure

identify
and
decouple
the
capability
that
matter
most
create
most
requirement_3
for
requirement_1
and
requirement_7
while
connector_3
regularly
use
social
analysis
technology_5
such
a
codescene
to
find
the
most
lively
component_22
make
sure
to
pattern_12
signal
from
the
noise
if
the
build
component_7
happen
to
touch
or
auto
generate
on
every
connector_18
overlay
the
frequently
connector_3
with
the
technology_1
roadmap
upcoming
connector_2
and
find
the
intersection
to
decouple
decouple
capability
and
not
whenever
developer
want
to
extract
a
component_3
out
of
an
exist
component_7
they
have
two
way
to
go
about
it
extract
or
rewrite
capability
often
by
default
the
component_3
extraction
or
monolith
decomposition
be
imagine
a
a
requirement_8
of
quality_attribute_12
the
exist
implementation
a
be
and
extract
it
into
a
separate
component_3
partly
because
we
have
a
cognitive
bias
towards
the
we
design
and
connector_5
the
labor
of
build
no
matter
how
painful
the
component_16
or
imperfect
the
connector_data_6
make
u
grow
love
for
it
this
be
in
fact

a
the
ikea
effect
unfortunately
this
bias
be
go
to
hold
the
monolith
decomposition
effort
back
it
cause
the
developer
and
more
importantly
technical
manager
to
disregard
the
high
cost
and
low
requirement_3
of
extract
and
quality_attribute_12
the

alternatively
the
delivery
team
have
the
option
of
rewrite
the
capability
and
retire
the
old

the
rewrite
give
them
an
opportunity
to
revisit
the
requirement_1
capability
initiate
a
conversation
with
the
requirement_1
to
simplify
the
component_6
component_16
and
challenge
the
old
assumption
and
constraint
build
over
time
into
the
component_7
it
also
provide
an
opportunity
for
a
technology_3
refresh
connector_11
the
component_3
with
a
programming
technology_6
and
technology_3
technology_4
that
be
most
suitable
for
that
particular
component_3
for
example
in
the
retail
component_7
the
‘pricing
and
promotion’
capability
be
an
intellectually
complex
piece
of

it
enable
dynamic
configuration
and
component_8
of
requirement_10
and
promotion
rule
provide
discount
and
offer
base
on
a
variety
of
parameter
such
a
requirement_7
behavior
loyalty
technology_1
bundle
etc
this
capability
be
arguably
a
quality_attribute_7
candidate
for
quality_attribute_12
and
extraction
in
contrast
‘customer
profile’
be
a
quality_attribute_1
crud
capability
that
be
mostly
compose
of
boilerplate
for
serialization
handle
storage
and
configuration
hence
it
be
a
quality_attribute_7
candidate
for
rewrite
and
retire
in
my
experience
in
majority
of
the
decomposition
scenario
the
team
be
quality_attribute_7
off
to
rewrite
the
capability
a
a
component_3
and
retire
the
old

this
be
consider
the
high
cost
and
low
requirement_3
of
quality_attribute_12
due
to
reason
such
a
below
there
be
a
large
amount
of
boilerplate
that
deal
with
environmental
connector_1
such
a
connector_20
component_8
configuration
at
runtime
connector_20
connector_data_1
component_15
pattern_13
and
be
build
with
old
technology_7
most
of
this
boilerplate
need
to
be
rewrite
the
infrastructure
to
component_23
a
pattern_2
be
very
different
from
the
decade
old
component_8
runtime
and
will
require
a
very
different
kind
of
boilerplate

it
be
very
likely
that
the
exist
capability
be
not
build
around
clear
domain
concept
this
connector_data_7
in
transport
or
connector_21
connector_data_1
connector_data_8
that
be
not
reflect
the
domain
component_24
and
require
undergo
a
big
restructure
a
long
live
component_6
that
have
go
through
many
iteration
of
connector_3
could
have
a
high
toxicity
level
and
low
requirement_3
for
quality_attribute_12
unless
the
capability
be
relevant
align
with
a
clear
domain
concept
and
have
high
intellectual
property
i
strongly
recommend
a
rewrite
and
retire
of
the
old

figure

quality_attribute_12
and
extract
high
requirement_3
with
low
toxicity
rewrite
and
retire
low
requirement_3
with
high
toxicity
use
toxicity
analysis
technology_5
such
a
checkstyle
to
make
decision
around
rewrite
vs
quality_attribute_12
go
macro
first
then
micro
find
the
domain
boundary
in
a
component_6
monolith
be
both
an
art
and
science
a
a
general
rule
apply
domain
drive
design
technique
to
find
the
bound
component_25
define
pattern_1
boundary
be
a
quality_attribute_7
place
to
start
i
admit
far
too
often
i
see
an
overcorrection
from
large
monolith
to
really
small
component_3
really
small
component_4
whose
design
be
inspire
and
drive
by
the
exist
normalize
pattern_10
of
the
connector_data_1
this
approach
to
identify
component_3
boundary
almost
always
lead
to
a
cambrian
explosion
of
large
number
of
anemic
component_4
for
crud
resource
for
many
to
the
pattern_1
architecture
this
create
a
high
friction
environment
that
ultimately
fail
the
test
of
independent
release
and
connector_22
of
the
component_3
it
create
a
quality_attribute_2
component_7
that
be
hard
to
debug
a
quality_attribute_2
component_7
that
be
break
across
pattern_14
boundary
and
hence
difficult
to
keep
consistent
a
component_7
that
be
too
complex
for
the
operational
maturity
of
the
organization
though
there
be
some
heuristic
on
how
‘micro’
should
be
the
pattern_2
the
size
of
the
team
the
time
to
rewrite
the
component_3
how
much
behavior
it
must
pattern_5
etc
my
advice
be
that
the
size
quality_attribute_4
on
how
many
component_4
the
delivery
and
team
can
independently
release
pattern_6
and
operate
start
with
large
component_4
around
a
logical
domain
concept
and
break
the
component_3
down
into
multiple
component_4
when
the
team
be
operationally
ready
for
example
on
the
journey
decouple
the
retail
component_7
developer
start
with
one
component_3
‘buy’
that
pattern_5
both
the
content
of
a
‘shopping
bag’
a
well
a
capability
of
buy
the
shop
bag
i
e
‘check
out’
a
their
ability
to
form
small
team
and
release
large
number
of
component_4
grow
then
they
can
decouple
‘shopping
bag’
from
‘check
out’
into
a
separate
component_3
figure

decouple
macro
component_4
around
rich
domain
concept
and
when
ready
breakdown
component_4
to
small
domain
concept
use
richardson
maturity
component_26
l3
and
hyperlink
to
enable
future
decouple
of
component_4
without
impact
caller
i
e
caller
discover
how
to
checkout
and
do
not
in
advance
migrate
in
atomic
evolutionary
step
the
idea
of
vanish
a
component_6
monolith
into
thin
technology_8
by
decouple
it
into
beautifully
design
pattern_1
be
somewhat
of
a
myth
and
arguably
undesirable
any
season
engineer
can
connector_6
story
of
component_6
migration
and
modernization
attempt
that
connector_16
plan
and
initiate
with
over
optimism
of
total
completion
and
at
best
connector_16
abandon
at
a
quality_attribute_7
enough
point
in
time
long
term
plan
of
such
endeavor
connector_16
abandon
because
the
macro
condition
connector_3
the
component_27
run
out
of
money
the
organization
pivot
it
focus
to
something
else
or
leadership
in
support
of
it
leave
so
this
reality
should
be
design
in
how
the
team
approach
the
monolith
to
pattern_1
journey
i
connector_data_3
this
approach
migration
in
atomic
step
of
architecture
evolution
where
every
step
of
the
migration
should
take
the
architecture
close
to
it
target
state
each
unit
of
evolution
might
be
a
small
step
or
a
large
leap
but
be
atomic
either
complete
or
revert
this
be
specially
important
a
we
be
take
an
iterative
and
incremental
approach
to
improve
the
overall
architecture
and
decouple
component_3
every
increment
must
leave
u
in
a
quality_attribute_7
place
in
term
of
the
architecture
goal
use
the
evolutionary
architecture
fitness
metaphor
the
architecture
fitness
after
every
atomic
step
of
migration
should
generate
a
close
requirement_3
to
the
architecture’s
goal
me
illustrate
this
point
with
an
example
imagine
the
pattern_2
architecture
goal
be
to
increase
the
quality_attribute_13
of
developer
modify
the
overall
component_7
to
connector_4
requirement_3
the
team
decide
to
decouple
the
end
component_9
pattern_15
into
a
separate
component_3
base
on
oauth


technology_9
this
component_3
be
intend
to
both
replace
how
the
exist
old
architecture
component_14
component_8
pattern_8
the
end
component_9
a
well
a
architecture
pattern_1
validate
the
end
component_9

s
connector_data_3
this
increment
in
the
evolution
‘auth
component_3
introduction’
one
way
to
introduce
the
component_3
be
to
go
through
these
step
first

build
the
auth
component_3
connector_11
oauth


technology_9

a
pattern_15
path
in
the
monolith
component_28
to
connector_data_3
auth
component_3
for
pattern_8
the
end
component_9
on
whose
behalf
it
be
component_16
a
connector_data_9
if
the
team
stop
here
and
pivot
into
build
some
other
component_3
or
feature
they
leave
the
overall
architecture
in
a
state
of
increase
entropy
in
this
state
there
be
two
way
of
pattern_8
the
component_9
the
oauth


base
path
and
old
client’s
password
component_17
base
path
at
this
point
the
team
be
actually
further
away
from
their
overall
goal
of
make
connector_2
fast
any
developer
to
the
monolith
need
to
deal
with
two
path
increase
cognitive
load
of
understand
the

and
slow
component_16
of
connector_3
and
test
it
instead
the
team
can
include
the
follow
step
in
our
atomic
unit
of
evolution

replace
old
client’s
password
component_17
base
pattern_15
with
oauth


path

retire
the
old
pattern_15
path
from
the
monolith
at
this
point
we
can
argue
that
the
team
have
connector_16
close
to
the
target
architecture
figure

quality_attribute_8
the
architecture
towards
pattern_1
with
atomic
step
of
architecture
evolution
where
after
each
step
the
overall
architecture
be
improve
towards
it
goal
even
though
pattern_16
connector_2
might
take
it
further
away
from
it
fitness
objective
the
atomic
unit
of
monolith
decomposition
include
decouple
the
component_3
redirect
all
component_21
to
component_3
retire
the
old
path
in
the
monolith
the
anti
pattern_11
decouple
the
component_3
use
for
component_21
and
never
retire
the
old
i
often
find
team
end
migration
of
a
capability
out
of
the
monolith
and
claim
victory
a
soon
a
the
capability
be
build
without
retire
the
old
path
the
anti
pattern_11
describe
above
the
reason
for
this
be
a
the
focus
on
short
term
benefit
of
introduce
a
capability
and
b
the
total
amount
of
effort
require
to
retire
the
old
implementation
while
face
compete
priority
for
build
feature
in
order
to
do
the
right
thing
we
need
to
strive
for
make
the
atomic
step
a
small
a
possible
migrate
with
this
approach
we
can
break
up
the
journey
to
short
trip
we
can
safely
stop
revive
and
survive
this
long
journey
slaying
the
monolith
significant
revision


first
publish
topic
architecture
refactoring
agile
delivery
pattern_1
connector_data_1
test
dsl
about
me
about
book
faq
content
video
content
index
board
game
photography
thoughtworks
insight
career
technology_1
follow
twitter
technology_2
©
martin
fowler
|
privacy
requirement_11
|
disclosure
