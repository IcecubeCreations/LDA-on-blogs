technology_1
pattern_1
architecture
mammatus
search
this
navigationaboutjava
pattern_1
architecturemicroservices
architecture
coursemicroservice
component_1
discovery
with
consulreactive
microserviceshigh
quality_attribute_1
microserviceswelcome
to
mammatus
inc
|
technology_1
pattern_1
expertsjava
reactive
pattern_2
trainingjava
pattern_2
consultingmicroservices
architecture
|
consul
component_1
discovery
and
health
for
pattern_1
architecture
tutorialmicroservices
monitoringintroduction
to
technology_2
technology_3
part
1apache
spark™
quick
start
for
real
time
analyticsapache
technology_3
introduction
part2
technology_3
sqlwhat
be
pattern_2
architecture
technology_4
versus
pattern_2
architecturemicroservices
and
dockercloud
newskafka
architecturekafka
train
technology_1
pattern_1
architecture
pattern_1
architecture|
technology_1
microservicesauthor
bio
rick
hightower
be
one
of
the
primary
developer
of
the
qbit
technology_1
pattern_1
lib
and
well
a
reakt
reactive
technology_1
lib
with
promise
pattern_3
and
connector_1
update

the
term
pattern_1
architecture
be
now
a
popular
term
unlike
many
trend
this
one
seem
to
have
some
momentum
and
be
more
about
how
people
be
actually
develop
component_2
versus
vendor
commandeer
and
needlessly
complicate
something
quality_attribute_2
pattern_4
start
off
a
a
rather
quality_attribute_2
set
of
concept
and
become
something
very
large
and
complex
component_2
be
quality_attribute_3
web
component_2
be
quality_attribute_3
pattern_4
have
bad
reputation
and
be
associate
with
be
overly
complicate
technology_5
bpel
w
*
etc
pattern_1
be
not
technology_4
in
fact
it
in
many
way
it
be
directly
the
opposite
for
example
pattern_4
often
embrace
technology_6
which
be
a
very
strongly
type
and
rigid
way
to
define
a
component_1

technology_6
and
connector_data_1
schema
take
all
of
the
x
out
of
technology_7
there
be
no
concrete
definition
of
pattern_1
architecture
but
there
be
certain
thematic
aspect
in
it
component_3
some
thing
be
hard
to
define
but
you
when
you
see
it
the
focus
on
pattern_1
be
a
focus
on
requirement_1
capability
and
a
refocus
on
connector_data_2
orient
programming
root
and
organize
around
requirement_1
domain
with
connector_data_3
and
requirement_1
rule
co
locate
in
the
same
component_4
or
set
of
component_4
pattern_1
attempt
to
quality_attribute_4
independent
component_2
with
bound
component_5
to
adopt
the
pattern_1
style
be
to
recognize
that
the
world
be
polyglot
programming
and
the
easy
requirement_2
be
around
technology_8
technology_9
and
other
web
technology_10
technology_11
pattern_1
embrace
smart
and
dumb
pip
a
pattern_1
architecture
embrace
technology_12
and
tolerant
reader
with
the
idea
that
the
connector_2
a
bit
and
it
be
nice
to
allow
some
quality_attribute_5
in
what
property

make
up
a
connector_data_4
a
smart
end
point
and
a
dumb
pattern_5
would
be
the
opposite
end
of
the
spectrum
than
something
bpel
and
esb
provide
or
other
pattern_6
mechanism
for
technology_4
while
pattern_4
embrace
component_2
be
stateless
pattern_1
embrace
the
need
for
state
and
embrace
oop
fundamental
of
keep
your
requirement_1
component_6
and
connector_data_3
together
connector_3
the
pattern_4
manifesto
and
connector_3
the
wikipedia
component_7
on
technology_4
try
to
do
the
exact
opposite
and
you
be
a
quality_attribute_3
way
down
the
road
of
adopt
a
pattern_1
architecture
shun
statelessness
and
embrace
sharding
pattern_7
eventual
consistency
and
component_1
connector_data_3
ownership
shun
technology_6
and
embrace
technology_8
pattern_8
and
technology_9
connector_data_5
rule
the
day
connector_4
connector_data_5
over
technology_11
be
do
for
quality_attribute_1
be
the
web
pattern_2
doubtersbefore
you
roll
your
eye
and
buck
against
the
goad
realize
that
word
have
power
people
be
do
technology_13
before
it
be
connector_5
technology_13
give
something
a
name
help
guide
it
evolution
and
development
people
be
do
technology_14
before
the
term
be
coin
but
the
idea
be
powerful
and
in
many
way
pattern_1
be
a
term
technology_13
and
technology_14
it
be
a
coding_keyword_1
adoption
name
for
what
people
be
mostly
already
do
to
a
certain
extent
”microservices”
be
a
powerful
term
it
be
one
you
need
to
embrace
it
be
very
pragmatic
it
be
likely
that
you
have
be
do
some
or
all
of
what
pattern_1
architecture
be
already
one
day
pattern_1
will
go
the
way
of
technology_13
it
will
be
so
common
it
will
be
a
forgo
conclusion
pattern_1
be
about
pragmatism
not
vendor
raise
barrier
to
competitor
by
create
overly
complex
specification
we
need
to
define
pattern_1
a
little
more
formerly
so
it
do
not
go
the
way
of
pattern_4
and
every
vendor
connector_6
to
form
a
committee
and
dishonor
it
intention
with
a
set
of
nifty
technology_15
bauble
pattern_4
be
a
huge
success
and
a
failure
a
failure
because
the
term
have
actually
no
mean
or
rather
so
many
mean
and
yet
and
google’s
version
of
pattern_4
be
a
huge
success
look
at
successful
thing
that
we
have
to
connector_data_6
pattern_4
and
those
be
probably
more
pattern_1
and
plain
web
component_1
from
here
on
out
when
i
refer
to
technology_4
i
be
refer
to
the
big
requirement_3
technology_5
technology_16
stateless

grain
bpel
esb
vendor
lovefest
that
be
pattern_4
not
the
useful
pattern_4
implementation
quality_attribute_3
pattern_4
be
connector_5
web
component_2
and
be
technology_9
connector_data_6
pattern_8
and
technology_11
pattern_4
be
the
aforementioned
quagmire
indeed
technology_17
show
pattern_4
on
the
decline
with
some
level
off
when
this
be
first
connector_7
there
be
no
demand
yet
for
pattern_1
but
not
the
idea
s
time
have
come
pattern_1
support
requirement_4
component_8
wellin
the
technology_1
world
pattern_1
have
a
special
mean
besides
technology_18
which
us
the
technology_19
formerly

a
technology_1


technology_1
on
the
component_9
be
dead
or
very
insignificant
one
of
java’s
many
role
be
a
component_10
for
build
component_2
for
requirement_4
component_11
and
web
component_9
this
be
another
reason
to
embrace
a
common
quality_attribute_6
technology_9
technology_10
base
connector_8
mechanism
because
one
of
the
big
component_12
of
component_2
be
requirement_4
component_13
and
web
component_13
web
component_13
be
thick
than
before
requirement_4
component_13
might
be
connector_7
a
web
component_13
and
or
have
component_14
that
run
in
both
the
requirement_4
component_10
and
a
pure
browser
play
this
be
not

this
be
an
ongoing
trend
the
idea
of
a
pure
monolithic
style
web
component_3
connector_7
in
technology_1
be
a
dinosaur
it
become
infeasible
somewhere
between

and
now
technology_1
component_2
can
be
the
mc
in
the
pattern_9
world
but
technology_20
technology_21
objectivec
technology_18
technology_1


own
the
component_9
component_8
be
connector_9
fat
which
mean
component_2
be
connector_9
thin
this
be
a
major
drive
force
in
pattern_2
proliferation
one
thing
well
principle
and
fallacy
of
the
monolithcontinuous
delivery
the
pattern_1
architectural
approach
be
to
create
small
component_2
that
be
focus
on
a
small
requirement_1
domain
or
crosscut
concern
pattern_1
adopt
the
unix
single
purpose
utility
approach
to
component_1
development
they
be
small
so
they
can
be
release
more
often
and
be
connector_7
to
be
malleable
they
be
easy
to
connector_7
they
be
easy
to
connector_2
pattern_1
go
hand
in
hand
with
continuous
requirement_2
and
continuous
delivery
the
component_2
be
independent
enough
not
to
need
a
gigantic
release
train
to
release
improvement
or
feature
in
the
technology_1
world
this
mean
you
will
be
use
other
pattern_2
technology_22
to
provide
frequent
release
do
not
try
explain
the
pattern_2
style
by
compare
it
to
the
monolithic
component_3
no
one
ever
set
out
to
purposely
build
a
huge
monolith
and
a
monolith
be
not
a
three
tiered
web
component_3
yes
monolithic
component_15
happen
but
compare
pattern_1
to
a
monolith
be
compare
agile
development
to
not
have
any
component_4
the
huge
monolith
be
not
an
architecture
style
it
be
usually
a
mistake
collection
of
technical
debt
absorb
by
a
development
team
when
the
technology_23
team
go
off
the
rail
also
even
if
someone
be
build
a
large
web
component_3
it
be
often
the
requirement_5
ok
not
that
often
that
they
break
their
up
into
and
have
internal
component_2
that
might
be
easy
to
break
off
into
component_1
and
then
one
day
pattern_1
if
their
component_3
be
a
big
ball
of
spaghetti

then
that
have
nothing
to
do
with
lack
of
pattern_1
or
them
try
to
develop
a
monolithic
their
component_4
train
and
culture
be
the
issue
and
it
probably
have
a
lot
to
do
with
technology_23
pressure
and
component_4
the
first
issue
i
have
with
connector_10
something
a
monolith
which
give
it
a
negative
connotation
be
that
what
you
be
really
describe
be
a
web
component_3
in
the
component_5
of
most
discussion
of
pattern_1
and
not
a
true
monolith
if
you
have
a
successful
web
component_3
and
it
be
connector_9
so
large
that
you
have
to
break
it
up
into
many
web
component_15
or
component_1
this
be
a
quality_attribute_3
thing
you
have
what
we
connector_data_6
a
successful
component_3
there
be
technology_24
that
simplify
connector_11
basic
web
component_15
rail
grail
technology_25
some
technology_26
technology_27
and
their
ilk
these
be
great
technology_24
quality_attribute_3
to
have
a
successful
component_3
that
be
a
monolith
than
not
connector_12
requirement_1
requirement_6
but
even
successful
component_3
reach
a
limit
in
size
where
it
become
hard
to
connector_12
feature
and
the
release
train
connector_6
large
and
large
this
be
where
break
thing
into
pattern_1
can
really
help
there
be
nothing
wrong
with
the
basic
web
component_3
if
your
component_3
be
grow
large
in
feature
and
requirement_7
than
you
expect
then
use
these
technology_24
to
create
a
basic
web
component_3
might
be
the
wrong
approach
or
you
have
to
go
off
the
technology_28
with
these
technology_24
and
start
break
feature
off
into
component_2
and
perhaps
pattern_1
if
you
that
many
of
your
component_8
be
go
to
be
requirement_4
component_8
and
you
have
potentially
hundred
thousand
or

million
component_16
then
these
technology_24
be
probably
the
wrong
approach
to
start
with
if
you
re
connector_11
a
department
level
component_3
and
these
technology_24
be
exactly
the
right
approach
and
you
not
need
to
use
pattern_1
don’t
be
dogmatic
in
the
end
the
goal
be
to
provide
requirement_1
requirement_6
and
roi
for
your
requirement_8
not
impress
your
friend
at
the
next
jug
meet
not
every
technology_24
or
architecture
fit
every
component_3
not
every
component_3
have
quality_attribute_7
concern
or
the
same
type
of
quality_attribute_7
concern
a
pattern_2
benefit
greatly
by
use
some
of
these
monolithic
technology_24
and
technology_27
to
provide
admin
visibility
and
diagnostics
into
the
pattern_2

t
throw
the
baby
out
with
the
bathwater
it
s
all
about
engineering
requirement_9
off
and

what
be
the
drive
factor
that
be
go
to
form
your
architecture
sometimes
this
be
an
easy
thing
to
do
other
time
you
have
to
connector_7
that
first
version
connector_13
it
go
and
then
come
back
and
revisit
the
architecture
pattern_1
be
a
great
approach
for
many
thing
and
increasingly
so
with
disparate
component_9
requirement_10
and
requirement_4
but
don’t
coding_keyword_2
the
tail
wag
the
dog
requirement_3
component_15
flashbackwhile
it
be
true
requirement_3
component_15
be
often
build
with
a
three
tier
architecture
backend

component_17
and
a
gui
connector_7
in
technology_29
technology_21
this
have
more
to
do
with
the
world
connector_2
than
an
active
choice
the
real
driver
for
pattern_1
architecture
be
requirement_10
virtualization
o
containerization
technology_30
proliferation
of
requirement_4
component_18
cheap
memory
more
virtualization
more
core
ssd
trend
towards
fat
component_9

gbe

gbe
etc
the
big
requirement_3
web
component_19
be
become
obsolete
to
a
certain
extent
at
least
for
large
component_3
it
be
not
we
one
day
come
up
with
a
quality_attribute_3
idea
and
then
one
day
we
be
hey
what
if
we
could
make
our
more
modular
the
grind
connector_2
under
our
collective
foot
the
way
we
build
quality_attribute_4
and
connector_14
have
connector_2
hardware
quality_attribute_8
virtualization
quality_attribute_8
containerization
happen
requirement_10
computing
become
a
real
thing
and
so
compel
that
it
be
hard
to
ignore
the
smart
phone
tablet
requirement_4
revolution
happen
pattern_2
be
the
connector_15
to
these
external

pattern_1
and
technology_14
be
two
trend
that
be
more
focus
on
how
to
connector_16
development
where
deployment
be
increasingly
requirement_11
and
component_8
be
increasingly
requirement_4
base
you
can’t
compare
component_9
component_20
development
of
the
mid
90
to
component_21
development
from
the
70
you
can’t
compare
requirement_3
component_15
from

to
pattern_2
development
target
requirement_4
and
web
component_8
and
other
pattern_1
in

the
world
connector_2
we
adjust
pattern_2
trend
be
correction
not
a
religion
history
of
requirement_3
applicationsremember
1990s
the
reason
why
requirement_3
component_15
be
connector_7
with
three
tier
be
be
to
avoid
dll
hell
and
the
monolith
we
do
it
with
the
technology_24
quality_attribute_9
at
the
time
back
in
the
day
we
use
to
build
component_13
that
be
two
tiered
you
have
to
actually
go
to
each
component_16
component_22
and
help
them
install
the
component_19
there
be
a
damn
quality_attribute_3
chance
they
download
some
shareware
that
instal
a
dll
that
screw
up
the
install
and
you
be
in
hell
it
be
not
we
be
“hey
james
”
“what
martin
”
“do
you
want
to
build
a
huge
monolith
”
“sure
martin
”
we
try
technology_31
but
technology_1
gui
development
back
then
suck

i

t
think
it
suck
so
bad
now
but
it
lose
it
window
of
opportunity
for
adoption
then
we
be
leave
with
technology_29
technology_21
component_8
and
force
everyone
to
use
the
same
browser
in
the
corporation
at
least
for
the
corporate
component_13
i
work
at
many
corporation

that
ban
technology_21
due
to
incompatibility
of
browser
you
be
leave
with
screen
painting
with
technology_29
it
be
a
a
colorful
green
screen
of
yesteryear
but
way
slow
but
pretty
there
be
many
reason
why
this
style
of
“enterprise
development”
do
not
work
in
the
requirement_10
and
for
requirement_4
component_18
the
component_20
side
component_15
no
long
need
to
handle
technology_9
connector_data_7
connector_13
connector_data_3
from
a
component_17
and
connector_17
all
domain
component_6
and
draw
pretty
picture
in
technology_29
much
pain
and
great
expense
have
be
incur
try
connector_13
this
three
tier
architecture
to
quality_attribute_10
in
the
requirement_10
for
various
component_11
connector_7
in
a
polyglot
of
technology_19
pattern_1
exist
because
requirement_4
requirement_10
cheap
ram
cheap
disk
and
improve
virtualization
it
be
really
take
the
world
where
it
be
it
be
not
revolutionary
at
all
component_20
component_23
ear
and
war

they
rest
in
peaceif
you
have
live
through
technology_17
dcom
corba
ejbs
technology_32
j2ee
technology_16
technology_4
dce
etc
then
you
the
idea
of
component_2
and
component_14
be
not
a
thing
but
they
be
a
date
expire
concept
for
the
most
part
one
issue
with
requirement_3
component_14
be
they
assume
the
use
of
hardware
component_24
which
be
large
monolith
and
you
want
to
run
a
lot
of
thing
on
the
same
component_20
that
be
why
we
have
war
and
ear

and
all
sort
of
nifty
component_14
and
archive
well
turn
out
in

that
make
no
sense
operate
component_25
and
component_24
be
ephemeral
virtualized
resource
and
can
be
ship
a
component_23
we
have
technology_33
image
amis
technology_34
vagrant
and
technology_35
the
world
connector_2
move
on
pattern_1
recognize
this
trend
so
you
be
not
develop
you
do
when
the
hardware
requirement_10
pattern_6
multi
core
and
virtualization
be
not
there
you
do
not
develop
in
the
90
with
punch
card
do
you
so
don’t
use
an
ear
or
a
war
in

now
you
can
run
a
technology_36
in
a
technology_35
image
which
be
a
component_4
pretend
to
be
an
o
run
in
an
o
that
be
run
in
the
requirement_10
which
be
run
inside
of
a
virtual
component_22
which
be
run
in
linux
component_20
that
you
don’t
own
that
you
connector_18
with
people
who
you
don’t

connector_13
a
busy
season
well
then
spin
up

more
component_20
instance
for
a
few
week
or
hour
this
be
why
you
run
technology_1
pattern_1
a
standalone
component_26
and
not
run
inside
of
a
technology_1
ee
container
the
technology_1
ee
container
be
no
long
need
because
component_24
be
not
giant
refrigerator
component_27
that
you
order
from
sun
and
wait
three
month
for
circa

don’t
fight
classpath
classloader
hell
of
technology_1
ee
hell
your
whole
damn
o
be
now
an
ephemeral
container
technology_35
connector_12
an
image
with
all
the
libs
you
need
don’t
quality_attribute_4
to
a
technology_1
ee
component_20
which
have
to
be
versioned
and
configure
you
be
only
run
one
component_1
in
it
anyway
turn
out
you
don’t
have
five
war
run
in
the
same
technology_1
ee
container
since
oh
about

coding_keyword_2
it
go
if
you
be
quality_attribute_4
a
war
to
a
technology_1
ee
container
then
you
be
probably
not
do
pattern_2
development
if
you
have
more
than
one
war
in
the
container
or
an
ear

then
you
be
definitely
not
do
pattern_2
development
if
you
be
quality_attribute_4
your
component_1
a
an
ami
or
technology_35
container
and
your
pattern_2
have
a
coding_keyword_3

then
you
might
be
connector_11
a
pattern_2
pattern_1
architecture
opt
to
break
not
into
component_14
but
into
quality_attribute_11
independently
release
able
component_2
which
run
a
one
or
more
component_4
component_3
and
other
component_2
connector_19
with
each
other
so
where
we
might
have
use
a
component_20
side
component_23
we
use
a
pattern_2
run
in
independent
component_4
where
we
might
have
have
war
or
ear
now
we
have
a
technology_35
container
or
a
ami
that
have
the
entire
component_19
preloaded
and
configure
with
exactly
the
technology_37
it
need
technology_1
and
otherwise
technology_8
technology_9
technology_11
…
no
technology_5
now
you
have
to
document
the
pattern_1
technology_9
technology_8
so
other
developer
can
connector_data_6
into
it
we
could
say
rest
and
certainly
you
can
use
concept
from
rest
but
hey
technology_9
connector_data_5
be
enough
to
be
consider
a
pattern_2
keep
this
in
mind
no
technology_7
no
technology_16
no
technology_5
no
wadl
technology_8
ok
you
can
some
meta
connector_data_3
and
document
how
to
talk
to
your
component_1
but
the
idea
be
the
doc
should
be
document
with
curl
if
you
be
only
use
technology_38
or
connector_data_1
then
you
be
not
produce
a
pattern_2
technology_12
be
a
must
document
should
sound
more

i
give
you
this
connector_data_7
with
these
coding_keyword_4
params
and
technology_12
body
and
you
respond
with
this
technology_8
keep
it
quality_attribute_2
you
can
provide
thing
in
addition
to
technology_8
but
technology_12
be
the
minimum
requirement
if
you
be
not
connector_20
up
technology_12
and
connector_21
technology_12
over
technology_9
or
technology_9
technology_11
then
what
you
connector_7
be
not
probably
not
a
pattern_2
connector_data_6
quality_attribute_1
pattern_10
callsone
of
the
issue
with
remote
connector_data_5
be
quality_attribute_1
this
be
why
you
will
want
to
organize
component_2
around
a
domain
that
will
help
keep
the
connector_data_3
for
that
component_1
with
that
component_1
and
it
will
not
need
to
connector_22
with
other
component_2
or
a
foreign
component_17
every
time
it
connector_6
a
connector_data_7
for
it
connector_data_3
while
remote
connector_data_5
be
expensive
this
can
be
accommodate
for
by
use
pattern_11
connector_data_6
pattern_12
and
technology_11
technology_8
reactive
programming
pattern_2
technology_1
lib
remember
technology_11
allow
pattern_13
directional
connector_8
for
quality_attribute_1
you
should
prefer
pattern_14
connector_data_5
that
be
pattern_10
and
can
be
connector_23
in
pattern_12
coding_keyword_1
or
technology_11
if
you
be
able
to
handle
connector_data_8
in
connector_24
in
an
pattern_11
manner
and
utilize
the
hardware
efficiently
then
you
might
be
do
pattern_1
development
another
approach
for
increasing
remote
connector_data_6
quality_attribute_1
be
to
go
all
pattern_4
on
your
component_28
and
focus
on
coarse
grain
connector_15
but
this
be
almost
always
a
mistake
you
can
connector_7
coarse
grain
technology_9
component_29
so
more
be
connector_12
with
each
connector_data_6
this
be
a
problem
because
it
be
hard
to
connector_7
and
use
coarse
grain
technology_9
component_29
a
they
often
conflate
many
subdomain
connector_data_3
in
the
same
connector_data_6
in
the
name
of
quality_attribute_1
and
aggregation
it
be
easy
to
pattern_12
many
small
connector_data_5
and
create
component_1
aggregator
you
will
need
to
do
both
pattern_12
and
aggregation
of
domain
coarse
grain
dumb
fast
pip
and
pattern_12
connector_data_5
turn
them
into
connector_1
be
a
quality_attribute_3
indication
that
what
you
connector_7
be
a
pattern_2
some
connector_data_6
this
style
reactive
programming
and
reactive
programming
go
hand
in
hand
with
pattern_1
they
be
intrinsically
relate
quality_attribute_12
on
quality_attribute_7
need
component_2
need
be
sharded
while
a
component_1
run
in
a
single
component_4
for
quality_attribute_7
that
component_1
really
be
run
in
many
component_26
on
many
virtual
component_22
pattern_1
be
not
stateless
pattern_1
should
own
their
connector_data_3
this
mean
a
private
component_17
this
mean
use
a
connector_data_3
lease
component_30
for
elasticity
or
a
private
component_17
shard
per
sharded
component_1
we
will
talk
more
about
this
late
to
more
about
how
to
quality_attribute_10
pattern_1
connector_25
out
high
quality_attribute_1
pattern_1
to
more
about
what
a
technology_1
pattern_2
look
connector_3
rise
of
the
component_22
if
your
component_1
be
connector_9
all
of
it
connector_data_3
from
a
component_17
that
be
connector_26
by
one
or
more
web
component_3
and
or
other
component_2
and
or
other
component_3
then
you
do
not
connector_7
a
pattern_2
if
your
component_1
be
100%
stateless
then
what
you
connector_7
be
not
a
pattern_2
pattern_1
do
not
negate
the
need
for
have
technology_37
if
you
be
make
many
connector_data_5
to
a
pattern_2
there
be
an
indication
that
you
maybe
need
a
technology_37
instead
of
a
pattern_2
adopt
pattern_2
architecture
do
not
make
you
a
quality_attribute_3
component_25
engineer
you
will
need
some
common
sense
component_25
knowledge
and
or
a
very
quality_attribute_3
perf
test
regiment
many
will
fail
and
go
back
to
a
traditional
three
tier
web
development
version
of
component_2
or
some
form
of
requirement_3
pattern_4
or
connector_7
a
more
traditional
stateless
web
component_1
pattern_2
component_4
devopsthis
be
a
point
in
the
discussion
where
people
conflate
a
lot
of
idea
from
other
pet
project
or
pet
component_26
and
shove
that
into
the
pattern_2
technology_39
let’s
not
something
that
have
so
many
definition
tend
to
connector_13
dilute
and
meaningless
concept
devops
continuous
delivery
continuous
requirement_2
requirement_10
computing
agile
component_26
etc
be
compel
in
their
own
right
you
don’t
need
to
have
an
agile
devops
requirement_10
setup
to
start
connector_9
benefit
from
pattern_2
development
certainly
they
complement
each
other
don’t
combine
them
a
one
concept
pattern_1
have
a
lot
more
to
do
with
requirement_10
virtualization
o
containerization
etc
then
it
do
agile
development
vs
rup
the
idea
of
the
cradle
to
grave
development
of
an
component_3
or
component_1
be
not
an
idea
that
be
invent
in
the
early
or
late
2000s
hire
developer
that
be
also
component_25
engineer
and
responsible
for
development
load
test
test
and
deployment
be
not
a
concept
to
me
at
all
this
be
a
recur
concept
that
i
have
see
in
my

year
career
over
and
over
it
be
the
more
rare
concept
and
one
that
i
find
completely
dysfunctional
where
the
developer
toss
something
over
the
wall
to
qa
and
ops
to
quality_attribute_4
i
feel
the
strong
urge
to
tell
you
a
lot
of
anecdote
for
my
career
so
i
have
pinch
myself
very
hard
snap
my
red
suspender
and
yank
the
hair
of
my
white
beard
to
resist
smart
and
dumb
pip
actor
reactive
and
active
connector_data_2
requirement_3
component_1
bus
esb
and
vendor
drive
pattern_4
be
a
bad
idea
it
be
one
you
hear
a
lot
of
talk
about
but
you
never
see
actual
successful
deployment
of
complex
connector_data_4
connector_27
choreography
transformation
and
apply
requirement_1
rule
willy
nilly
and
provide
a
graphical
representation
of
your
overly
complicate
runtime
component_4
be
a
horrible
idea
i
be
not
say
it
be
never
need
you
can
do
and
will
need
to
quality_attribute_13
with
component_31
component_15
and
technology_24
technology_40
et
al
can
help
but
you
should
not
start
design
your
component_32
from
scratch
around
esbs
and
technology_40
it
be
a
necessary
evil
at
time
but
evil
none
the
le
yes
wrap
component_31
“monolithic”
or
yesteryear
corba
dcom
tps
expensive
connector_data_4
bus
from
high
requirement_12
vendor
in
pattern_4
and
esb
or
even
quality_attribute_3
old
“rest”
be
sometimes
need
but
that
do
not
mean
that
you
connector_13
to
redefine
pattern_1
into
it
pattern_1
be
not
component_31
requirement_2
pattern_1
be
how
you
develop
greenfield
component_2
in

it
be
not
a
component_31
turd
polish
pattern_4
and
esb
even
if
sometimes
you
do
need
component_31
turd
polish
you
where
a
quality_attribute_3
place
to
component_33
your
requirement_1
component_6

requirement_1
people
almost
never
never
never
connector_2
requirement_1
rule
on
the
fly
because
if
they
do
that
would
be
edit
and
would
require
test
or
production
would
go
down
this
be
not
to
say
that
there
be
not
real
use
requirement_5
for
thing
drool
this
be
to
say
technology_41
and
activiti
be
the
exception
not
the
rule
you
who
be
quality_attribute_3
at
connector_2
requirement_1
rule
in
and
make
sure
production
do
not
go
down
your
development
team
all
developer
prefer
smart
and
dumb
pip
because
bpel
activiti
w
choreography
or
bpel
or
pattern_6
be
demoware
bullshit
if
you
have
ever
have
the
joy
of
maintain
or
try
to
grok
a
big
mass
of
spaghetti
crapfest
you
realize
that
create
cool
neat
o
technology_24
around
component_31
requirement_2
pattern_12
do
not
make
them
easy
to
comprehend
or
maintain
technology_8
technology_9
technology_11
work
everywhere
they
work
in
browser
they
work
from
technology_42
technology_43
technology_44
component_4
they
work
from
technology_1
they
work
from
technology_26
web
component_3
they
work
in
all
requirement_4
component_9
they
be
the
least
common
denominator
and
they
be
quality_attribute_2
to
connector_3
and
understand
and
document
web
component_2
be
great
vendor
drive
pattern_4
pattern_6
and
esbs
be
a
nightmare
to
debug
not
all
web
component_2
should
be
pattern_1
but
you
should
have
a
very
strong
and
powerful
reason
for
use
technology_16
technology_5
vendor
technology_4
developer
the
world
over
prefer
to
use
technology_45
that
the
world_wide_web
and
unix
be
build
on
because
it
be
quality_attribute_2
to
grok
operationally
quality_attribute_14
easy
to
pattern_15
even
with
third
party
akamai
and
technology_24
technology_46
i
prefer
unix
technology_47

web
pattern_16
requirement_10
etc
to
esb
sometimes
a
pattern_12
be
a
pattern_12

wrap
it
in
esb
or
make
a
connector_data_9
reduce
cluster
might
make
you
feel
more
important
but
be
it
provide
requirement_1
requirement_6
sometimes
it
be
more
often
than
not
it
be
misapply
tech
not
every
pattern_12
need
to
be
a
technology_48
connector_data_9
reduce
or
esb
pattern_6
sometimes
they
can
be
pattern_12
that
be
kick
off
by
technology_47
esbs
and
technology_48
be
need
i
be
not
anti
esb
or
connector_data_9
reduce
you
invoke
micro
component_2
through
technology_9
and
technology_11
or
some
form
of
connector_data_4
you
should
prefer
technology_9
and
technology_11
and
only
use
pattern_17
with
mom
if
you
want
quality_attribute_15
technology_11
be
lightweight
connector_data_4
it
be
support
by
all
programming
technology_19
requirement_4
component_34
and
the
web
and
it
exist
today
0mq
technology_49
technology_50
technology_51
be
all
great
if
you
need
some
level
of
quality_attribute_15
or
quality_attribute_1
if
you
do
not
then
technology_11
should
be
enough
for
99%
of
your
need
and
have
some

benefit
of
be
reachable
from
web
component_9
the
connector_data_4
bus
connector_28
an
opaque
connector_data_4
so
you
will
need
to
encode
the
connector_data_4
in
a
universally
understand
technology_52
which
usually
end
up
be
technology_8
there
be
time
when
you
need
something
fast
and
binary
technology_8

technology_52
abound
binary
should
be
the
exception
technology_12
be
a
fast
a
most
binary
technology_52
and
fast
than
many
if
something
be
quality_attribute_9
via
a
connector_data_4
bus
connector_data_6
then
it
should
also
be
quality_attribute_9
via
an
technology_9
technology_8
connector_data_6
rest
if
you
can’t
exercise
your
component_1
component_28
via
curl
and
have
it
coding_keyword_5
technology_8
then
you
do
not
connector_7
a
pattern_2
with
technology_24
technology_53
qbit
vertx
technology_51
etc
the
concept
of
an
bus
or
a
connector_data_4
bus
or
connector_4
connector_data_10
or
connector_4
connector_data_5
exist
a
core
concept
to
the
pattern_11
invocation
component_30
which
be
essential
for
pattern_1
connector_data_10
can
be
handle
at
first
in
component_4
by
a
component_1
a
more
quality_attribute_10
be
need
those
connector_data_10
can
be
pattern_12
connector_29
to
other
technology_54
you
can
connector_7
component_2
internal
to
your
component_3
which
be
somewhere
between
a
technology_37
and
a
pattern_2
which
can
one
day
be
more
readily
break
out
into
actual
pattern_1
reactive
actor
and
active
connector_data_11
embrace
the
concept
of
connector_1
connector_data_4
component_35
and
bus
they
be
a
natural
fit
for
a
pattern_2
architecture
pattern_12
of
connector_data_4
back
pressure
base
pattern_12
be
use
to
connector_30
courser
grain
connector_data_10
over
the
wire
which
can
minimize
the
requirement_13
loss
of
move
component_2
to
component_26
run
on
other
component_22
since
technology_53
technology_55
qbit
and
vertx
support
in
proc
component_2
and
out
of
proc
component_2
use
the
same
underlie
to
a
dumb
pattern_5
it
be
easy
to
move
component_2
in
proc
or
out
of
proc
pattern_2
a
requirement_13
need
dictate
if
you
be
make
a
lot
of
pattern_18
connector_data_6
then
what
you
connector_7
be
not
a
pattern_2
technology_24
technology_56
polyglot
programming
languagesstandards
be
great
that
be
why
there
be
so
many
of
them
attempt
to
standardize
on
technology_57
component_34
be
often
thwart
by
use
vendor
technology_23
merge
with
other
requirement_8
buy
requirement_8
adopt
requirement_4
component_10
constant
churn
of
component_9
technology_27
and
component_10
etc
pattern_1
architecture
embrace
polyglot
programming
technology_19
and
programming
technology_19
this
be
where
microserver
technology_9
technology_11
and
technology_8
tolerant
reader
come
into
play
a
it
provide
a
minimal
pattern_5
and
technology_52
to
support
connector_2
and
polyglot
of
programming
technology_19
component_1
own
their
datadatabases
be
use
for
report
and
offline
analysis
component_1
connector_31
which
could
use
a
component_17
be
for
a
component_1
or
a
component_1
shard
operational
connector_data_3
and
report
historical
backup
connector_data_3
should
be
split
up
connector_data_3
for
a
component_1
should
only
be
editable
by
that
component_1
pattern_1
architecture
be
back
to
oop
basic
connector_data_2
component_2
when
you
connector_32
them
remotely
own
their
connector_data_3
and
requirement_1
component_6
each
component_1
connector_31
connector_data_3
and
component_36
connector_data_3
in
it
pattern_19
of
the
world
connector_data_3
be
specific
for
it
component_1
this
be
not
a
concept
this
be
basic
oop
in
additional
evidence
of
go
back
to
oop
root
and
domain
drive
development
pattern_1
own
their
connector_data_3
storage
this
could
mean
a
component_17
or
key
requirement_6
component_33
on
the
same
technology_35
technology_54
a
the
technology_36
run
the
component_1
which
connector_6
replicate
and
back
up
of

pattern_1
do
not
use
a
connector_26
component_17
for
operational
connector_data_3
a
micro
component_1
might
fallback
to
a
connector_26
component_17
if
connector_data_3
be
not
in
the
component_1
but
this
would
be
the
exception
not
the
rule
if
someone
think
that
pattern_1
be
stateless
it
be
ok
to
roll
your
eye
at
them
a
pattern_1
component_1
edit
connector_data_3
and
it
replicate
it
shard
it
and
use
eventual
consistency
to
back
that
connector_data_3
up
but
it
own
the
connector_data_3
and
it
and
it
alone
can
edit
it
connector_data_3
if
that
be
not
what
you
connector_7
then
you
do
not
connector_7
a
pattern_1
in
memory
computing
eventual
consistency
pattern_7
fit
nicely
with
pattern_1
remember
ram
be
the
disk
and
the
hard
drive
or
ssd
be
the
tape
backup
true
quality_attribute_1
be
when
you
can
edit
your
connector_data_3
without
first
connector_33
to
see
if
you
have
the
late
copy
from
the
component_17
that
sit
on
another
component_20
component_1
discovery
design
for
failurein
addition
to
automate
deployment
virtualization
and
requirement_10
pattern_6
automation
pattern_1
use
pattern_1
component_1
discovery
and
pattern_1
pattern_20
to
recover
from
failure
and
to
spread
load
across
more
technology_54
the
ability
to
discover
component_1
technology_54
and

them
into
the
mix
be
connector_5
elasticity
this
include
pattern_20
of
component_1
detecting
failure
remove
unhealthy
technology_54
out
of
the
mix

additional
component_2
into
a
run
component_32
a
key
component_23
of
pattern_1
architecture
be
reactive
programming
which
be
an
pattern_11
programming
mode
and
the
ability
to
use
back
pressure
to
fail
gracefully
if
the
load
surpass
the
capacity
of
a
technology_54
rather
than
have
a
cascade
failure
if
your
component_1
under
unexpected
load
become
unresponsive
then
you
do
not
connector_7
a
pattern_2
if
your
component_1
under
load
throw
error
connector_data_10
and
tell
component_8
it
be
under
too
much
load
and
you
can
spin
up
technology_54
and
the
technology_54
can
discover
each
other
component_1
discovery
and
live
another
day
then
you
connector_7
a
pattern_2
pattern_1
be
resilient
and
elastic
summarykeys
way
to
identify
pattern_1
us
component_1
discovery
it
might
be
a
microserviceasync
component_30
pattern_10
it
might
be
a
microserviceuses
back
pressure
to
detect
when
it
overload
to
survive
another
day
it
might
be
a
microserviceuses
pattern_20
to
report
health
status
it
might
be
a
microserviceused
a
bound
domain
and
own
it
connector_data_3
it
might
be
a
microserviceapis
be
reachable
via
technology_11
technology_9
over
technology_12
it
might
be
a
microserviceuses
technology_35
or
an
ami
it
might
be
a
microserviceyour
component_1
run
a
single
component_4
or
a
set
of
sharded
component_2
it
might
be
a
microserviceyou
don’t
hard
location
of
component_1
you
use
component_1
discovery
etcd
consul
or
some
other
requirement_10
friendly
elastic
way
to
spin
up
servicesyou
also
component_33
other
form
of
config
in
requirement_10
friendly
place
etcd
and
consul
or
technology_58
or
inside
the
hide
technology_30
instance
web
component_20
and
you
can
connector_13
connector_data_12
while
the
component_1
be
runningyou
use
back
pressure
if
you
component_1
connector_6
overload
it
do
not
become
unresponsive
it
connector_34
currently
unavailable
connector_data_10
so
upstream
component_8
and
component_2
can
connector_35
around
it
they
could
even
connector_13
the
last

quality_attribute_3
whatever
from
technology_58
or
from
akamai
one
downstream
component_1
that
in
unresponsive
will
not
kill
all
upstream
component_2
and
clientskeys
way
to
identify
technology_1
microservicesyou
don’t
use
an
ear
or
war
filesyour
component_2
have
coding_keyword_3
methodsyou
don’t
auto
quality_attribute_4
technology_1
component_23
you
auto
quality_attribute_4
ami
image
or
technology_35
containersyou
use
a
fatjar
that
be
runnable
a
a
component_4
or
sharded
component_1
or
you
use
gradle
distzip
or
disttaryour
be
non
block
if
you
have
to
use
a
pattern_18
component_28
for
requirement_2
you
do
it
from
a
pattern_10
component_37
pool
remember
pattern_1
be
not
a
thing
and
they
be
not
cool
or
hip
pattern_1
be
obvious
evolutionary
architecture
to
connector_16
the
revolutionary
thing
that
already
happen
web
requirement_10
requirement_4
component_20
virtualization
o
containerization
multi
core
component_20
cheap
and
cheap
ram

bit
computing
10gbe
100gbe
etc
this
be
not
extreme
or
cool
this
be
obvious
reactionary
architecture
to
this
amaze
tech
landscape
that
we
live
in
it
be
le
about
the
fashion
show
of
technology_57
coolness
and
more
about
not
use
technology_24
and
technique
that
be
antique
in
this
environment
give
up
your
punch
card
and
war

and
join
in
i
have
more
to
say
but
this
coding_keyword_1
be
way
too
long
already
i
leave
you
with
these
connector_36
thank
you
for
connector_37
if
you
connector_13
this
far
in
the
mean
time
feel
free
to
connector_3
about
qbit
the
technology_1
pattern_1
lib
that
focus
on
pattern_1
technology_11
technology_12
and
technology_9
use
active
connector_data_11
and
high
quality_attribute_1
component_38
pattern_17
and
bus
for
modern
requirement_10
and
requirement_4
component_15
back
end
reference
and
connector_37
material

pattern_1
by
martin
fowler
and
james
lewis2
pattern_1
architecture
by
chris
richardson3
micro
component_2
–
technology_1
the
unix
way
by
james
lewis4
pattern_1
or
how
i

to
stop
make
monolith
and
love
conway’s
law
by
cliff
moon5
micro
component_1
architecure
by
fred
george6
pattern_1
be
not
a
free
lunch
by
benjamin
wootton7
antifragility
and
pattern_1
by
rus
miles8
the
unix
philosophy9
conway’s
law10
architecture11
migrate
to
pattern_1
by
adrian
cockroft12
pattern_1
with
technology_59

pattern_1
for
the
grumpy
neckbeard14
pattern_1
definition
on
wikipedia15
pattern_1
and
devops
by
adrian
cockcroft16
build
and
quality_attribute_4
pattern_1
bart
blommaerts17
pattern_1
on
the
technology_36
alexander
heusingfeld18
pattern_1
shaun
abramsmore
about
qbitwhat
be
qbit
again
qbit
be
a
pattern_21
technology_37
for
pattern_1
it
be
similar
to
many
other
project
technology_53
technology_59
pattern_3
etc
qbit
be
a
technology_37
not
a
component_10
qbit
have
technology_37
to
put
a
component_1
behind
a
component_38
qbit
component_35
can
be
deal
with
directly
or
you
can
create
a
component_1
qbit
component_2
can
be
connector_38
by
technology_11
technology_9
technology_9
pipeline
and
other
type
of
technology_60
a
component_1
in
qbit
be
a
technology_1
whose
be
connector_17
behind
component_1
component_38
qbit
connector_39
apartment
component_30
component_39
and
be
similar
to
the
actor
component_30
or
a
quality_attribute_3
description
would
be
active
connector_data_2
qbit
do
not
use
a
disruptor
it
us
regular
technology_1
component_38
qbit
can
do
north
of

million
pattern_22
pong
connector_data_5
per
second
which
be
an
amaze
quality_attribute_1
see
a
high
a
200m
qbit
also
support
connector_10
component_2
via
rest
and
technology_11
qbit
be
pattern_1
in
the
pure
web
sense
technology_8
technology_9
technology_11
etc
reactive
programming
component_1
discovery
component_1
type
component_9
pattern_23
type
technology_1
pattern_2
lib
update
for
qbitservice
discoverywe
be
quality_attribute_13
now
with
consul
this
allow
component_2
to
show
health
status
up
down
warn
this
be
use
for
component_1
discovery
and
cluster
qbit
have
a
cluster
bus
not
part
of
qbit
core
but
a
technology_37
we
have
bus
pattern_7
then
we

the
cluster
by
use
consul
discovery
consul
be
technology_61
or
etcd
we
take
what
be
in
the
bus
cluster
component_6
and
break
that
out
into
a
core
concept
of
a
servicediscovery
servicediscovery
allow
a
developer
to
manage
servicepools
a
servicepool
be
a
collection
of
component_1
definition
for
a
component_1
name
and
it
fire
when
a
component_1
be

to
the
pool
or
remove
servicedefinition
be
component_40
port
health
component_1
name
and
unique
component_1
coding_keyword_6
if
a
component_1
become
unhealthy
use
consul
pattern_20
it
connector_6
take
out
of
the
pool
there
be
a
plan
to
support
a
wide
variety
of
way
to
do
servicediscovery
consul
be
the
first
one
reactive
programmingwe
improve
the
reactive
programming
support
qbit
have
always
be
reactive
a
it
be
pattern_11
and
us
the
active
connector_data_2
architecture
which
be
a
derivative
of
the
actor
component_30
it
be
now
easy
to
do
thing
connector_data_6
component_1
a
connector_data_6
component_1
b
then
use
the
connector_data_13
from
b
to
connector_data_6
component_1
technology_62
coding_keyword_5
the
connector_data_13
of
a
technology_62
and
timeout
if
a
take
long
than

m
timeout
if
b
take
long
than

m
timeout
if
bc
take
long
than

m
and
timeout
if
the
whole
thing
take
long
than

m
it
do
this
an
pattern_11
manner
it
be
wicked
fast
this
reactive
coordination
us
technology_1

lambda
handle

pattern_8
connector_data_6
technology_11
connector_data_5
be
all
do
through
component_1

the
programming
component_30
be
pojos
qbit
be
a
technology_1
first
programming
component_30
it
us
common
technology_1
idiom
to
do
reactive
programming
it
focus
on
technology_1

it
be
one
of
the
few
of
a
crowd
of
reactive
programming
libs
technology_27
that
focus
on
technology_1

it
be
not
a
lib
connector_7
in
xyz
that
have
a
few
technology_1
example
to
mark
a
connector_25
off
connector_data_14
it
be
connector_7
in
technology_1
and
focus
on
technology_1
reactive
programming
use
active
connector_data_11
architecture
which
be
a
focus
on
oop
reactive
programming
with
lambda
and
be
not
a
pure
functional
play
it
be
a
technology_1

play
on
reactive
programming
component_2
can
be
stateful
which
fit
the
micro
component_1
architecture
well
component_2
will
typically
own
or
lease
the
connector_data_3
instead
of
use
a
pattern_15
component_1
typesservice
bundle
many
pattern_11
component_2
connector_40
a
single
connector_data_15
component_38
and
or
connector_40
a
connector_data_7
component_38
component_1
component_20
a
wrapper
for
a
component_1
bundle
that
connector_41
component_2
to
the
web
component_1
component_38
an
in
proc
pattern_11
component_1
qbit
us
pattern_12
component_35
for
requirement_13
there
be
also
cpu
sharded
component_1
each
component_1
do
a
portion
of
the
workload
in
it
own
component_39
to
maximize
core
utilization
the
idea
here
be
you
have
a
large
mass
of
connector_data_3
that
you
need
to
do
calculation
on
you
can
keep
the
connector_data_3
in
memory
fault
it
in
or
keep
in
the
large
part
of
the
histogram
in
memory
not
the
long
tail
you
shard
on
an
argument
to
the
component_1

this
be
how
i
connector_7
some
personalization
component_41
in
the
recent
past
component_37
pool
component_1
these
be
for
io
where
you
have
to
talk
to
an
io
component_1
that
be
not
pattern_11
component_17
usually
or
component_31
requirement_2
or
even
if
you
have
to
do
a
lot
of
io
these
component_2
be
semi
stateless
they
manage
conversational
state
of
many
connector_data_8
but
it
be
transient
servicequeue
wrap
a
technology_1
connector_data_2
and
force
connector_data_6
connector_15
and
to
go
through
high
quality_attribute_1
pattern_12
component_38
servicebundle
us
a
collection
of
servicequeues
serviceserver
us
a
servicebundle
and
connector_41
it
to
rest
technology_8
and
technology_11
technology_8

be
quality_attribute_13
into
the
component_32
you
can
register
for
an
use
an
annotation
@eventchannel
or
you
can
connector_42
the
pattern_24

bus
can
be
replicate
bus
can
be
cluster
optional
technology_37
there
be
not
one
bus
you
can
create
a
many
a
you

currently
the
bus
work
over
technology_11
technology_8
you
could
connector_43
from
non
technology_1
component_3
component_9
qbit
support
create
pattern_11
component_9
you
can
use
the
component_9
connector_data_2
to
create
a
pattern_23
to
a
remote
component_1
you
can
use
the
component_1
component_38
connector_data_2
to
create
a
local
in
proc
pattern_23
to
a
component_1
the
programming
component_30
be
the
same
for
local
and
remote
pattern_23
it
be
possible
to
make
720m
connector_data_5
a
second
this
include
connector_44
the
connector_15
back
from
a
single
remote
pattern_23
more
to
come
in
the
mean
time
feel
free
to
connector_3
about
qbit
the
technology_1
pattern_2
lib
that
focus
on
pattern_1
technology_11
technology_12
and
technology_9
use
active
connector_data_11
and
high
quality_attribute_1
component_38
pattern_17
and
bus
for
modern
requirement_10
and
requirement_4
component_15
back
end
qbit
lingoqbit
be
a
technology_1
pattern_2
lib
support
rest
technology_12
and
technology_11
it
be
connector_7
in
technology_1
but
i
might
one
day
connector_7
a
version
in
technology_63
or
go
or
technology_64
but
that
would
require
a
large
payday
component_1
pojo
plain
old
technology_1
connector_data_2
behind
a
component_38
that
can
connector_43
connector_data_5
via
pattern_23
connector_data_5
or

have
one
component_39
manage

connector_data_6
and
connector_15
or
two
one
for
connector_data_5
and
and
the
other
for
connector_15
so
connector_15
pattern_25
do
not
block
component_1
one
be
fast
unless
connector_15
block
component_2
can
use
technology_59
pattern_9
style
pattern_8
annotation
to
connector_32
themselves
to
the
outside
world
via
pattern_8
and
technology_11
servicebundle
many
pojos
behind
one
connector_15
component_38
and
many
connector_43
component_38
there
be
one
component_39
for
all
connector_15
or
not
they
also
can
be
one
connector_43
component_38
component_38
a
component_39
manage
a
component_38
it
support
pattern_12
it
have
for
empty
reachedlimit
startedbatch
idle
you
can
listen
to
these
from
component_2
that
sit
behind
a
component_38
you

t
have
to
use
component_1
you
can
use
component_38
s
direct
serviceserver
servicebundle
that
be
connector_38
to
pattern_8
and
technology_11
communicationeventbus
eventbus
be
a
way
to
connector_30
a
lot
of
connector_data_10
to
component_2
that
be
loosely
coupledclientproxy
way
to
invoke
component_1
through
pattern_11

component_1
can
be
inproc
same
component_4
or
remoted
over
technology_11
non
block
qbit
be
a
pattern_10
lib
you
use
pattern_26
via
technology_1

lambda
you
can
also
connector_30
connector_data_10
and
connector_13
connector_data_16
pattern_17
be
build
into
the
component_32
so
you
can
easily
coordinate
complex
connector_data_17
quality_attribute_1
there
be
a
lot
of
room
for
improvement
with
quality_attribute_1
but
already
qbit
be
very
fast
200m+
tps
inproc
pattern_22
pong
10m
20m+
tps
bus
500k
tps
pattern_14
connector_data_5
over
technology_11
technology_8
etc
more
work
need
to
be
do
to
improve
quality_attribute_1
but
now
it
be
fast
enough
where
i
be
work
more
with
quality_attribute_16

more
about
qbit
detail

qbit
pattern_2
example
doc
component_38
pattern_26
for
qbit
component_38
base
component_1
quick
start
build
a
quality_attribute_2
rest
web
pattern_2
component_20
with
qbit
quick
start
build
a
todo
web
pattern_2
component_9
with
qbit
quick
start
build
a
todo
web
pattern_2
component_20
with
qbit
quick
start
build
boon
for
the
qbit
pattern_2
component_41
quick
start
build
qbit
the
pattern_2
lib
for
technology_1
rough
cut
connector_20
up
single
component_7
component_15
from
qbit
technology_1
technology_12
pattern_2
lib
rough
cut
work
with
bus
for
qbit
the
pattern_2
component_41
rough
cut
work
with
inproc
pattern_1
rough
cut
work
with
private
bus
for
inproc
pattern_1
rough
cut
work
with
strongly
type
bus
pattern_23
for
qbit
technology_1
pattern_2
lib
rough
cut
work
with
component_32
manager
for
qbit
mircoservice
lib
subpages

pattern_1
architecture
connector_37
connector_data_14

mammatus
inc
technology_1
pattern_1
expert
we
provide
train
consult
and
mentor
in
high
quality_attribute_1
pattern_2
development
support
for
technology_65
and
technology_51
in
technology_66
technology_30
technology_51
train
technology_51
consult
technology_65
train
technology_65
consult
technology_3
train
technology_3
consult
sign
in|report
abuse|print
page|powered
by
sit
