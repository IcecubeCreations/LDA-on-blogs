micro
component_1
versioning
strategy
toggle
navigation
niels
nu
home
archive
about
micro
component_1
versioning
strategy
identify
the
problem
with
versioning
and
explore
possible
solution

on


μservices
be
hip
they
have
be
for
a
while
now
but
while
a
very
strong
modular
loosely
couple
approach
tend
to
make
project
easy
to
maintain
it
also
bring
it’s
own
set
of
problem
in
this
i
want
to
dive
into
one
of
these
problem
versioning
this
come
with
example

update
i
have
also
create
a
more
in
depth
implementation
of
this
adapter
pattern_1
in
technology_1
connector_1
all
about
it
here
introduction
a
few
year
ago
i
work
on
a
project
that
use
a
μservice
ish
approach
while
the
be
well
connector_2
and
a
complete
joy
to
work
on
versioning
the
component_1
be
not
take
into
account
for
serialization
between
component_1
a
home
grow
pattern_2
pattern_3
base
on
technology_2
and
kryo
be
use
it
be
fast
and
easy
to
use
but
it
have
one
huge
problem
the
component_1
could
not
connector_3
between
each
other
unless
the
serialize
have
the
exact
same
connector_data_1
and
they
use
the
same
or
at
least
quality_attribute_1
kryo
version
since
there
be
also
no
version
negotiation
between
the
component_1
there
be
only
one
solution
quality_attribute_2
the
entire
ecosystem
a
one
big
monolith
and
this
be
something
a
lot
with
mic
a
modular
monolith
instead
of
a
true
μservice
architecture
where
you
don’t
have
the
benefit
of
a
μservice
architecture
agility
you
should
be
able
to
swap
one
of
the
component_1
out
while
you
still
have
the
downside
of
a
μservice
architecture
mainly
you
lose
the
ability
to
do
pattern_4
update
this
be
why
if
you
decide
on
go
for
a
μservice
architecture
you
need
to
figure
out
and
decide
on
a
strategy
to
use
and
stick
to
it
connector_data_2
technology_3
let’s
start
with
a
connector_data_2
technology_3
in
the
example
in
the
introduction
we
use
a
binary
technology_3
that
while
it
be
small
and
fast
have
one
big
issue
in
that
it
be
hard
or
almost
impossible
to
make
backward
quality_attribute_1
this
be
a
mistake
while
there
be
binary
technology_3
that
allow
for
backwards
quality_attribute_3
technology_4
smile
in
our
example
we’ll
use
technology_5
if
a
technology_6
version

it
should
be
handle
fine
by
old
component_2
important
make
sure
you
test
this
i
be
currently
work
at
a
large
bank
where
we
have
a
misbehave
component_2
that
didn’t
ignore
unknown
technology_7
and
crash
technology_6
version
i
mention
the
technology_6
version
and
this
be
the
second
important
component_3
that
you
need
to
decide
on
your
technology_6
version
number
you
can
in
fact
use
a
single
number
you
bump
whenever
a
version
break
quality_attribute_3
since
your
technology_6
be
backward
quality_attribute_1
always
within
a
version
there
be
no
acute
need
for
a
major
minor
versioning
technology_8
also
make
sure
that
the
component_2
always
tell
the
component_4
which
technology_6
version
it
expect
when
the
component_2
doesn’t
we
should
in
fact
throw
an
error
instead
of
make
the
implicit
assumption
the
component_2
want
a
certain
version
this
tell
a
developer
that
he
must
always
include
the
version
you
also
need
this
connector_data_3
to
how
many
component_5
be
still
not
up
to
date
to
ass
the
impact
of
deprecate
old
version
strategy
so
now
that
we
decide
on
a
connector_data_2
technology_3
and
a
technology_6
versioning
strategy
we
can
now
apply
this
and
decide
on
a
strategy
we’ll
use
a
very
quality_attribute_4
order
component_6
for
a
web
shop
a
an
example
we
have
a
single
connector_4
connector_data_4
that

an
order
with
it’s
connector_data_5
base
on
it’s

we
have
two
version

and

that
be
not
quality_attribute_1
version

connector_5
{


customerfirstname
john
customerlsatname
williams
ordertotal

pattern_5

item
{
name
milk
qtty

requirement_1


}
{
name
bread
qtty

requirement_1


}
}
a
you
can
see
we
make
a
few
mistake
in
this
connector_5
the
customerlastname
be
misspell
and
the
ordertotal
be
in
cent
be
inconsistent
with
the
order
item
requirement_1
be
decimal
number
so
we
fix
this
in
technology_3
version

{


customerfirstname
john
customerlastname
williams
ordertotal


pattern_5

item
{
name
milk
qtty

requirement_1


}
{
name
bread
qtty

requirement_1


}
}
much
quality_attribute_5
also
completely
incompatible
connector_6
base
versioning
a
relatively
simply
strategy
that
work
well
for
api’s
that
be
externally
connector_7
be
to
simply
have
the
version
in
the
connector_8
url
so
the
first
version
of
our
component_2
will
connector_4
v1
order

and

version
base
on
our
component_6
would
connector_data_6
connector_4
v2
order

we
would
then
have
the
old
version
of
the
component_6
run
on
port

and
the
version
on
port

a
reverse
pattern_6

technology_9
would
then
simply
connector_8
the
connector_data_6
remove
the
vn
bit
to
the
correspond
component_4
this
be
a
strategy
that
be
relatively
simply
to
connector_9
even
in
hindsight
but
it
do
some
with
a
few
drawback
the
first
one
be
obviously
that
you
need
to
be
able
to
keep
old
version
of
component_1
run
in
parallel
a
version
of
our
order
component_7
might
for
example
alter
the
component_8
in
such
a
way
that
old
version
can’t
connector_10
the
connector_data_2
anymore
another
issue
be
that
while
this
work
well
for
externally
connector_7
component_1
we’re
talk
about
μservices
here
you’d
have
many
component_1
connector_3
between
each
other
that
would
all
have
to
go
through
a
reverse
pattern_6
pattern_7
base
versioning
another
approach
be
to
move
the
component_9
of
handle
backwards
quality_attribute_3
to
the

in
my
opinion
this
make
sense
the
developer
who
make
the
modification
tend
to
how
to
be
backwards
quality_attribute_1
best
our
example
be
base
on
technology_1
although
conceptually
any
technology_10
and
technology_11
can
be
use
which
internally
us
technology_12
for
technology_7
serialization
technology_12
have
the
concept
of
pattern_7
a
common
scenario
of
these
kind
of
pattern_7
be
that
you
want
to
connector_11
only
a
part
of
a
person’s
detail
for
unauthorized
component_10
and
more
connector_data_3
for
pattern_8
friend
of
component_11
similar
to
how
for
example
your
e
mail
on
your
profile
can
be
make
quality_attribute_6
only
to
your
close
friend
more
info
on
technology_12
pattern_7
here
in
the
example
project
i
have
create
a
pattern_9
that
show
the
two
approach
let’s
take
a
look
at
the
constructor
first
pattern_9
{
orderdb


order

john
williams
currenttimemillis
order
item
milk



order
item
bread



viewmap
put

pattern_7
version1

adaptermap
put

o
mappingjacksonvalue

orderv1
o
}
a
you
can
see
we
fill
our
component_8
with
a
single
order
and
also
configure
the
pattern_7
and
adapter
connector_data_7
a
pattern_7
a
explain
in
the
connector_12
be
any

it
us
instead
of
plain

so
that
it
can
use
basic
connector_data_8
inheritance
the
adapter
be
a
quality_attribute_4
that
connector_data_9
an
order
to
a
mappingjacksonvalue
connector_data_8
i
will
also
explain
the
getprotocolversion
utility

private
getprotocolversion
{
=
connector_data_6
getheader
x
technology_6
version
if

==

{
throw
noprotocolversionexception
}
else
{
parseint

}
}
this

use
by
both
versioning

be
how
we
connector_4
the
technology_6
version
from
the
component_2
supply

if
it’s
not
supply
it
will
respond
with
a

status

note
normally
you
would
have
a
generic
pattern_10
base
solution
that
handle
this
but
for
simplicity’s
sake
this
component_9
be
in
the
pattern_9

the
pattern_9
component_12
be
relatively
quality_attribute_4
@requestmapping
requirement_2
=
method1
{id}
=
requestmethod
connector_4
mappingjacksonvalue
getmethod1
@pathvariable

{
mappingjacksonvalue
connector_data_10
=
mappingjacksonvalue
find

connector_data_10
setserializationview
getorderview
connector_data_10
}
private

getorderview
{
viewmap
getordefault
getprotocolversion
pattern_7
version2

}
what
you
probably
notice
be
that
we
don’t
an
order
connector_data_8
from
the
pattern_9
you’d
normally
do
but
use
a
technology_12
mappingjacksonvalue
wrapper
instead
this
give
u
the
quality_attribute_7
to
supply
a
different
pattern_7
base
on
the
version
the
getorderview
simply
look
up
a
pattern_7
base
on
the
version
or

the
default
version2
pattern_7
now
we
set
the
pattern_7
let’s
see
how
the
backwards
quality_attribute_3
be
handle
this
be
handle
in
the
orderserializer
which
be
a
technology_13
technology_12
serializer
orderserializer
extend
jsonserializer
order
{
private
final
bigdecimal
hundred
=
bigdecimal

@override
serialize
order
order
jsongenerator
jsongenerator
serializerprovider
serializerprovider
throw
ioexception
{
jsongenerator
writestartobject
jsongenerator
writenumberfield

order
getid
jsongenerator
writestringfield
customerfirstname
order
getcustomerfirstname
if
serializerprovider
getactiveview
==
pattern_7
version1

{
jsongenerator
writestringfield
customerlsatname
order
getcustomerlastname
jsongenerator
writenumberfield
ordertotal
order
getordertotal
multiply
hundred
longvalue
}
else
{
jsongenerator
writestringfield
customerlastname
order
getcustomerlastname
jsongenerator
writenumberfield
ordertotal
order
getordertotal
}
jsongenerator
writenumberfield
pattern_5
order
gettimestamp
serializerprovider
defaultserializefield
item
order
getitems
jsongenerator
jsongenerator
writeendobject
}
}
the
reason
i’ve
use
a
serializer
instead
of
use
the
technology_13
pattern_7
requirement_3
be
because
it
can’t
handle
serialize
a
property
under
a
different
name
very
well
a
you
can
see
the
pattern_7
be
supply
to
the
serializer
through
the
serializerprovider
getactiveview
and
you
can
perform
your
quality_attribute_3
component_9
base
on
this
the
downside
be
that
you
have
to
do
a
lot
of
manual
work
adapter
base
versioning
a
that
be
in
my
opinion
a
bit
more
elegant
be
the
component_13
of
the
adapter
design
pattern_1
we
take
advantage
of
the
loosely
couple
nature
of
μservices
and
base
on
the
technology_6
version
a
completely
different
connector_data_8
in
this
approach
we
will
also
use
the
x
technology_6
version
supply
by
the
component_2
so
let’s
take
a
look
at
the
second
connector_8
@requestmapping
requirement_2
=
method2
{id}
=
requestmethod
connector_4
mappingjacksonvalue
getmethod2
@pathvariable

{
adapt
find

}
private
mappingjacksonvalue
adapt
order
order
{
adaptermap
getordefault
getprotocolversion
mappingjacksonvalue

apply
order
}
the
pattern_9
pass
the
find
order
to
an
adapt
that
look
up
the
connector_data_7
yay
for
technology_14

and
apply
it
to
an
order
a
you
have
see
in
the
constructor
for
version

it
wrap
the
order
in
an
orderv1
connector_data_8
that
then
connector_13
serialize
by
technology_12
into
the
output
it
look
this
orderv1
{
private
final
bigdecimal
hundred
=
bigdecimal

private
order
order
orderv1
order
order
{
this
order
=
order
}
getcustomerfirstname
{
order
getcustomerfirstname
}
@jsonproperty
customerlsatname
getcustomerlastname
{
order
getcustomerlastname
}
long
getordertotal
{
order
getordertotal
multiply
hundred
longvalue
}
long
gettimestamp
{
order
gettimestamp
}
connector_data_11
order
item
getitems
{
order
getitems
}
}
this
be
a
typical
adapter
it
doesn’t
contain
any
connector_data_2
itself
it
adapt
the
version
to
an
old

this
way
all
the
important
component_9
be
still
in
the
order
and
only
adapter
component_9
be
contain
in
the
adapter
what
i
about
this
solution
be
that
it
be
clear
and
easy
to
connector_1
doesn’t
require
a
lot
of
keep
in
mind
you
only
need
adapter
for
that
break
between
version
and
be
also
easy
to
adapt
heh
to
different
serialization

this
mechanism
can
easily
be
apply
to
for
example
technology_4
serialization
and
or
component_1
connector_3
with
for
example
technology_15
component_14
conclusion
i’ve
show
a
few
approach
in
this
and
each
of
these
have
their
pro’s
and
con’s
the
important
lesson
however
be
that
versioning
should
be
part
of
your
architecture
and
not
some
kind
of
afterthought
for
external
api’s
it’s
already
important
but
with
the
fine
mesh
of
interconnect
component_1
you
see
in
a
μservice
architecture
it’s
a
must
to
decide
on
a
strategy
and
no
matter
which
strategy
you
choose
you
have
to
make
sure
that
you
always
clearly
connector_3
in
the
url
the
name
of
your
technology_15
topic
or
a

what
the
expect
technology_6
version
be
without
it
it
be
impossible
to
connector_8
impossible
to
connector_2
adapter
and
impossible
to
even
which
version
be
out
there
in
the
wild
i
hope
you
enjoy
this
a
much
a
i
enjoy
connector_14
it
feel
free
to
play
around
with
the
example
and
please
me
if
you
have

or
question
copyright
©
niels
dommerholt
bake
with
jbake
template
clean
