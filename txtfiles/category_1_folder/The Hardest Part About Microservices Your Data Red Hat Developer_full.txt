the
hard
part
about
pattern_1
your
connector_data_1
|
developer
sorry
you
need
to
enable
technology_1
to
visit
this
skip
to
content
topic
feature
topic
technology_2
how
this
powerful
open
component_1
technology_3
help
you
manage
component_2
across
container
in
any
environment
quarkus
technology_2
requirement_1
technology_4
with
low
memory
footprint
and
fast
boot
time
for
pattern_1
and
serverless
component_3
devops
devops
involve
the
combination
of
cultural
connector_1
component_4
automation
and
technology_3
to
improve
your
time
to
requirement_2
linux
develop
component_5
on
the
most
popular
linux
for
the
enterprise—all
while
use
the
late
technology_5
other
topic
technology_6
core
technology_7
technology_8
on
technology_2
component_6
requirement_3
technology_9
k
container
connector_data_1
requirement_4
connector_data_1
science
devops
devtools
edge
computing
pattern_2
architecture
gitops
istio
component_7
mesh
technology_4
technology_1
pattern_1
technology_10
open_source
operator
technology_11
serverless
technology_12
pattern_3
all
topic
technology_13
feature
technology_13
requirement_5
linux
a
quality_attribute_1
prove
foundation
that
s
versatile
enough
for
roll
out
component_3
virtualizing
environment
and
create
a
quality_attribute_2
hybrid
requirement_6
technology_14
open
hybrid
requirement_6
technology_2
component_8
to
build
run
and
quality_attribute_3
container
base
component_5
now
with
developer
technology_3
ci
cd
and
release
requirement_3
build
of
openjdk
the
build
of
openjdk
be
a
free
and
supportable
open_source
implementation
of
the
technology_4
component_8
technology_15
edition
technology_4
se
more
technology_13
3scale
component_6
requirement_3
amq
technology_16
automation
component_8
codeready
container
codeready
studio
codeready
workspace
container
development
technology_17
fuse
technology_18
requirement_5
component_3
component_8
component_4
automation
manager
migration
technology_19
for
component_5
technology_14
component_6
requirement_3
technology_14
component_3
runtimes
technology_14
connector_data_1
science
technology_14
connector_2
for
technology_7
technology_8
decision
manager
developer
toolset
build
of
quarkus
pattern_3
all
technology_13
develop
in
the
sandbox
developer
sandbox
build
technology_3
partner
search
search
all
the
hard
part
about
pattern_1
your
connector_data_1
pattern_1
christian
posta
guest
author
component_9
of
content
technology_20
www
youtube
technology_21
watch
v=mrv0dqtqpfu
the
challenge
of
connector_data_1
with
pattern_1
of
the
reason
we
attempt
a
pattern_1
architecture
chief
among
them
be
allow
your
team
to
be
able
to
work
on
different
part
of
the
component_10
at
different
quality_attribute_4
with
minimal
impact
across
team
so
we
want
team
to
be
autonomous
capable
of
make
decision
about
how
to
best
connector_3
and
operate
their
component_7
and
free
to
make
connector_4
a
quickly
a
the
requirement_7
desire
if
we
have
our
team
organize
to
do
this
then
the
pattern_4
in
our
component_11
architecture
will
begin
to
quality_attribute_5
into
something
that
look
pattern_1
to
gain
this
autonomy
we
need
to
“shed
our
dependencies”
but
that’s
a
lot
easy
to
say
than
do
i’ve
see
folk
refer
to
this
idea
in
part
trivially
a
“each
pattern_5
should
own
and
control
it
own
component_12
and
no
two
component_13
should
connector_5
a
component_12
”
the
idea
be
sound
don’t
connector_5
a
single
component_12
across
component_13
because
then
you
run
into
conflict
compete
connector_6
connector_7
pattern_6
connector_data_1
component_14
conflict
coordination
challenge
etc
but
a
single
component_12
do
afford
u
a
lot
of
quality_attribute_6
and
convenience
acid
transaction
single
place
to
look
well
understand
kinda
one
place
to
manage
etc
so
when
build
pattern_1
how
do
we
reconcile
these
quality_attribute_6
with
split
up
our
component_12
into
multiple
small
component_12
let’s
see
first
for
an
“enterprise”
build
pattern_1
we
need
to
make
the
follow
thing
clear
what
be
the
domain
what
be
reality
where
be
the
pattern_7
boundary
how
should
pattern_1
connector_8
across
boundary
what
if
we
turn
the
component_12
inside
out
what
be
the
domain
this
seem
to
be
ignore
at
a
lot
of
place
but
be
a
huge
difference
between
how
the
internet
requirement_8
practice
pattern_1
and
how
a
traditional
requirement_5
or
fail
because
of
neglect
this
connector_3
pattern_1
before
we
can
build
a
pattern_5
and
reason
about
the
connector_data_1
it
u
produce
connector_9
etc
we
need
to
have
a
reasonably
quality_attribute_7
crisp
understand
about
what
that
connector_data_1
be
represent
for
example
before
we
can
component_15
connector_data_2
into
a
component_12
about
“bookings”
for
our
ticketmonsterand
it
migration
to
pattern_1
we
need
to
understand
“what
be
a
booking”
in
your
domain
you
need
to
understand
what
be
an
account
or
an
requirement_9
or
a
claim
etc
to
do
that
we
need
to
dig
into
what
be
“it”
in
reality
for
example
“what
be
a
book”
try
to
stop
and
think
about
that
a
it’s
a
fairly
quality_attribute_8
example
try
to
think
what
be
a
book
how
would
we
express
this
in
a
connector_data_1
component_14
be
a
book
something
with
component_16
be
a
newspaper
a
book
it
have
component_16
so
maybe
a
book
have
a
hard
cover
or
be
not
something
that’s
release
publish
every
day
if
i
connector_7
a
book
which
i
do
pattern_1
for
technology_4
developer
the
pattern_8
have
an
entry
for
me
with
a
single
row
represent
my
book
but
a
bookstore
have
of
my
book
be
each
one
a
book
or
be
they
copy
how
would
we
represent
this
what
if
a
book
be
so
long
it
have
to
be
break
down
into
volume
be
each
volume
a
book
or
all
of
them
combine
what
if
many
small
composition
be
combine
together
be
the
combination
the
book
or
each
individual
one
so
basically
i
can
publish
a
book
have
many
copy
of
it
in
a
bookstore
each
one
with
multiple
volume
so
what
be
a
book
then
the
reality
be
there
be
no
reality
there
be
no
objective
definition
of
“what
be
a
book”
with
respect
to
reality
so
to
answer
any
question
that
we
have
to
“who’s
ask
the
question
and
what
be
the
context”
component_17
be
king
we
a
human
can
quickly
and
even
unconsciously
resolve
the
ambiguity
of
this
understand
because
we
have
a
component_17
in
our
head
in
the
environment
and
in
the
question
but
a
component_18
doesn’t
we
need
to
make
this
component_17
explicit
when
we
build
our
and
component_14
our
connector_data_1
use
a
book
be
to
illustrate
this
be
simplistic
your
domain
an
requirement_5
with
it
account
requirement_10
book
claim
etc
be
go
to
be
far
more
complicate
and
far
more
conflict
ambiguous
we
need
boundary
where
do
we
draw
the
boundary
the
work
in
the
domain
drive
design
help
u
deal
with
this
complexity
in
the
domain
we
draw
a
bind
component_17
around
component_19
requirement_11
connector_data_3
and
aggregate
that
*model**
our
domain
state
another
way
we
build
and
refine
a
component_14
that
represent
our
domain
and
that
component_14
be
contain
within
a
boundary
that
define
our
component_17
and
this
be
explicit
these
boundary
end
up
be
our
pattern_1
or
the
component_2
within
the
boundary
end
up
be
pattern_1
or
both
either
way
pattern_1
be
about
boundary
and
so
be
ddd
our
connector_data_1
component_14
how
we
wish
to
represent
concept
in
a
physical
connector_data_1
store…note
the
explicit
difference
here
be
drive
by
our
domain
component_14
not
the
other
way
around
when
we
have
this
boundary
we
and
can
make
assertion
about
what
be
“correct”
in
our
component_14
and
what
be
incorrect
these
boundary
also
imply
a
certain
level
of
autonomy
bind
component_17
“a”
have
a
different
understand
of
what
a
“book”
be
than
bind
component_17
“b”
eg
maybe
bind
component_17
“a”
be
a
search
component_7
that
search
for
title
where
a
single
title
be
a
“book”
maybe
bind
component_17
“b”
be
a
checkout
component_7
that
component_20
a
transaction
base
on
how
many
book
titles+copies
you’re
buy
etc
you
stop
and
say
“wait
a
minute…
netflix
doesn’t
say
anything
about
domain
drive
design…
neither
do
twitter
nor
linkedin…
why
should
i
listen
to
this
about
ddd”
well
here’s
why
“people
try
to
copy
netflix
but
they
can
only
copy
what
they
see
they
copy
the
connector_data_4
not
the
process”
adrian
cockcroft
former
netflix
chief
requirement_6
architect
the
journey
to
pattern_1
be
that
a
journey
it
will
be
different
for
each
requirement_8
there
be
no
hard
and
fast
rule
only
tradeoff
copy
what
work
for
one
requirement_8
because
it
appear
to
work
at
this
one
instant
be
an
attempt
to
skip
the
component_4
journey
and
will
not
work
and
the
point
to
make
here
be
that
your
requirement_5
be
not
netflix
in
fact
i’d
argue
that
for
however
complex
the
domain
be
at
netflix
it’s
not
a
complicate
a
it
be
at
your
component_21
requirement_5
search
for
and
show
movie
tweet
update
a
linkedin
profile
etc
be
all
a
lot
quality_attribute_8
than
your
insurance
claim
component_4
component_10
these
internet
requirement_8
go
to
pattern_1
because
of
quality_attribute_4
to
requirement_2
and
sheer
volume
quality_attribute_3
a
tweet
to
twitter
be
simple…
tweet
and
display
tweet
connector_2
for
million
component_22
be
incredibly
complex
requirement_5
today
be
go
to
have
to
confront
complexity
in
both
the
domain
a
well
a
quality_attribute_3
so
connector_10
the
fact
that
this
be
a
journey
that
balance
domain
quality_attribute_3
and
organizational
connector_1
it
will
be
different
for
each
organization
don’t
ignore
it
what
be
the
pattern_7
boundary
back
to
the
story
we
need
something
domain
drive
design
to
help
u
understand
the
component_23
we’ll
use
to
connector_3
our
component_11
and
draw
boundary
around
these
component_23
within
a
component_17
so
we
connector_10
that
a
requirement_10
account
book
etc
mean
different
thing
to
different
bind
component_17
but
at
the
end
of
the
day
we
end
up
with
these
relate
concept
quality_attribute_9
around
our
architecture
but
we
need
some
way
to
reconcile
connector_4
across
these
different
component_23
when
connector_4
happen
we
need
to
account
for
this
but
first
we
need
to
identify
our
pattern_7
boundary
unfortunately
we
a
developer
still
seem
to
approach
build
quality_attribute_9
component_11
all
wrong
we
still
look
through
the
lens
of
one
single
relational
acid
component_12
we
also
ignore
the
peril
of
an
pattern_9
unreliable
requirement_12
to
wit
we
do
thing
connector_7
fancy
technology_22
that
keep
u
from
have
to
anything
about
the
requirement_12
include
pattern_10
technology_22
component_12
abstraction
that
also
ignore
the
requirement_12
and
try
to
connector_3
everything
with
point
to
point
pattern_11
invocation
rest
technology_23
other
technology_24
connector_data_3
serialization
pattern_10
technology_25
etc
we
build
component_11
without
regard
to
authority
vs
autonomy
and
end
up
try
to
solve
the
quality_attribute_9
connector_data_1
problem
with
thing
two
phase
connector_11
across
lot
of
independent
component_7
or
we
ignore
these
concern
all
together
this
mindset
lead
to
build
very
brittle
component_11
that
don’t
scale…and
it
doesn’t
matter
if
you
connector_data_5
it
technology_26
pattern_1
miniservices
whatever
so
what
do
i
mean
by
pattern_7
boundary
i
mean
the
small
unit
of
atomicity
that
you
need
with
respect
to
the
requirement_7
invariant
whether
you
use
a
database’s
acid
property
to
connector_3
the
atomicity
or
a
two
phase
connector_11
etc
doesn’t
really
matter
the
point
be
we
want
to
make
these
pattern_7
boundary
a
small
a
possible
ideally
a
single
transaction
on
a
single
connector_data_3
vernon
vaughn
have
a
series
of
essay
describe
this
approach
with
ddd
aggregate
so
we
can
quality_attribute_3
when
we
build
our
domain
component_14
use
ddd
terminology
we
identify
component_19
requirement_11
connector_data_6
and
aggregate
aggregate
in
this
component_17
be
connector_data_6
that
pattern_12
other
component_19
requirement_11
connector_data_6
and
be
responsible
for
enforce
invariant
there
can
be
multiple
aggregate
within
a
bind
component_17
for
example
let’s
say
we
have
the
follow
use
requirement_13
“allow
requirement_10
to
search
for
flights”
“allow
a
requirement_10
to
pick
a
seat
on
a
particular
flight”
“allow
requirement_10
to
book
a
flight”
we’d
probably
have
three
bind
component_17
here
search
book
and
ticket
we’d
likely
have
lot
more
payment
loyalty
standby
upgrade
etc
but
we’ll
keep
it
narrow
to
these
three
search
be
responsible
for
show
flight
for
specific
connector_12
and
itinerary
for
a
give
time
frame
range
of
day
time
etc
book
will
be
responsible
for
tee
up
the
book
component_4
with
requirement_10
connector_data_2
name
connector_13
frequent
flyer
number
etc
seat
preference
and
payment
connector_data_2
ticket
would
be
responsible
for
actually
settle
the
reservation
with
the
airline
and
issue
a
ticket
within
each
bind
component_17
we
want
to
identify
pattern_7
boundary
where
we
can
enforce
constraint
invariant
we
will
not
consider
atomic
transaction
across
bind
component_17
we’ll
discus
this
in
the
next
section
how
would
we
component_14
this
consider
we
want
small
transaction
boundary
this
be
a
very
simplify
version
of
book
a
flight
btw
maybe
a
flight
aggregate
that
pattern_12
requirement_11
time
date
connector_14
and
component_24
requirement_10
plan
and
book
this
seem
to
make
sense
a
flight
have
a
plane
seat
requirement_10
and
book
the
flight
aggregate
be
responsible
for
keep
track
of
plan
seat
etc
for
the
purpose
of
create
book
this
make
some
sense
from
a
connector_data_1
component_14
standpoint
inside
of
a
component_12
nice
relational
component_14
with
constraint
and
foreign
key
etc
or
make
a
nice
connector_data_3
component_14
inheritance
composition
in
our
component_1
but
let’s
look
at
what
happen
be
there
really
invariant
across
all
book
plan
flight
etc
to
create
an
book
that
be
if
we
a
plane
to
the
flight
aggregate
should
we
really
include
requirement_10
and
book
in
that
transaction
probably
not
what
we
have
here
be
an
aggregate
build
with
compositional
and
connector_data_1
component_14
convenience
in
mind
however
the
pattern_7
boundary
be
too
big
if
we
have
lot
of
connector_4
to
flight
seat
book
etc
we’ll
have
a
lot
of
pattern_7
conflict
whether
use
optimistic
or
pessimistic
lock
won’t
matter
and
that
obviously
doesn’t
quality_attribute_3
never
mind
fail
order
all
the
time
because
a
flight
schedule
be
connector_1
be
a
terrible
requirement_14
what
if
we
break
the
pattern_7
boundary
a
little
small
maybe
book
seatavailability
and
flight
be
their
own
independent
aggregate
a
book
pattern_12
requirement_10
connector_data_2
preference
and
maybe
payment
connector_data_2
the
seatavailability
aggregate
pattern_12
plan
and
plane
configuration
flight
aggregate
be
make
up
of
schedule
connector_12
etc
…
but
we
can
proceed
with
create
book
without
impact
transaction
on
flight
schedule
and
plan
seatavailability
from
a
domain
perspective
we
want
to
be
able
to
do
that
we
don’t
need
100%
strict
consistency
across
plan
flight
book
but
we
do
want
to
correctly
component_25
flight
schedule
connector_4
a
an
admin
plane
configuration
a
a
vendor
and
book
from
requirement_10
so
how
do
we
connector_3
thing
“pick
a
particular
seat”
on
a
flight
during
the
book
component_4
we
connector_data_5
into
the
seatavailability
aggregate
and
ask
it
to
reserve
a
seat
on
a
plane
this
seat
reservation
would
be
connector_3
a
a
single
transaction
for
example
hold
seat
23a
and
a
reservation
we
can
associate
this
reservation
with
the
book
and
submit
the
book
the
seat
be
at
one
point
“reserved”
each
of
these
reserve
a
seat
and
connector_10
a
book
be
individual
transaction
and
can
each
proceed
independently
without
any
kind
of
two
phase
connector_11
or
two
phase
lock
note
use
a
“reservation”
here
be
a
requirement_7
requirement
we
don’t
do
seat
assignment
here
we
reserve
the
seat
this
requirement
would
need
to
be
fetter
out
potentially
through
iteration
of
the
component_14
because
the
technology_27
for
the
use
requirement_13
at
first
simply
say
“allow
a
requirement_10
to
pick
a
seat”
a
developer
could
try
to
infer
that
the
requirement
mean
“pick
from
the
remain
seat
assign
this
to
the
requirement_10
remove
it
from
inventory
and
don’t
sell
more
ticket
than
seats”
this
would
be
extra
unnecessary
invariant
that
would
additional
burden
to
our
pattern_7
component_14
which
the
requirement_7
doesn’t
really
hold
a
an
invariant
the
requirement_7
be
certainly
okay
take
book
without
complete
seat
assignment
and
even
overselling
the
flight
this
be
an
example
of
allow
the
true
domain
guide
you
toward
small
simplify
yet
fully
atomic
pattern_7
boundary
for
the
individual
aggregate
involve
the
story
cannot
end
here
though
because
we
now
have
to
rectify
the
fact
that
there
be
all
these
individual
transaction
that
need
to
come
together
at
some
point
different
part
of
the
connector_data_1
be
involve
ie
i
create
a
book
and
seat
reservation
but
these
be
not
settle
transaction
wrt
to
connector_15
a
board
pass
ticket
etc
how
should
pattern_1
connector_8
across
boundary
we
want
to
keep
the
true
requirement_7
invariant
in
tact
with
ddd
we
choose
to
component_14
these
invariant
a
aggregate
and
enforce
them
use
single
transaction
for
an
aggregate
there
be
requirement_13
where
we’re
update
multi
aggregate
in
a
single
transaction
across
a
single
component_12
or
multiple
component_12
but
those
scenario
would
be
the
exception
we
still
need
to
maintain
some
form
of
consistency
between
aggregate
and
eventually
between
bind
component_17
so
how
should
we
do
this
one
thing
we
should
understand
quality_attribute_9
component_11
be
finicky
there
be
very
few
guarantee
if
any
we
can
make
about
anything
in
a
quality_attribute_9
component_10
in
bind
time
thing
will
fail
thing
be
non
deterministically
slow
or
appear
to
have
fail
component_11
have
non
synchronize
time
boundary
etc
so
why
try
to
fight
it
what
if
we
embrace
this
and
bake
it
into
our
consistency
component_23
across
our
domain
what
if
we
say
“between
our
necessary
pattern_7
boundary
we
can
live
with
other
part
of
our
connector_data_1
and
domain
to
be
reconcile
and
make
consistent
at
some
late
point
in
time”
a
we’ve
be
say
for
pattern_1
we
requirement_11
autonomy
we
requirement_11
be
able
to
make
connector_4
independent
of
other
component_11
in
term
of
quality_attribute_10
technology_28
technology_29
etc
this
decouple
of
time
and
any
guarantee
about
anything
between
component_13
in
any
bind
time
allow
u
to
truly
achieve
this
sort
of
autonomy
this
be
not
unique
to
component_18
systems…
or
any
component_11
for
that
matter
so
i
say
between
transaction
boundary
and
between
bind
component_17
use
to
connector_8
consistency
be
immutable
connector_data_7
that
capture
an
interest
point
in
time
that
should
be
pattern_13
to
peer
peer
will
listen
to
the
in
which
they’re
interest
and
make
decision
base
on
that
connector_data_1
component_15
that
connector_data_1
component_15
some
derivative
of
that
connector_data_1
update
their
own
connector_data_1
base
on
some
decision
make
with
that
connector_data_1
etc
etc
continue
the
flight
book
example
i
somehow
start
lol
instead
of
use
my
ticketmonster
example…
that’s
what
happen
when
i
start
connector_7
when
a
book
be
component_15
via
an
acid
style
transaction
how
do
we
end
up
ticket
that
that’s
where
the
aforementioned
ticket
bind
component_17
come
in
the
book
bind
component_17
would
publish
an
“newbookingcreated”
and
the
ticket
bind
component_17
would
connector_9
that
and
proceed
to
connector_16
with
the
backend
potentially
component_21
ticket
component_10
this
obviously
require
some
kind
of
requirement_4
and
connector_data_1
transformation
which
something
technology_7
technology_9
would
be
great
at
it
also
bring
up
some
other
question
how
do
we
do
a
connector_7
to
our
component_12
and
publish
to
a
component_26
connector_data_8
appliance
atomically
and
what
if
we
have
order
requirement
causal
requirement
between
our
and
what
about
one
component_12
per
component_7
ideally
our
aggregate
would
use
command
and
domain
directly
a
a
first
citizen
that
be
any
be
connector_3
a
command
and
any
connector_17
be
connector_3
a
technology_30
to
and
we
could
more
cleanly
connector_data_9
between
the
we
use
internal
to
our
bind
component_17
and
those
we
use
between
component_17
we
could
publish
ie
newbookingcreated
to
a
pattern_14
component_26
and
then
have
a
component_27
connector_9
this
from
the
component_26
and
insert
it
idempotently
into
the
component_12
without
have
to
use
xa
2pc
transaction
instead
of
insert
into
the
component_12
ourselves
we
could
insert
the
into
an
dedicate
component_15
that
act
both
a
component_12
and
a
pattern_14
pattern_15
topic
this
be
probably
the
prefer
connector_14
or
you
can
continue
to
use
an
acid
component_12
and
connector_18
connector_4
to
that
component_12
to
a
persistent
replicate
requirement_15
technology_7
technology_8
use
something
debeziumand
deduce
the
use
some
kind
of
processor
steam
processor
either
way
the
point
be
we
want
to
connector_8
between
boundary
with
immutable
point
in
time
this
come
with
some
great
advantage
we
avoid
expensive
potentially
impossible
transaction
component_23
across
boundary
we
can
make
connector_4
to
our
component_10
without
impede
progress
of
other
part
of
the
component_10
time
and
quality_attribute_10
we
can
decide
how
quickly
or
slowly
we
want
to
see
the
rest
of
the
outside
world
and
become
eventually
consistent
we
can
component_15
the
connector_data_1
in
our
own
component_12
however
we’d
use
the
technology_5
appropriate
for
our
component_7
we
can
make
connector_4
to
our
schema
component_12
at
our
leisure
we
become
much
more
quality_attribute_11
fault
tolerant
and
quality_attribute_12
you
have
to
pay
even
more
attention
to
cap
theorem
and
the
technology_5
you
choose
to
connector_3
your
storage
component_26
noteably
this
come
with
disadvantage
it’s
more
complicate
difficult
to
debug
since
you
have
a
delay
when
see
you
cannot
make
any
assumption
about
what
other
component_11
which
you
cannot
do
anyway
but
it’s
more
pronounce
in
this
component_14
more
difficult
to
operationalize
you
have
to
pay
even
more
attention
to
cap
theorem
and
the
technology_5
you
choose
to
connector_3
your
storage
component_26
i
connector_data_10
“paying
attention
to
cap
et
al”
in
both
column
because
although
it
place
a
bit
more
of
a
burden
on
you
it’s
imperative
that
you
do
so
anyway
it’s
imperative
that
we
always
pay
attention
to
the
different
form
of
connector_data_1
consistency
and
pattern_16
in
our
quality_attribute_9
connector_data_1
component_10
rely
on
“our
component_12
in
acid”
be
no
long
acceptable
especially
when
that
acid
component_12
most
likely
default
to
some
weak
consistency
anyway…
so
much
for
your
acid
property
another
interest
concept
that
emerge
from
this
approach
be
the
ability
to
connector_3
a
pattern_6
a
“command
query
separation
responsibility”
where
we
separate
our
connector_6
component_14
and
our
connector_7
component_23
into
separate
component_7
remember
we
lament
the
internet
requirement_8
don’t
have
very
complex
domain
component_14
this
be
evident
in
their
connector_7
component_23
be
quality_attribute_8
insert
a
tweet
into
a
quality_attribute_9
requirement_15
for
example
however
their
connector_6
component_23
be
crazy
complicate
because
of
their
quality_attribute_3
cqrs
help
separate
these
concern
on
the
flip
side
in
an
requirement_5
the
connector_7
component_23
might
be
incredibly
complicate
while
the
connector_6
component_23
be
quality_attribute_8
flat
select
connector_19
and
flat
dto
connector_data_3
cqrs
be
a
powerful
separation
of
concern
pattern_6
to
evaluate
once
you’ve
connector_20
proper
boundary
and
a
quality_attribute_7
way
to
propogate
connector_data_1
connector_4
between
aggregate
and
between
bind
component_17
so
what
about
a
component_7
have
only
one
component_12
and
doesn’t
connector_5
with
any
other
component_7
in
this
scenario
we
have
component_27
that
subscribe
to
the
connector_18
of
and
insert
connector_data_1
into
a
connector_21
component_12
that
the
primary
aggregate
might
end
up
use
this
“shared
database”
be
perfectly
fine
remember
there
be
no
rule
tradeoff
in
this
instance
we
have
multiple
component_13
work
in
concert
together
with
the
same
component_12
and
so
long
a
we
our
team
own
all
the
component_4
we
don’t
negate
any
of
our
advantage
of
autonomy
thusly
when
you
hear
someone
say
“a
pattern_5
should
have
it
own
component_12
and
not
connector_5
it
anyone
else”
you
can
respond
“well
kinda”
what
if
we
turn
the
component_12
inside
out
what
if
we
take
the
concept
in
the
previous
section
to
it
logical
extreme
what
if
we
say
we’ll
use
connector_18
for
everything
and
also
persist
these
forever
what
if
we
say
component_12
pattern_17
index
be
really
materialize
pattern_3
of
a
persistent
requirement_15
connector_18
of
that
happen
in
the
past
and
the
current
state
be
a
leave
fold
over
all
of
those
this
approach
bring
even
more
benefit
that
you
can
to
the
benefit
of
connector_8
via
connector_data_10
above
now
you
can
treat
your
component_12
a
a
“current
state”
of
component_25
not
the
true
component_25
you
can
introduce
component_5
and
re
connector_6
the
past
and
examine
their
behavior
in
term
of
“what
would
have
happened”
you
can
perfect
audit
requirement_15
for
free
you
can
introduce
version
of
your
component_3
and
perform
quite
exhaustive
test
on
it
by
replay
the
you
can
more
easily
reason
about
component_12
versioning
upgrade
schema
connector_4
by
replay
the
into
the
component_12
you
can
migrate
to
completely
component_12
technology_5
ie
maybe
you
find
you’ve
outgrow
your
relational
db
and
you
want
to
switch
to
a
specialize
component_12
index
for
more
connector_data_2
on
this
take
a
look
at
martin
kleppmann’s
talk
title
“turning
the
component_12
inside
out
with
technology_7
samza”
when
you
book
a
flight
on
aa
technology_21
delta
technology_21
or
unite
technology_21
you’re
see
some
of
these
concept
in
action
when
you
choose
a
seat
you
don’t
actual
connector_20
assign
it
you
reserve
it
when
you
book
your
flight
you
don’t
actually
have
a
ticket
you
connector_20
an
late
tell
you
you’ve
be
confirm
ticket
have
you
ever
have
a
plane
connector_1
and
be
assign
a
different
seat
for
the
actual
flight
or
be
to
the
gate
and
hear
them
ask
for
volunteer
to
give
up
their
seat
because
they
oversold
the
flight
these
be
all
example
of
pattern_7
boundary
eventual
consistency
compensate
transaction
and
even
apology
at
work
moral
of
the
story
the
moral
of
the
story
here
be
that
connector_data_1
connector_data_1
requirement_4
connector_data_1
boundary
requirement_5
usage
pattern_6
quality_attribute_9
component_11
theory
time
etc
be
all
the
hard
part
of
pattern_1
since
pattern_1
be
really
quality_attribute_9
component_10
i’m
see
too
much
confusion
around
technology_5
“if
i
use
technology_12
i’m
do
microservices”
“i
need
to
solve
component_7
discovery
load
balance
in
the
requirement_6
before
i
can
do
microservices”
“i
must
have
a
single
component_12
per
microservice”
and
useless
“rules”
regard
pattern_1
don’t
worry
once
the
big
vendor
have
come
and
sell
you
all
the
fancy
suite
of
technology_13
mmm…
pattern_18
ring
a
bell
you’ll
still
be
leave
to
do
the
hard
part
connector_data_10
above
last
update
recent
experiment
with
the
technology_14
component_6
requirement_3
developer
sandbox
pattern_19
unwanted
connector_data_11
in
cryostat
connector_22
jfr
connector_data_1
fast
with
cryostat
s
download
component_28
eat
up
few
resource
in
cryostat
with
sidecar
report
manage
technology_8
component_7
which
be
right
for
you
please
enable
technology_1
to
pattern_3
the
powered
by
disqus
feature
topic
istio
quarkus
ci
cd
serverless
requirement_5
technology_4
linux
pattern_1
devops
build
connector_15
start
center
developer
technology_3
interactive
container
catalog
operator
marketplace
certify
component_5
on
technology_31
quicklinks
what
s
devnation
upcoming
book
cheat
video
technology_13
connector_8
status
requirement_16
report
a
issue
report
a
quality_attribute_13
problem
help
during
covid
about
u
sale
developer
build
here
go
anywhere
we
serve
the
builder
the
problem
solver
who
create
career
with
join
u
if
you’re
a
developer
engineer
web
designer
front
end
designer
ux
designer
component_18
scientist
architect
tester
technology_13
manager
project
manager
or
team
lead
sign
me
up
©2022
inc
privacy
statement
term
of
use
all
requirement_17
and
guideline
