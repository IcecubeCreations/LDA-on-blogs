introduce
the
component_1
base
component_2
—
smash
magazineskip
to
content
jump
to
all
topic
start
connector_1
the
jump
to
connector_data_1
of
all
articlesarticlesguidesbookseventsmembershipjob
boardnewsletterpodcastswrite
for
usadvertise
with
u
more
le
lessarticlesguidesbookseventsmembershipjob
boardnewsletterpodcastswrite
for
usadvertise
with
u
clear
searchaccessibilityuxcssjavascriptperformancedesignfigmawallpapersreactvueround
upsweb
designguidesbusinesscareerprivacyjump
to
all
↬leonardo
losovizjan
commentsintroducing
the
component_1
base
api37
min
readapi
graphql
technology_1
performanceshare
on
twitter
linkedinabout
the
authorleonardo
losoviz
be
a
freelance
developer
and
writer
with
an
ongoing
quest
to
quality_attribute_1
innovative
paradigm
serverless
technology_2
component_3
side
component_1
graphql
…
more
about
leonardo
↬email
newsletteryour
smash
weekly
tip
on
front
end
&
ux
trust
by
folk
pattern_1
spam
from
your
requirement_1
build
in
demand
skill
ux
ui
and
hci
—
northwestern
online
m
in
info
design
&
strategy
advertise
on
smash
magazine
top
membership
the
fundamental
of
ux
connector_2
workshop
smart
design
pattern_2
with
vitaly
friedman
design
cod
video
motion
graphic
&
more
quick
summary
↬
in
the
world
of
apis
graphql
have
lately
overshadow
pattern_3
due
to
it
ability
to
query
and
connector_3
all
require
connector_data_2
in
a
single
connector_data_3
in
this
i
will
describe
a
different
type
of
technology_3
base
around
component_1
which
take
a
step
further
the
amount
of
connector_data_2
it
can
fetch
from
a
single
connector_data_3
this
be
update
on
to
technology_4
to
readers’
feedback
the
author
have
custom
query
capability
to
the
component_1
base
component_2
and
describe
how
it
work
an
component_2
be
the
connector_4
pattern_4
for
an
component_4
to
load
connector_data_2
from
the
component_3
in
the
world
of
apis
pattern_3
have
be
the
more
establish
methodology
but
have
lately
be
overshadow
by
graphql
which
offer
important
advantage
over
rest
whereas
pattern_3
require
multiple
technology_5
connector_data_4
to
fetch
a
set
of
connector_data_2
to
render
a
component_1
graphql
can
query
and
connector_3
such
connector_data_2
in
a
single
connector_data_3
and
the
connector_5
will
be
exactly
what
be
require
without
over
or
under
fetch
connector_data_2
a
typically
happen
in
rest
in
this
i
will
describe
another
way
of
fetch
connector_data_2
which
i
have
design
and
connector_6
“pop”
and
open
component_5
here
which
expand
on
the
idea
of
fetch
connector_data_2
for
several
component_6
in
a
single
connector_data_3
introduce
by
graphql
and
take
it
a
step
further
i
e
while
pattern_3
fetch
the
connector_data_2
for
one
resource
and
graphql
fetch
the
connector_data_2
for
all
resource
in
one
component_1
the
component_1
base
component_2
can
fetch
the
connector_data_2
for
all
resource
from
all
component_7
in
one
component_8
use
a
component_1
base
component_2
make
most
sense
when
the
be
itself
build
use
component_1
i
e
when
the
webpage
be
iteratively
compose
of
component_7
wrap
other
component_7
until
at
the
very
top
we
obtain
a
single
component_1
that
represent
the
component_8
for
instance
the
webpage
show
in
the
image
below
be
build
with
component_1
which
be
outline
with
square
the
component_8
be
a
component_1
wrap
component_7
wrap
component_1
a
show
by
the
square
large
preview
a
component_1
base
component_2
be
able
to
make
a
single
connector_data_3
to
the
component_3
by
connector_data_3
the
connector_data_2
for
all
of
the
resource
in
each
component_1
a
well
a
for
all
of
the
component_7
in
the
component_8
which
be
accomplish
by
keep
the
relationship
among
component_7
in
the
component_2
connector_data_5
itself
among
others
this
connector_data_5
offer
the
follow
several
benefit
a
component_8
with
many
component_7
will
connector_7
only
one
connector_data_3
instead
of
many
connector_data_2
connector_8
across
component_7
can
be
fetch
only
once
from
the
db
and
only
once
in
the
connector_5
it
can
greatly
reduce
—
even
completely
remove
—
the
need
for
a
connector_data_2
component_9
we
will
explore
these
in
detail
throughout
the
but
first
let’s
explore
what
component_7
actually
be
and
how
we
can
build
a
base
on
such
component_1
and
finally
explore
how
a
component_1
base
component_2
work
recommend
connector_9
a
graphql
primer
why
we
need
a
kind
of
apimore
after
jump
continue
connector_1
below
↓meet
“typescript
in
lessons”
our
technology_6
guide
to
typescript
with
detail
walkthroughs
hand
on
example
and
common
gotchas
—
all
break
down
into
short
quality_attribute_2
lesson
for
developer
who
enough
technology_1
to
be
dangerous
jump
to
component_10
of
content
↬building
a
through
componentsa
component_1
be
simply
a
set
of
piece
of
technology_7
technology_1
and
technology_8
put
all
together
to
create
an
autonomous
component_11
this
can
then
wrap
other
component_7
to
create
more
complex
connector_data_5
and
be
itself
wrap
by
other
component_1
too
a
component_1
have
a
purpose
which
can
range
from
something
very
basic
such
a
a
connector_10
or
a
to
something
very
elaborate
such
a
a
carousel
or
a
drag
and
drop
image
uploader
component_7
be
most
useful
when
they
be
generic
and
enable
customization
through
inject
property
or
“props”
so
that
they
can
serve
a
wide
of
use
requirement_2
in
the
utmost
requirement_2
the
itself
become
a
component_1
the
term
“component”
be
often
use
to
refer
both
to
requirement_3
and
design
for
instance
concern
requirement_3
technology_1
technology_9
such
a
technology_4
or
technology_10
allow
to
create
component_12
side
component_1
which
be
able
to
self
render
for
instance
after
the
component_2
fetch
their
require
connector_data_2
and
use
prop
to
set
configuration
requirement_4
on
their
wrap
component_1
enabling
quality_attribute_3
concern
design
bootstrap
have
standardize
how
look
and
feel
through
it
front
end
component_1
technology_11
and
it
have
become
a
healthy
trend
for
team
to
create
design
component_13
to
maintain
their
which
allow
the
different
team
member
designer
and
developer
but
also
marketer
and
salesman
to
speak
a
unify
technology_12
and
express
a
consistent
identity
componentizing
a
then
be
a
very
sensible
way
to
make
the
become
more
quality_attribute_4
sit
use
technology_1
technology_9
such
a
technology_4
and
technology_10
be
already
component_1
base
at
least
on
the
component_12
side
use
a
component_1
technology_11
bootstrap
doesn’t
necessarily
make
the
be
component_1
base
it
could
be
a
big
blob
of
technology_7
however
it
incorporate
the
concept
of
quality_attribute_5
element
for
the
component_14
if
the
be
a
big
blob
of
technology_7
for
u
to
componentize
it
we
must
break
the
layout
into
a
series
of
recur
pattern_2
for
which
we
must
identify
and
catalogue
section
on
the
component_8
base
on
their
similarity
of
requirement_3
and
style
and
break
these
section
down
into
pattern_5
a
granular
a
possible
attempt
to
have
each
pattern_5
be
focus
on
a
single
goal
or
action
and
also
try
to
match
common
pattern_5
across
different
section
note
brad
frost’s
“atomic
design”
be
a
great
methodology
for
identify
these
common
pattern_2
and
build
a
quality_attribute_5
design
component_15
brad
frost
identify
five
distinct
level
in
atomic
design
for
create
design
component_15
large
preview
hence
build
a
through
component_7
be
akin
to
play
with
lego
each
component_1
be
either
an
atomic
requirement_3
a
composition
of
other
component_1
or
a
combination
of
the
two
a
show
below
a
basic
component_1
an
avatar
be
iteratively
compose
by
other
component_7
until
obtain
the
webpage
at
the
top
sequence
of
component_7
produce
from
an
avatar
all
the
way
up
to
the
webpage
large
preview
the
component_1
base
component_2
specificationfor
the
component_1
base
component_2
i
have
design
a
component_1
be
connector_6
a
“module”
so
from
now
on
the
term
“component”
and
“module”
be
use
interchangeably
the
relationship
of
all
wrap
each
other
from
the
top
most
all
the
way
down
to
the
last
level
be
connector_6
the
“component
hierarchy”
this
relationship
can
be
express
through
an
associative
an
of
key
=
property
on
the
component_3
side
in
which
each
state
it
name
a
the
key
attribute
and
it
inner
under
the
property
the
component_2
then
simply
encode
this
a
a
technology_13
connector_data_6
for
consumption
component_1
hierarchy
on
component_3
side
e
g
through
technology_2
top
=
=
level1
=
=
level11
=
=
level12
=
=
level121
=
=
level2
=
=
level21
=
=
component_1
hierarchy
encode
a
technology_14
{
top
{
{
level1
{
{
level11
{
}
level12
{
{
level121
{
}
}
}
}
}
level2
{
{
level21
{
}
}
}
}
}
}
the
relationship
among
be
define
on
a
strictly
top
down
fashion
a
wrap
other
and
who
they
be
but
it
doesn’t
—
and
doesn’t
care
—
which
be
wrap
him
for
instance
in
the
technology_13
above
level1
it
wrap
level11
and
level12
and
transitively
it
also
it
wrap
level121
but
level11
doesn’t
care
who
be
wrap
it
consequently
be
unaware
of
level1
have
the
component_1
base
connector_data_5
we
can
now
the
actual
connector_data_7
require
by
each
which
be
categorize
into
either
set
such
a
configuration
requirement_4
and
other
property
and
connector_data_2
such
a
the
of
the
query
component_16
connector_data_8
and
other
property
and
place
accordingly
under
entry
modulesettings
and
moduledata
{
modulesettings
{
top
{
configuration
{
}
{
level1
{
configuration
{
}
{
level11
{
repeat
}
level12
{
configuration
{
}
{
level121
{
repeat
}
}
}
}
}
level2
{
configuration
{
}
{
level21
{
repeat
}
}
}
}
}
}
moduledata
{
top
{
dbobjectids
{
level1
{
dbobjectids
{
level11
{
repeat
}
level12
{
dbobjectids
{
level121
{
repeat
}
}
}
}
}
level2
{
dbobjectids
{
level21
{
repeat
}
}
}
}
}
}
}
follow
the
component_2
will
the
component_16
connector_data_6
connector_data_2
this
connector_data_7
be
not
place
under
each
but
under
a
connector_8
section
connector_6
component_16
to
avoid
duplicate
connector_data_7
when
two
or
more
different
fetch
the
same
connector_data_8
from
the
component_16
in
addition
the
component_2
represent
the
component_16
connector_data_6
connector_data_2
in
a
relational
manner
to
avoid
duplicate
connector_data_7
when
two
or
more
different
component_16
connector_data_8
be
relate
to
a
common
connector_data_6
such
a
two
have
the
same
author
in
other
word
component_16
connector_data_6
connector_data_2
be
normalize
recommend
connector_9
build
a
serverless
form
for
your
sitethe
connector_data_5
be
a
dictionary
organize
under
each
connector_data_6
type
first
and
connector_data_6
second
from
which
we
can
obtain
the
connector_data_6
property
{
component_16
{
primary
{
dbobject_type
{
dbobject_id
{
property
}
}
}
}
}
this
technology_13
connector_data_6
be
already
the
connector_5
from
the
component_1
base
technology_3
it
technology_15
be
a
specification
all
by
itself
a
long
a
the
component_3
the
technology_13
connector_5
in
it
require
technology_15
the
component_12
can
connector_11
the
component_2
independently
of
how
it
be
connector_12
hence
the
component_2
can
be
connector_12
on
any
technology_12
which
be
one
of
the
beauty
of
graphql
be
a
specification
and
not
an
actual
implementation
have
enable
it
to
become
quality_attribute_6
in
a
myriad
of
technology_12
note
in
an
upcoming
i
will
describe
my
implementation
of
the
component_1
base
component_2
in
technology_2
which
be
the
one
quality_attribute_6
in
the
repo
technology_3
connector_5
examplefor
instance
the
component_2
connector_5
below
contain
a
component_1
hierarchy
with
two
component_8
=
fee
where
fee
fetch
please
notice
the
follow
each
which
be
it
query
connector_data_8
from
property
dbobjectids
and
for
the
each
the
connector_data_6
type
for
it
query
connector_data_8
from
property
dbkeys
each
post’s
connector_data_2
be
find
under
and
the
post’s
author
connector_data_2
correspond
to
the
author
with
the
give
under
the
post’s
property
author
be
find
under
component_14
because
the
component_16
connector_data_6
connector_data_2
be
relational
property
author
contain
the
to
the
author
connector_data_6
instead
of
printing
the
author
connector_data_2
directly
{
moduledata
{
component_8
{
{
fee
{
dbobjectids
}
}
}
}
modulesettings
{
component_8
{
{
fee
{
dbkeys
{
author
component_14
}
}
}
}
}
component_16
{
primary
{
{
{
title
hello
world
author
}
{
title
everything
fine
author
}
}
component_14
{
{
name
leo
}
}
}
}
}
difference
fetch
connector_data_2
from
resource
base
schema
base
and
component_1
base
apislet’s
see
how
a
component_1
base
component_2
such
a
pop
compare
when
fetch
connector_data_2
to
a
resource
base
component_2
such
a
rest
and
to
a
schema
base
component_2
such
a
graphql
let’s
say
imdb
have
a
component_8
with
two
component_7
which
need
to
fetch
connector_data_2
“featured
director”
show
a
description
of
george
lucas
and
a
connector_data_1
of
his
film
and
“films
recommend
for
you”
show
film
such
a
star
war
episode
i
—
the
phantom
menace
and
the
terminator
it
could
look
this
component_1
feature
director
and
film
recommend
for
you
for
the
next
generation
imdb
large
preview
let’s
see
how
many
connector_data_4
be
need
to
fetch
the
connector_data_2
through
each
component_2
for
this
example
the
“featured
director”
component_1
bring
one
connector_data_9
“george
lucas”
from
which
it
connector_13
two
film
star
war
episode
i
—
the
phantom
menace
and
star
war
episode
ii
—
attack
of
the
clone
and
for
each
film
two
actor
“ewan
mcgregor”
and
“natalie
portman”
for
the
first
film
and
“natalie
portman”
and
“hayden
christensen”
for
the
second
film
the
component_1
“films
recommend
for
you”
bring
two
connector_data_10
star
war
episode
i
—
the
phantom
menace
and
the
terminator
and
then
fetch
their
director
“george
lucas”
and
“james
cameron”
respectively
use
pattern_3
to
render
component_1
feature
director
we
need
the
follow
connector_data_4
this
number
can
vary
quality_attribute_7
on
how
much
connector_data_2
be
provide
by
each
i
e
how
much
over
fetch
have
be
connector_12
connector_14
feature
director
connector_14
director
george
lucas
connector_14
film
the
phantom
menace
connector_14
film
attack
of
the
clone
connector_14
actor
ewan
mcgregor
connector_14
actor
natalie
portman
connector_14
actor
hayden
christensen
graphql
allow
through
strongly
type
schema
to
fetch
all
the
require
connector_data_2
in
one
single
connector_data_3
per
component_1
the
query
to
fetch
connector_data_2
through
graphql
for
the
component_1
featureddirector
look
this
after
we
have
connector_12
the
correspond
schema
query
{
featureddirector
{
name
country
avatar
film
{
title
thumbnail
actor
{
name
avatar
}
}
}
}
and
it
produce
the
follow
connector_5
{
connector_data_2
{
featureddirector
{
name
george
lucas
country
usa
avatar
film
{
title
star
war
episode
i
the
phantom
menace
thumbnail
actor
{
name
ewan
mcgregor
avatar
}
{
name
natalie
portman
avatar
}
}
{
title
star
war
episode
ii
attack
of
the
clone
thumbnail
actor
{
name
natalie
portman
avatar
}
{
name
hayden
christensen
avatar
}
}
}
}
}
and
query
for
component_1
“films
recommend
for
you”
produce
the
follow
connector_5
{
connector_data_2
{
film
{
title
star
war
episode
i
the
phantom
menace
thumbnail
director
{
name
george
lucas
avatar
}
}
{
title
the
terminator
thumbnail
director
{
name
james
cameron
avatar
}
}
}
}
pop
will
issue
only
one
connector_data_3
to
fetch
all
the
connector_data_2
for
all
component_7
in
the
component_8
and
normalize
the
connector_data_9
the
to
be
connector_6
be
simply
the
same
a
the
url
for
which
we
need
to
connector_14
the
connector_data_2
an
additional
parameter
output=json
to
indicate
to
bring
the
connector_data_2
in
technology_13
technology_15
instead
of
printing
it
a
technology_7
connector_14
url
of
the
component_8
output=json
assume
that
the
connector_data_5
have
a
top
name
component_8
contain
feature
director
and
film
recommend
for
you
and
these
also
have
submodules
this
component_8
feature
director
director
film
film
actor
film
recommend
for
you
film
director
the
single
technology_13
connector_5
will
look
this
{
modulesettings
{
component_8
{
{
feature
director
{
dbkeys
{
people
}
{
director
film
{
dbkeys
{
film
film
}
{
film
actor
{
dbkeys
{
actor
people
}
}
}
}
}
}
film
recommend
for
you
{
dbkeys
{
film
}
{
film
director
{
dbkeys
{
director
people
}
}
}
}
}
}
}
moduledata
{
component_8
{
{
feature
director
{
dbobjectids
}
film
recommend
for
you
{
dbobjectids
}
}
}
}
component_16
{
primary
{
people
{
{
name
george
lucas
country
usa
avatar
film
}
{
name
ewan
mcgregor
avatar
}
{
name
natalie
portman
avatar
}
{
name
hayden
christensen
avatar
}
{
name
james
cameron
avatar
}
}
film
{
{
title
star
war
episode
i
the
phantom
menace
actor
director
thumbnail
}
{
title
star
war
episode
ii
attack
of
the
clone
actor
thumbnail
}
{
title
the
terminator
director
thumbnail
}
}
}
}
}
let’s
analyze
how
these
three
compare
to
each
other
in
term
of
quality_attribute_8
and
the
amount
of
connector_data_2
connector_3
speedthrough
rest
have
to
fetch
connector_data_4
to
render
one
component_1
can
be
very
slow
mostly
on
requirement_5
and
shaky
connector_data_2
connector_15
hence
the
jump
from
pattern_3
to
graphql
represent
a
great
deal
for
quality_attribute_8
because
we
be
able
to
render
a
component_1
with
only
one
connector_data_3
pop
because
it
can
fetch
all
connector_data_2
for
many
component_7
in
one
connector_data_3
will
be
fast
for
render
many
component_7
at
once
however
most
likely
there
be
no
need
for
this
have
component_7
be
render
in
order
a
they
appear
in
the
component_8
be
already
a
quality_attribute_9
practice
and
for
those
component_7
which
appear
under
the
fold
there
be
certainly
no
rush
to
render
them
hence
both
the
schema
base
and
component_1
base
component_17
be
already
pretty
quality_attribute_9
and
clearly
superior
to
a
resource
base
technology_3
amount
of
dataon
each
connector_data_3
connector_data_2
in
the
graphql
connector_5
be
duplicate
actress
“natalie
portman”
be
fetch
twice
in
the
connector_5
from
the
first
component_1
and
when
consider
the
joint
output
for
the
two
component_1
we
can
also
find
connector_8
connector_data_2
such
a
film
star
war
episode
i
—
the
phantom
menace
pop
on
the
other
hand
normalize
the
component_16
connector_data_2
and
it
only
once
however
it
carry
the
overhead
of
printing
the
connector_data_5
hence
quality_attribute_7
on
the
particular
connector_data_3
have
duplicate
connector_data_2
or
not
either
the
schema
base
component_2
or
the
component_1
base
component_2
will
have
a
small
size
in
conclusion
a
schema
base
component_2
such
a
graphql
and
a
component_1
base
component_2
such
a
pop
be
similarly
quality_attribute_9
concern
requirement_6
and
superior
to
a
resource
base
component_2
such
a
rest
recommend
connector_9
understand
and
use
pattern_3
apisparticular
property
of
a
component_1
base
apiif
a
component_1
base
component_2
be
not
necessarily
quality_attribute_9
in
term
of
requirement_6
than
a
schema
base
technology_3
you
be
wonder
then
what
be
i
try
to
achieve
with
this
in
this
section
i
will
attempt
to
convince
you
that
such
an
component_2
have
incredible
potential
provide
several
feature
which
be
very
desirable
make
it
a
serious
contender
in
the
world
of
apis
i
describe
and
demonstrate
each
of
it
unique
great
feature
below
the
connector_data_2
to
be
connector_3
from
the
component_16
can
be
infer
from
the
component_1
hierarchywhen
a
display
a
property
from
a
db
connector_data_6
the
not
or
care
what
connector_data_6
it
be
all
it
care
about
be
define
what
property
from
the
load
connector_data_6
be
require
for
instance
consider
the
image
below
a
load
an
connector_data_6
from
the
component_16
in
this
requirement_2
a
single
and
then
it
descendant
will
show
certain
property
from
the
connector_data_6
such
a
title
and
content
while
some
load
the
component_16
connector_data_6
others
load
property
large
preview
hence
along
the
component_1
hierarchy
the
“dataloading”
will
be
in
charge
of
loading
the
query
connector_data_8
the
loading
the
single
in
this
requirement_2
and
it
descendant
will
define
what
property
from
the
db
connector_data_6
be
require
title
and
content
in
this
requirement_2
fetch
all
the
require
property
for
the
db
connector_data_6
can
be
do
automatically
by
traverse
the
component_1
hierarchy
start
from
the
dataloading
we
iterate
all
it
descendant
all
the
way
down
until
reach
a
dataloading
or
until
the
end
of
the
tree
at
each
level
we
obtain
all
require
property
and
then
merge
all
property
together
and
query
them
from
the
component_16
all
of
them
only
once
in
the
connector_data_5
below
single
fetch
the
connector_data_10
from
the
db
the
with
and
submodules
title
and
content
define
property
to
be
load
for
the
query
db
connector_data_6
title
and
content
respectively
submodules
layout
and
fetch
next
do
not
require
any
connector_data_2
single
=
load
connector_data_8
with
connector_data_6
type
and
layout
title
=
load
property
title
content
=
load
property
content
fetch
next
the
query
to
be
connector_16
be
calculate
automatically
from
the
component_1
hierarchy
and
their
require
connector_data_2
contain
all
the
property
need
by
all
the
and
their
submodules
select
title
content
from
where
=
by
fetch
the
property
to
connector_3
directly
from
the
the
query
will
be
automatically
update
whenever
the
component_1
hierarchy
connector_17
if
for
instance
we
then
submodule
thumbnail
which
require
connector_data_2
thumbnail
single
=
load
connector_data_8
with
connector_data_6
type
and
layout
title
=
load
property
title
content
=
load
property
content
thumbnail
=
load
property
thumbnail
fetch
next
then
the
query
be
automatically
update
to
fetch
the
additional
property
select
title
content
thumbnail
from
where
=
because
we
have
establish
the
component_16
connector_data_6
connector_data_2
to
be
connector_3
in
a
relational
manner
we
can
also
apply
this
strategy
among
the
relationship
between
component_16
connector_data_8
themselves
consider
the
image
below
start
from
the
connector_data_6
type
and
move
down
the
component_1
hierarchy
we
will
need
to
shift
the
db
connector_data_6
type
to
component_14
and
correspond
to
the
post’s
author
and
each
of
the
post’s
respectively
and
then
for
each
it
must
connector_17
the
connector_data_6
type
once
again
to
component_14
correspond
to
the
comment’s
author
move
from
a
component_16
connector_data_6
to
a
relational
connector_data_6
possibly
connector_17
the
connector_data_6
type
a
in
=
author
go
from
to
component_14
or
not
a
in
author
=
follower
go
from
component_14
to
component_14
be
what
i
connector_data_11
“switching
domains”
connector_17
the
db
connector_data_6
from
one
domain
to
another
large
preview
after
switch
to
a
domain
from
that
level
at
the
component_1
hierarchy
downwards
all
require
property
will
be
subject
to
the
domain
name
be
fetch
from
the
component_14
connector_data_6
represent
the
post’s
author
content
be
fetch
from
the
connector_data_6
represent
each
of
the
post’s
name
be
fetch
from
the
component_14
connector_data_6
represent
the
author
of
each
traverse
the
component_1
hierarchy
the
component_2
when
it
be
switch
to
a
domain
and
appropriately
update
the
query
to
fetch
the
relational
connector_data_6
for
example
if
we
need
to
show
connector_data_2
from
the
post’s
author
technology_16
submodule
author
will
connector_17
the
domain
at
that
level
from
to
the
correspond
component_14
and
from
this
level
downwards
the
db
connector_data_6
load
into
the
component_18
pass
to
the
be
the
component_14
then
submodules
component_14
name
and
component_14
avatar
under
author
will
load
property
name
and
avatar
under
the
component_14
connector_data_6
single
=
load
connector_data_8
with
connector_data_6
type
and
layout
title
=
load
property
title
content
=
load
property
content
author
=
switch
domain
from
to
component_14
base
on
property
author
component_14
layout
component_14
name
=
load
property
name
component_14
avatar
=
load
property
avatar
fetch
next
connector_data_9
in
the
follow
query
select
p
title
p
content
p
author
u
name
u
avatar
from
p
inner
join
component_19
u
where
p
=
and
p
author
=
u
in
summary
by
configure
each
appropriately
there
be
no
need
to
connector_18
the
query
to
fetch
connector_data_2
for
a
component_1
base
technology_3
the
query
be
automatically
produce
from
the
connector_data_5
of
the
component_1
hierarchy
itself
obtain
what
connector_data_8
must
be
load
by
the
dataloading
the
to
connector_3
for
each
load
connector_data_6
define
at
each
descendant
and
the
domain
switch
define
at
each
descendant
remove
replace
or
alter
any
will
automatically
update
the
query
after
connector_16
the
query
the
connector_3
connector_data_2
will
be
exactly
what
be
require
—
nothing
more
or
le
observe
connector_data_2
and
calculate
additional
propertiesstarting
from
the
dataloading
down
the
component_1
hierarchy
any
can
observe
the
connector_data_10
and
calculate
extra
connector_data_2
connector_data_12
base
on
them
or
feedback
requirement_4
which
be
place
under
entry
moduledata
for
instance
fetch
next
can
a
property
indicate
if
there
be
more
connector_data_10
to
fetch
or
not
base
on
this
feedback
requirement_4
if
there
aren’t
more
connector_data_9
the
will
be
disable
or
hide
{
moduledata
{
component_8
{
{
single
{
{
fetch
next
{
feedback
{
hasmoreresults
true
}
}
}
}
}
}
}
}
implicit
knowledge
of
require
connector_data_2
decrease
complexity
and
make
the
concept
of
an
“endpoint”
become
obsoleteas
show
above
the
component_1
base
component_2
can
fetch
exactly
the
require
connector_data_2
because
it
have
the
component_20
of
all
component_7
on
the
component_3
and
what
connector_data_2
be
require
by
each
component_1
then
it
can
make
the
knowledge
of
the
require
connector_data_2
implicit
the
advantage
be
that
define
what
connector_data_2
be
require
by
the
component_1
can
be
update
on
the
component_3
side
without
have
to
redeploy
technology_1
and
the
component_12
can
be
make
dumb
ask
the
component_3
to
provide
whatever
connector_data_2
it
be
that
it
need
thus
decreasing
the
complexity
of
the
component_12
side
component_4
in
addition
connector_19
the
component_2
to
connector_3
the
connector_data_2
for
all
component_7
for
a
specific
url
can
be
carry
out
simply
by
query
that
url
plus
the
extra
parameter
output=json
to
indicate
component_2
connector_data_2
instead
of
printing
the
component_8
hence
the
url
become
it
own
or
consider
in
a
different
way
the
concept
of
an
“endpoint”
become
obsolete
connector_data_3
to
fetch
resource
with
different
apis
large
preview
connector_3
subset
of
connector_data_2
connector_data_2
can
be
fetch
for
specific
find
at
any
level
of
the
component_1
hierarchywhat
happen
if
we
don’t
need
to
fetch
the
connector_data_2
for
all
in
a
component_8
but
simply
the
connector_data_2
for
a
specific
start
at
any
level
of
the
component_1
hierarchy
for
instance
if
a
connector_20
an
infinite
scroll
when
scroll
down
we
must
fetch
only
connector_data_2
for
this
and
not
for
the
other
on
the
component_8
this
can
be
accomplish
by
pattern_1
the
branch
of
the
component_1
hierarchy
that
will
be
include
in
the
connector_5
to
include
property
only
start
from
the
specify
and
ignore
everything
above
this
level
in
my
implementation
which
i
will
describe
in
an
upcoming
the
pattern_1
be
enable
by
parameter
modulefilter=modulepaths
to
the
url
and
the
selected
or
be
indicate
through
a
modulepaths
parameter
where
a
“module
path”
be
the
connector_data_1
of
start
from
the
top
most
to
the
specific
e
g
module1
=
module2
=
module3
have
path
module1
module2
module3
and
be
pass
a
a
url
parameter
a
module1
module2
module3
for
instance
in
the
component_1
hierarchy
below
every
have
an
entry
dbobjectids
module1
dbobjectids
module2
dbobjectids
module3
dbobjectids
module4
dbobjectids
module5
dbobjectids
module6
dbobjectids
then
connector_data_3
the
webpage
url
parameter
modulefilter=modulepaths
and
modulepaths
=module1
module2
module5
will
produce
the
follow
connector_5
module1
module2
module5
dbobjectids
module6
dbobjectids
in
essence
the
component_2
start
loading
connector_data_2
start
from
module1
=
module2
=
module5
that’s
why
module6
which
come
under
module5
also
bring
it
connector_data_2
while
module3
and
module4
do
not
in
addition
we
can
create
custom
pattern_1
to
include
a
pre
arrange
set
of
for
instance
connector_19
a
component_8
with
modulefilter=userstate
can
only
those
which
require
component_14
state
for
render
them
in
the
component_12
such
a
module3
and
module6
module1
module2
module3
dbobjectids
module5
module6
dbobjectids
the
connector_data_7
of
which
be
the
start
come
under
section
requestmeta
under
entry
filteredmodules
a
an
of
path
requestmeta
{
filteredmodules
module1
module2
module3
module1
module2
module5
module6
}
this
feature
allow
to
connector_12
an
uncomplicated
single
component_8
component_4
in
which
the
frame
of
the
be
load
on
the
initial
connector_data_3
component_8
navigation
top
dbobjectids
navigation
side
dbobjectids
component_8
content
dbobjectids
but
from
them
on
we
can
append
parameter
modulefilter=page
to
all
connector_data_3
url
pattern_1
out
the
frame
and
bring
only
the
component_8
content
component_8
navigation
top
navigation
side
component_8
content
dbobjectids
similar
to
pattern_1
userstate
and
component_8
describe
above
we
can
connector_12
any
custom
pattern_1
and
create
rich
component_14
experience
the
be
it
own
apia
show
above
we
can
pattern_1
the
component_2
connector_5
to
connector_3
connector_data_2
start
from
any
a
a
consequence
every
can
connector_21
with
itself
from
component_12
to
component_3
by
it
path
to
the
webpage
url
in
which
it
have
be
include
i
hope
you
will
excuse
my
over
excitement
but
i
truly
can’t
emphasize
enough
how
wonderful
this
feature
be
when
create
a
component_1
we
don’t
need
to
create
an
component_2
to
go
alongside
with
it
to
connector_3
connector_data_2
rest
graphql
or
anything
at
all
because
the
component_1
be
already
able
to
talk
to
itself
in
the
component_3
and
load
it
own
connector_data_2
—
it
be
completely
autonomous
and
self
serve
each
dataloading
export
the
url
to
connector_21
with
it
under
entry
dataloadsource
from
under
section
datasetmodulemeta
{
datasetmodulemeta
{
module1
{
{
module2
{
{
module5
{
meta
{
dataloadsource
technology_5
component_8
url
modulefilter=modulepaths&modulepaths
=module1
module2
module5
}
{
module6
{
meta
{
dataloadsource
technology_5
component_8
url
modulefilter=modulepaths&modulepaths
=module1
module2
module5
module6
}
}
}
}
}
}
}
}
}
}
fetch
connector_data_2
be
decouple
across
and
dryto
make
my
point
that
fetch
connector_data_2
in
a
component_1
base
component_2
be
highly
decouple
and
dry
don’t
repeat
yourself
i
will
first
need
to
show
how
in
a
schema
base
component_2
such
a
graphql
it
be
le
decouple
and
not
dry
in
graphql
the
query
to
fetch
connector_data_2
must
indicate
the
connector_data_2
for
the
component_1
which
include
subcomponents
and
these
also
include
subcomponents
and
so
on
then
the
topmost
component_1
need
to
what
connector_data_2
be
require
by
every
one
of
it
subcomponents
too
a
to
fetch
that
connector_data_2
for
instance
render
the
featureddirector
component_1
might
require
the
follow
subcomponents
render
featureddirector
div
country
{country}
{foreach
film
a
film}
film
film={film}
{
foreach}
div
render
film
div
title
{title}
pic
{thumbnail}
{foreach
actor
a
actor}
actor
actor={actor}
{
foreach}
div
render
actor
div
name
{name}
photo
{avatar}
div
in
this
scenario
the
graphql
query
be
connector_12
at
the
featureddirector
level
then
if
subcomponent
film
be
update
connector_data_3
the
title
through
property
filmtitle
instead
of
title
the
query
from
the
featureddirector
component_1
will
need
to
be
update
too
to
mirror
this
connector_data_7
graphql
have
a
versioning
mechanism
which
can
deal
with
this
problem
but
sooner
or
late
we
should
still
update
the
connector_data_7
this
produce
quality_attribute_10
complexity
which
could
be
difficult
to
handle
when
the
inner
component_7
often
connector_17
or
be
produce
by
third
party
developer
hence
component_7
be
not
thoroughly
decouple
from
each
other
similarly
we
want
to
render
directly
the
film
component_1
for
some
specific
film
for
which
then
we
must
also
connector_12
a
graphql
query
at
this
level
to
fetch
the
connector_data_2
for
the
film
and
it
actor
which
redundant
portion
of
the
same
query
will
live
at
different
level
of
the
component_1
connector_data_5
so
graphql
be
not
dry
because
a
component_1
base
component_2
already
how
it
component_7
wrap
each
other
in
it
own
connector_data_5
then
these
problem
be
completely
avoid
for
one
the
component_12
be
able
to
simply
connector_data_3
the
require
connector_data_2
it
need
whichever
this
connector_data_2
be
if
a
subcomponent
connector_data_2
connector_17
the
overall
component_20
already
and
adapt
immediately
without
have
to
modify
the
query
for
the
parent
component_1
in
the
component_12
therefore
the
be
highly
decouple
from
each
other
for
another
we
can
fetch
connector_data_2
start
from
any
path
and
it
will
always
the
exact
require
connector_data_2
start
from
that
level
there
be
no
duplicate
connector_22
whatsoever
or
even
connector_22
to
start
with
hence
a
component_1
base
component_2
be
fully
dry
this
be
another
feature
that
really
excite
me
and
make
me
connector_14
wet
yes
pun
fully
intend
sorry
about
that
connector_3
configuration
requirement_4
in
addition
to
component_16
datalet’s
revisit
the
example
of
the
feature
director
component_1
for
the
imdb
describe
above
which
be
create
—
you
guess
it
—
with
bootstrap
instead
of
hardcoding
the
bootstrap
classnames
or
other
property
such
a
the
title’s
technology_7
tag
or
the
avatar
max
width
inside
of
technology_1
whether
they
be
fix
inside
the
component_1
or
set
through
prop
by
parent
component_1
each
can
set
these
a
configuration
requirement_4
through
the
technology_3
so
that
then
these
can
be
directly
update
on
the
component_3
and
without
the
need
to
redeploy
technology_1
similarly
we
can
pass
such
a
the
title
feature
director
which
can
be
already
pattern_6
internationalize
on
the
component_3
side
avoid
the
need
to
quality_attribute_11
locale
configuration
to
the
front
end
similar
to
fetch
connector_data_2
by
traverse
the
component_1
hierarchy
the
component_2
be
able
to
connector_23
the
require
configuration
requirement_4
for
each
and
nothing
more
or
le
the
configuration
requirement_4
for
the
feature
director
component_1
might
look
this
{
modulesettings
{
component_8
{
{
feature
director
{
configuration
{
alert
alert
info
title
feature
director
titletag
h3
}
{
director
film
{
configuration
{
{
wrapper
avatar
mr
body
body
film
row
film
col
sm
}
avatarmaxsize
100px
}
{
film
actor
{
configuration
{
{
wrapper
card
image
card
img
top
body
card
body
title
card
title
avatar
img
thumbnail
}
}
}
}
}
}
}
}
}
}
}
please
notice
how
—
because
the
configuration
property
for
different
be
nest
under
each
module’s
level
—
these
will
never
collide
with
each
other
if
have
the
same
name
e
g
property
from
one
will
not
override
property
from
another
avoid
have
to
namespaces
for
high
degree
of
quality_attribute_12
achieve
in
the
applicationaccording
to
wikipedia
quality_attribute_12
mean
the
degree
to
which
a
system’s
component_7
be
separate
and
recombine
often
with
the
benefit
of
quality_attribute_13
and
variety
in
use
the
concept
of
quality_attribute_12
be
use
primarily
to
reduce
complexity
by
break
a
component_15
into
vary
degree
of
interdependence
and
independence
across
and
‘hide
the
complexity
of
each
part
behind
an
abstraction
and
interface’
be
able
to
update
a
component_1
from
the
component_3
side
without
the
need
to
redeploy
technology_1
have
the
consequence
of
quality_attribute_9
quality_attribute_3
and
quality_attribute_10
of
component_1
i
will
demonstrate
this
by
re
imagine
how
this
example
cod
for
technology_4
would
fare
in
a
component_1
base
technology_3
let’s
say
that
we
have
a
shareonsocialmedia
component_1
currently
with
two
item
facebookshare
and
twittershare
this
render
shareonsocialmedia
ul
li
connector_24
on
facebookshare
url={window
location
href}
li
li
connector_24
on
twitter
twittershare
url={window
location
href}
li
ul
but
then
technology_17
connector_14
kind
of
cool
so
we
need
to
an
item
instagramshare
to
our
shareonsocialmedia
component_1
too
render
shareonsocialmedia
ul
li
connector_24
on
facebookshare
url={window
location
href}
li
li
connector_24
on
twitter
twittershare
url={window
location
href}
li
li
connector_24
on
technology_17
instagramshare
url={window
location
href}
li
ul
in
the
technology_4
implementation
a
it
can
be
see
in
the
connector_10
a
component_1
instagramshare
under
component_1
shareonsocialmedia
force
to
redeploy
the
technology_1
for
the
latter
one
so
then
these
two
be
not
a
decouple
a
they
could
be
in
the
component_1
base
technology_3
though
we
can
readily
use
the
relationship
among
already
describe
in
the
component_2
to
couple
the
together
while
originally
we
will
have
this
connector_5
{
modulesettings
{
connector_24
on
social
{
{
connector_24
{
configuration
{
}
}
twitter
connector_24
{
configuration
{
}
}
}
}
}
}
after
technology_17
we
will
have
the
upgrade
connector_5
{
modulesettings
{
connector_24
on
social
{
{
connector_24
{
configuration
{
}
}
twitter
connector_24
{
configuration
{
}
}
technology_17
connector_24
{
configuration
{
}
}
}
}
}
}
and
by
iterate
all
the
requirement_4
under
modulesettings
connector_24
on
social
component_1
shareonsocialmedia
can
be
upgrade
to
show
the
instagramshare
component_1
without
the
need
to
redeploy
any
technology_1
hence
the
component_2
support
the
addition
and
removal
of
without
compromise
from
other
attain
a
high
degree
of
quality_attribute_12
requirement_7
component_12
side
pattern_7
connector_data_2
storethe
connector_3
component_16
connector_data_2
be
normalize
in
a
dictionary
connector_data_5
and
standardize
so
that
start
from
the
requirement_4
on
dbobjectids
any
piece
of
connector_data_2
under
component_16
can
be
reach
by
follow
the
path
to
it
a
indicate
through
entry
dbkeys
whichever
way
it
be
pattern_8
hence
the
component_21
for
organize
connector_data_2
be
already
requirement_7
to
the
component_2
itself
we
can
benefit
from
this
situation
in
several
way
for
instance
the
connector_data_2
for
each
connector_data_3
can
be
into
a
component_12
side
pattern_7
contain
all
connector_data_2
connector_data_3
by
the
component_14
throughout
the
component_22
hence
it
be
possible
to
avoid
an
external
connector_data_2
component_9
such
a
redux
to
the
component_4
i
mean
concern
the
handle
of
connector_data_2
not
concern
other
feature
such
a
the
undo
redo
the
collaborative
environment
or
the
time
travel
debug
also
the
component_1
base
connector_data_5
promote
pattern_7
the
component_1
hierarchy
quality_attribute_7
not
on
the
url
but
on
what
component_7
be
need
in
that
url
this
way
two
under
and
will
connector_24
the
same
component_1
hierarchy
and
the
connector_data_7
of
what
be
require
can
be
reutilized
across
them
a
a
consequence
all
property
other
than
component_16
connector_data_2
can
be
pattern_7
on
the
component_12
after
fetch
the
first
and
reutilized
from
then
on
so
that
only
component_16
connector_data_2
for
each
subsequent
must
be
fetch
and
nothing
else
quality_attribute_14
and
re
purposingthe
component_16
section
of
the
component_2
can
be
extend
enabling
to
categorize
it
connector_data_7
into
customize
subsection
by
default
all
component_16
connector_data_6
connector_data_2
be
place
under
entry
primary
however
we
can
also
create
custom
entry
where
to
place
specific
db
connector_data_6
property
for
instance
if
the
component_1
“films
recommend
for
you”
describe
early
on
show
a
connector_data_1
of
the
requirement_8
in
user’s
friend
who
have
watch
this
film
under
property
friendswhowatchedfilm
on
the
film
db
connector_data_6
because
this
requirement_4
will
connector_17
quality_attribute_7
on
the
requirement_8
in
component_14
then
we
connector_25
this
property
under
a
userstate
entry
instead
so
when
the
component_14
requirement_8
out
we
only
delete
this
branch
from
the
pattern_7
component_16
on
the
component_12
but
all
the
primary
connector_data_2
still
remain
{
component_16
{
userstate
{
film
{
{
friendswhowatchedfilm
}
}
}
primary
{
film
{
{
title
the
terminator
}
}
people
{
{
name
peter
}
{
name
john
}
}
}
}
}
in
addition
up
to
a
certain
point
the
connector_data_5
of
the
component_2
connector_5
can
be
re
purpose
in
particular
the
component_16
connector_data_10
can
be
in
a
different
connector_data_2
connector_data_5
such
a
an
instead
of
the
default
dictionary
for
instance
if
the
connector_data_6
type
be
only
one
e
g
film
it
can
be
technology_15
a
an
to
be
fee
directly
into
a
typeahead
component_1
{
title
star
war
episode
i
the
phantom
menace
thumbnail
}
{
title
star
war
episode
ii
attack
of
the
clone
thumbnail
}
{
title
the
terminator
thumbnail
}
support
for
aspect
orient
programmingin
addition
to
fetch
connector_data_2
the
component_1
base
component_2
can
also
connector_data_2
such
a
for
create
a
or
a
and
connector_16
any
kind
of
such
a
requirement_8
the
component_14
in
or
out
connector_26
requirement_8
requirement_1
and
so
on
there
be
no
restriction
any
requirement_3
provide
by
the
underlie
cm
can
be
invoke
through
a
—
at
any
level
along
the
component_1
hierarchy
we
can
any
number
of
and
each
can
connector_16
it
own
hence
not
all
must
necessarily
be
relate
to
the
expect
action
of
the
connector_data_3
a
when
do
a
put
or
delete
in
pattern_3
or
connector_26
a
mutation
in
graphql
but
can
be
to
provide
extra
requirement_3
such
a
connector_26
an
to
the
admin
when
a
component_14
create
a
so
by
define
the
component_1
hierarchy
through
connector_27
injection
or
configuration
the
component_2
can
be
say
to
support
aspect
orient
programming
“a
programming
paradigm
that
aim
to
increase
quality_attribute_12
by
allow
the
separation
of
cross
cut
concern
”recommended
connector_9
protect
your
with
feature
policyenhanced
securitythe
name
of
the
be
not
necessarily
fix
when
in
the
output
but
can
be
shorten
mangle
connector_17
randomly
or
in
short
make
variable
any
way
intend
while
originally
think
for
shorten
the
component_2
output
so
that
name
carousel
feature
or
drag
and
drop
component_14
image
could
be
shorten
to
a
base
notation
such
a
a1
a2
and
so
on
for
the
production
environment
this
feature
allow
to
frequently
connector_17
the
name
in
the
connector_5
from
the
component_2
for
quality_attribute_15
reason
for
instance
input
name
be
by
default
name
a
their
correspond
then
connector_6
username
and
password
which
be
to
be
render
in
the
component_12
a
input
type=
text
name=
{input_name}
and
input
type=
password
name=
{input_name}
respectively
can
be
set
vary
random
requirement_4
for
their
input
name
such
a
zwh8dseg
and
qbg7m6ef
today
and
c3omlbjo
and
c46ovgn6
tomorrow
make
it
more
difficult
for
spammer
and
requirement_9
to
target
the
versatility
through
alternative
modelsthe
nest
of
allow
to
branch
out
to
another
to
quality_attribute_16
for
a
specific
or
technology_18
or
connector_17
some
style
or
requirement_3
and
then
to
the
original
branch
for
instance
let’s
say
the
webpage
have
the
follow
connector_data_5
module1
module2
module3
module4
module5
module6
in
this
requirement_2
we’d
to
make
the
also
work
for
amp
however
module2
module4
and
module5
be
not
amp
quality_attribute_17
we
can
branch
these
out
into
similar
amp
quality_attribute_17
module2amp
module4amp
and
module5amp
after
which
we
keep
loading
the
original
component_1
hierarchy
so
then
only
these
three
be
substitute
and
nothing
else
module1
module2amp
module3
module4amp
module5amp
module6
this
make
it
fairly
easy
to
generate
different
output
from
a
single
codebase
fork
only
here
and
there
a
need
and
always
scoped
and
restrain
to
individual
demonstration
timethe
connector_28
the
component_2
a
explain
in
this
be
quality_attribute_6
in
this
open
component_5
pattern_9
i
have
quality_attribute_11
the
pop
component_2
under
technology_5
nextapi
getpop
for
demonstration
purpose
the
run
on
technology_19
so
the
url
permalinks
be
those
typical
to
technology_19
a
note
early
through
parameter
output=json
to
them
these
url
become
their
own
component_2
the
be
back
by
the
same
component_16
from
the
pop
demo
so
a
visualization
of
the
component_1
hierarchy
and
connector_3
connector_data_2
can
be
do
query
the
same
url
in
this
other
e
g
visit
the
technology_5
demo
getpop
u
leo
explain
the
connector_data_2
from
technology_5
nextapi
getpop
u
leo
output=json
the
connector_29
below
demonstrate
the
component_2
for
requirement_2
describe
early
on
the
homepage
a
single
an
author
a
connector_data_1
of
and
a
connector_data_1
of
component_14
an
pattern_1
from
a
specific
a
tag
pattern_1
which
require
component_14
state
and
pattern_1
to
bring
only
a
component_8
from
a
single
component_8
component_4
an
of
location
to
fee
into
a
typeahead
alternative
component_23
for
the
“who
we
are”
component_8
normal
printable
embeddable
connector_17
the
name
original
vs
mangle
pattern_1
connector_data_7
only
set
connector_data_2
plus
component_16
connector_data_2
example
of
technology_13
by
the
technology_3
large
preview
conclusiona
quality_attribute_9
component_2
be
a
step
stone
for
create
quality_attribute_18
easily
quality_attribute_4
and
powerful
component_4
in
this
i
have
describe
the
concept
power
a
component_1
base
component_2
which
i
believe
be
a
pretty
quality_attribute_9
technology_3
and
i
hope
i
have
convinced
you
too
so
far
the
design
and
implementation
of
the
component_2
have
involve
several
iteration
and
take
more
than
five
year
—
and
it’s
not
completely
ready
yet
however
it
be
in
a
pretty
decent
state
not
ready
for
production
but
a
a
quality_attribute_19
alpha
these
day
i
be
still
work
on
it
work
on
define
the
open
specification
connector_28
the
additional
pattern_5
such
a
render
and
connector_2
documentation
in
an
upcoming
i
will
describe
how
my
implementation
of
the
component_2
work
until
then
if
you
have
any
think
about
it
—
regardless
whether
positive
or
negative
—
i
would
love
to
connector_9
your
below
update
31st
jan
custom
query
capabilitiesalain
schlesser
that
an
component_2
which
can’t
be
custom
query
from
the
component_12
be
worthless
take
u
back
to
technology_20
a
such
it
can’t
compete
with
either
pattern_3
or
graphql
after
give
his
a
few
day
of
think
i
have
to
admit
that
he
be
right
however
instead
of
dismiss
the
component_1
base
component_2
a
a
well
intentioned
but
not
quite
there
yet
endeavour
i
do
something
much
quality_attribute_9
i
connector_14
to
connector_12
the
custom
query
capability
for
it
and
it
work
a
charm
in
the
follow
connector_10
connector_data_2
for
a
resource
or
collection
of
resource
be
fetch
a
typically
do
through
rest
however
through
parameter
we
can
also
specify
what
specific
connector_data_2
to
connector_3
for
each
resource
avoid
over
or
underfetching
connector_data_2
a
single
and
a
collection
of
parameter
fields=title
content
datetimea
component_14
and
a
collection
of
component_19
parameter
fields=name
username
descriptionthe
connector_29
above
demonstrate
fetch
connector_data_2
only
for
the
query
resource
what
about
their
relationship
for
instance
let’s
say
that
we
want
to
connector_3
a
connector_data_1
of
with
title
and
content
each
post’s
with
content
and
date
and
the
author
of
each
with
name
and
url
to
achieve
this
in
graphql
we
would
connector_12
the
follow
query
query
{
{
title
content
{
content
date
author
{
name
url
}
}
}
}
for
the
implementation
of
the
component_1
base
technology_3
i
have
pattern_6
the
query
into
it
correspond
“dot
syntax”
expression
which
can
then
be
supply
through
parameter
query
on
a
“post”
resource
this
requirement_4
be
fields=title
content
content
date
author
name
author
url
or
it
can
be
simplify
use
|
to
group
all
apply
to
the
same
resource
fields=title|content
content|date
author
name|url
when
connector_16
this
query
on
a
single
we
obtain
exactly
the
require
connector_data_2
for
all
involve
resource
{
datasetmodulesettings
{
dataload
dataquery
singlepost
{
dbkeys
{
author
component_14
}
}
}
datasetmoduledata
{
dataload
dataquery
singlepost
{
dbobjectids
}
}
component_16
{
{
{
title
a
lovely
tango
content
div
class=\
responsiveembed
container\
iframe
loading=
lazy
width=\
480\
height=\
270\
src=\
technology_5
\\
\\
www
youtube
com\\
embed\\
sxm3xyutc1s
feature=oembed\
frameborder=\
0\
allowfullscreen
\\
iframe
\\
div
\n
}
}
{
{
content
p
a
class=\
hashtagger
tag\
href=\
technology_5
\\
\\
newapi
getpop
org\\
tags\\
videos\\
\
#videos
\\
a
\\u00a0
a
class=\
hashtagger
tag\
href=\
technology_5
\\
\\
newapi
getpop
org\\
tags\\
tango\\
\
#tango
\\
a
\\
p
\n
date
aug
author
}
{
content
p
fjlasdjf
dlsfjdfsj
\\
p
\n
date
jun
author
}
}
component_14
{
{
name
leonardo
losoviz
url
technology_5
\\
\\
newapi
getpop
org\\
u\\
leo\\
}
{
name
leo2
url
technology_5
\\
\\
newapi
getpop
org\\
u\\
leo2\\
}
}
}
}
hence
we
can
query
resource
in
a
pattern_3
fashion
and
specify
schema
base
connector_22
in
a
graphql
fashion
and
we
will
obtain
exactly
what
be
require
without
over
or
underfetching
connector_data_2
and
normalize
connector_data_2
in
the
component_16
so
that
no
connector_data_2
be
duplicate
favourably
the
query
can
include
any
number
of
relationship
nest
deep
down
and
these
be
resolve
with
linear
complexity
time
worst
requirement_2
of
o
n+m
where
n
be
the
number
of
technology_21
that
switch
domain
in
this
requirement_2
and
author
and
m
be
the
number
of
connector_3
connector_data_10
in
this
requirement_2
+
+
component_14
and
average
requirement_2
of
o
n
this
be
more
quality_attribute_20
than
graphql
which
have
polynomial
complexity
time
o
n^c
and
suffer
from
increasing
connector_30
time
a
the
level
depth
increase
finally
this
component_2
can
also
apply
modifier
when
query
connector_data_2
for
instance
for
pattern_1
what
resource
be
connector_3
such
a
can
be
do
through
graphql
to
achieve
this
the
component_2
simply
sit
on
top
of
the
component_4
and
can
conveniently
use
it
requirement_3
so
there
be
no
need
to
reinvent
the
wheel
for
instance
parameter
filter=posts&searchfor=internet
will
pattern_1
all
contain
internet
from
a
collection
of
the
implementation
of
this
feature
will
be
describe
on
an
upcoming
rb
ra
yk
il
explore
more
onapigraphqljavascriptperformancesmashing
newslettertips
on
front
end
&
ux
connector_23
weekly
in
your
inbox
the
thing
you
can
actually
use
front
end
&
ux
workshop
onlinewith
practical
takeaway
live
component_22
video
component_24
and
a
friendly
q&a
typescript
in
lessonseverything
typescript
with
walkthroughs
and
example
and
other
book
browse
all
smash
magazine
topicsaccessibilityandroidanimationappscssdesigndesign
patternsdesign
systemse
commercefreebiesgraphicshtmlillustratorinspirationiosjavascriptmobilepattern
librariesperformancephotoshoppluginsreactresponsive
designservice
workerssketchtypographyuiusabilityuser
experiencewallpapersweb
designwordpressworkflowwith
a
commitment
to
quality
content
for
the
design
find
by
vitaly
friedman
and
sven
lennartz
2006–2022
smash
be
proudly
run
on
netlify
font
by
latinotype
✎
connector_18
for
uscontact
usabout
u
impressum
privacy
policymembership
logindelivery
timesadvertiseback
to
top
