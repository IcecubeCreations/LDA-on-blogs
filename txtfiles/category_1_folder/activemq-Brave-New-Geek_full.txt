technology_1
–
brave
geek
skip
to
content
brave
geek
introspection
of
a
engineer
home
about
me
archive
real
kinetic
technology_2
tag
technology_1

on

2014october

2020dissecting
connector_data_1
component_1
disclaimer



–
the
benchmark
and
requirement_1
analysis
present
in
this
should
not
be
rely
on
this
be
connector_1
roughly
six
year
ago
and
at
the
time
be
the
connector_data_2
of
my
exploration
of
various
pattern_1
component_2
the
benchmark
be
not
connector_2
in
a
meaningful
way
which
i
discuss
in
a
follow
up

this
will
remain
for
posterity
and

purpose
but
i
do
not
claim
that
this
connector_data_3
be
quality_attribute_1
or
useful
continue
my
series
on
connector_data_1
component_3
i
spend
this
weekend
dissect
various
technology_3
for
perform
quality_attribute_2
connector_data_1
in
this
analysis
i
look
at
a
few
different
aspect
include
component_4
characteristic
ease
of
deployment
and
quality_attribute_3
and
requirement_1
quality
the
connector_data_1
component_1
have
be
categorize
into
two
group
brokerless
and
pattern_2
brokerless
connector_data_1
component_1
be
pattern_3
such
that
there
be
no
middleman
involve
in
the
transmission
of
connector_data_1
while
pattern_2
component_1
have
some
sort
of
component_5
in
between

the
component_6
i’ll
be
analyze
be
brokerless
nanomsg
technology_4
pattern_2
technology_5
nats
technology_6
kestrel
nsq
technology_7
technology_8
technology_9
nats
to
start
let’s
look
at
the
requirement_1
metric
since
this
be
arguably
what
people
care
the
most
about
i’ve
measure
two
key
metric
quality_attribute_4
and
quality_attribute_5
all
test
be
run
on
a
macbook
pro


ghz
i7
16gb
ram
these
test
be
evaluate
a
pattern_4
topology
with
a
single
component_7
and
single
component_8
this
provide
a
quality_attribute_6
baseline
it
would
be
interest
to
benchmark
a
quality_attribute_7
up
topology
but
require
more
instrumentation
the
use
for
benchmarking
connector_1
in
go
be
quality_attribute_8
on
technology_10
the
connector_data_4
below
shouldn’t
be
take
a
gospel
a
there
be
likely
optimization
that
can
be
make
to
squeeze
out
requirement_1
gain
connector_3
connector_data_5
be
welcome
quality_attribute_4
benchmark
quality_attribute_4
be
the
number
of
connector_data_6
per
second
the
component_2
be
able
to
component_9
but
what’s
important
to
note
here
be
that
there
be
no
single
“throughput”
that
a
component_3
might
have
we’re
connector_4
connector_data_6
between
two
different

so
what
we
observe
be
a
“sender”
quality_attribute_4
and
a
“receiver”
throughput—that
be
the
number
of
connector_data_6
that
can
be
connector_5
per
second
and
the
number
of
connector_data_6
that
can
be
connector_6
per
second
this
test
be
perform
by
connector_4



1kb
connector_data_6
and
measure
the
time
to
connector_7
and
connector_8
on
each
side
many
requirement_1
test
tend
to
use
small
connector_data_6
in
the
range
of

to

byte
i
choose
1kb
because
it’s
more
representative
of
what
you
might
see
in
a
production
environment
although
this
vary
requirement_2
by
requirement_2
for
connector_data_1
orient
technology_11
component_2
only
one
pattern_2
be
use
in
most
requirement_2
a
cluster
environment
would
yield
much
quality_attribute_6
connector_data_2
unsurprisingly
there’s
high
quality_attribute_4
on
the
connector_4
side
what’s
interest
however
be
the
disparity
in
the
sender
to
receiver
ratio
technology_4
be
capable
of
connector_4
over



connector_data_6
per
second
but
be
only
able
to
connector_8
about


second
in
contrast
nanomsg
connector_9
shy
of



second
but
can
connector_8
almost



now
let’s
take
a
look
at
the
pattern_2
connector_data_1
component_3
intuitively
we
observe
that
pattern_2
connector_data_1
component_1
have
dramatically
le
quality_attribute_4
than
their
brokerless
counterpart
by
a
couple
order
of
magnitude
for
the
most
part
half
the
pattern_2
component_1
have
a
quality_attribute_4
below


connector_data_1
second
the
number
for
technology_8
might
be
a
bit
mislead
though
despite
provide
pattern_5
requirement_3
it’s
not
really
design
to
operate
a
a
quality_attribute_9
pattern_1
component_3
in
a
similar
fashion
to
technology_12
technology_8
disconnect
slow
component_10
and
it’s
important
to
point
out
that
it
be
not
able
to
quality_attribute_10
handle
this
volume
of
connector_data_1
a
such
we
consider
it
an
outlier
technology_6
and
technology_9
nats
have
similar
requirement_1
characteristic
to
technology_8
but
be
able
to
quality_attribute_10
handle
the
connector_data_1
volume
without
intermittent
failure
the
go
implementation
of
nats
gnatsd
have
exceptional
quality_attribute_4
for
a
pattern_2
connector_data_1
component_3
outlier
aside
we
see
that
the
pattern_2
component_1
have
fairly
uniform
quality_attribute_4
unlike
the
brokerless
technology_3
there
be
little
to
no
disparity
in
the
sender
to
receiver
ratio
which
themselves
be
all
very
close
to
one
quality_attribute_5
benchmark
the
second
key
requirement_1
metric
be
connector_data_1
quality_attribute_5
this
measure
how
long
it
take
for
a
connector_data_1
to
be
connector_10
between

intuition
might
tell
u
that
this
be
simply
the
inverse
of
quality_attribute_4
i
e
if
quality_attribute_4
be
connector_data_1
second
quality_attribute_5
be
second
connector_data_1
however
by
look
closely
at
this
image
borrow
from
a
technology_4
white
paper
we
can
see
that
this
isn’t
quite
the
requirement_2
the
reality
be
that
the
quality_attribute_5
per
connector_data_1
connector_5
over
the
wire
be
not
uniform
it
can
vary
wildly
for
each
one
in
truth
the
relationship
between
quality_attribute_5
and
quality_attribute_4
be
a
bit
more
involve
unlike
quality_attribute_4
however
quality_attribute_5
be
not
measure
at
the
sender
or
the
receiver
but
rather
a
a
whole
but
since
each
connector_data_1
have
it
own
quality_attribute_5
we
will
look
at
the
average
of
all
of
them
go
further
we
will
see
how
the
average
connector_data_1
quality_attribute_5
fluctuate
in
relation
to
the
number
of
connector_data_6
connector_7
again
intuition
tell
u
that
more
connector_data_6
mean
more
component_3
which
mean
high
quality_attribute_5
a
we
do
before
we’ll
start
by
look
at
the
brokerless
component_2
in
general
our
hypothesis
prove
correct
in
that
a
more
connector_data_6
be
connector_5
through
the
component_2
the
quality_attribute_5
of
each
connector_data_1
increase
what’s
interest
be
the
taper
at
the


point
in
which
quality_attribute_5
appear
to
increase
at
a
slow
rate
a
we
approach



connector_data_1
another
interest
observation
be
the
initial
spike
in
quality_attribute_5
between


and


connector_data_1
which
be
more
pronounce
with
nanomsg
it’s
difficult
to
pinpoint
causation
but
these
connector_11
might
be
indicative
of
how
connector_data_1
pattern_6
and
other
requirement_4
technology_13
traversal
optimization
be
connector_2
in
each
technology_3
more
connector_data_7
point
provide
quality_attribute_6
visibility
we
see
some
similar
pattern_7
with
pattern_2
component_1
and
also
some
interest
one
technology_8
behave
in
a
similar
manner
a
before
with
an
initial
quality_attribute_5
spike
and
then
a
quick
taper
off
it
differ
in
that
the
taper
become
essentially
constant
right
after


connector_data_1
nsq
doesn’t
exhibit
the
same
spike
in
quality_attribute_5
and
behave
more
or
le
linearly
kestrel
fit
our
hypothesis
notice
that
technology_9
nats
and
nats
hardly
even
register
on
the
requirement_5
they
exhibit
surprisingly
low
quality_attribute_5
and
unexpected
relationship
with
the
number
of
connector_data_1
interestingly
the
connector_data_1
quality_attribute_5
for
technology_9
nats
and
nats
appear
to
be
constant
this
be
counterintuitive
to
our
hypothesis
you
have
notice
that
technology_6
technology_1
and
technology_7
be
absent
from
the
above
requirement_5
this
be
because
their
quality_attribute_5
tend
to
be
order
of
magnitude
high
than
the
other
pattern_2
connector_data_1
component_3
so
technology_5
and
technology_7
be
group
into
their
own
technology_14
category
i’ve
also
include
technology_6
since
it’s
in
the
same
ballpark
here
we
see
that
rabbitmq’s
quality_attribute_5
be
constant
while
technology_5
and
technology_6
be
linear
what’s
unclear
be
the
apparent
disconnect
between
their
quality_attribute_4
and
mean
quality_attribute_5
qualitative
analysis
now
that
we’ve
see
some
empirical
connector_data_7
on
how
these
different
technology_3
perform
i’ll
take
a
look
at
how
they
work
from
a
pragmatic
point
of
pattern_8
connector_data_1
quality_attribute_4
and
quality_attribute_11
be
important
but
it
isn’t
very
practical
if
the
technology_3
be
difficult
to
use
quality_attribute_12
or
maintain
technology_4
and
nanomsg
technically
speak
nanomsg
isn’t
a
connector_data_1
component_3
but
rather
a
connector_data_8
style
technology_3
for
perform
quality_attribute_2
pattern_1
through
a
variety
of
convenient
pattern_7
a
a
connector_data_2
there’s
nothing
to
quality_attribute_12
aside
from
embed
the
technology_3
itself
within
your
component_11
this
make
deployment
a
non
issue
nanomsg
be
connector_1
by
one
of
the
technology_4
author
and
a
i
discuss
before
work
in
a
very
similar
way
to
that
technology_3
from
a
development
standpoint
nanomsg
provide
an
overall
clean
technology_15
unlike
technology_12
there
be
no
notion
of
a
component_12
in
which
technology_16
be
bind
to
furthermore
nanomsg
provide
pluggable
transport
and
pattern_1
technology_17
which
make
it
more
open
to
extension
it
additional
build
in
quality_attribute_13
technology_17
also
make
it
quite
appeal
technology_12
it
guarantee
that
connector_data_6
will
be
connector_12
atomically
intact
and
order
but
do
not
guarantee
the
delivery
of
them
partial
connector_data_6
will
not
be
connector_12
and
it’s
possible
that
some
connector_data_6
won’t
be
connector_12
at
all
the
library’s
author
martin
sustrik
make
this
abundantly
clear
guarantee
delivery
be
a
myth
nothing
be
100%
guarantee
that’s
the
nature
of
the
world
we
live
in
what
we
should
do
instead
be
to
build
an
internet

component_2
that
be
resilient
in
face
of
failure
and
connector_13
around
damage
the
philosophy
be
to
use
a
combination
of
topology
to
build
resilient
component_6
that
in
these
guarantee
in
a
best
effort
sort
of
way
on
the
other
hand
nanomsg
be
still
in
beta
and
not
be
consider
production
ready
consequently
there
aren’t
a
lot
of
resource
quality_attribute_8
and
not
much
of
a
development
around
it
technology_4
be
a
battle
test
pattern_1
technology_3
that’s
be
around
since

some
perceive
it
a
a
predecessor
to
nanomsg
but
what
nano
lack
be
where
technology_4
thrives—a
flourish
developer
and
a
deluge
of
resource
and
support
material
for
many
it’s
the
de
facto
technology_18
for
build
fast
pattern_9
quality_attribute_2
pattern_1
component_6
that
quality_attribute_7
nanomsg
technology_4
be
not
a
connector_data_1
orient
technology_11
and
simply
operate
a
a
connector_data_8
abstraction
in
term
of
quality_attribute_14
it’s
very
much
the
same
a
nanomsg
although
it
component_4
be
marginally
more
involve
technology_5
and
technology_7
technology_5
and
technology_7
be
implementation
of
technology_19
they
act
a
pattern_2
which
ensure
connector_data_6
be
connector_12
technology_5
and
technology_7
support
both
persistent
and
non
persistent
delivery
by
default
connector_data_6
be
connector_1
to
disk
such
that
they
survive
a
pattern_2
restart
they
also
support
pattern_10
and
pattern_9
connector_4
of
connector_data_6
with
the
former
have
substantial
impact
on
quality_attribute_5
to
guarantee
delivery
these
pattern_2
use
connector_data_1
acknowledgement
which
also
incur
a
massive
quality_attribute_5
penalty
a
far
a
quality_attribute_15
and
fault
tolerance
go
these
pattern_2
support
cluster
through
connector_14
storage
or
connector_14
nothing
component_1
can
be
replicate
across
cluster
technology_20
so
there
be
no
single
point
of
failure
or
connector_data_1
loss
technology_14
be
a
non
trivial
technology_17
which
it
creator
claim
to
be
over
engineer
these
additional
guarantee
be
make
at
the
expense
of
major
complexity
and
requirement_1
requirement_6
off
fundamentally
component_13
be
more
difficult
to
connector_2
and
use
since
they’re
connector_data_1
pattern_2
technology_5
and
technology_7
be
additional
move
part
that
need
to
be
manage
in
your
quality_attribute_2
component_2
which
bring
deployment
and
quality_attribute_3
cost
the
same
be
true
for
the
remain
connector_data_1
component_1
be
discuss
nats
and
technology_9
nats
nats
gnatsd
be
a
pure
go
implementation
of
the
technology_9
nats
pattern_1
component_2
nats
be
quality_attribute_2
pattern_1
rethink
to
be
le
enterprisey
and
more
lightweight
this
be
in
direct
contrast
to
component_6
technology_1
technology_7
and
others
apcera’s
derek
collison
the
library’s
author
and
former
technology_21
architect
describe
nats
a
“more
a
nervous
system”
than
an
requirement_7
connector_data_1
component_3
it
doesn’t
do
persistence
or
connector_data_1
transaction
but
it’s
fast
and
easy
to
use
cluster
be
support
so
it
can
be
build
on
top
of
with
high
quality_attribute_15
and
failover
in
mind
and
component_13
can
be
sharded
unfortunately
tl
and
technology_22
be
not
yet
support
in
nats
they
be
in
the
technology_9
nats
but
on
the
roadmap
a
we
observe
early
nats
perform
far
quality_attribute_6
than
the
original
technology_23
implementation
component_13
can
be
use
interchangeably
with
nats
and
technology_9
nats
technology_6
originally
develop
by
linkedin
technology_6
connector_15
pattern_4
pattern_1
through
a
quality_attribute_2
connector_16
requirement_8
it’s
design
to
operate
a
a
cluster
that
can
be
connector_17
by
large
amount
of
component_10
horizontal
quality_attribute_16
be
do
effortlessly
use
technology_24
so
that
additional
component_14
and
pattern_2
can
be
introduce
seamlessly
it
also
transparently
take
care
of
cluster
rebalancing
technology_6
us
a
persistent
connector_16
requirement_8
to
component_15
connector_data_6
on
the
pattern_2
unlike
other
quality_attribute_17
component_1
which
usually
remove
persist
connector_data_6
on
consumption
technology_6
retain
them
for
a
configure
period
of
time
this
mean
that
connector_data_6
can
be
“replayed”
in
the
that
a
component_8
fail
technology_24
make
manage
technology_6
cluster
relatively
easy
but
it
do
introduce
yet
another
element
that
need
to
be
maintain
that
say
technology_6
connector_18
a
great
component_4
and
technology_25
have
an
excellent
go
component_10
connector_19
sarama
that
make
interfacing
with
technology_6
very
quality_attribute_18
kestrel
kestrel
be
a
quality_attribute_2
connector_data_1
component_3
open
component_16
by
twitter
it’s
intend
to
be
fast
and
lightweight
because
of
this
it
have
no
concept
of
cluster
or
failover
while
technology_6
be
build
from
the
grind
up
to
be
cluster
through
technology_24
the
onus
of
connector_data_1
partitioning
be
put
upon
the
component_13
of
kestrel
there
be
no
cross
connector_20
between
technology_20
it
make
this
requirement_6
off
in
the
name
of
quality_attribute_19
it
feature
quality_attribute_17
component_3
item
expiration
pattern_11
connector_21
and
fanout
component_1
while
operate
over
technology_26
or
memcache
technology_17
kestrel
be
design
to
be
small
but
this
mean
that
more
work
must
be
do
by
the
developer
to
build
out
a
quality_attribute_9
pattern_1
component_2
on
top
of
it
technology_6
seem
to
be
a
more
“all
in
one”
solution
nsq
nsq
be
a
pattern_1
component_17
build
by
bitly
i
use
the
word
component_17
because
there’s
a
lot
of
technology_18
build
around
nsq
to
make
it
useful
for
real
time
quality_attribute_2
connector_data_1
the
daemon
that
connector_8
component_3
and
connector_22
connector_data_6
to
component_13
be
connector_19
nsqd
the
daemon
can
run
standalone
but
nsq
be
design
to
run
in
a
a
quality_attribute_2
decentralized
topology
to
achieve
this
it
leverage
another
daemon
connector_19
nsqlookupd
nsqlookupd
act
a
a
component_18
discovery
mechanism
for
nsqd
instance
nsq
also
provide
nsqadmin
which
be
a
web
ui
that
display
real
time
cluster
statistic
and
act
a
a
way
to
perform
various
administrative
connector_data_9
clear
component_1
and
manage
topic
by
default
connector_data_6
in
nsq
be
not
quality_attribute_17
it’s
primarily
design
to
be
an
in
memory
connector_data_1
component_3
but
component_3
size
can
be
configure
such
that
after
a
certain
point
connector_data_6
will
be
connector_1
to
disk
despite
this
there
be
no
build
in
pattern_12
nsq
us
acknowledgement
to
guarantee
connector_data_1
delivery
but
the
order
of
delivery
be
not
guarantee
connector_data_6
can
also
be
connector_12
more
than
once
so
it’s
the
developer’s
responsibility
to
introduce
idempotence
similar
to
technology_6
additional
technology_20
can
be

to
an
nsq
cluster
seamlessly
it
also
connector_18
both
an
technology_27
and
technology_28
technology_15
which
mean
you
don’t
actually
need
a
component_10
technology_3
to
connector_23
connector_data_6
into
the
component_2
despite
all
the
move
part
it’s
actually
quite
easy
to
quality_attribute_12
it
component_4
be
also
easy
to
use
and
there
be
a
number
of
component_10
technology_3
quality_attribute_8
technology_8
last
up
be
technology_8
while
technology_8
be
great
for
lightweight
pattern_1
and
transient
storage
i
can’t
advocate
it
use
a
the
technology_29
of
a
quality_attribute_2
pattern_1
component_2
it
pattern_5
be
fast
but
it
capability
be
limit
it
would
require
a
lot
of
work
to
build
a
quality_attribute_9
component_2
there
be
solution
quality_attribute_6
suit
to
the
problem
such
a
those
describe
above
and
there
be
also
some
quality_attribute_16
concern
with
it
these
matter
aside
technology_8
be
easy
to
use
it’s
easy
to
quality_attribute_12
and
manage
and
it
have
a
relatively
small
footprint
quality_attribute_20
on
the
use
requirement_2
it
can
be
a
great
choice
for
real
time
pattern_1
a
i’ve
explore
before
conclusion
the
purpose
of
this
analysis
be
not
to
present
some
sort
of
“winner”
but
instead
showcase
a
few
different
option
for
quality_attribute_2
connector_data_1
there
be
no
“one
size
fit
all”
option
because
it
quality_attribute_20
entirely
on
your
need
some
use
requirement_2
require
fast
fire
and
forget
connector_data_1
others
require
delivery
guarantee
in
fact
many
component_6
will
connector_data_10
for
a
combination
of
these
my
hope
be
that
this
dissection
will
offer
some
insight
into
which
solution
work
best
for
a
give
problem
so
that
you
can
make
an
intelligent
decision
follow
@tyler_treat
popularyou
cannot
have
exactly
once
deliveryeverything
you
about
quality_attribute_5
be
wrongbenchmarking
connector_data_1
component_3
latencystructuring
a
requirement_9
infrastructure
organizationa
look
at
nanomsg
and
quality_attribute_13
technology_17
why
technology_4
shouldn
t
be
your
first
choice
recent
sre
doesn’t
quality_attribute_7
connector_data_11
a
requirement_9
infrastructure
organization
we
suck
at
meet
connector_24
big
win
with
small
team
on
tight
deadline
continuous
deployment
for
technology_30
glue
category
algorithm
requirement_10
technology_31
technology_30
bash
benchmarking
requirement_11
requirement_9
component_19
science
pattern_13
consult
culture
connector_data_7
connector_data_12
component_20
design
pattern_7
devops
quality_attribute_2
component_6
economics
gcp
go
infinitum
technology_32
technology_33
technology_34
liftbridge
requirement_12
mathematics
pattern_1
postmortem
technology_35
real
kinetic
quality_attribute_21
architecture
engineering
technology_36
component_6
theory
unix
archive


























































tag
agile
algorithm
technology_31
component_21
component_22
architecture
benchmarking
requirement_11
cap
theorem
requirement_9
requirement_9
requirement_13
consensus
consistency
consult
culture
component_20
design
pattern_7
devops
quality_attribute_2
requirement_8
quality_attribute_2
component_6
engineering
culture
engineering
empathy
fault
tolerance
gcp
go
infinitum
technology_32
technology_6
connector_data_1
orient
technology_11
connector_data_1
component_1
pattern_1
pattern_14
nats
nats
connector_25
ops
requirement_1
component_9
technology_37
development
productivity
raft
quality_attribute_13
serverless
technology_38
engineering
connector_26
component_9
component_6
proudly
powered
by
technology_39
