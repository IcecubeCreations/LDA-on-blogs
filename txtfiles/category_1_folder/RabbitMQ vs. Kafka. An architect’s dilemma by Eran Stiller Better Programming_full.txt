technology_1
vs
technology_2
an
architect’s
dilemma
|
by
eran
still
|
quality_attribute_1
programmingopen
in
apphomenotificationslistsstorieswritepublished
inbetter
programmingeran
stillerfollowfeb
2020·6
min
readsaverabbitmq
vs
kafkaan
architect’s
dilemmaphoto
by
justin
luebke
on
unsplashintroductionas
a
architect
deal
with
a
lot
of
pattern_1
base
component_1
i
often
encounter
the
ever
repeat
question
“should
i
use
technology_1
or
technology_2
”
for
some
reason
many
developer
pattern_2
these
technology_3
a
quality_attribute_2
while
this
be
true
for
some
requirement_1
there
be
various
underlie
difference
between
these
component_2
a
a
connector_data_1
different
scenario
require
a
different
solution
and
choose
the
wrong
one
might
severely
impact
your
ability
to
design
develop
and
maintain
your
solution
the
goal
of
this
piece
be
first
to
introduce
the
basic
pattern_3
pattern_4
pattern_5
then
it
continue
to
present
both
technology_1
and
technology_2
and
their
internal
connector_data_2
part
highlight
the
critical
difference
between
these
component_2
their
various
advantage
and
disadvantage
and
how
to
choose
between
the
two
pattern_3
pattern_4
patternsasynchronous
pattern_4
be
a
pattern_4
technology_4
where
connector_data_3
production
by
a
component_3
be
decouple
from
it
component_4
by
a
component_5
when
deal
with
pattern_4
component_1
we
typically
identify
two
pattern_4
pattern_5
—
connector_data_3
pattern_6
and
publish
subscribe
connector_data_3
queueingin
the
connector_data_3
component_6
connector_1
pattern_5
component_7
temporally
decouple
component_8
from
component_5
multiple
component_8
can
connector_2
connector_data_4
to
the
same
component_6
however
when
a
component_5
component_9
a
connector_data_3
it’s
lock
or
remove
from
the
component_6
and
be
no
long
quality_attribute_3
only
a
single
component_5
connector_3
a
specific
connector_data_3
connector_data_3
queuingas
a
side
note
if
the
component_5
fail
to
component_4
a
certain
connector_data_3
the
pattern_4
component_2
typically
the
connector_data_3
to
the
component_6
where
it’s
make
quality_attribute_3
for
other
component_5
besides
temporal
decouple
component_7
allow
u
to
quality_attribute_4
component_8
and
component_10
independently
a
well
a
provide
a
degree
of
fault
tolerance
against
component_4
error
publish
subscribein
the
pattern_7
or
pub
sub
connector_1
pattern_5
a
single
connector_data_3
can
be
connector_4
and
component_4
by
multiple
pattern_8
concurrently
publish
subscribethis
pattern_5
allow
a
pattern_9
for
example
to
connector_5
all
pattern_8
that
something
have
happen
in
the
component_1
many
pattern_6
component_11
often
associate
pattern_10
with
the
term
topic
in
technology_1
topic
be
a
specific
type
of
pattern_10
implementation
a
type
of
exchange
to
be
exact
but
for
this
piece
i
refer
to
topic
a
a
representation
of
pattern_10
a
a
whole
generically
speak
there
be
two
type
of
subscription
an
ephemeral
subscription
where
the
subscription
be
only
active
a
long
the
component_5
be
up
and
run
once
the
component_5
shut
down
their
subscription
and
yet
to
be
component_4
connector_data_4
be
lose
a
quality_attribute_5
subscription
where
the
subscription
be
maintain
a
long
a
it’s
not
explicitly
delete
when
the
component_5
shut
down
the
pattern_4
component_2
maintain
the
subscription
and
connector_data_3
component_4
can
be
resume
late
rabbitmqrabbitmq
be
an
implementation
of
a
connector_data_3
pattern_11
—
often
refer
to
a
a
component_12
bus
it
natively
support
both
pattern_4
pattern_5
describe
above
other
popular
implementation
of
connector_data_3
pattern_11
include
technology_5
technology_6
technology_7
component_12
bus
and
quality_attribute_6
component_6
component_12
sqs
all
of
these
implementation
have
a
lot
in
common
many
concept
describe
in
this
piece
apply
to
most
of
them
queuesrabbitmq
support
classic
connector_data_3
pattern_6
out
of
the
component_13
a
developer
define
name
component_6
and
then
pattern_9
can
connector_2
connector_data_4
to
that
name
component_6
component_5
in
turn
use
the
same
component_6
to
connector_6
connector_data_4
to
component_4
them
connector_data_3
exchangesrabbitmq
connector_7
pattern_10
via
the
use
of
connector_data_3
exchange
a
pattern_9
publish
it
connector_data_4
to
a
connector_data_3
exchange
without
who
the
pattern_8
of
these
connector_data_4
be
each
component_5
wish
to
subscribe
to
an
exchange
create
a
component_6
the
connector_data_3
exchange
then
component_7
produce
connector_data_4
for
component_10
to
connector_8
it
can
also
pattern_12
connector_data_4
for
some
pattern_8
base
on
various
connector_9
rule
technology_1
connector_data_3
exchangeit’s
important
to
note
technology_1
support
both
ephemeral
and
quality_attribute_5
subscription
a
component_5
can
decide
the
type
of
subscription
they’d
to
employ
via
rabbitmq’s
technology_8
due
to
rabbitmq’s
architecture
we
can
also
create
a
hybrid
approach
—
where
some
pattern_8
form
component_5
group
that
work
together
component_4
connector_data_4
in
the
form
of
compete
component_10
over
a
specific
component_6
in
this
manner
we
connector_10
the
pattern_10
pattern_5
while
also
allow
some
pattern_8
to
quality_attribute_4
up
to
handle
connector_4
connector_data_3
pub
sub
and
pattern_6
combinedapache
kafkaapache
technology_2
isn’t
an
implementation
of
a
connector_data_3
pattern_11
instead
it’s
a
quality_attribute_7
connector_11
component_2
unlike
technology_1
which
be
base
on
component_7
and
exchange
kafka’s
storage
pattern_13
be
connector_10
use
a
component_14
transaction
requirement_2
technology_2
also
provide
a
connector_12
component_15
to
component_4
connector_12
in
real
time
and
a
connector
component_15
for
easy
requirement_3
with
various
connector_data_5
component_16
however
these
be
out
of
the
scope
of
this
piece
the
requirement_4
vendor
provide
alternative
solution
for
kafka’s
storage
pattern_13
these
solution
include
technology_7
hub
and
to
some
extent
technology_9
kinesis
connector_data_5
connector_13
there
be
also
requirement_4
specific
and
open
component_16
alternative
to
kafka’s
connector_13
component_4
capability
but
again
these
be
out
of
the
scope
of
this
topicskafka
doesn’t
connector_10
the
notion
of
a
component_6
instead
technology_2
connector_14
collection
of
component_17
in
category
connector_15
topic
for
each
topic
technology_2
maintain
a
component_14
requirement_2
of
connector_data_3
each
component_14
be
an
order
immutable
sequence
of
component_18
where
connector_data_4
be
continually
append
technology_2
append
connector_data_4
to
these
component_14
a
they
arrive
by
default
it
u
a
round
robin
partitioner
to
spread
connector_data_4
uniformly
across
component_14
component_3
can
modify
this
behavior
to
create
logical
connector_12
of
connector_data_3
for
example
in
a
pattern_14
component_19
we
might
want
to
create
logical
connector_data_3
connector_12
accord
to
every
message’s
tenant
in
an
iot
scenario
we
might
want
to
have
each
producer’s
identity
connector_data_6
to
a
specific
component_14
constantly
make
sure
all
connector_data_4
from
the
same
logical
connector_13
connector_data_6
to
the
same
component_14
guarantee
their
delivery
in
order
to
component_5
technology_2
producersconsumers
connector_8
connector_data_4
by
maintain
an
offset
or
index
to
these
component_14
and
connector_16
them
sequentially
a
single
component_5
can
connector_8
multiple
topic
and
component_10
can
quality_attribute_4
up
to
the
number
of
component_14
quality_attribute_3
a
a
connector_data_1
when
create
a
topic
one
should
carefully
consider
the
expect
quality_attribute_8
of
pattern_4
on
that
topic
a
group
of
component_10
work
together
to
connector_8
a
topic
be
connector_15
a
component_5
group
kafka’s
component_15
typically
handle
the
balance
of
component_14
component_4
between
component_10
in
a
component_5
group
and
the
connector_17
of
consumers’
current
component_14
offset
technology_2
consumersimplementing
pattern_4
pattern_5
with
kafkakafka’s
implementation
connector_data_7
quite
well
to
the
pattern_10
pattern_5
a
component_3
can
connector_2
connector_data_4
to
a
specific
topic
and
multiple
component_5
group
can
connector_8
the
same
connector_data_3
each
component_5
group
can
quality_attribute_4
individually
to
handle
the
load
since
component_10
maintain
their
component_14
offset
they
can
choose
to
have
a
quality_attribute_5
subscription
that
maintain
it
offset
across
restart
or
an
ephemeral
subscription
which
throw
the
offset
away
and
restart
from
the
late
component_18
in
each
component_14
every
time
it
start
up
however
it’s
a
le
than
perfect
fit
for
the
connector_data_3
component_6
pattern_5
of
we
could
have
a
topic
with
a
single
component_5
group
to
emulate
classic
connector_data_3
component_6
nevertheless
this
have
multiple
drawback
part
of
this
piece
discus
at
length
it’s
important
to
note
technology_2
retain
connector_data_4
in
component_14
up
to
a
preconfigured
period
regardless
of
whether
component_10
connector_8
these
connector_data_3
this
retention
mean
component_10
be
free
to
reread
past
connector_data_3
furthermore
developer
can
also
use
kafka’s
storage
pattern_13
for
connector_18
mechanism
such
a
component_16
and
audit
requirement_2
close
wordswhile
technology_1
and
technology_2
be
sometimes
quality_attribute_2
their
implementation
be
very
different
from
each
other
a
a
connector_data_1
we
can’t
pattern_2
them
a
member
of
the
same
category
of
technology_10
one
be
a
connector_data_3
pattern_11
and
the
other
be
a
quality_attribute_7
connector_11
component_2
a
solution
architect
we
should
acknowledge
these
difference
and
actively
consider
which
of
these
type
of
solution
we
should
use
for
a
give
scenario
part
connector_19
these
difference
and
provide
guidance
on
when
to
use
each
further
readingif
you’d
to
connector_20
more
regard
the
internal
implementation
of
technology_1
and
technology_2
i
recommend
the
follow
resource
technology_11
component_20
explain
—
rabbitmqintroduction
to
technology_12
technology_2
19more
from
quality_attribute_1
programmingfollowadvice
for
programmer
subscribe
to
our
daily
digest
technology_13
technology_14
@bttrprogramming
subscriberead
more
from
quality_attribute_1
programmingrecommended
from
mediumoffed19559403please
connector_21
my
technology_15
loan
calculator
home
work
aetherus
zhouimplementing
pattern_15
component_6
with
technology_16
and
otp
21tony
wilson
jesurajmulticolor
for
text
in
swiftmichael
chihow
to
make
the
most
out
of
programming
tutorialsrusben
guzmancreating
a
cooldown
component_1
in
unitymike
mcmillaninlevel
up
codinghow
to
to
component_21
connector_22
templatespranav
pathakwhy
and
how
big
mnc’s
u
technology_17
justin
lakeapi
design
first
vs
firstabouthelptermsprivacyget
the
appget
startederan
stiller877
followersa
architect
consultant
and
instructor
codevalue
founder
&
cto
regional
director
mrd
&
pattern_16
on
technology_7
technology_13
still
followmore
from
mediumlove
sharmaindev
geniuseverything
about
quality_attribute_7
connector_data_3
queuetuğrul
bayrakidempotent
consumersphillip
kigenyiindev
scribbles1
pattern_17
foundationlima
vadakarainjohn
lewis
&
partner
engineeringlearnings
from
a
pattern_17
migration
journeyhelpstatuswritersblogcareersprivacytermsaboutknowable
