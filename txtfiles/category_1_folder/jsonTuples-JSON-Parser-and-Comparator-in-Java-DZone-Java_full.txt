jsontuples
technology_1
requirement_1
and
comparator
in
technology_2
technology_2
technology_2
zone
thanks
for
visit
today
edit
profile
manage
subscription
how
to
coding_keyword_1
to
submission
guideline
sign
out
pattern_1
profile
coding_keyword_1
coding_keyword_1
an
manage
my
draft
over

million
developer
have
join

requirement_2
in
join
refcardz
trend
report
webinars
zone
|
agile
requirement_3
requirement_4
requirement_5
component_1
devops
requirement_6
iot
technology_2
pattern_2
open_source
requirement_7
quality_attribute_1
web
dev
technology_2
zone
jsontuples
technology_1
requirement_1
and
comparator
in
technology_2
jsontuples
technology_1
requirement_1
and
comparator
in
technology_2
more
about
the
jsontuples
technology_3
that
can
requirement_8
technology_1
text
to
immutable
requirement_9
by
william
jiang
·
jul


·
technology_2
zone
·

connector_1
tweet

56k
pattern_1
join
the
and
connector_2
the
full
member
experience
join
for
free
the
jsontuples
technology_3
par
technology_1
text
to
immutable
technology_1
requirement_9
which
can
then
be
convert
to
connector_data_1
or
connector_data_2
for
crud

and
then
back
to
technology_1
requirement_9
a
a
unique
feature
jsontuples
can
compare
two
technology_1
text
or
compare
any
two
technology_2
connector_data_3
to
connector_2
their
minimum
delta
in
second
background
before
this
project
inspire
with
the
concept
of
the
functional
programming
paradigm
another
technology_2
technology_3
functionextensions
be
publish
to
make
connector_data_4
immutable
refer
technology_2
without
care
if
they
throw
exception
or
not
and
enable
complex
requirement_10
component_2
base
on
connector_data_2
base
run
time
evaluation
when
i
try
to
develop
a
prototype
pattern_3
component_3
test
technology_4
by
use
technology_1
text
a
template
to
compose
connector_data_5
or
match
connector_3
automatically
i
find
the
technology_1
requirement_1
quality_attribute_2
be
either
too
complex
to
set
up
or
not
fast
or
convenient
enough
to
convert
technology_1
to
from
technology_2
connector_data_3
a
i
have
expect
consider
the
quality_attribute_3
of
technology_1
syntax
i
try
to
connector_4
this
technology_1
requirement_1
with
a
simplify
architecture
over
tuple
from
the
functionextensions
technology_3
to
exploit
the
benefit
of
the
pure
and
immutable
connector_data_6
once
the
technology_1
requirement_1
be
do
i
try
to
find
a
way
to
compare
two
technology_1
text
to
connector_2
their
minimum
difference
thankfully
this
attempt
turn
out
satisfactory
by
compare
two
big
technology_2
connector_data_3
in
second
to
connector_2
the
delta
connector_5
start
the
follow
connector_6
to
your
pom
technology_5
connector_6
coding_keyword_2
io
technology_6
cruisoring
coding_keyword_2
coding_keyword_3
jsontuples
coding_keyword_3
version



version
connector_6
alternatively
you
can
connector_2
the
package
from
technology_7
central
directly
connector_data_2
between
technology_1
requirement_9
and
technology_2
connector_data_3
the
technology_1
requirement_9
here
refer
to


define
in
thejsontuples
project
the
technology_2
connector_data_3
refer
to
common
technology_2
type
primitive
requirement_9
or
connector_data_6
a
well
a
generic
connector_data_2
collection
and
coding_keyword_4
the
jsontuples
be
connector_4
base
on
the
connector_data_7
from
technology_8

with
direct
mapping
between
technology_1
requirement_9
or


define
in
jsontuples
and
technology_2
connector_data_6
a
show
below
constant
sub

technology_2
equivalent
technology_1
sample
note
ijsonvalue
t
jsonvalue
t
coding_keyword_5
coding_keyword_5
coding_keyword_5
coding_keyword_5
be
invalid
true
true
true
requirement_11
sensitive
thus
true
be
not
connector_7
false
false
false
false
be
invalid
jsonstring
coding_keyword_6
a
coding_keyword_6
special
char
\n
or
\t
would
be
trim
by
default
jsonnumber
coding_keyword_7
biginteger
double
bigdecimal

45e5
the
actual
connector_data_6
connector_1
doesn
t
affect
equal
which
would
compare
by
tostring
ijsonvalue
namedvalue
connector_data_2
coding_keyword_6
connector_data_6
coding_keyword_8
connector_data_2
coding_keyword_6
connector_data_6
{
coding_keyword_9

name
tom
}
coding_keyword_8
have
connector_4
connector_data_2
coding_keyword_6
connector_data_6
the
namedvalueis
use
internally
ijsonvalue
ijsonvalue
connector_data_1
connector_data_6
jsonarray
connector_data_6
or
collection
coding_keyword_5
true

abc
{}
jsonarray
can
hold
any
number
of
ijsonvalue
all
these
type
extend
the
generic
tuple
type
and
be
thus
immutable
the
major
define
here
be
ijsonvalue
for
any
technology_1
requirement_9
with
solid
mean
except
namedvalue
that
be
similar
to
connector_data_2
entry
and
use
a
build
block
of
coding_keyword_8
by
assign
a
jsonvalue
with
a
name
of
jsonstring
of
the
seven
type
represent
by
ijsonvalue
the
first
five
quality_attribute_4
type
coding_keyword_5
true
false
jsonstring
jsonnumber
be
refer
a
leaf
technology_9
since
their
technology_2
counterpart
cannot
be
split
further
and
while
coding_keyword_8
and
jsonarray
contain
zero
to
multiple
of
them
the
ijsonable
getleafcount
reflect
how
many
leaf
technology_9
it
have
by
count
the
occurrence
of
the
first

quality_attribute_4
type
the
two
major
technology_1
requirement_9
be
coding_keyword_8
and
jsonarray
that
could
be
treat
a
technology_2
connector_data_2
coding_keyword_6
connector_data_6
and
collection
connector_data_6
or
connector_data_6
naturally
under
the
hood
thejsonobject
retain
the
order
of
it
element
with
linkedhashmap
requirement_8
technology_1
text
and
connector_8
the
requirement_8
technology_1
requirement_9
the
jsontuples
can
requirement_8
give
technology_1
text
to
any
of
the
seven
typesijsonvalues
in
the
above
component_4
then
connector_9
the
getobject
or
asmutableobject
would
coding_keyword_10
the
contain
technology_2
requirement_9
a
immutable
or
mutable
technology_2
connector_data_3
for
convenient
component_5
component_6
use
to
requirement_8
technology_1
text
constructor
of
all
above
technology_1
requirement_9
in
bold
coding_keyword_5
true
false
jsonstring
jsonnumber
coding_keyword_8
and
jsonarray
be
protect
and
would
be
create
by
connector_9
the
follow
apis
the
strict
technology_1
syntax
connector_10
be
not
activate
by
default
coding_keyword_11
to
requirement_8
a
give
coding_keyword_6
or
part
of
a
charsequence
to
a
specific
type
of
ijsonvalue
ijsonvalue
requirement_1
requirement_8
charsequence
generate
ijsonvalue
base
on
the
give
technology_1
text
content
if
the
technology_1
text
be
of
right
syntax
the
ijsonvalue
connector_data_8
shall
be
cast
to
one
of
coding_keyword_5
true
false
jsonstring
jsonnumber
coding_keyword_8
or
jsonarray
jsonstring
parsestring
coding_keyword_6
jsontext
the
give
technology_1
text
must
be
wrap
by
a
pair
of
quotation
mark
jsonvalue
requirement_8
charsequence
range
expect
and
requirement_8
a
part
of
the
give
technology_1
component_7
a
one
of
coding_keyword_5
true
false
jsonstring
jsonnumber
coding_keyword_8
requirement_8
coding_keyword_6
valuestring
expect
the
valuestring
be
enclose
by
{
and
}
and
cast
the
connector_data_8
of
requirement_1
requirement_8
to
be
coding_keyword_8
jsonarray
requirement_8
coding_keyword_6
valuestring
expect
the
valuestring
be
enclose
by
and
and
cast
the
connector_data_8
of
requirement_1
requirement_8
to
be
jsonarray
coding_keyword_11
ijsonvalue
jsonify
connector_data_6
connector_data_6
of
utility
technology_2
be
the
only
component_3
use
to
convert
technology_2
connector_data_3
to
technology_1
requirement_9
define
in
jsontuples
it
would
connector_11
the
type
of
the
give
connector_data_6
to
connector_data_9
a
above
for
type
not
cover
above
by
default
the
asjsonstringfromothers
connector_data_6
connector_data_6
would
be
connector_12
to
generate
a
jsonstring
but
it
be
possible
to
inject
serialization
de
serialization
into
utility
classconverters
that
be
a
connector_data_2

tuple2
where
the
requirement_9
of
a
give
include
both
serialization
and
de
serialization
for
a
concern
type
of
connector_data_6
then
the
serialization
would
be
connector_12
to
convert
the
match
instance
to
it
text
equivalent
the
above
have
multiple
variation
to
connector_7
optional
argument
basic
example
of
requirement_8
technology_1
text
there
be
no
config
need
before
connector_9
the
coding_keyword_11

the
unit
test
below
show
how
ijsonvalue
requirement_1
requirement_8
charsequence
can
be
use
to
requirement_8
different
text
to
correspond
ijsonvalue
type
@test
coding_keyword_12
coding_keyword_13
parsetext_getrightijsonvalue
{
requirement_8
text
of
coding_keyword_5
true
or
false
assertalltrue
jsonvalue
coding_keyword_5
==
requirement_1
requirement_8
false
coding_keyword_5
assertalltrue
jsonvalue
true
==
requirement_1
requirement_8
false
true
assertalltrue
jsonvalue
false
==
requirement_1
requirement_8
false
false
text
of
a
number
to
jsonnumber
jsonnumber
number
=
jsonnumber
requirement_1
requirement_8
false


assertequals


number
getobject
text
enclose
by
s
would
be
requirement_8
a
jsonstring
jsonstring
coding_keyword_6
=
jsonstring
requirement_1
requirement_8
false
\
abc
\n
\t\
\r
assertequals
abc
coding_keyword_6
getobject
if
jsonstring
forbidunescapedcontrols
be
set
to
false
then
special
character
\n
\r
would
not
be
remove
try
{
revokable
register
jsonstring
forbidunescapedcontrols
v
jsonstring
forbidunescapedcontrols
=
v
false
coding_keyword_6
=
jsonstring
requirement_1
requirement_8
false
\
abc
\n
\t\
\r
assertequals
abc
\n
\t
coding_keyword_6
getobject
}finally
{
revokable
revokeall
}
connector_data_2
alike
text
would
be
requirement_8
a
coding_keyword_8
coding_keyword_8
connector_data_6
=
coding_keyword_8
requirement_1
requirement_8
false
{\
id\

\
name\
coding_keyword_5
\
courses\
\
english\
\
math\
\
science\
}
assertequals

connector_data_6
connector_2
coding_keyword_9
assertallnull
connector_data_6
connector_2
name
assertequals

connector_data_6
{
english
math
science
}
connector_data_6
connector_2

coding_keyword_4
alike
text
would
be
requirement_8
a
jsonarray
jsonarray
coding_keyword_4
=
jsonarray
requirement_1
requirement_8
false

coding_keyword_5
true
\
abc\
false
coding_keyword_5
{\
id\
123}
assertequals

coding_keyword_4
connector_2

assertalltrue
coding_keyword_4
size
==

coding_keyword_4
contain
coding_keyword_5
coding_keyword_4
containsall
coding_keyword_4
aslist
true
abc
assertequals

connector_data_6
{false
null}
coding_keyword_4
connector_2

connector_data_2
mapat5
=
connector_data_2
coding_keyword_4
connector_2

assertequals

mapat5
connector_2
coding_keyword_9
}
the
asserttrue
and
assertequals
be
helper

in
assert
technology_2
of
functionextensions



to
assert
multiple
expression
or
compare
element
of
two
coding_keyword_4
or
collection
the
above
test
illustrate
how
coding_keyword_8
can
be
refer
to
a
a
connector_data_2
coding_keyword_6
connector_data_6
while
jsonarray
can
refer
it
element
a
a
connector_data_1
however
all
connector_13
on
them
would
connector_2
unsupportedoperationexception
due
to
the
immutable
nature
inherit
from
tuple
requirement_8
in
lenient
or
strict
mode
with
error
highlight
by
assume
the
technology_1
text
to
be
syntax
correct
the
requirement_1
would
work
in
lenient
mode
by
default
to
connector_2
a
bit
high
quality_attribute_5
and
neglect
any
error
that
bring
no
ambiguity
a
the
unit
test
below
@test
coding_keyword_12
coding_keyword_13
validatelenientparsing_withunexpectedchars_ignoreifnoconfusion
{
assertequals
{\
id\

\
name\
\
alice\
}
requirement_1
requirement_8
false
xxx{\
id\
xxx

\
name\
\
alice\
}
tojsonstring
coding_keyword_5
assertequals
{\
id\

\
name\
\
alice\
}
requirement_1
requirement_8
false
xxx{\
\
\
id\

\
name\
\
alice\
}xxx
tojsonstring
coding_keyword_5
assertequals
{\
id\

\
name\
\
alice\
}
requirement_1
requirement_8
false
{xxx\
id\

xxx
\
name\
\
alice\
}
tojsonstring
coding_keyword_5
assertequals
{\
id\

\
name\
\
alice\
}
requirement_1
requirement_8
false
{\
id\

\
name\
\
alice\
}
coding_keyword_5
tojsonstring
coding_keyword_5
}
notice
there
be
many
illegal
xxx
would
be
neglect
when
people
can
still
guess
out
the
intend
content
on
the
other
hand
it
be
possible
to
enforce
more
strict
syntax
connector_10
by
connector_9
ijsonvalue
requirement_8
boolean
isstrictly
charsequence
jsontext
with
isscritly=true
with
a
overhead
of

5%
then
the
same
technology_1
text
would
cause
error
throw
@test
coding_keyword_12
coding_keyword_13
validatestrictparsing_withunexpectedchars_throwexceptions
{
assertexception
requirement_1
requirement_8
true
\
id\
\
id\

\
name\
\
alice\
}
nullpointerexception

colon
shall
only
present
in
coding_keyword_8
assertexception
requirement_1
requirement_8
true
{\
id\
\
id\

\
name\
\
alice\
}
illegalstateexception

wrong
state
before
colon
lastname=\
id\
laststringvalue=\
id\
assertexception
requirement_1
requirement_8
true
xxx{\
id\
xxx

\
name\
\
alice\
}
illegalstateexception

only
white
space
be
expect
assertexception
requirement_1
requirement_8
true
{\
id\
xxx

\
name\
\
alice\
}
illegalstateexception

only
white
space
be
expect
assertexception
requirement_1
requirement_8
true
{\
id\
\
\

\
name\
\
alice\
}
illegalstateexception

two
jsonstrings
must
be
seperated
by
a
control
char
assertexception
requirement_1
requirement_8
true
{\
id\

\
name\
\
alice\
}xxx
illegalstateexception

only
white
space
be
expect
assertexception
requirement_1
requirement_8
true
{\
id\

\
name\
\
alice\
}
illegalstateexception

miss
requirement_9
coding_keyword_6
}
by
connector_14
the
coding_keyword_11
variable
of
requirement_1
parse_strictly
to
true
to
turn
off
the
default
lenient
requirement_8
connector_9
ijsonvalue
requirement_8
charsequence
jsontext
would
enforce
the
strict
syntax
connector_10
automatically
when
there
be
syntax
error
find
when
requirement_8
in
either
lenient
or
strict
mode
the
problematic
text
would
be
highlight
for
further
correction
stringify
technology_1
requirement_9
with
indent
instruction
in
the
ijsonable
that
be
the
super
of
ijsonvalue
the
indent
argument
within
coding_keyword_6
tojsonstring
coding_keyword_6
indent
determine
how
to
generate
a
coding_keyword_6
representation
of
an
ijsonvalue
instance
empty
coding_keyword_6
would
connector_data_8
in
the
common
indent
beautiful
form
that
be
easy
to
identify
the
pattern_4
connector_data_10
of
technology_1
element
the
tostring
would
produce
the
same
thing
coding_keyword_5
would
produce
the
most
condense
form
all
space
out
of
jsonstring
would
be
remove
other
coding_keyword_6
compose
of
whitespaces

only
would
fill
each
line
of
the
coding_keyword_6
with
the
specify
lead
space
the
unit
test
below
show
how
it
work
@test
coding_keyword_12
coding_keyword_13
tojsonstring
{
coding_keyword_8
obj
=
coding_keyword_8
requirement_8
{
\
age\

\
other\
\
none\
\
name\
coding_keyword_5
}
assertequals
{\
age\

\
other\
\
none\
\
name\
null}
obj
tojsonstring
coding_keyword_5
assertequals
{\n
\
age\

\n
\
other\
\
none\
\n
\
name\
null\n}
obj
tojsonstring
assertequals
{\n
\
age\

\n
\
other\
\
none\
\n
\
name\
null\n
}
obj
tojsonstring
assertequals
{\n
\
age\

\n
\
other\
\
none\
\n
\
name\
null\n
}
obj
tojsonstring
}
since
technology_1
text
represent
connector_data_2
or
coding_keyword_4
be
use
most
coding_keyword_8
requirement_8
coding_keyword_6
valuestring
and
jsonarray
requirement_8
coding_keyword_6
valuestring
act
a
syntactic
sugar
to
cast
the
ijsonvalue
to
coding_keyword_8
or
jsonarray
behind
the
scene
connector_15
requirement_8
connector_data_8
a
technology_2
connector_data_3
a
show
in
the
basic
requirement_8
example
the
requirement_8
jsonarray
and
coding_keyword_8
can
be
connector_16
a
immutable
connector_data_1
connector_data_6
and
connector_data_2
coding_keyword_6
connector_data_6
respectively
by
connector_9
the
connector_data_6
getobject
define
in
the
ijsonvalue

and
the
connector_data_6
coding_keyword_10
would
compose
by
common
technology_2
connector_data_3
coding_keyword_5
booleans
coding_keyword_6
number
and
combination
of
them
a
coding_keyword_4
or
connector_data_2
but
they
cannot
be
modify
to
perform
crud

theobject
asmutableobject
of
ijsonvalue
shall
be
connector_12
to
connector_2
the
quality_attribute_6
version
the
example
below
suggest
@test
coding_keyword_12
coding_keyword_13
testasmutableobject_canbeupdated
{
coding_keyword_8
obj
=
coding_keyword_8
requirement_8
{
\
age\

\
other\
\
none\
\
name\
coding_keyword_5
\
members\
\
alice\
\
bob\
}
connector_data_2
coding_keyword_6
connector_data_6
connector_data_2
=
connector_data_2
coding_keyword_6
connector_data_6
obj
asmutableobject
assertequals

connector_data_2
connector_2
age
assertequals
coding_keyword_5
connector_data_2
connector_2
name
connector_data_2
put
age

connector_data_2
remove
name
connector_data_1
member
=
connector_data_1
connector_data_2
connector_2
member
member
remove
alice
member


alan
member

carter
coding_keyword_8
update
=
utility
asjsonobject
connector_data_2
assertequals
{\
age\

\
other\
\
none\
\
members\
\
alan\
\
bob\
\
carter\
}
update
tojsonstring
coding_keyword_5
}
at
the
end
of
the
above
cod
the
utility
asjsonobject
connector_data_2
would
turn
the
technology_2
connector_data_2
to
a
coding_keyword_8
that
might
be
suitable
for
big
technology_2
connector_data_6
for
small
one
a
you
can
find
from
the
unit
test
of
this
project
i
tend
to
initialize
a
connector_data_2
or
connector_data_1
by
requirement_8
a
coding_keyword_6
then
connector_9
getobject
would
connector_1
some
type
convert
any
technology_2
connector_data_3
to
ijsonvalues
a
the
above
example
illustrate
the
utility
asjsonobject
connector_data_6
would
convert
a
technology_2
connector_data_2
to
a
coding_keyword_8
a
more
generic
component_3
be
ijsonvalue
jsonify
connector_data_6
connector_data_6
by
default
it
enable
the
follow
conversion
in
order
technology_2
coding_keyword_5
to
jsonvalue
coding_keyword_5
an
ijsonvalue
instance
to
itself
directly
technology_2
true
false
to
jsonvalue
true
or
jsonvalue
false
respectively
technology_2
coding_keyword_6
connector_data_3
to
jsonstring
connector_data_6
technology_2
number
connector_data_3
to
jsonnumber
connector_data_6
technology_2
connector_data_2
to
coding_keyword_8
technology_2
collection
or
coding_keyword_4
to
jsonarray
for
unknown
type
of
technology_2
connector_data_6
jsonstring
would
be
use
to
represent
their
tostring
you
might
have
notice
that
convert
unknown
technology_2
connector_data_3
to
their
tostring
s
be
not
quite
reasonable
that
be
mainly
due
to
miss
something
technology_10
to
serialize
deserialize
technology_2
to
from
technology_1
coding_keyword_6
that
be
out
of
the
scope
of
this
project
but
the
follow
unit
test
show
how
it
can
be
support
if
helper
be
define
coding_keyword_12
student{
coding_keyword_12
coding_keyword_6
name
coding_keyword_12
coding_keyword_14
age
coding_keyword_12
student
coding_keyword_6
name
coding_keyword_14
age
{
this
name
=
name
this
age
=
age
}
coding_keyword_12
coding_keyword_6
tojson
{
coding_keyword_10
coding_keyword_6
technology_11
{\
name\
\
%s\
\
age\
%d}
name
age
}
}
@test
coding_keyword_12
coding_keyword_13
testjsonify_withstudentinstances
{
functionthrowable
connector_data_6
ijsonvalue
studenttojson
=
student
requirement_1
requirement_8
student
student
tojson
utility
classconverters
put
student

tuple
create
studenttojson
coding_keyword_5
connector_data_2
studentinclass
=
hashmap
{{
put
year
year7
put
active
true
put
student
coding_keyword_4
aslist
student
alice

student
bob

}}
assertequals
{\
year\
\
year7\
\
active\
true
\
students\
{\
name\
\
alice\
\
age\
12}
{\
name\
\
bob\
\
age\
13}
}
utility
jsonify
studentinclass
tojsonstring
coding_keyword_5
}
though
not
in
the
scope
of
jsontuples
if
there
be
an
technology_10
alike
technology_3
to
requirement_8
the
pojos
in
your
work
project
then
it
shall
be
quite
convenient
to
handle
literately
any
technology_2
connector_data_3
to
and
from
technology_1
text
requirement_7
of
jsontuples
unlike
other
technology_1
requirement_1
the
jsontuples
apply
a
simplify
high
level
state
component_8
to
component_5
the
character
of
technology_1
text
under
requirement_8
in
three
step
delimit
the
scope
of
coding_keyword_6
enclose
by
quote
and
neglect
any
char
inside
include
the
escape
quote
that
be
behind
of
an
opening
with
back
slash
\
ahead
extract
any
jsonstrings
directly
neglect
all
char
except
control
char
use
in
technology_1
that
be
left_brace
{
right_brace
}
left_bracket
right_bracket
comma
colon
perform
strict
syntax
connector_10
if
need
only
the
above
control
char
would
be
feed
into
a
state
component_8
to
harvest
the
requirement_8
connector_data_11
recursively
with
only
the
previous
control
char
consider
unless
there
be
any
syntax
error
encounter
and
then
the
requirement_1
need
to
revisit
the
start
of
the
text
cause
the
error
the
component_5
of
technology_1
text
would
hardly
revisit
the
previous
content
before
the
last
control
and
even
the
control
char
identify
early
would
be
connector_17
without
evaluate
for
the
second
time
when
run
the
unit
test
below
from
my

core
i7
7700hq
@

8g
laptop
to
requirement_8
the

1m
technology_1
text

time
@test
coding_keyword_12
coding_keyword_13
test6104kjson
{
coding_keyword_6
jsontext
=
resourcehelper
gettextfromresourcefile
catalog
technology_8
coding_keyword_14
jsontextlength
=
jsontext
length
coding_keyword_6
sortedstring
=
coding_keyword_5
for
coding_keyword_14
i
=

i

i++
{
coding_keyword_8
connector_data_8
=
logger
m
measurement
start
requirement_8
technology_1
text
of
%dk
jsontextlength

coding_keyword_8
requirement_1
requirement_8
false
jsontext
coding_keyword_14
leafcount
=
checknotnull
connector_data_8
fail
to
requirement_8
the
josn
text
getleafcount
ijsonvalue
sortedvalue
=
logger
m
measurement
start
sorting
coding_keyword_8
with
%d
leaf
technology_9
leafcount
connector_data_8
getsorted
comparator
naturalorder
sortedstring
=
logger
m
measurement
start
tojsonstring
coding_keyword_5
sortedvalue
tojsonstring
coding_keyword_5
}
measurement
purge
loglevel
warn
}
the
screenshot
below
show
the
average
and
max
time
to
requirement_8
the

1m
be
279ms
and
306ms
respectively
almost
20m
s
quality_attribute_5
for
such
middle
size
technology_1
text
it
be
not
so
ideal
when
requirement_8
huge
technology_1

for
the
181m
technology_1

if
you
connector_1
it
a
technology_12
\temp\citylots
technology_8
then
the
follow
test
@test
@ignore
coding_keyword_12
coding_keyword_13
test181mjson
{
coding_keyword_6
jsontext
=
logger
m
measurement
start
load
technology_1
a
coding_keyword_6
resourcehelper
gettextfromresourcefile
technology_12
temp
citylots
technology_8
coding_keyword_14
jsontextlength
=
jsontext
length
coding_keyword_6
sortedstring
=
coding_keyword_5
coding_keyword_8
connector_data_8
=
logger
m
measurement
start
requirement_8
technology_1
text
of
%dk
jsontextlength

coding_keyword_8
requirement_1
requirement_8
true
jsontext
assertnotnull
connector_data_8
fail
to
requirement_8
the
technology_1
text
measurement
purge
loglevel
warn
}
the
requirement_2
show
it
might
take


second
to
component_5

megabyte
connector_data_12
intermittently
that
might
happen
because
of
technology_2
garbage
collection
though
run
the
same
test
from
a
slow
pc
with
8g
memory
only
would
crash
the
technology_13
when
it
take
exponentially
long
time
to
component_5

megabyte
after
100m
a
show
in
the
requirement_2
image
requirement_8
181m
technology_1
from
pc
with
8g
mem
txt
the
jsontuples
shall
be
responsive
enough
to
handle
technology_1
of
normal
size
compare
two
ijsonvalues
or
compare
two
technology_2
connector_data_3
after
connector_18
the
requirement_8

i
start
to
exploit
the
possibility
of
compare
two
ijsonvalue
instance
to
show
their
difference
it
turn
out
to
be
more
difficult
than
connector_18
the
requirement_8
scenario
to
be
compare
actually
it
be
not
always
difficult
the
combination
of
ijsonvalues
to
be
compare
can
be
classify
a
the
follow
scenario
between
quality_attribute_4
ijsonvalue
type
namely
coding_keyword_5
true
false
jsonstring
jsonnumber
that
be
also
leaf
technology_9
of
compose
any
technology_1
content
compare
their
tostring
would
be
fair
enough
so
thus
jsonnumber
coding_keyword_5
orjsonstring
coding_keyword_5
would
be
equal
to
jsonvalue
coding_keyword_5
the
jsonnumber
coding_keyword_7
valueof

would
be
equal
to
jsonnumber
1l
between
different
type
of
ijsonvalue
compare
a
jsonnumber
with
a
jsonstring
or
coding_keyword_8
vs
jsonarray
then
a
jsonarray
compose
by
these
two
ijsonvalue
instance
would
explain
everything
between
two
coding_keyword_8
instance
their
name
the
key
of
two
connector_data_2
can
associate
their
entry
easily
to
allow
further
comparison
of
the
correspond
requirement_9
between
two
jsonarray
instance
now
come
the
interest
part
if
the
position
of
their
element
matter
then
it
be
straight
connector_19
compare
two
coding_keyword_8
instance
with
their
position
a
the
implicit
key
if
the
position
of
their
element
doesn
t
matter
then
bind
their
element
to
connector_2
the
least
difference
set
before
further
compare
the
first
three
and
a
half
scenario
be
quite
quality_attribute_4
and
worth
no
discussion
but
the
last
requirement_11
of
compare
two
jsonarray
instance
when
their
order
be
neglect
be
the
real
challenge
especially
when
both
of
them
contain
hundred
or
thousand
of
similar
element
however
i
believe
it
be
also
quite
use
when
consider
them
a
two
set
or
two
connector_data_13
create
from
identical
set
of
element
when
one
of
them
connector_2
one
or
several
element
in
the
middle
remove
immutable
tuples
with
immutable
hashcodes
and
signature
the
tuple
define
in
functionextensions
be
extend
to
summarize
it
content
a
a
set
of
coding_keyword_7
since
these
strong
type
connector_data_3
whose
constructor
connector_7
only
argument
decorate
with
final
their
element
shall
be
immutable
with
fix
order
if
extend
properly
thus
their
and
their
child
s
hashcodes
be
also
fix
thus
can
be
buffer
a
set
that
could
be
the
least
cost
connector_data_14
to
be
compare
in
technology_2
a
unit
test
show
how
the
getsignatures
inherit
from
tuple
can
reveal
the
common
point
and
potential
difference
of
two
jsonobjects
@test
coding_keyword_12
coding_keyword_13
testgetsignatures
{
coding_keyword_6
text
=
{\
address\
coding_keyword_5
\
scores\
{\
english\

\
science\

\
math\
90}
\
name\
\
test
name\
\
id\

\
isactive\
true
\
class\
\
7a\
}
coding_keyword_8
object1
=
coding_keyword_8
requirement_8
text
namedvalue
connector_20
=
object1
getvalue

namedvalue
score
=
object1
getvalue

namedvalue
name
=
object1
getvalue

namedvalue
coding_keyword_9
=
object1
getvalue

namedvalue
isactive
=
object1
getvalue

namedvalue
classnamedvalue
=
object1
getvalue

set
coding_keyword_7
signature1
=
object1
getsignatures
logger
i
object1
tojsonstring
coding_keyword_5
logger
technology_14
connector_20
%s\tscores
%s\tname
%s\tid
%s\tisactive
%s\tclass
%s\n\tobject1
%s\n
connector_20
hashcode
score
hashcode
name
hashcode
coding_keyword_9
hashcode
isactive
hashcode
classnamedvalue
hashcode
deeptostring
signature1
assertalltrue
signature1
size
==

signature1
containsall
coding_keyword_4
aslist
object1
hashcode
connector_20
hashcode
score
hashcode
name
hashcode
coding_keyword_9
hashcode
isactive
hashcode
classnamedvalue
hashcode
coding_keyword_8
object2
=
object1
getsorted
comparator
naturalorder
logger
i
object2
tojsonstring
coding_keyword_5
set
coding_keyword_7
signature2
=
object2
getsignatures
namedvalue
sortedscores
=
namedvalue
requirement_8
\
scores\
{\
english\

\
math\

\
science\
88}
logger
technology_14
connector_20
%s\tsortedscores
%s\tname
%s\tid
%s\tisactive
%s\tclass
%s\n\tobject2
%s\n
connector_20
hashcode
sortedscores
hashcode
name
hashcode
coding_keyword_9
hashcode
isactive
hashcode
classnamedvalue
hashcode
deeptostring
signature2
assertalltrue
signature2
size
==

signature2
containsall
coding_keyword_4
aslist
object2
hashcode
connector_20
hashcode
name
hashcode
coding_keyword_9
hashcode
isactive
hashcode
classnamedvalue
hashcode
signature2
contain
sortedscores
hashcode
}
it
output
be
mark
with
different
color
to
highlight
why
it
be
connector_12
signature
the
object1
and
object2
connector_21
same
set
of
namedvalues
except
the
embed
coding_keyword_8
identify
by
score
by
compare
their
signature
along
it
be
quite
easy
to
see
that
pair
of
element
shall
be
compare
together
while
other
pair
identify
by
connector_20
name
coding_keyword_9
and
ect
would
conclude
a
no
difference
quickly
connector_10
the
two
pair
of
score
jsonobjects
clearly
they
be
refer
to
the
same
thing
if
define
a
technology_2
connector_data_2
waste
time
to
compare
these
jsonobjects
with
the
same
element
of
different
order
would
be
a
waste
of
time
that
be
why
come
the
sorting
that
be
usually
not
support
by
technology_1
requirement_1
sorting
with
stringcomparator
the
isortable
getsorted
comparator
inherit
by
ijsonvalue
wold
re
arrange
the
element
of
coding_keyword_8
with
desirable
order
and
it
would
also
be
use
by
the
jsonarray
to
pass
to
all
it
child
jsonobjects
consequently
two
jsonobjects
or
jsonarrays
connector_22
the
same
comparator
coding_keyword_6
to
sorting
the
name
of
their
coding_keyword_8
would
represent
their
child
of
the
same
element
with
identical
signature
to
ensure
a
prefer
order
or
retain
the
original
order
of
the
embed
jsonobjects
an
ordinalcomparator
can
be
construct
easily
and
supply
to
either
requirement_1
requirement_8
or
ijsonvalue
getsorted
comparator
to
connector_2
array3
which
would
be
show
a
@test
coding_keyword_12
coding_keyword_13
getsortedwithorderednames
{
coding_keyword_8
obj
=
coding_keyword_8
requirement_8
{
\
age\

\
name\
coding_keyword_5
\
other\
\
none\
}
coding_keyword_8
naturalordered
=
coding_keyword_8
obj
getsorted
name
other
coding_keyword_6
coding_keyword_6
=
naturalordered
tostring
assertequals
{\n
+
\
name\
coding_keyword_5
\n
+
\
other\
\
none\
\n
+
\
age\
123\n
+
}
coding_keyword_6
coding_keyword_8
naturalreversed
=
obj
getsorted
naturalordered
namecomparator
reverse
coding_keyword_6
=
naturalreversed
tostring
assertequals
{\n
+
\
age\

\n
+
\
other\
\
none\
\n
+
\
name\
null\n
+
}
coding_keyword_6
}
connector_2
the
least
different
pair
when
order
be
neglect
to
compare
two
jsonarrays
when
their
element
s
order
doesn
t
matter
the
component_2
behind
would
use
the
signature
to
pair
element
by
find
out
the
least
different
pair
that
be
a
quite
complex
with
acceptable
requirement_7
the
follow
test
would
load
the
6m
technology_1

connector_14

of
it
leaf
technology_9
then
compare
their
difference
for

time
@test
@ignore
coding_keyword_12
coding_keyword_13
testdeltawith_oflargeobjects
{
coding_keyword_6
jsontext
=
resourcehelper
gettextfromresourcefile
catalog
technology_8
coding_keyword_14
connector_23
=

coding_keyword_14
jsontextlength
=
jsontext
length
coding_keyword_8
original
=
logger
m
measurement
start
requirement_8
technology_1
of
%dk
jsontextlength

coding_keyword_8
requirement_8
jsontext
coding_keyword_14
originalleafcount
=
original
getleafcount
try
revokable
revokable
=
logger
setlevelinscope
loglevel
debug
{
for
coding_keyword_14
i
=

i

i++
{
connector_data_2
coding_keyword_6
connector_data_6
modifiablemap
=
connector_data_2
coding_keyword_6
connector_data_6
logger
m
measurement
start
connector_2
quality_attribute_6
connector_data_2
original
asmutableobject
connector_data_6
packageslist
=
modifiablemap
connector_2
package
logger
m
measurement
start
modify
%d
leaf
requirement_9
connector_14
modifyandshuffle
packageslist
connector_14
connector_data_6
shuffledarray
=
logger
m
measurement
start
shuffle
package
connector_data_1
a
coding_keyword_4
arrayhelper
shuffle
connector_data_1
packageslist
toarray
modifiablemap
put
package
shuffledarray
coding_keyword_8
modifiedobject
=
logger
m
measurement
start
jsonify
back
to
coding_keyword_8
coding_keyword_8
utility
jsonify
modifiablemap
coding_keyword_14
modifiedleafcount
=
modifiedobject
getleafcount
logger
technology_14
connector_1
modify
coding_keyword_8
with
%d
leave
to
%s
modifiedleafcount
logger
m
measurement
start
connector_1
modify
technology_8
resourcehelper
savetexttotargetfile
modifiedobject
tostring
modify
technology_8
ijsonvalue
delta
=
logger
m
measurement
start
deltawith
between
connector_data_6
with
%d
leaf
and
another
with
%d
leaf
originalleafcount
modifiedleafcount
original
deltawith
modifiedobject
po
assertnotnull
delta
fail
to
connector_2
connector_data_8
coding_keyword_6
deltastring
=
delta
tostring
matcher
matcher
=
pattern_5
compile
changedvalue\\d{3}
matcher
deltastring
coding_keyword_14
count
=

while
matcher
find
{
count++
}
coding_keyword_6
pattern_6
=
datetimehelper
asstring
localdatetime
now
mmddhhmmss
coding_keyword_6
modifedfile
=
resourcehelper
savetexttotargetfile
modifiedobject
tostring
coding_keyword_6
technology_11
modified%s
technology_8
pattern_6
coding_keyword_6
deltafile
=
resourcehelper
savetexttotargetfile
delta
tostring
coding_keyword_6
technology_11
delta%s
technology_8
pattern_6
logger
i
there
be
%d
connector_14
requirement_9
find
the
modify
be
connector_1
a
%s
and
delta
be
connector_1
a
%s
count
modifedfile
deltafile
}
}finally
{
measurement
purge
loglevel
warn
}
}
the
output
from
my
laptop
show
it
usually
take


second
to
identify
all

difference
by
compare
two
jsonobjects
with
275k
leaf
technology_9
compare
two
ijsonvalues
with
optional
instruction
the
ijsonvalue
deltawith
ijsonvalue
other
coding_keyword_6
indexname
define
in
ijsonvalue
connector_7
a
coding_keyword_6
parameter
to
instruct
how
to
compare
when
indexname
be
coding_keyword_5
then
the
jsonarrays
would
be
convert
to
jsonobjects
with
their
index
a
the
name
explicitly
otherwise
when
indexname
be
not
coding_keyword_5
then
the
position
of
their
element
would
not
affect
how
they
be
pair
to
compare
when
indexname
be
that
be
also
the
default
set
of
jsonarray
defaultindexname
would
show
only
the
difference
without
their
position
connector_data_7
when
indexname
be
a
coding_keyword_6
contain
+
would
not
only
show
the
difference
of
pair
element
with
their
index
but
also
show
the
index
difference
of
identical
element
at
different
position
otherwise
only
show
the
difference
of
pair
element
with
their
index
there
be
many
unit
test
create
and
one
example
be
below
@test
coding_keyword_12
coding_keyword_13
comparetwoarrays_difsizewithelementdifferences_returnnonempty
{
jsonarray
coding_keyword_4
=
jsonarray
alice
bob
ellen
jsonarray
array2
=
jsonarray
alice
withdelta
{\
age\

\
class\
\
7f\
}
ellen
logger
technology_14
array2
%s
array2
ijsonable
delta1
=
coding_keyword_4
deltawith
array2
ijsonable
delta2
=
array2
deltawith
coding_keyword_4
index
ijsonable
delta3
=
array2
deltawith
coding_keyword_4
+pos
logger
technology_14
delta1
%s\ndelta2
%s\ndelta3
%s
delta1
delta2
delta3
assertequals
{\
age\


\
class\
\
7n\
\
7f\
}
{\
name\
\
bob\
\
gender\
\
m\
\
age\

\
class\
\
7c\
\
scores\
{\
english\

\
science\

\
humanity\

\
math\
80}}
coding_keyword_5
delta1
tojsonstring
coding_keyword_5
assertequals
{\
index\


\
age\


\
class\
\
7f\
\
7n\
}
{\
1\
coding_keyword_5
\
1\
{\
name\
\
bob\
\
gender\
\
m\
\
age\

\
class\
\
7c\
\
scores\
{\
english\

\
science\

\
humanity\

\
math\
80}}}
delta2
tojsonstring
coding_keyword_5
assertequals
{\
+pos\


\
age\


\
class\
\
7f\
\
7n\
}
{\
+pos\


}
{\
1\
coding_keyword_5
\
1\
{\
name\
\
bob\
\
gender\
\
m\
\
age\

\
class\
\
7c\
\
scores\
{\
english\

\
science\

\
humanity\

\
math\
80}}}
delta3
tojsonstring
coding_keyword_5
}
compare
two
technology_2
connector_data_3
with
jsontuples
since
technology_2
connector_data_3
can
be
convert
to
technology_1
requirement_9
by
jsontuples
and
these
technology_1
requirement_9
can
be
compare
to
connector_2
their
difference
there
be
two
coding_keyword_11
define
in
the
utility
technology_2
to
compare
two
technology_2
connector_data_3
directly
ijsonvalue
deltawith
connector_data_6
obj1
connector_data_6
obj2
coding_keyword_6
indexkey
convert
both
connector_data_3
to
ijsonvalues
then
connector_2
the
delta
with
strategy
identify
by
the
indexkey
ijsonvalue
deltawith
connector_data_6
obj1
connector_data_6
obj2
a
simplify
version
use
the
default
jsonarray
defaultindexname
the
unit
test
below
show
how
it
work
@test
coding_keyword_12
coding_keyword_13
testjsonify_withdifferentobjects_getrightijsonvalues
{
assertequals
jsonvalue
coding_keyword_5
utility
jsonify
coding_keyword_5
assertequals
jsonvalue
false
utility
jsonify
false
assertequals

jsonstring
coding_keyword_6
utility
jsonify
coding_keyword_6
assertequals


utility
jsonify


getobject
set
connector_data_6
complexset
=
linkedhashset
coding_keyword_4
aslist
character
{
a
b
}
true
coding_keyword_14
{1
2}
double
{new
double
{


0}
double
{3
3}}
connector_data_6
{
ok
null}
jsonarray
coding_keyword_4
=
jsonarray
utility
jsonify
complexset
connector_data_6
connector_data_6
=
coding_keyword_4
getobject
assertequals

connector_data_6
{
connector_data_6
{
a
b
}
true
connector_data_6
{1
2}
connector_data_6
{new
connector_data_6
{


0d}
connector_data_6
{3
3}}
connector_data_6
{
ok
null}}
connector_data_6
connector_data_2
coding_keyword_6
connector_data_6
connector_data_2
=
linkedhashmap
connector_data_2
put
purpose
test
connector_data_2
put
coding_keyword_4
coding_keyword_4
connector_data_2
put
other
coding_keyword_5
coding_keyword_8
coding_keyword_8
=
coding_keyword_8
utility
jsonify
connector_data_2
assertequals
{\
purpose\
\
test\
\
array\
\
a\
\
b\
true








\
ok\
coding_keyword_5
\
other\
null}
coding_keyword_8
tojsonstring
coding_keyword_5
}
conclusion
a
a
conclusion
the
follow
connector_data_3
have
be
meet
define
limit
technology_1
to
enable
technology_1
coding_keyword_6
component_5
a
outline
in
technology_8

especially
coding_keyword_8
and
jsonarray
par
big
technology_1
text
block
and
connector_24
the
content
a
coding_keyword_8
jsonarray
that
be
immutable
serialize
coding_keyword_8
jsonarray
to
technology_1
text
in
some
different
technology_11
sort
the
order
of
coding_keyword_8
element
with
stringcomparator
recursively
to
connector_2
technology_1
text
of
unify
form
convert
a
collection
or
coding_keyword_4
to
from
jsonarray
or
a
connector_data_2
coding_keyword_6
connector_data_6
to
from
coding_keyword_8
with
immutable
tuples
to
keep
the
connector_data_4
the
technology_1
requirement_9
coding_keyword_8
and
jsonarray
can
be
convert
to
quality_attribute_6
connector_data_2
coding_keyword_6
connector_data_6
or
arraylist
for
crud
the
technology_1
requirement_9
can
be
use
a

to
compare
technology_2
connector_data_3
to
connector_2
their
minimum
difference
a
another
technology_1
connector_data_6
for
example
find
out
the
difference
between
an
coding_keyword_4
and
a
set
whose
element
or
not
be
consistent
some
desirable
feature
be
not
include
connector_data_2
technology_2
to
from
technology_1
a
technology_15
or
technology_16
be
not
support
in
the
current
version
when
convert
coding_keyword_8
jsonarray
to
a
customize
connector_data_2
or
collection
they
would
be
connector_data_2
to
linkedhashmap
and
arraylist
for
modification
expression
to
locate
the
element
of
technology_8
jsonpath
be
not
support
yet
for
me
work
out
this
technology_3
be
a
really
challenge
and
reward
experience
i
hope
this
can
help
you
to
solve
some
real
problem
associate
with
technology_8
and
even
connector_data_4
analysis
technology_1
technology_2
programming
technology_17
unit
test
connector_data_6
component_9
science
requirement_1
programming
technology_17
element
publish
at
with
permission
of
william
jiang
see
the
original
here
opinion
express
by
contributor
be
their
own
popular
on

pattern_7
to
a
web
component_10
with
auth0
technology_18
and
jwt

best
practice
to
do
functional
test
on
the
requirement_5
how
to
design
a
crud
web
component_11
for
inheritable
component_12
refactoring
technology_2
component_10
connector_data_6
orient
and
functional
approach

technology_2
partner
resource
x
about
u
about
connector_25
feedback
career
sitemap
advertise
advertise
with
contribute
on
submission
guideline
mvb
component_13
become
a
contributor
visit
the
writer
zone
legal
term
of
component_11
privacy
requirement_12
u

park
office
drive
suite

durham
nc

support@dzone
technology_19
+1



coding_keyword_15
s
be
friend

technology_19
be
powered
by
