technology_1
technology_2
esb
vergleich
#2
predic8entwicklungbranchenssoschnittstellenesb
einführungbeispiel
clientsberatunganwendungsintegrationapi
reviewschulungwebinaremicroservicesintegrationrest
apisbig
datasoaonsitekursmaterialagbsteilnahme
faqbewertungenterminetermine
nach
datumraumanforderungenreferenzenfallstudienappssoaappsweb
0sonstigesveröffentlichungenmicroserviceskubernetes
&
dockerrestsecurityopen
component_1
integrationmobileenterpriseiotjavascriptsoa
&
web
servicesvorträgeautorenvideoopen
sourceapi
gatewaysoa
monitorservice
virtualisierungvirtuelle
serviceskontakthotelsanreisefreizeittippsjobssenior
technology_3
entwickler
w
m
djava
entwickler
m
w
djava
student
m
w
dkubernetes
administrator
m
w
dfreiberufler
m
w
dbachelorarbeitenbewerbung
al
coderinhalt
der
bewerbungazubi
fachinformatiker
w
m
dapache
technology_2
open_source
requirement_1
vergleich
teil
dieser
artikel
ist
teil
einer
reihe
die
open_source
requirement_1
werkzeuge
vorstellt
und
vergleicht
den
anfang
macht
mit
diesem
artikel
technology_1
technology_2
da
technology_2
auch
im
servicemix
technology_4
fuse
und
talend
esb
zum
einsatz
kommt
technology_1
technology_2
ist
ein
auf
den
„enterprise
requirement_1
patterns“
basierendes
requirement_1
technology_5
requirement_2
requirement_1
pattern_1
werden
im
gleichnamigen
buch
von
gregor
hophe
und
bobby
woolf
beschrieben
wer
da
buch
noch
nicht
hat
sollte
e
sich
unbedingt
besorgen
da
buch
ist
eine
bibel
für
alle
die
systeme
und
anwendungen
verbinden
möchten
technology_2
ist
kein
component_2
und
keine
plattform
e
ist
ein
technology_5
und
steht
dem
entwickler
in
form
von
bibliotheken
zur
verfügung
die
bibliotheken
sind
schlank
und
können
leicht
in
eigene
projekte
z
b
über
eine
technology_6
abhängigkeit
integriert
werden
e
wäre
aber
falsch
technology_2
auf
eine
bibliothek
zu
reduzieren
alle
eigenschaften
eines
ausgewachsenen
requirement_2
component_3
bus
mit
deployment
überwachung
und
garantierter
zustellung
lassen
sich
auch
mit
technology_2
durch
die
kombination
mit
weiteren
projekten
realisieren
beispielsweise
kommt
oft
der
technology_7
al
connector_data_1
pattern_2
und
al
runtime
technology_8
technology_9
oder
der
servicemix
zum
einsatz
entwicklung
integrationsabläufe
die
routen
werden
in
technology_2
mit
einer
domain
spezifischen
sprache
z
b
in
technology_3
technology_10
oder
connector_data_2
beschrieben
wie
da
in
der
praxis
aussieht
soll
ein
beispiel
verdeutlichen
da
folgende
connector_data_3
zeigt
eine
mit
der
technology_3
dsl
realisierte
connector_1
die
einen
endpunkt
für
kontaktlisten
im
technology_11
technology_12
bereitstellt
die
kontakte
der
liste
werden
gesplittet
und
die
privaten
kontakte
in
einem
verzeichnis
die
geschäftskontakte
in
einer
connector_data_1
component_4
abgelegt
die
technology_3
dsl
ist
eine
fluent
technology_13
bei
der
methodenaufrufe
aneinander
gehängt
werden
der
connector_1
lässt
sich
vom
technology_3
compiler
übersetzen
und
drückt
doch
gut
verständlich
den
integrationsablauf
au
from
technology_14
technology_15
localhost
in
split
jsonpath
$
kontakte
*
choice
when
quality_attribute_1
${body
art
}
==
private
marshal
technology_16
to
private
otherwise
marshal
xstream
to
requirement_3
end
der
endpunkt
nimmt
technology_11
nachrichten
wie
die
folgende
über
technology_15
entgegen
{
kontakte
{
name
franz
art
private
}
{
name
peter
art
requirement_3
}
}
über
den
technology_11
path
ausdruck
$
kontakte
*
wird
die
nachricht
in
einzelne
nachrichten
mit
jeweils
einem
kontakt
aufgespaltet
die
erstellung
de
technology_11
path
ausdrucks
und
de
skriptes
für
die
ermittlung
private
kontakte
${body
art
}
==
private
mu
vom
entwickler
auch
in
anderen
produkten
mit
graphischem
editor
vorgenommen
werden
dort
werden
dieselben
ausdrücke
in
feldern
der
graphischen
editoren
angegeben
entwicklungsumgebungen
unterstützen
bei
der
entwicklung
von
routen
mit
vervollständigung
und
fehlerkorrektur
wie
der
screenshot
be
beispiel
von
intellij
zeigt
abbildung
komfortables
editieren
von
technology_2
routen
mit
vervollständigung
in
intellij
obwohl
oder
gerade
weil
im
gearbeitet
wird
bekommt
der
entwickler
eine
gute
unterstützung
bei
der
erstellung
von
routen
konnektoren
für
technology_1
technology_2
gibt
e
viele
konnektoren
mit
unterstützung
selbst
für
exotische
protokolle
und
formate
requirement_3
konnektoren
gibt
e
u
a
für
technology_17
und
technology_18
aber
die
auswahl
ist
wesentlich
eingeschränkter
al
für
technology_19
oder
talend
viele
requirement_3
anwendungen
bieten
eine
web
component_5
oder
pattern_3
schnittstelle
und
lassen
sich
mit
jedem
integrationswerkzeug
ansprechen
technology_20
funktionsbausteine
können
per
web
component_3
aufgerufen
werden
und
technology_17
bietet
sowohl
web
component_5
al
auch
eine
pattern_3
schnittstelle
an
die
mehrzahl
der
requirement_3
anwendungen
verfügen
über
mit
technology_21
oder
technology_22
beschriebene
schnittstellen
und
können
daher
auch
ohne
einen
requirement_3
konnektor
komfortabel
angesprochen
werden
connector_data_4
technology_2
enthält
keinen
graphischen
mapper
um
datenformate
von
quellformaten
auf
zielformate
abzubilden
die
transformation
einer
nachricht
von
technology_12
a
nach
technology_12
b
erfolgt
in
technology_2
mit
hilfe
de
eip
muster
connector_data_1
pattern_4
für
da
e
gleich
mehrere
umsetzungen
gibt
skriptsprache
z
b
quality_attribute_1
groovytemplating
z
b
technology_23
xqueryjavadozer
javabean
connector_data_4
technology_5
groovyxslt
einige
meiner
kollegen
schreiben
lieber
ein
kurzes
technology_24
skript
anstatt
einer
xslt
transformation
der
technology_24
ist
oft
kürzer
und
aussagekräftiger
darüber
hinaus
sind
in
technology_24
berechnungen
oder
umwandlungen
in
andere
formate
wie
technology_11
leichter
realisierbar
wer
mit
technology_2
einen
graphischen
mapper
einsetzen
möchte
kann
sich
den
auf
technology_2
basierenden
talend
esb
ansehen
bei
dem
man
die
technology_2
routen
mit
dem
technology_25
transformer
kombinieren
kann
requirement_4
und
pattern_5
technology_2
routen
können
über
die
technology_3
requirement_4
extension
kurz
technology_26
verwaltet
werden
die
anzahl
der
verarbeiteten
fehlerhaften
sowie
gerade
sich
in
ausführung
befindlichen
nachrichten
können
al
statistiken
ausgelesen
werden
performanz
daten
stehen
ebenfalls
zur
verfügung
über
technology_26
kann
auch
mit
der
populären
hawt
io
requirement_4
konsole
technology_2
überwacht
werden
hawt
io
ist
nicht
bestandteil
von
technology_2
hawt
io
entwickelt
sich
zur
universellen
konsole
für
technology_3
component_2
e
gibt
plugins
u
a
für
technology_27
technology_28
und
natürlich
auch
für
technology_2
der
screenshot
zeigt
die
graphische
visualisierung
der
connector_1
von
weiter
oben
abbildung
visualisierung
von
technology_2
routen
mit
hawt
iodie
visualisierung
von
hawt
io
unterstützt
auch
debug
und
trace
in
der
abbildung
unten
sieht
sieht
man
den
inhalt
einer
nachricht
zum
zeitpunkt
al
die
nachricht
vom
marhsal
schritt
bearbeitet
wurde
abbildung
trace
von
nachrichten
mit
technology_2
der
nächste
screenshot
zeigt
statistiken
zu
jedem
einzelnen
schritt
einer
connector_1
da
finden
von
pattern_6
spot
die
be
meisten
zu
langen
laufzeiten
beitragen
wird
damit
zum
kinderspiel
abbildung
profile
von
technology_2
routen
mit
hawt
io5
deployment
technology_2
selbst
enthält
nur
ein
technology_3
component_6
um
routen
zu
starten
aber
keine
laufzeitumgebung
dafür
können
technology_2
routen
in
fast
alle
laufzeitumgebungen
installiert
werden
mögliche
deployment
für
technology_2
sind
technology_3
in
einer
technology_3
vmspring
frameworkdienst
de
betriebssystems
der
eine
technology_3
vm
startetweb
anwendungenapplication
serverspring
boot
anwendungendocker
containerosgi
runtimes
die
produkte
von
technology_4
und
talend
kommen
bereits
mit
einer
mächtigen
laufzeitumgebung
für
technology_2
routen
performanz
und
speicherverbrauch
der
footprint
für
die
ausführung
einer
technology_2
connector_1
ist
sehr
gering
in
der
größenordnung
von
wenigen
megabyte
die
verwendeten
konnektoren
und
muster
besonders
aufwendige
transformationen
bestimmen
die
performanz
von
technology_2
weit
mehr
al
da
technology_5
selbst
über
da
profile
können
requirement_5
hotspot
leicht
gefunden
und
optimiert
werden
fazit
mit
den
folgenden
eigenschaften
war
technology_2
seiner
zeit
voraus
und
hat
integrationslösungen
und
zahlreiche
andere
projekte
beeinflusst
beschreibung
von
integrationsrouten
mit
einer
auf
technology_3
basierenden
problembezogenen
sprache
dsl
funktionale
programmierung
für
die
implementierung
von
intergration
pattern_1
beispielsweise
den
aggregator
für
da
erzeugen
einer
aggregrierten
nachricht
au
mehreren
einzelnen
nachrichten
modularer
aufbau
auf
der
basis
de
technology_9
frameworksverzicht
auf
ein
kanonisches
datenformat
technology_2
kann
intern
nicht
nur
mit
connector_data_2
sondern
auch
mit
technology_16
technology_3
objekten
oder
beliebigen
anderen
formaten
arbeiten
die
konvertierung
von
csv
zeilen
in
technology_3
objekte
oder
die
von
connector_data_2
nach
technology_11
führt
technology_2
automatisch
über
konnektoren
durch
bei
jedem
arbeitsschritt
kann
sich
der
entwickler
für
da
für
die
aufgabe
passende
technology_12
entscheiden
technology_2
ist
schlank
und
gleichzeitig
eines
der
mächtigsten
oder
vielleicht
sogar
da
mächtigste
werkzeug
für
die
requirement_1
kommerzielle
produkte
wie
talend
esb
und
technology_4
fuse
basieren
auf
technology_1
technology_2
technology_1
technology_2
hat
mit
abstand
die
größte
und
größte
verbreitung
all
hier
betrachteten
werkzeuge
für
nicht
programmierer
ist
technology_2
da
falsche
werkzeug
wer
nicht
programmieren
kann
und
sich
auch
nicht
mit
der
technology_3
plattform
auskennt
kommt
aber
auch
nicht
mit
allen
anderen
hier
betrachteten
open_source
projekten
zurecht
und
sollte
sich
da
angebot
kommerzieller
close
component_1
anbieter
ansehen
wer
bereits
über
technology_3
kenntnisse
verfügt
gewöhnt
sich
schnell
an
die
technology_3
dsl
und
kann
sich
eine
andere
arbeitsweise
kaum
noch
vorstellen
weitere
folgen
esb
vergleichapache
nifiservicemixtalend
esbjboss
fuse
esbmule
esbwso2
esbspring
requirement_1
video
zu
technology_1
technology_2
integrationmicroservicesapache
camelopen
sourceesbartikelframeworkwebinarerest
apismicroservicesapi
sicherheitintegration
mit
technology_1
camelkubernetes
für
managerkubernetes
workshopapache
artemisartikelrest
graphql
&
grpc
im
vergleichservice
mesh
einführung
&
vergleich
von
istio
und
linkerdmicroservices
mit
technology_9
&
cloudapi
managementcamel
nifi
technology_4
fuse
technology_19
&
talend
esb
im
vergleichblogunterschied
zwischen
component_6
gateway
und
component_3
meshminimale
größe
eines
microservicesitemapjobsimpressumdatenschutzerklärung©
predic8
gmbh
bonn
