guía
de
technology_1
technology_2
de
lo
básico
a
la
integración
de
technology_3
|
toptaldevelopershiring
toptal
handpicks
top
technology_1
developer
to
suit
your
need
top
3%whyclientsenterprisecommunityblogabout
usfollow
u
onlog
ingo
to
your
profileengineeringall
blogsicon
chevronicon
closesearchfilter
byallengineeringdesignfinanceprojectsproducttoptal
insightsview
all
resultsengineeringdesignfinanceprojectsproducttoptal
insightsback
end19
minute
readintegración
optimizada
de
un
de
technology_1
cameldiseñar
una
arquitectura
de
integración
de
sistemas
puede
ser
una
tarea
difícil
y
empeora
si
estás
diseñando
para
a
escala
un
autobús
de
servicio
empresarial
puede
ser
una
forma
de
solucionar
los
desafíos
pero
definitivamente
ésta
no
e
la
solución
más
sencilla
en
este
artículo
technology_4
ingeniero
de
freelance
de
toptal
anton
goncharov
no
brinda
una
descripción
detallada
de
los
desafíos
de
la
integración
de
sistemas
y
una
guía
para
abordar
esos
desafíos
con
technology_1
technology_2
authorauthoranton
goncharovanton
have
extensive
expertise
in
design
quality_attribute_1
and
quality_attribute_2
component_1
he’s
fluent
in
technology_5
technology_6
technology_7
and
technology_8
development
sharesharetranslated
by
marisela
ordaz
this
be
originally
connector_1
in
englishel
raramente
si
e
que
existe
tiene
en
un
vacío
informativo
al
menos
esa
e
la
suposición
que
los
ingenieros
de
podemos
hacer
para
la
mayoría
de
la
aplicaciones
que
desarrollamos
en
cualquier
escala
cada
pieza
de
software—de
una
forma
u
otra—se
comunica
con
otro
por
varias
razones
para
obtener
datos
de
referencia
de
alguna
parte
para
enviar
señales
de
monitoreo
para
estar
en
contacto
con
otros
servicios
mientras
e
parte
de
un
sistema
distribuido
y
más
en
este
aprenderás
cuáles
son
algunos
de
los
mayores
desafíos
de
integrar
de
gran
tamaño
y
cómo
technology_1
technology_2
los
resuelve
con
facilidad
technology_4
problema
diseño
de
arquitectura
para
la
integración
de
sistemas
e
posible
que
hayas
hecho
lo
siguiente
al
menos
una
vez
en
la
vida
de
la
ingeniería
de
identifica
un
fragmento
de
la
lógica
de
negocio
que
debes
iniciar
technology_4
envío
de
datos
en
la
misma
capa
de
aplicación
escribe
la
transformaciones
de
datos
de
acuerdo
con
lo
que
espera
technology_4
destinatario
envuelve
los
datos
en
una
estructura
que
sea
adecuada
para
transferir
y
enrutar
a
través
de
una
red
abre
una
conexión
a
una
aplicación
de
destino
utilizando
un
controlador
apropiado
o
un
technology_9
de
cliente
envía
los
datos
y
maneja
la
respuesta
¿por
qué
e
esta
una
mala
línea
de
acción
si
bien
solo
tienes
unas
pocas
conexiones
de
este
tipo
sigue
siendo
manejable
con
un
número
creciente
de
relaciones
entre
sistemas
la
lógica
de
negocios
de
la
aplicación
se
mezcla
con
la
lógica
de
integración
que
trata
de
adaptar
datos
compensar
la
diferencias
tecnológicas
entre
do
sistemas
y
transferir
datos
al
sistema
externo
con
technology_10
pattern_1
o
solicitude
más
exóticas
si
estuvieras
integrando
varias
aplicaciones
sería
increíblemente
difícil
volver
a
trazar
la
imagen
completa
de
la
dependencias
en
dicho
código
¿dónde
se
producen
los
datos
y
qué
servicios
los
consumen
tendrás
muchos
lugares
donde
la
lógica
de
integración
está
duplicada
para
arrancar
con
este
enfoque
aunque
la
tarea
se
realiza
técnicamente
terminamos
con
grandes
problemas
con
la
capacidad
de
mantenimiento
y
la
escalabilidad
de
la
integración
la
rápida
reorganización
de
los
flujos
de
datos
en
este
sistema
e
casi
imposible
por
no
mencionar
problemas
más
profundos
como
la
falta
de
monitoreo
la
interrupción
de
circuitos
la
laboriosa
recuperación
de
datos
etc
esto
e
especialmente
importante
cuando
se
integra
en
technology_4
ámbito
de
una
empresa
considerablemente
grande
hacer
frente
a
la
integración
empresarial
significa
trabajar
con
un
conjunto
de
aplicaciones
que
operan
en
una
amplia
gama
de
plataformas
y
se
encuentran
en
diferentes
ubicaciones
technology_4
intercambio
de
datos
en
un
entorno
de
de
este
tipo
e
bastante
exigente
debe
cumplir
con
los
estándares
de
alta
seguridad
de
la
industria
y
proporcionar
una
forma
confiable
de
transferir
datos
en
un
entorno
empresarial
la
integración
de
sistemas
requiere
un
diseño
de
arquitectura
separado
y
completamente
elaborado
este
artículo
te
presentará
la
dificultades
únicas
que
enfrenta
la
integración
de
y
brindará
algunas
soluciones
basadas
en
la
experiencia
para
tareas
de
integración
no
familiarizaremos
con
technology_1
technology_2
un
marco
útil
que
puede
aliviar
los
peores
aspectos
del
dolor
de
cabeza
de
un
desarrollador
de
integración
seguiremos
con
un
ejemplo
de
cómo
technology_2
puede
ayudar
a
establecer
la
comunicación
en
un
clúster
de
microservicios
impulsados
​​por
technology_3
dificultades
de
integración
un
enfoque
ampliamente
utilizado
para
resolver
technology_4
problema
e
desacoplar
una
capa
de
integración
en
tu
aplicación
puede
existir
dentro
de
la
misma
aplicación
o
como
una
pieza
de
dedicada
que
se
ejecuta
de
forma
independiente—en
este
último
caso
se
denomina
technology_11
¿qué
problemas
enfrentas
normalmente
cuando
desarrollas
y
soportas
technology_11
en
general
tiene
los
siguientes
elementos
clave
todos
los
canal
de
datos
no
son
confiables
en
cierta
medida
los
problemas
derivados
de
esta
falta
de
fiabilidad
pueden
no
producirse
mientras
la
intensidad
de
los
datos
sea
baja
o
moderada
cada
nivel
de
almacenamiento
desde
la
memoria
de
la
aplicación
hasta
los
cachés
inferiores
y
technology_4
equipo
que
se
encuentra
debajo
está
sujeto
a
posibles
falla
algunos
errores
raros
surgen
solo
con
grandes
volúmenes
de
datos
incluso
los
productos
maduros
de
proveedores
listos
para
producción
tienen
problemas
de
seguimiento
de
errores
no
resueltos
relacionados
con
la
pérdida
de
datos
un
sistema
de
technology_11
debería
poder
informarle
sobre
estas
víctimas
de
datos
y
reenviar
technology_4
mensaje
de
suministro
de
manera
oportuna
la
aplicaciones
usan
diferentes
protocolos
y
formatos
de
datos
esto
significa
que
un
sistema
de
integración
e
una
cortina
para
transformaciones
de
datos
y
adaptadores
para
otros
participantes
y
utiliza
una
variedad
de
tecnologías
estos
pueden
incluir
llamadas
de
component_2
pattern_1
quality_attribute_3
pero
también
podrían
tener
acceso
a
un
intermediario
de
cola
enviar
órdenes
csv
a
través
de
technology_12
o
datos
de
extracción
de
lot
a
una
tabla
de
base
de
datos
esta
e
una
larga
lista
y
nunca
se
acortará
los
cambios
en
los
formatos
de
datos
y
la
reglas
de
enrutamiento
son
inevitable
cada
paso
en
technology_4
proceso
de
desarrollo
de
una
aplicación
que
cambium
la
estructura
de
datos
generalmente
conduce
a
cambios
en
los
formatos
de
datos
de
integración
y
la
transformaciones
a
veces
los
cambios
de
infraestructura
con
los
flujos
de
datos
reorganizados
de
la
empresa
son
necesarios
por
ejemplo
estos
cambios
pueden
ocurrir
cuando
se
introduce
un
único
punto
de
validación
de
datos
de
referencia
que
debe
procesar
toda
la
entradas
de
datos
maestro
en
toda
la
empresa
con
los
sistemas
n
podemos
terminar
teniendo
un
máximo
de
casi
conexiones
n^2
entre
ellos
por
lo
que
la
cantidad
de
lugares
donde
los
cambios
deben
aplicarse
crece
bastante
rápido
será
como
una
avalancha
para
mantener
la
capacidad
de
mantenimiento
una
capa
de
technology_11
debe
proporcionar
una
imagen
clara
de
la
dependencias
con
un
enrutamiento
y
una
transformación
de
datos
versátiles
estas
idea
deben
tenerse
en
cuenta
al
diseñar
la
integración
y
elegir
la
solución
de
technology_11
más
adecuada
una
de
la
formas
posibles
de
manejarlo
e
aprovechar
un
bus
de
servicio
empresarial
esb
pero
los
esb
proporcionados
por
los
principales
proveedores
generalmente
son
demasiado
pesados
​​y
con
frecuencia
son
muy
problemáticos
e
casi
imposible
comenzar
rápidamente
con
un
esb
tiene
una
curva
de
aprendizaje
bastante
empinada
y
su
flexibilidad
se
sacrifica
a
una
larga
lista
de
características
y
herramientas
incorporadas
en
mi
opinión
la
soluciones
livianas
de
integración
de
código
abierto
son
muy
superiores
son
más
elásticas
fáciles
de
implementar
en
la
nube
y
fáciles
de
escalar
la
integración
del
no
e
fácil
de
hacer
hoy
a
medida
que
construimos
arquitecturas
de
microservicios
y
no
ocupamos
de
enjambres
de
pequeños
servicios
también
tenemos
grandes
expectativas
de
cuán
eficientemente
deben
comunicarse
patrones
de
integración
empresarial
como
era
de
esperar
como
technology_4
desarrollo
de
en
general
technology_4
desarrollo
del
enrutamiento
y
la
transformación
de
datos
implica
operaciones
repetitivas
la
experiencia
en
esta
área
ha
sido
resumida
y
sistematizada
por
profesionales
que
manejan
problemas
de
integración
desde
hace
bastante
tiempo
en
technology_4
resultado
hay
un
conjunto
de
plantillas
extraídas
llamadas
patrones
de
integración
empresarial
utilizado
para
diseñar
flujos
de
datos
estos
métodos
de
integración
fueron
descritos
en
technology_4
libro
del
mismo
nombre
por
gregor
hophe
y
bobby
wolfe
que
e
muy
parecido
al
significativo
libro
de
gang
of
four
pero
en
technology_4
área
de
de
pegado
para
dar
un
ejemplo
technology_4
patrón
de
normalizador
introduce
un
componente
que
mapea
semánticamente
mensajes
iguales
que
tienen
diferentes
formatos
de
datos
para
un
único
modelo
canónico
o
technology_4
agregador
e
un
eip
que
combina
una
secuencia
de
mensajes
en
uno
dado
que
se
trata
de
abstracciones
tecnológicamente
independientes
que
se
utilizan
para
resolver
problemas
arquitectónicos
los
eip
ayudan
a
redactar
un
diseño
de
arquitectura
que
no
profundiza
en
technology_4
nivel
del
código
sino
que
describe
los
flujos
de
datos
con
suficiente
detalle
tal
notación
para
describir
la
ruta
de
integración
no
solo
hace
que
technology_4
diseño
sea
conciso
sino
que
también
establece
una
nomenclatura
común
y
un
lenguaje
común
que
son
muy
importantes
en
technology_4
contexto
de
la
solución
de
una
tarea
de
integración
con
los
miembros
del
equipo
de
diversas
áreas
comerciales
presentando
technology_1
technology_2
hace
varios
años
estaba
construyendo
una
integración
empresarial
en
una
gran
red
minorista
de
comestible
con
tiendas
en
ubicaciones
ampliamente
distribuidas
comencé
con
una
solución
propietaria
de
esb
que
resultó
ser
demasiado
engorrosa
de
mantener
entonces
nuestro
equipo
se
encontró
con
technology_1
technology_2
y
después
de
hacer
un
trabajo
de
“prueba
de
concepto”
rápidamente
reescribimos
todos
nuestros
flujos
de
datos
en
la
ruta
de
technology_2
technology_1
technology_2
se
puede
describir
como
un
“enrutador
de
mediación”
un
marco
de
technology_11
orientado
a
mensajes
que
implementa
la
lista
de
eip
con
lo
que
me
familiaricé
hace
uso
de
estos
patrones
admite
todos
los
protocolos
de
transporte
comunes
y
tiene
un
amplio
conjunto
de
adaptadores
útiles
incluidos
technology_2
permite
technology_4
manejo
de
una
serie
de
rutinas
de
integración
sin
necesidad
de
escribir
su
propio
código
aparte
de
esto
destacaría
la
siguientes
características
de
technology_1
technology_2
la
ruta
de
integración
se
escriben
como
tuberías
hechas
de
bloques
crea
una
imagen
totalmente
transparente
para
ayudar
a
rastrear
los
flujos
de
datos
technology_2
tiene
adaptadores
para
muchas
component_2
populares
por
ejemplo
obtener
datos
de
technology_1
technology_13
supervisar
la
instancias
de
technology_14
technology_15
integrarse
con
technology_16
toda
estas
tareas
se
pueden
resolver
utilizando
componentes
disponibles
listos
para
usar
la
ruta
de
technology_1
technology_2
se
pueden
escribir
en
technology_5
o
technology_17
dsl
una
configuración
connector_data_1
también
está
disponible
pero
se
vuelve
demasiado
detallada
y
tiene
peores
capacidades
de
depuración
no
impone
restricciones
en
la
pila
tecnológica
de
los
servicios
de
comunicación
pero
si
escribe
en
technology_5
o
technology_18
puede
incrustar
technology_2
en
una
aplicación
en
lugar
de
ejecutarlo
de
forma
independiente
la
notación
de
enrutamiento
utilizada
por
technology_2
se
puede
describir
con
technology_4
siguiente
pseudocódigo
quality_attribute_3
from
component_3
transform
transformer
to
destination
la
fuente
transformador
y
destino
son
los
puntos
finale
que
hacen
referencia
a
los
componentes
de
implementación
por
sus
uri
¿qué
le
permite
a
technology_2
resolver
los
problemas
de
integración
que
describí
anteriormente
echemos
un
vistazo
en
primer
lugar
la
lógica
de
enrutamiento
y
transformación
ahora
sólo
se
encuentra
en
una
configuración
de
technology_1
technology_2
dedicada
en
segundo
lugar
a
través
de
la
dsl
concisa
y
natural
junto
con
technology_4
uso
de
eip
aparece
una
imagen
de
la
dependencias
entre
los
sistemas
está
hecho
de
abstracciones
comprensibles
y
la
lógica
de
enrutamiento
e
fácilmente
ajustable
y
por
último
no
tenemos
que
escribir
montones
de
código
de
transformación
porque
los
adaptadores
apropiados
probablemente
ya
estén
incluidos
debo
añadir
que
technology_1
technology_2
e
un
marco
maduro
y
recibe
actualizaciones
periódicas
tiene
una
gran
comunidad
y
una
considerable
base
de
conocimientos
acumulada
tiene
sus
propias
desventajas
technology_2
no
debe
tomarse
como
una
suite
de
integración
compleja
e
una
caja
de
herramientas
sin
funciones
de
alto
nivel
como
herramientas
de
gestión
de
procesos
de
negocio
o
pattern_2
de
actividad
pero
se
puede
usar
para
crear
dicho
los
sistemas
alternativos
pueden
ser
por
ejemplo
technology_6
requirement_1
o
technology_19
esb
para
technology_6
requirement_1
aunque
se
considera
ligero
en
mi
experiencia
armarlo
y
escribir
muchos
archivos
de
configuración
connector_data_1
puede
resultar
inesperadamente
complicado
y
no
e
una
salida
fácil
technology_19
esb
e
un
conjunto
de
herramientas
robusto
y
muy
funcional
pero
como
su
nombre
lo
indica
e
un
bus
de
servicio
empresarial
por
lo
que
pertenece
a
una
categoría
de
peso
diferente
technology_19
se
puede
comparar
con
fuse
esb
un
producto
similar
basado
en
technology_1
technology_2
con
un
amplio
conjunto
de
características
para
mí
utilizar
technology_1
technology_2
para
pegar
servicios
hoy
en
día
e
una
tarea
obvia
e
fácil
de
usar
y
produce
una
descripción
clara
de
lo
que
pasa
al
mismo
tiempo
e
lo
suficientemente
funcional
para
construir
integraciones
complejas
escribir
una
ruta
de
muestra
comencemos
a
escribir
technology_4
código
comenzaremos
por
un
flujo
de
datos
sincrónico
que
enruta
los
mensajes
de
una
sola
fuente
a
una
lista
de
destinatarios
la
reglas
de
enrutamiento
se
escribirán
en
technology_5
dsl
usaremos
technology_20
para
construir
technology_4
proyecto
primero
agrega
la
siguiente
dependencia
al
pom
technology_21
connector_2
connector_2
technology_1
technology_2
technology_2
core
version
version
connector_2
connector_2
alternativamente
la
aplicación
se
puede
construir
encima
del
arquetipo
technology_2
archetype
technology_5
la
definiciones
de
ruta
de
technology_2
se
declaran
en
technology_4
método
routebuilder
configure
configure
{
errorhandler
defaulterrorhandler
maximumredeliveries
from
order
noop=true
routeid
requirement_2
incoming
${file
onlyname}
unmarshal
technology_22
jsonlibrary
technology_23
order
unmarshal
technology_24
to
order
contain
connector_data_2
orderitem
split
quality_attribute_3
body
item
split
connector_data_2
to
component_4
one
by
one
to
requirement_2
inputorderitem
choice
when
quality_attribute_3
${body
type}
==
drink
to
direct
bar
when
quality_attribute_3
${body
type}
==
dessert
to
direct
dessertstation
when
quality_attribute_3
${body
type}
==
pattern_3
meal
to
direct
hotmealstation
when
quality_attribute_3
${body
type}
==
pattern_4
meal
to
direct
coldmealstation
otherwise
to
direct
others
from
direct
bar
routeid
bar
requirement_2
handle
drink
from
direct
dessertstation
routeid
dessertstation
requirement_2
handle
dessert
from
direct
hotmealstation
routeid
hotmealstation
requirement_2
handle
pattern_3
meal
from
direct
coldmealstation
routeid
coldmealstation
requirement_2
handle
pattern_4
meal
from
direct
others
routeid
others
requirement_2
handle
something
other
}
en
esta
definición
creamos
una
ruta
que
recupera
los
registros
del
archivo
technology_22
los
divide
en
elementos
y
enruta
a
un
conjunto
de
controladores
en
función
del
contenido
del
mensaje
vamos
a
ejecutarlo
en
los
datos
de
prueba
preparados
obtendremos
la
salida
info
|
total
connector_3
of
which
be
start
info
|
technology_1
technology_2
camelcontext
technology_2
start
in
second
info
|
incoming
order1
technology_22
info
|
exchange
exchangepattern
inonly
bodytype
technology_25
antongoncharov
technology_2
example
component_5
orderitem
body
orderitem{id=
type=
drink
name=
americano
qty=
}
info
|
handle
drink
info
|
exchange
exchangepattern
inonly
bodytype
technology_25
antongoncharov
technology_2
example
component_5
orderitem
body
orderitem{id=
type=
pattern_3
meal
name=
french
omelette
qty=
}
info
|
handle
pattern_3
meal
info
|
exchange
exchangepattern
inonly
bodytype
technology_25
antongoncharov
technology_2
example
component_5
orderitem
body
orderitem{id=
type=
pattern_3
meal
name=
lasagna
qty=
}
info
|
handle
pattern_3
meal
info
|
exchange
exchangepattern
inonly
bodytype
technology_25
antongoncharov
technology_2
example
component_5
orderitem
body
orderitem{id=
type=
pattern_3
meal
name=
rice
ball
qty=
}
info
|
handle
pattern_3
meal
info
|
exchange
exchangepattern
inonly
bodytype
technology_25
antongoncharov
technology_2
example
component_5
orderitem
body
orderitem{id=
type=
dessert
name=
blueberry
pie
qty=
}
info
|
handle
dessert
como
era
de
esperar
technology_2
envió
mensajes
a
los
destinos
opciones
de
transferencia
de
datos
en
technology_4
ejemplo
anterior
la
interacción
entre
componentes
e
sincrónica
y
se
realiza
a
través
de
la
memoria
de
la
aplicación
sin
embargo
hay
muchas
más
formas
de
comunicarse
cuando
manejamos
aplicaciones
separadas
que
no
comparten
memoria
intercambio
de
archivos
una
aplicación
produce
archivos
de
datos
compartidos
para
que
technology_4
otro
los
consuma
e
donde
vive
technology_4
espíritu
de
la
vieja
escuela
este
método
de
comunicación
tiene
una
plétora
de
consecuencias
falta
de
transacciones
y
consistencia
bajo
rendimiento
y
coordinación
aislada
entre
sistemas
muchos
desarrolladores
terminaron
escribiendo
soluciones
de
integración
caseras
para
hacer
que
technology_4
proceso
sea
más
o
menos
manejable
base
de
datos
común
haz
que
la
aplicaciones
almacenen
los
datos
que
desean
compartir
en
un
esquema
común
de
una
única
base
de
datos
diseñar
un
esquema
unificado
y
manejar
technology_4
acceso
concurrente
a
la
tablas
son
los
desafíos
más
importantes
de
este
enfoque
al
igual
que
con
technology_4
intercambio
de
archivos
e
fácil
que
esto
se
convierta
en
un
cuello
de
botella
permanente
llamada
de
component_2
remota
proporciona
una
interfaz
para
permitir
que
una
aplicación
interactúe
con
otra
aplicación
en
ejecución
como
una
llamada
de
método
típica
la
aplicaciones
comparten
funcionalidad
a
través
de
invocaciones
de
technology_26
pero
la
vinculas
estrechamente
en
technology_4
proceso
mensajería
haz
que
cada
aplicación
se
conecte
a
un
sistema
de
mensajería
común
e
intercambie
datos
e
invoque
technology_4
comportamiento
de
forma
asíncrona
mediante
mensajes
ni
technology_4
remitente
ni
technology_4
destinatario
deben
estar
en
funcionamiento
al
mismo
tiempo
para
entregar
technology_4
mensaje
hay
más
formas
de
interactuar
pero
debemos
tener
en
cuenta
que
en
términos
general
existen
do
tipos
de
interacción
sincrónica
y
asincrónica
technology_4
primero
e
como
llamar
a
una
función
en
su
código
technology_4
flujo
de
ejecución
estará
esperando
hasta
que
se
ejecute
y
devuelva
un
valor
con
un
enfoque
asincrónico
los
mismos
datos
se
envían
a
través
de
una
cola
de
mensajes
intermedia
o
un
tema
de
suscripción
se
puede
implementar
una
llamada
a
función
remota
asíncrona
como
eip
solicitud
respuesta
sin
embargo
la
mensajería
asíncrona
no
e
un
remedio
implica
ciertas
restricciones
raramente
f
component_2
de
mensajería
en
la
web
los
servicios
pattern_1
sincrónicos
son
mucho
más
populares
pero
technology_4
technology_11
de
mensajería
se
usa
ampliamente
en
intranet
empresarial
o
infraestructura
de
back
end
del
sistema
distribuido
uso
de
cola
de
mensajes
hagamos
nuestro
ejemplo
asincrónico
un
sistema
de
que
gestiona
cola
y
temas
de
suscripción
se
llama
agente
de
mensajes
e
como
un
sistema
de
gestión
de
base
de
datos
relacionables
technology_27
para
tablas
y
columnas
la
cola
funcionan
como
una
integración
punto
a
punto
mientras
que
los
temas
son
para
la
comunicación
publicación
suscripción
con
muchos
destinatarios
usaremos
technology_1
technology_28
como
intermediario
de
mensajes
technology_29
porque
e
sólido
e
incrustable
agrega
la
siguiente
dependencia
a
veces
e
excesivo
agregar
technology_30
all
que
contiene
todos
los
archivos
jar
de
technology_30
para
technology_4
proyecto
pero
mantendremos
la
dependencias
de
nuestra
aplicación
sin
complicaciones
connector_2
technology_1
technology_30
technology_30
all
version
version
connector_2
luego
inicia
technology_4
intermediario
programáticamente
en
technology_6
tenemos
una
autoconfiguración
para
esto
al
conectar
la
dependencia
technology_20
technology_6
boot
starter
technology_30
ejecuta
un
nuevo
intermediario
de
mensajes
con
los
siguientes
comandos
especificando
sólo
technology_4
punto
final
del
conector
brokerservice
pattern_5
=
brokerservice
pattern_5
addconnector
technology_31
localhost
pattern_5
start
y
agrega
technology_4
siguiente
fragmento
de
configuración
al
cuerpo
del
método
configure
connectionfactory
connectionfactory
=
activemqconnectionfactory
technology_31
localhost
this
getcontext
addcomponent
technology_30
activemqcomponent
jmscomponent
connectionfactory
ahora
podemos
actualizar
technology_4
ejemplo
anterior
usando
cola
de
mensajes
la
cola
se
crearán
automáticamente
en
la
entrega
de
mensajes
configure
{
errorhandler
defaulterrorhandler
maximumredeliveries
connectionfactory
connectionfactory
=
activemqconnectionfactory
technology_31
localhost
this
getcontext
addcomponent
technology_30
activemqcomponent
jmscomponent
connectionfactory
from
order
noop=true
routeid
requirement_2
incoming
${file
onlyname}
unmarshal
technology_22
jsonlibrary
technology_23
order
unmarshal
technology_24
to
order
contain
connector_data_2
orderitem
split
quality_attribute_3
body
item
split
connector_data_2
to
component_4
one
by
one
to
requirement_2
inputorderitem
choice
when
quality_attribute_3
${body
type}
==
drink
to
technology_30
component_6
bar
when
quality_attribute_3
${body
type}
==
dessert
to
technology_30
component_6
dessertstation
when
quality_attribute_3
${body
type}
==
pattern_3
meal
to
technology_30
component_6
hotmealstation
when
quality_attribute_3
${body
type}
==
pattern_4
meal
to
technology_30
component_6
coldmealstation
otherwise
to
technology_30
component_6
others
from
technology_30
component_6
bar
routeid
barasync
requirement_2
drink
from
technology_30
component_6
dessertstation
routeid
dessertasync
requirement_2
dessert
from
technology_30
component_6
hotmealstation
routeid
hotmealasync
requirement_2
pattern_3
meal
from
technology_30
component_6
coldmealstation
routeid
coldmealasync
requirement_2
pattern_4
meal
from
technology_30
component_6
others
routeid
othersasync
requirement_2
others
}
bien
ahora
la
interacción
se
ha
vuelto
asincrónica
los
consumidores
potenciales
de
esta
información
pueden
acceder
a
ella
cuando
estén
listos
para
hacerlo
este
e
un
ejemplo
de
acoplamiento
quality_attribute_4
que
tratamos
de
lograr
en
una
arquitectura
reactiva
la
falta
de
disponibilidad
de
uno
de
los
servicios
no
bloqueará
a
los
demás
además
un
consumidor
puede
escalar
y
leer
de
la
cola
en
paralelo
la
cola
en
sí
misma
puede
escalar
y
ser
particionada
la
cola
persistentes
pueden
almacenar
los
datos
en
technology_4
disco
a
la
espera
de
ser
procesados
incluso
cuando
todos
los
participantes
se
cayeron
en
consecuencia
este
sistema
e
más
tolerante
a
la
falla
un
hecho
sorprendente
e
que
cern
usa
technology_1
technology_2
y
technology_28
para
monitorear
los
sistemas
del
gran
colisionador
de
hadrones
lhc
también
hay
una
tesis
de
maestría
interesante
que
explica
la
elección
de
una
solución
de
technology_11
apropiada
para
esta
tarea
entonces
como
dicen
en
la
parte
clave
“sin
jms—no
hay
física
de
partículas
”
monitorear
en
technology_4
ejemplo
anterior
creamos
technology_4
canal
de
datos
entre
do
servicios
e
un
punto
de
falla
potencial
adicional
en
una
arquitectura
por
lo
que
debemos
cuidarlo
echemos
un
vistazo
a
la
funciones
de
monitoreo
que
ofrece
technology_1
technology_2
básicamente
expone
información
estadística
sobre
sus
ruta
a
través
de
los
mbeans
a
los
que
puede
acceder
technology_32
technology_28
expone
estadísticas
de
cola
de
la
misma
manera
vamos
a
encender
technology_4
servidor
technology_32
en
la
aplicación
para
permitir
que
se
ejecute
con
la
opciones
de
línea
de
comando
dorg
technology_1
technology_2
technology_32
creatermiconnector=true
dorg
technology_1
technology_2
technology_32
mbeanobjectdomainname=org
technology_1
technology_2
dorg
technology_1
technology_2
technology_32
rmiconnector
registryport=1099
dorg
technology_1
technology_2
technology_32
serviceurlpath=camel
ahora
ejecuta
la
aplicación
para
que
la
ruta
haya
hecho
su
trabajo
abre
la
herramienta
estándar
jconsole
y
conéctate
al
proceso
de
solicitud
conéctate
a
la
url
component_7
technology_32
technology_33
technology_34
technology_33
localhost
technology_2
dirígete
al
dominio
technology_1
technology_2
en
technology_4
árbol
mbeans
podemos
ver
que
todo
sobre
enrutamiento
está
bajo
control
tenemos
technology_4
número
de
mensajes
en
vuelo
technology_4
recuento
de
errores
y
technology_4
recuento
de
mensajes
en
la
cola
esta
información
se
puede
canalizar
a
algún
conjunto
de
herramientas
de
monitoreo
con
una
gran
funcionalidad
como
graphana
o
kibana
puedes
hacer
esto
implementando
la
conocida
pila
elk
también
hay
una
consola
web
conectable
y
quality_attribute_5
que
proporciona
una
interfaz
de
usuario
para
administrar
technology_2
technology_28
y
muchos
más
llamada
hawt
io
probando
ruta
technology_1
technology_2
tiene
una
funcionalidad
bastante
amplia
para
escribir
ruta
de
prueba
con
componentes
simulados
e
una
herramienta
poderosa
pero
escribir
ruta
separadas
solo
para
la
pruebas
e
un
proceso
que
connector_4
tiempo
sería
más
eficiente
ejecutar
pruebas
en
la
ruta
de
producción
sin
modificar
su
canalización
technology_2
tiene
esta
característica
y
puede
implementarse
utilizando
technology_4
componente
advicewith
vamos
a
habilitar
la
lógica
de
prueba
en
nuestro
ejemplo
y
ejecutar
una
prueba
de
muestra
connector_2
junit
junit
version
version
scope
test
scope
connector_2
connector_2
technology_1
technology_2
technology_2
test
version
version
scope
test
scope
connector_2
la
clase
de
prueba
e
asyncroutetest
extend
cameltestsupport
{
@override
protect
routebuilder
createroutebuilder
throw
exception
{
asyncroutebuilder
}
@before
mockendpoints
throw
exception
{
component_8
getroutedefinition
advicewith
component_8
advicewithroutebuilder
{
@override
configure
throw
exception
{
we
substitute
all
actual
component_9
with
mock
mockendpointsandskip
technology_30
component_6
bar
mockendpointsandskip
technology_30
component_6
dessertstation
mockendpointsandskip
technology_30
component_6
hotmealstation
mockendpointsandskip
technology_30
component_6
coldmealstation
mockendpointsandskip
technology_30
component_6
others
and
replace
the
connector_5
s
component_3
with
test
replacefromwith
testinbox
}
}
}
@test
testsyncinteraction
throw
interruptedexception
{
testjson
=
{\
id\
\
order\
{\
id\
\
name\
\
americano\
\
type\
\
drink\
\
qty\
\
1\
}
{\
id\
\
name\
\
french
omelette\
\
type\
\
pattern_3
meal\
\
qty\
\
1\
}
{\
id\
\
name\
\
lasagna\
\
type\
\
pattern_3
meal\
\
qty\
\
1\
}
{\
id\
\
name\
\
rice
balls\
\
type\
\
pattern_3
meal\
\
qty\
\
1\
}
{\
id\
\
name\
\
blueberry
pie\
\
type\
\
dessert\
\
qty\
\
1\
}
}
connector_6
mock
and
set
an
expectation
mockendpoint
mockendpoint
=
getmockendpoint
mock
technology_30
component_6
hotmealstation
mockendpoint
expectedmessagecount
simulate
put
in
the
inbox
folder
template
sendbodyandheader
testinbox
testjson
exchange
file_name
test
technology_22
connector_7
that
expectation
be
meet
assertmockendpointssatisfied
}
}
ahora
ejecuta
pruebas
para
la
aplicación
con
mvn
test
podemos
ver
que
nuestra
ruta
se
ha
ejecutado
con
éxito
con
technology_4
asesoramiento
de
prueba
no
hay
mensajes
pasados
​​a
través
de
la
cola
real
y
la
pruebas
se
han
pasado
info
|
connector_5
start
and
connector_8
from
testinbox
info
|
incoming
test
technology_22
info
|
assert
mock
technology_30
component_6
hotmealstation
be
satisfy
usando
technology_1
technology_2
con
technology_3
cluster
uno
de
los
problemas
de
integración
hoy
en
día
e
que
la
aplicaciones
ya
no
son
estáticas
en
una
infraestructura
en
la
nube
trabajamos
con
servicios
virtuales
que
se
ejecutan
en
múltiples
nodos
al
mismo
tiempo
permite
la
arquitectura
de
microservicios
con
una
red
de
servicios
pequeños
y
livianos
que
interactúan
entre
sí
estos
servicios
tienen
una
vida
no
confiable
y
tenemos
que
descubrirlos
dinámicamente
pegar
servicios
en
la
nube
en
conjunto
e
una
tarea
que
se
puede
resolver
con
technology_1
technology_2
e
especialmente
interesante
por
technology_4
sabor
de
eip
y
technology_4
hecho
de
que
technology_2
tiene
muchos
adaptadores
y
admite
una
amplia
gama
de
protocolos
la
versión
reciente
agrega
technology_4
componente
servicecall
que
introduce
una
característica
de
llamar
a
una
component_2
y
resolver
su
dirección
a
través
de
mecanismos
de
descubrimiento
de
clúster
actualmente
e
quality_attribute_6
con
consul
technology_3
ribbon
etc
algunos
ejemplos
de
código
donde
servicecall
está
configurado
con
consul
se
pueden
encontrar
fácilmente
usaremos
technology_3
aquí
porque
e
mi
solución
de
clúster
favorita
technology_4
esquema
de
integración
será
technology_4
siguiente
technology_4
servicio
order
y
technology_4
servicio
inventory
será
un
par
de
aplicaciones
triviales
technology_6
devolviendo
datos
estáticos
no
estamos
atados
a
una
pila
de
tecnología
particular
aquí
estos
servicios
están
produciendo
los
datos
que
queremos
procesar
controlador
de
servicio
de
orden
@restcontroller
ordercontroller
{
private
final
orderstorage
orderstorage
@autowired
ordercontroller
orderstorage
orderstorage
{
this
orderstorage
=
orderstorage
}
@requestmapping
info
info
{
order
component_7
uuid
=
+
orderapplication
serviceid
}
@requestmapping
order
connector_data_2
order
getall
{
orderstorage
getall
}
@requestmapping
order
{id}
order
getone
@pathvariable
{
orderstorage
getone
}
}
produce
connector_data_3
en
technology_4
formato
{
item
}
{
item
}
technology_4
controlador
de
servicio
inventory
e
absolutamente
similar
al
servicio
order
@restcontroller
inventorycontroller
{
private
final
inventorystorage
inventorystorage
@autowired
inventorycontroller
inventorystorage
inventorystorage
{
this
inventorystorage
=
inventorystorage
}
@requestmapping
info
info
{
inventory
component_7
uuid
=
+
inventoryapplication
serviceid
}
@requestmapping
item
connector_data_2
inventoryitem
getall
{
inventorystorage
getall
}
@requestmapping
item
{id}
inventoryitem
getone
@pathvariable
{
inventorystorage
getone
}
}
inventorystorage
e
un
repositorio
genérico
que
contiene
datos
en
este
ejemplo
devuelve
objetos
predefinidos
estáticos
que
se
clasifican
según
technology_4
siguiente
formato
{
name
laptop
description
up
to
hour
battery
life
requirement_3
9}
{
name
pattern_2
description
inch
response_time
7ms
requirement_3
0}
{
name
headphone
description
soft
leather
ear
cup
requirement_3
9}
{
name
mouse
description
design
for
comfort
and
quality_attribute_7
requirement_3
0}
{
name
keyboard
description
layout
u
requirement_3
5}
vamos
a
escribir
una
ruta
de
puerta
de
enlace
que
los
conecte
pero
sin
servicecall
en
este
paso
rest
order
connector_6
description
connector_6
all
order
with
detail
outtype
testresponse
connector_5
setheader
content
type
constant
component_1
technology_22
setheader
connector_9
constant
component_1
technology_22
setheader
exchange
http_method
constant
connector_6
removeheaders
camelhttp*
to
http4
localhost
order
bridgeendpoint=true
unmarshal
formatorder
enrich
direct
enrichfrominventory
orderaggregationstrategy
to
requirement_2
connector_data_4
endrest
from
direct
enrichfrominventory
transform
quality_attribute_3
${null}
setheader
content
type
constant
component_1
technology_22
setheader
connector_9
constant
component_1
technology_22
setheader
exchange
http_method
constant
connector_6
removeheaders
camelhttp*
to
http4
localhost
item
bridgeendpoint=true
unmarshal
formatinventory
ahora
imagina
que
cada
servicio
ya
no
e
una
instancia
específica
sino
una
nube
de
instancias
que
funcionan
como
una
sola
usaremos
minikube
para
probar
technology_4
clúster
de
technology_3
localmente
configura
la
ruta
de
la
red
para
ver
los
nodos
de
technology_3
localmente
technology_4
ejemplo
dado
e
para
un
entorno
mac
linux
#
remove
exist
connector_3
sudo
connector_5
n
delete
dev
&1
#
connector_3
sudo
connector_5
n
$
minikube
ip
#
ip
range
be
use
by
technology_35
in
minikube
sudo
connector_5
n
$
minikube
ip
ifconfig
bridge100
|
grep
member
|
technology_36
{print
$2}’
#
use
name
from
the
output
of
the
previous
command
#
need
for
xhyve
driver
which
i
m
use
for
test
sudo
ifconfig
bridge100
hostfilter
en5
envuelve
los
servicios
en
contenedores
technology_35
con
una
configuración
de
dockerfile
como
esta
from
openjdk
jdk
alpine
volume
tmp
target
order
srv
snapshot
jar
component_10
jar
target
lib
lib
env
java_opts=
entrypoint
exec
technology_5
$java_opts
djava
quality_attribute_8
egd=file
dev
urandom
jar
component_10
jar
crea
y
envía
la
imágenes
del
servicio
al
registro
de
technology_35
ahora
ejecuta
los
nodos
en
technology_4
clúster
local
de
technology_3
configuración
de
implementación
de
technology_3
technology_37
apiversion
extension
v1beta1
kind
deployment
metadata
name
inventory
spec
replica
selector
matchlabels
component_10
inventory
template
metadata
label
component_10
inventory
spec
container
name
inventory
image
inventory
srv
late
imagepullpolicy
never
port
containerport
exponer
estas
implementaciones
como
servicios
en
clúster
kubectl
connector_10
deployment
order
srv
type=nodeport
kubectl
connector_10
deployment
inventory
srv
type=nodeport
ahora
podemos
verificar
si
la
solicitude
son
atendidas
por
nodos
elegidos
al
azar
del
clúster
ejecuta
curl
x
technology_38
info
secuencialmente
varias
veces
para
acceder
al
minikube
nodeport
para
technology_4
servicio
expuesto
usando
tu
component_11
y
puerto
en
technology_4
resultado
vemos
que
hemos
logrado
equilibrio
de
solicitude
~~~
inventory
component_7
uuid
=
22f8ca6b
f56b
927b
cbf9fcf81da5
inventory
component_7
uuid
=
b7a4d326
1e76
a0a6
1016394fafda
inventory
component_7
uuid
=
b7a4d326
1e76
a0a6
1016394fafda
inventory
component_7
uuid
=
22f8ca6b
f56b
927b
cbf9fcf81da5
inventory
component_7
uuid
=
50323ddb
3ace
820a
6b4e85775af4
~~~
agrega
la
dependencias
technology_2
technology_3
y
technology_2
netty4
technology_38
al
pom
technology_21
del
proyecto
a
continuación
configura
technology_4
componente
servicecall
para
usar
technology_4
descubrimiento
de
nodo
maestro
de
technology_3
compartido
para
toda
la
llamadas
de
servicio
entre
la
definiciones
de
ruta
kubernetesconfiguration
kubernetesconfiguration
=
kubernetesconfiguration
kubernetesconfiguration
setmasterurl
technology_38
kubernetesconfiguration
setclientcertfile
component_12
antongoncharov
minikube
component_13
crt
kubernetesconfiguration
setclientkeyfile
component_12
antongoncharov
minikube
component_13
key
kubernetesconfiguration
setnamespace
default”
servicecallconfigurationdefinition
config
=
servicecallconfigurationdefinition
config
setservicediscovery
kubernetesclientservicediscovery
kubernetesconfiguration
component_8
setservicecallconfiguration
config
technology_4
servicecall
eip
complementa
bien
technology_4
technology_6
la
mayoría
de
la
opciones
se
pueden
configurar
directamente
en
technology_4
archivo
component_1
property
potenciar
la
ruta
technology_2
con
technology_4
componente
servicecall
rest
order
connector_6
description
connector_6
all
order
with
detail
outtype
testresponse
connector_5
hystrix
setheader
content
type
constant
component_1
technology_22
setheader
connector_9
constant
component_1
technology_22
setheader
exchange
http_method
constant
connector_6
removeheaders
camelhttp*
servicecall
requirement_4
srv
http4
requirement_4
deployment
bridgeendpoint=true
unmarshal
formatorder
enrich
direct
enrichfrominventory
orderaggregationstrategy
to
requirement_2
connector_data_4
endrest
from
direct
enrichfrominventory
transform
quality_attribute_3
${null}
setheader
content
type
constant
component_1
technology_22
setheader
connector_9
constant
component_1
technology_22
setheader
exchange
http_method
constant
connector_6
removeheaders
camelhttp*
servicecall
order
srv
http4
order
srv
bridgeendpoint=true
unmarshal
formatinventory
también
activamos
technology_4
disyuntor
en
la
ruta
e
un
gancho
de
integración
que
permite
detener
llamadas
remotas
del
sistema
en
caso
de
errores
de
entrega
o
falta
de
disponibilidad
del
destinatario
esto
está
diseñado
para
evitar
falla
en
technology_4
sistema
en
cascada
technology_4
componente
hystrix
ayuda
a
lograr
esto
implementando
technology_4
patrón
de
disyuntor
vamos
a
ejecutarlo
y
enviar
una
solicitud
de
prueba
obtendremos
la
respuesta
agregada
de
ambo
servicios
{
item
{
name
pattern_2
description
inch
response_time
7ms
requirement_3
0}
{
name
headphone
description
soft
leather
ear
cup
requirement_3
9}
{
name
mouse
description
design
for
comfort
and
quality_attribute_7
requirement_3
0}
}
{
item
{
name
keyboard
description
layout
u
requirement_3
5}
{
name
headphone
description
soft
leather
ear
cup
requirement_3
9}
}
technology_4
resultado
e
technology_4
esperado
otros
casos
de
uso
mostré
cómo
technology_1
technology_2
puede
integrar
microservicios
en
un
clúster
¿cuáles
son
otros
usos
de
este
marco
en
general
e
útil
en
cualquier
lugar
donde
technology_4
enrutamiento
basado
en
reglas
sea
una
solución
por
ejemplo
technology_1
technology_2
puede
ser
un
technology_11
para
technology_4
internet
de
la
cosas
con
technology_4
adaptador
eclipse
kura
puede
manejar
la
monitorización
mediante
technology_4
transporte
de
señales
de
registro
de
diversos
componentes
y
servicios
como
en
technology_4
sistema
cern
también
puede
ser
un
marco
de
integración
para
pattern_6
empresarial
o
ser
un
portafolio
para
technology_4
procesamiento
de
datos
por
lot
aunque
no
compite
bien
con
technology_1
technology_39
en
esta
área
conclusión
puedes
ver
que
la
integración
de
sistemas
no
e
un
proceso
fácil
tenemos
suerte
porque
se
ha
acumulado
mucha
experiencia
e
importante
aplicarlo
correctamente
para
crear
soluciones
flexibles
y
tolerantes
a
falla
para
asegurar
la
aplicación
correcta
recomiendo
tener
una
lista
de
verificación
de
aspectos
importantes
de
integración
los
artículos
imprescindibles
incluyen
¿hay
una
capa
de
integración
separada
¿hay
pruebas
de
integración
¿conocemos
la
intensidad
máxima
de
datos
esperada
¿conocemos
technology_4
tiempo
de
entrega
de
datos
esperado
¿tiene
importancia
la
correlación
de
mensajes
¿qué
pasa
si
una
secuencia
se
rompe
¿deberíamos
hacerlo
de
forma
síncrona
o
asíncrona
¿dónde
cambian
los
formatos
y
la
reglas
de
enrutamiento
con
más
frecuencia
¿tenemos
formas
de
monitorear
technology_4
proceso
en
este
artículo
probamos
technology_1
technology_2
un
technology_40
de
integración
liviano
que
ayuda
a
ahorrar
tiempo
y
esfuerzo
al
resolver
problemas
de
integración
como
mostramos
puede
servir
como
una
herramienta
que
respalda
la
arquitectura
de
microservicios
relevante
al
asumir
la
total
responsabilidad
del
intercambio
de
datos
entre
los
microservicios
si
estás
interesado
en
aprender
más
sobre
technology_1
technology_2
recomiendo
mucho
technology_4
libro
“camel
in
action”
del
creador
del
technology_40
claus
ibsen
la
documentación
oficial
está
disponible
en
technology_2
technology_1
tagsmicroservicesintegrationapachecamelfreelancer
find
your
next
remote
freelance
jobsview
full
profileanton
goncharovfreelance
engineerabout
the
authoranton
be
a
skilled
back
end
engineer
and
a
passionate
learner
he
have
extensive
expertise
in
design
quality_attribute_1
and
quality_attribute_2
component_1
mainly
create
and
support
several
large
quality_attribute_9
quality_attribute_10
component_14
he
s
extremely
fluent
in
the
technology_5
technology_41
and
technology_6
technology_7
and
have
hand
on
experience
with
full
technology_7
technology_8
development
anton
also
strive
to
participate
in
work
he
have
open
component_3
pattern_7
publish
and
have
connector_11
speech
hire
antoncommentsplease
enable
technology_8
to
pattern_8
the
powered
by
disqus
powered
by
disqusworld
connector_11
weekly
connector_6
great
contentsubscription
imply
to
our
privacy
policythank
you
connector_7
out
your
inbox
to
confirm
your
invite
trend
articlesengineeringicon
chevronback
endoptimize
your
environment
for
development
and
production
a
pydantic
part
2engineeringicon
chevronback
endan
in
depth
look
at
technology_42
vs
javaengineeringicon
chevrondata
science
and
databasesunderstanding
twitter
dynamic
with
r
and
gephi
text
analysis
and
centralityengineeringicon
chevronweb
front
endacing
s
pagespeed
insight
assessmentsee
our
relate
talentapachekubernetesfreelancer
find
your
next
remote
freelance
jobshire
the
authorview
full
profileanton
goncharovfreelance
engineerread
nextengineeringicon
chevronback
endoptimize
your
environment
for
development
and
production
a
pydantic
part
2world
connector_11
weekly
sign
me
upsubscription
imply
to
our
privacy
policythank
you
connector_7
out
your
inbox
to
confirm
your
invite
world
connector_11
weekly
sign
me
upsubscription
imply
to
our
privacy
policythank
you
connector_7
out
your
inbox
to
confirm
your
invite
toptal
developersalgorithm
developersangular
developersaws
developersazure
developersbig
connector_data_3
architectsblockchain
developersbusiness
intelligence
developersc
developerscomputer
vision
developersdjango
developersdocker
developerselixir
developersgo
engineersgraphql
developersjenkins
developerskotlin
developerskubernetes
expertsmachine
engineersmagento
developer
net
developersr
developersreact
requirement_5
developersruby
on
technology_43
developerssalesforce
developerssql
developerssys
adminstableau
developersunreal
component_15
developersxamarin
developersview
more
freelance
developersjoin
the
toptal®
hire
a
developerorapply
a
a
developermost
in
demand
talentios
developersfront
end
developersux
designersui
designersfinancial
component_5
consultantsinterim
cfosdigital
project
managersaws
expertsabouttop
3%clientsfreelance
developersfreelance
designersfreelance
finance
expertsfreelance
project
managersfreelance
technology_44
managersfreelance
jobsspecialized
servicesutilities
&
toolsresearch
&
analysis
centerabout
uscontactcontact
uspress
centercareersfaqsocialthe
world
s
top
talent
on
demand®copyright
toptal
llcprivacy
policywebsite
termsaccessibilityby
click
connector_9
you
agree
to
our
use
of
and
other
track
technology_45
in
accordance
with
our
requirement_6
connector_9
