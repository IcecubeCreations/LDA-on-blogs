technology_1
technology_2
and
the
requirement_1
of
abstraction
technology_1
technology_2
and
the
requirement_1
of
abstraction
|
antoine
kalmbach’s
antoine
kalmbach
home
about
index
technology_3
antoine
kalmbach
ane@iki
fi
technology_1
technology_2
and
the
requirement_1
of
abstraction


technology_1
technology_2
be
a
connector_1
and
mediation
component_1
if
that
doesn’t
say
anything
to
you
let’s
try
this
technology_2

you
connector_2
together
these
can
vary
they
can
quality_attribute_1
local
component_2

or
external
component_3
technology_4
or
web
component_4
it
have
a
common
technology_5
technology_6
for
the
connector_data_1
so
that
your
connector_data_1
can
be
technology_7
agnostic
and
an
intuitive
dsl
for
specify
the
connector_3
and
how
the
connector_data_1
should
be
component_5
between
connector_data_2
the
common
technology_5
consist
of
exchange
and
connector_data_2
these
be
pattern_1
into
technology_7
specific
technology_6

a
technology_8
connector_data_3
by
component_2
which
provide
the
technical
implementation
of
that
component_4
i
e
the
translation
of
a
quality_attribute_1
connector_data_2
into
an
actual
technology_8
connector_data_3
the
connector_3
be
an
intuitive
dsl
that
speak
in
term
such
a
from
and
to
informally
you
can
create
a
connector_4
that
can
for
example
connector_5
connector_data_4
from
technology_9
and
connector_6
them
to
a

the
technology_5
be
much
rich
than
this
grouping
together
thing
aggregation
pattern_2
connector_7
split
load
balance
the
connector_data_5
go
on
choose
what
component_2
to
instantiate
be
do
use
an
uri
an
uri
will
identify
the
target
component_2
e
g
technology_10
myserver

instantiate
the
technology_10
component_2

instantiate
the
component_2
netty4
instantiate
the
technology_11
component_2
version


a
long
a
the
component_2
be
quality_attribute_2
in
the
classpath
it
will
be
instantiate
in
the
background
by
technology_2
the
total
number
of
quality_attribute_2
component_6
be
huge
you
have
e
g
technology_9
technology_10
technology_12
avro
connector
and
directory
rest
technology_13
technology_14
etc
more
esoteric
one
smpp
–
yes
you
can
connector_8
sm
with
technology_2
so
what’s
the
point
let’s
assume
we
need
to
quality_attribute_3
an
upstream
component_7
xyz
into
bar
xyz
provide
connector_data_1
to
you
use
a
binary
technology_15
technology_6
use
some

technology_7
technology_9
then
you
need
to
apply
some
transformation
to
the
connector_data_1
finally
connector_9
it
to
bar
which
connector_10
technology_16
and
require
the
connector_data_6
to
be

to
someurl
in
a
non
technology_2
set
use
your
favorite
technology_5
to
do
this
you
use
an
technology_4
connector
you
build
your
component_8
reader
and
de
serializer
apply
your
requirement_2
component_9
whatever
that
be
to
the
de
serialize
connector_data_1
transform
into
connector_data_7
the
connector_data_1
towards
someurl
use
some
technology_8
technology_17
fairly
straightforward
right
all
you
need
be
an
technology_4
technology_17
a
technology_8
technology_17
and
something
that
work
with
technology_15
and
technology_16
here’s
where
it
connector_11
hairy
three
month
in
you
be
inform
that
the
upstream
component_10
be
convert
to
technology_10
oh
well
you
think
it’s
nice
fast
and
connector_12
a
sane
version
of
technology_18
why
not
so
you
refactor
technology_4
to
technology_10
and
there
it
be
the
point
of
technology_2
be
this
the
previous
step
require
you
to
manually
refactor
your
technology_4
component_9
to
technology_10
but
you’re
connector_9
connector_data_2
you
don’t
really
care
about
the
technology_7
you’re
connector_9
connector_data_4
to
an

it’s
the
connector_data_1
you
should
care
about
nothing
else
so
here’s
when
technology_1
technology_2
come
in
it
let’s
you
specify
an
url
technology_10
localhost
blah
routingkey=events
xmc
*
to
use
the
technology_10
component_2
and
to
painlessly
switch
to
technology_12
you’d
a
connector_13
to
the
technology_2
technology_12
artifact
and
specify
the
url
a
technology_12
localhost

topic=test
and
the
technology_2
technology_12
component_2
handle
connector_data_2
delivery
for
you
since
you’re
connector_9
canonical
technology_2
connector_data_2
you
needn’t
trouble
yourself
on
how
this
connector_data_2
be
already
connector_8
it
be
likely
that
you
will
have
to
or
remove
some
connector_data_2

though
now
you
be
ask
be
that
it
be
it
really
that
quality_attribute_1
the
answer
be
that
it
quality_attribute_4
some
component_6
be
quality_attribute_5
than
others
if
you
want
to
be
truly
technology_7
and
component_2
agnostic
and
you
want
to
refactor
from
technology_7
foo
to
bar
by
switch
the
url
of
foo
to
bar
you
need
to
make
sure
that
you
can
configure
everything
for
that
use
the
uri
connector_data_2
exchange
do
not
require
extra
shenanigan
to
work
no
custom

or
a
special
technology_6
require
requirement_3
in
point
let’s
compare
switch
from
technology_4
to
technology_10
the
first
glare
difference
be
that
the
technology_4
component_2
do
not
connector_10
the
component_11
part
in
the
uri
so
we
need
to
do
something
camelcontext
ctx
=
defaultcamelcontext
ctx
addcomponent
technology_9
activemqcomponent
activemqcomponent
technology_19
component_12
pass@hostname
pattern_3
persistent=false
this
make
any
technology_9
uri
in
the
component_13
ctx
connector_2
to
the
parameter
configure
conversely
the
technology_10
component_2

you
directly
set
this
in
the
uri
part
multiple
connector_14
can
be
give
with
the
connector_14
parameter
so
if
you’re
go
with
technology_4
to
technology_10
your
actually
become
quality_attribute_1
but
the
complexity
merely
move
to
the
uri
the
other
way
around
you
have
to
move
your
uri
configuration
to
actual
or
technology_16
but
please
don’t
so
where
do
this
lead
u
ideally
the
situation
be
that
give
between
a
choice
between
three
component_2
you
could
use
an
external
configuration
that
configure
a
quality_attribute_1
uri
the
right
component_2
be
identify
base
on
the
uri
connector_15
out
of
the
classpath
this
assume
that
in
order
of
importance
the
be
volatile
and
finite
and
can
vary
between
different
implementation
each
implementation
have
a
component_2
which
be
in
the
classpath
and
say
volatility
vary
often
enough
it
warrant
dynamic
quality_attribute_6
via
configuration
edit
and
component_14
restart
if
all
of
the
above
hold
true
technology_2
might
a
quality_attribute_5
fit
for
you
otherwise
i’d
be
careful
the
abstraction
isn’t
free
what
this
lead
to
be
a
kind
of
complexity
shovel
although
with
the
technology_10
component_2
we
don’t
need
to
use
to
configure
it
we
move
it
to
the
uri
so
it’s
still
a
configuration
point
yet
it’s
a
nice
configuration
point
a
in
the
example
above
we
see
that
the
connector_3
contain
three
quality_attribute_7
variable
component_12
pass
and
hostname
so
in
addition
to
have
to
configure
the
component_7
use

we
have
to
still
configure
it
otherwise
lest
we
hard

the
requirement_4
into
the
component_15
the
above
approach
suffer
from
decentralization
you
now
have
two
place
where
you
customize
your
component_7
the
first
be
define
the
custom
component_2
for
a
component_7
in

the
second
be
configure
say
custom
component_2
via
other
mean
our
ability
to
centralize
configuration
–
any
configuration
not
that
of
technology_2
–
quality_attribute_4
on
the
power
of
the
configuration
technology_5
too
powerful
you
end
up
in
dsl
hell
not
powerful
enough
people
connector_6
their
own
horror
show
to
power
lastly
we
run
in
the
problem
of
universal
pluggability
or
universal
composition
we
imagine
that
component_16
technology_2
u
“run
anything”
and
“connect
everything”
but
the
reality
be
different
component_16
be
usually
make
of
a
finite
set
of
component_2
for
practical
purpose
it
make
no
sense
to
quality_attribute_4
on
every
technology_2
component_2
therefore
you
need
to
pick
your
connector_13
from
this
finite
set
of


this
effectively
shatter
the
myth
of
universal
pluggability
most
importantly
though
nobody
really
need
this
what
really
matter
be
the
quality_attribute_8
of
extension
a
well
design
component_2
be
completely
quality_attribute_7
through
it
uri
parameter
these
be
easy
to
to
your
technology_2
base
component_7
you
only
need
to
understand
the
configuration
the
connector_13
and
you’re
do
in
summary
if
you’re
consider
technology_1
technology_2
make
sure
you
connector_16
both
of
these
of
which
the
second
be
most
important
the
component_6
be
volatile
and
you
need
to
connector_17
them
often
so
that
you
can
justify
the
pluggable
hole
the
connector_17
uri
the
component_6
you
want
exist
and
be
completely
quality_attribute_7
via
that
pluggable
hole
if
you’re
unsure
of
the
first
item
you
can
still
treat
technology_2
a
a
lazy
way
to
future
proof
the
component_7
e
g
by
use
one
component_2
now
while

that
another
be
use
in
the
future
to
that
end
you
need
to
make
sure
that
the
component_6
fit
the
above
requirement
i’m
currently
work
on
a
technology_20
technology_17
for
a
technology_21
base
connector_1
dsl
it’s
shape
up
to
be
quite
nice
here’s
an
example
of
the
connector_1
dsl
connector_4
from
netty4
technology_8
localhost

foo
component_5
comp
body
in
to
technology_10
localhost

foo
my
goal
be
to
make
the
dsl
terse
and
functional
which
the
current
component_17
really
isn’t
and
to
technology_22
technology_2
component_18
and
component_19
to
it
the
nice
thing
about
technology_20
be
that
the
macro
component_7

me
define
these
really
easily
overall
technology_2
be
a
nice
abstraction
well
worth
the
effort
and
year
that
have
be
put
into
it
it’s
not
a
free
abstraction
since
there’s
always
a
slight
quality_attribute_9
or
configuration
overhead
if
it
work
it
remove
programmer
from
the
technology_7
level
move
them
to
the
connector_data_1
level
this
be
the
level
where
you
should
be
work
at
if
your
goal
be
to
shuffle
connector_data_1
around
for
this
purpose
when
it
work
technology_2
be
excellent
conversely
if
it
doesn’t
it
put
programmer
at
an
awkward
position
you’re
still
work
with
both
connector_data_1
and
technology_7
and
you
have
the
overhead
of
the
technology_23
to
deal
with
bad
your
be
now
pollute
by
the
requirement
of
technology_2

when
the
goal
of
technology_2
be
to
completely
remove
the
requirement
impose
by
in
general
that
say
in
requirement_5
scenario
technology_2
work
most
of
the
time
so
you
should
always
have
a
think
about
it
before
you
start
use
it
previous
half
technology_24
web
technology_23
next
implicit
power
©
antoine
kalmbach
see
copy
last
update
on


