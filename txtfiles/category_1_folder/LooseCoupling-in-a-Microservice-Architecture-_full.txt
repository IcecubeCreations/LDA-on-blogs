loose
couple
in
a
pattern_1
architecture
linkedin
and
3rd
party
use
essential
and
non
essential

to
provide
quality_attribute_1
analyze
and
improve
our
component_1
and
to
show
you
relevant

include
professional
and

on
and
off
linkedin
more
in
our
requirement_1
select
connector_1
to
or
reject
to
decline
non
essential

for
this
use
you
can
update
your
choice
at
any
time
in
your
setting
connector_1
reject
linkedin
patrick
van
vuuren
expand
search
people

dismiss
dismiss
dismiss
dismiss
dismiss
join
now
sign
in
loose
couple
in
a
pattern_1
architecture
report
this
coding_keyword_1
patrick
van
vuuren
patrick
van
vuuren
engineer
consultant
at
info
support
publish
oct


+
follow
more
and
more
monolithic
component_2
be
be
refactored
or
rewrite
use
the
pattern_1
architectural
pattern_2
this
be
about
how
pattern_3
can
be
decouple
in
numerous
way
use
technique
such
a
component_1
discovery
and
connector_data_1
component_3
loose
couple
be
basically
minimize
the
connector_2
between
two
or
more
component_4
connector_3
component_5
in
the
component_6
of
pattern_3
one
of
many
reason
why
requirement_2
abandon
monolithic
component_7
be
that
in
those
component_2
mostly
be
very
tightly
couple
connector_4
on
one
place
possibly
involve
make
connector_5
in
other
place
which
increase
the
development
time
and
effort
need
to
connector_6
that
extra
feature
also
separate
your
concern
within
a
monolith
be
very
difficult
to
maintain
because
the
amount
of
concern
you
have
to
deal
with
keep
grow
with
pattern_3
every
component_1
have
it
s
own
component_6
and
set
of
and
take
care
of
a
specific
concern
one
pattern_1
can
connector_4
it
entire
component_8
from
the
inside
but
from
the
outside
it
still
do
the
same
thing
awesome
right
therefore
the
decouple
between
pattern_3
be
enforce
automatically
by
separate
concern
whilst
this
be
very
quality_attribute_2
we
can
do
a
quality_attribute_2
at
decouple
by
focus
on
the
component_9
s
connector_7
connector_7
between
pattern_3
design
the
connector_7
between
pattern_3
be
one
of
the
most
important
thing
besides
separate
your
concern
how
you
connector_8
this
connector_7
can
be
do
in
several
way
for
several
purpose
i
ll
dive
into
two
technique
component_1
discovery
and
connector_data_1
technology_1
pattern_4
&
component_1
discovery
one
of
the
common
connector_7
pattern_2
be
to
use
technology_1
rest
these
be
define
in
each
pattern_1
to
fetch
and
modify
connector_data_2
one
of
the
downside
of
plain
technology_1
rest
be
that
you
need
to
give
every
pattern_1
knowledge
about
the
pattern_4
of
other
component_1
this
be
what
i
connector_data_3
a
connector_9
knowledge
in
your
component_9
wherein
a
pattern_1
have
knowledge
about
the
purpose
of
an
other
component_1
and
what
the
component_1
possibly
can
do
that
way
the
component_9
become
a
quality_attribute_3
monolith
because
the
requirement_3
component_8
be
split
up
into
separate
component_6
with
still
a
very
high
quality_attribute_4
between
each
component_1
a
high
quality_attribute_4
between
component_10
will
create
issue
because
a
pattern_1
that
be
do
connector_data_4
to
an
unavailable
pattern_4
because
of
a
component_1
outage
example
cannot
on
it
s
own
this
be
an
undesirable
manner
of
couple
one
of
the
possible
solution
be
a
technique
connector_10
component_1
discovery
each
pattern_1
register
it
own
technology_1
pattern_4
into
one
or
multiple
registry
quality_attribute_5
on
how
you
connector_11
component_6
on
that
infrastructural
level
from
this
registry
each
pattern_1
can
query
quality_attribute_6
technology_1
pattern_4

these
should
be
define
in
such
a
way
that
it
be
not
clear
which
component_1
it
be
but
what
it
can
do
a
component_1
should
not
care
about
which
component_1
do
the

but
that
a
component_1
do
the

a
real
world
example
be
go
with
your
bag
to
the
supermarket
and
buy
stuff
to
connector_12
the
do
any
cash
desk
will
do
although
we
would
to
connector_12
stuff
for
free
a
long
a
you
can
pay
for
your
stuff
and
go
home
although
this
be
a
lot
quality_attribute_2
it
still
have
certain
drawback
for
example
up
time
of
component_10
and
every
connector_data_5
always
require
a
connector_data_6
these
drawback
be
something
we
can
handle
with
our
next
topic
connector_data_1
pattern_5
&
bound
component_6
to
explain
how
we
can
conquer
these
drawback
i
will
first
describe
a
use
requirement_4
connector_8
with
component_1
discovery
coding_keyword_2
s
say
we
have
a
todo
connector_data_7
where
we
can
create
todo
s
however
our
bos
do
not
want
short
descriptive
todos
so
we
need
to
have
a
component_1
that
can
create
todos
but
also
one
that
can
validate
them
while
create
them
if
you
do
a
connector_data_5
from
the
component_11
the
connector_data_5
be
connector_13
to
the
component_1
that
create
todos
this
component_1
validate
the
todo
via
a
todo
validator
component_1
this
validator
coding_keyword_3
either
valid
or
invalid
if
valid
the
todo
be
create
and
the
component_12
connector_14
the
todo
in
the
todo
connector_data_7
if
invalid
the
component_12
connector_14
a
connector_data_8
why
the
todo
be
invalid
ok
connector_12
that
if
not
this
component_13
be
demonstrate
in
the
image
below
assume
every
component_1

where
to
connector_15
connector_data_9
to
via
component_1
discovery
a
explain
before
this
image
show
that
every
connector_data_5
require
a
connector_data_6
because
if
the
requestor
do
not
connector_12
a
connector_data_6
it
simply
cannot
do
anything
on
it
s
own
also
if
you
want
the
validator
to
connector_15
a
connector_data_1
that
be
interest
for
the
component_11
while
this
component_13
be
happen
you
have
a
problem
connector_16
a
connector_data_1
from
the
validator
be
not
possible
without
put
very
large
requirement_3
component_8
in
your
component_11
component_7
something
you
should
never
do
on
top
of
that
the
todo
creator
will
connector_12
a
connector_17
he
have
to
understand
and
have
to
deal
with
connector_16
connector_17
from
each
component_1
to
the
component_11
by
itself
reduce
the
knowledge
require
by
a
component_1
with
connector_data_1
you
do
not
have
to
think
about
wait
for
a
connector_data_6
on
the
publish
connector_data_1
you
only
have
to
think
within
the
pattern_1
itself
by
publish
connector_data_10
and
subscribe
to
certain
connector_data_1
for
example
a
component_11
be
interest
in
todos
that
be
create
or
not
pass
the
validation
a
validator
be
only
interest
in
todos
that
need
validation
and
publish
connector_data_10
about
whether
something
be
valid
or
invalid
the
creator
be
only
interest
in
todos
that
be
connector_data_5
for
creation
and
the
one
that
be
valid
so
the
todos
can
be
component_14
within
all
connector_7
a
certain
identifier
be
always
pass
with
every
connector_data_1
publish
our
component_12
component_7
can
then
differentiate
the
different
connector_data_10
come
in
by
that
identifier
so
correct
pattern_6
will
be
update
this
technique
allow
one
to
only
to
think
about
what
your
pattern_5
connector_data_11
and
connector_data_1
name
need
to
look
and
you
be
quality_attribute_2
to
go
with
that
say
the
follow
image
show
this
visually
keep
in
mind
that
this
be
a
use
requirement_4
do
demonstrate
the
power
of
connector_data_1
not
about
how
this
domain
should
look

beautiful
isn
t
it
use
this
kind
of
connector_7
every
component_1
be
interest
in
certain
connector_data_1
do
something
with
that
connector_data_1
and
publish
other
connector_data_1
what
happen
with
those
connector_data_10
be
not
relevant
for
the
component_1
the
component_1
operate
within
it
own
component_6
and
not
that
of
others
also
the
component_12
component_11
do
not
directly
rely
anymore
on
the
todo
creator
same
thing
for
the
todo
creator
vs
todo
validator
to
quality_attribute_2
understand
this
i
connector_6
an
example
base
on
a
previous
example
from
one
of
my

technology_2
redux
&
websockets
it
demonstrate
the
connector_7
flow
use
a
frontend
that
be
connector_18
to
a
gateway
via
websockets
a
addition
i

the
two
component_15
connector_6
in
technology_3
j
represent
the
todo
creator
and
todo
validator
for
the
pattern_5
i
use
technology_4
a
it
be
easy
to
set
up
a
few
component_16
for
our
messages*
with
every
connector_data_1
the
component_12
identifier
of
the
connector_18
technology_5
be
connector_13
with
every
connector_data_1
this
way
the
gateway

to
which
connector_data_12
it
should
connector_13
connector_data_13
to
a
there
be
no
direct
connector_17
connector_data_6
mechanism
the
example
component_17
can
be
find
on
here
low
couple
pattern_3
*
technology_4
introduce
a
single
point
of
failure
because
the
pattern_3
rely
on
the
technology_4
connector_data_1
pattern_7
for
subscribe
and
publish
connector_data_10
the
example
component_17
do
not
include
fallback
and
retry
feature
to
take
care
of
this
there
be
several
way
to
handle
this
by
use
cluster
quality_attribute_7
component_16
and
persistent
connector_data_1
so
downtime
be
minimal
and
connector_data_10
do
not
connector_12
lose
also
technology_4
isn
t
the
only
pattern_5
component_9
out
there
there
be
alternative
nats
and
technology_6
technology_7
wrap
up
pattern_3
be
about
separate
concern
in
different
bound
component_6
to
do
this
it
be
important
that
a
pattern_1
can
and
should
work
on
it
s
own
and
therefor
be
loosely
couple
connector_6
pattern_3
with
minimal
connector_2
do
not
give
a
pattern_1
unnecessary
knowledge
outside
it
s
own
component_6
use
minimal
direct
connector_7
between
component_10
to
ensure
it
have
no
direct
quality_attribute_4
and
therefore
can
on
it
s
own
big
thanks
for
connector_19
it
all
the
way
to
the
end
bear
in
mind
that
there
be
many
way
of
connector_20
and
design
pattern_3
there
be
simply
no
silver
bullet
in
do
it
though
pattern_3
connector_21
the
common
principle
of
separate
your
concern
decouple
make
that
easy
to
do
in
my
opinion
because
you
can
worry
le
about
the
rest
of
the
component_9
and
be
more
focus
on
the
component_8
within
your
pattern_1
patrick
van
vuuren
developer
&
scrum
master
@
proforto



connector_11
pranitha
reddy
kethiri
great
explanation
with
quality_attribute_8
example
usecase
crystal
clear
understand
provide
about
loosely
couple
micro
component_1
thanks
much
sign
in
to
this
connector_data_6
sign
in
to
connector_data_6
to
this
2y
report
this
stanislav
ondac
hello
coding_keyword_2
me
disagree
with
you
on
this
one
the
component_1
operate
within
it
own
component_6
and
not
that
of
others
pattern_5
help
you
only
with
operational
couple
you

t
need
other
component_1
to
be
quality_attribute_6
at
the
same
moment
but
not
with
logical
couple
validation
component_1
need
to
about
the
connector_data_1
connector_data_14
from
creator
component_1
or
any
other
component_1
who
will
produce
this
component_1
so
when
creator
connector_5
the
connector_data_1
connector_data_14
validator
be
affect
we
can
say
validator
be
tightly
couple
to
the
creator
component_1
sign
in
to
this
connector_data_6
sign
in
to
connector_data_6
to
this


3y
report
this
patrick
van
vuuren
hi
stanislav
thanks
for
your
connector_data_6
although
you
might
think
it
be
tightly
couple
i
technology_8
disagree
in
that
requirement_4
coding_keyword_2
me
explain
it
have
knowledge
how
to
validate
coding_keyword_2
s
say
todo
version

if
you
connector_4
the
connector_data_10
to
a
different
connector_data_14
coding_keyword_2
s
say
todo
version

he
will
invalidate
it
but
that
s
the
whole
point
it

how
to
validate
todo
version

the
validator
be
not
affect
or
tightly
couple
but
only
have
knowledge
of
a
certain
connector_data_1
connector_data_14
however
in
a
total
overview
without
the
validator
there
be
no
valid
todo
s
in
this
requirement_4
i
technology_8
advise
to
use
certain
contract
of
connector_data_1
schema
s
to
prevent
pick
up
or
connector_16
a
connector_data_1
that
have
a
different
connector_data_14
than
expect
these
will
help
with
further
implementation
a
complexity
grow
in
an
component_7
or
you
have
to
deal
with
versioning
sign
in
to
this
connector_data_6
sign
in
to
connector_data_6
to
this
3y
report
this
balaji
sijapati
nice
explanation
sign
in
to
this
connector_data_6
sign
in
to
connector_data_6
to
this
3y
report
this
dele
agagu
great
and
well
connector_6
sign
in
to
this
connector_data_6
sign
in
to
connector_data_6
to
this
3y
report
this
rik
driever
go
stuk
patrick
ik
zie
in
je
voorbeeld
dat
elk
component_5
steed
alle
relevante
connector_data_2
uit
de
component_3
haalt
verwerkt
en
weer
opnieuw
in
de
component_3
zet
hoe
zou
je
dat
aanpakken
wanneer
het
om
veel
connector_data_2
gaat
sign
in
to
this
connector_data_6
sign
in
to
connector_data_6
to
this

5y
report
this
patrick
van
vuuren
dat
ligt
er
dan
aan
wat
veel
connector_data_2
be
momenteel
ervaar
ik
nog
weinig
limieten
omtrent
de
maximum
connector_data_11
van
een
bericht
in
bijvoorbeeld
technology_4
maar
mocht
je
echt
meet
requirement_5
werken
zou
je
technology_6
technology_7
kunnen
gebruiken
en
dan
specifiek
hun
connector_22
technology_9
daarnaast
zijn
er
ook
nog
mogelijkheden
meet
het
requirement_6
component_18
dataflow
in
combinatie
meet
pattern_8
be
in
die
zin
hetzelfde
principe
dat
pattern_8
werkt
al
een
pattern_5
systeem
waarbij
dataflow
heel
go
be
in
het
verwerken
van
je
connector_data_2
sign
in
to
this
connector_data_6
sign
in
to
connector_data_6
to
this
5y
report
this
see
more

to
pattern_6
or
a

sign
in
to
pattern_6
or
a

sign
in
more

by
this
author
see
all
technology_2
redux
&
websockets
aug



tip
to
improve
your
technology_10
es6
development
feb


technology_2
component_4
unit
test
sep


others
also
pattern_6
loosely
couple
strongly
cohesive
pattern_3
prathish
kumar
srinivasan
4mo
pattern_3
be
not
loosely
couple
saga
nithish
selvakumaran
2y
my
quality_attribute_8
word
to
clarify
the
confusion
between
technology_11
cognito
component_12
pool
and
identity
pool
ahmad
alhady
3y
should
you
provide
component_11
technology_12
to
micro
component_1
component_19
also
requirement_7
be
hard
severin
gassauer
fleissner
1y
linkedin
©

about
quality_attribute_9
component_12
agreement
privacy
requirement_1
requirement_1
copyright
requirement_1
brand
requirement_1
guest
control
guideline
العربية
arabic
čeština
czech
dansk
danish
deutsch
german
english
english
español
spanish
français
french
हिंदी
hindi
bahasa
indonesia
bahasa
indonesia
italiano
italian
日本語
japanese
한국어
korean
bahasa
malaysia
malay
nederland
dutch
norsk
norwegian
polski
polish
português
portuguese
română
romanian
русский
russian
svenska
swedish
ภาษาไทย
thai
tagalog
tagalog
türkçe
turkish
简体中文
chinese
simplify
正體中文
chinese
traditional
technology_13
