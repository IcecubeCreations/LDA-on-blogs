technology_1
technology_2
hornetq
und
technology_3
im
vergleichentwicklungbranchenssoschnittstellenesb
einführungbeispiel
clientsberatunganwendungsintegrationapi
reviewschulungwebinaremicroservicesintegrationrest
apisbig
datasoaonsitekursmaterialagbsteilnahme
faqbewertungenterminetermine
nach
datumraumanforderungenreferenzenfallstudienappssoaappsweb
0sonstigesveröffentlichungenmicroserviceskubernetes
&
dockerrestsecurityopen
component_1
integrationmobileenterpriseiotjavascriptsoa
&
web
servicesvorträgeautorenvideoopen
sourceapi
gatewaysoa
monitorservice
virtualisierungvirtuelle
serviceskontakthotelsanreisefreizeittippsjobssenior
technology_4
entwickler
w
m
djava
entwickler
m
w
djava
student
m
w
dkubernetes
administrator
m
w
dfreiberufler
m
w
dbachelorarbeitenbewerbung
al
coderinhalt
der
bewerbungazubi
fachinformatiker
w
m
dactivemq
technology_2
hornetq
und
technology_3
im
vergleichvon
thomas
bayerdatum
januar
2013aktualisiert
juli
2018neuere
architekturen
und
da
standardisierte
technology_5
protokoll
haben
zu
einer
wahren
flut
an
connector_data_1
brokern
geführt
alle
pattern_1
nehmen
für
sich
in
anspruch
schnell
quality_attribute_1
und
zuverlässig
zu
sein
aber
worin
unterscheiden
sich
die
pattern_1
wirklich
wie
wähle
ich
einen
geeigneten
pattern_1
au
sollte
man
weiterhin
etablierte
pattern_1
wie
zum
beispiel
den
technology_6
verwenden
dieser
artikel
versucht
diese
fragen
zu
beantworten
und
den
leser
bei
der
auswahl
eines
geeigneten
pattern_1
zu
unterstützen
die
in
diesem
artikel
beschriebenen
pattern_1
mussten
unter
einer
open_source
lizenz
verfügbar
seinzugriff
von
technology_4
au
ermöglichenquality
of
component_2
eigenschaften
wie
garantierte
zustellung
und
persistenz
bieten
in
den
nächsten
abschnitten
werden
die
pattern_1
mit
ihren
besonderheiten
vorgestellt
danach
werden
kriterien
wie
persistenz
unterstützte
plattformen
performanz
und
verbreitung
behandelt
die
beschreibung
der
einzelnen
pattern_1
beginnt
mit
dem
verteidiger
dem
etablierten
technology_6
pattern_1
technology_7
activemqapache
technology_6
ist
mit
der
größten
anzahl
von
installationen
der
open_source
connector_data_1
pattern_1
mit
der
größten
verbreitung
technology_6
implementiert
die
technology_4
connector_data_1
component_2
spezifikation
und
bietet
zahlreiche
feature
wie
z
b
unterstützung
für
die
requirement_1
requirement_2
pattern_2
für
da
technology_8
technology_9
und
für
transaktionen
für
die
persistierung
von
nachrichten
können
verschiedene
speicher
verwendet
werden
die
datei
basierte
kaha
datenbank
bietet
eine
sehr
gute
performanz
da
sie
in
der
technology_4
vm
de
pattern_1
ausgeführt
wird
wenige
ressourcen
benötigt
und
für
nachrichten
optimiert
ist
beliebt
ist
im
requirement_1
umfeld
aber
die
verwendung
einer
relationalen
datenbank
wie
z
b
ibms
db
oder
die
datenbank
von
technology_10
die
verwendung
eines
technology_11
speicher
zusammen
mit
einer
relationalen
datenbank
ist
mit
einer
geschwindigkeitseinbuße
verbunden
bringt
jedoch
vorteile
für
den
betrieb
die
datenbank
für
die
persistenz
von
nachrichten
kann
in
da
operate
eines
rechenzentrums
eingebunden
werden
und
für
da
backup
kann
der
bestehende
mechanismus
verwendet
werden
e
macht
jedoch
nicht
immer
sinn
ein
backup
für
einen
nachrichten
speicher
zu
erstellen
ein
highlight
beim
technology_6
sind
die
zahlreichen
möglichkeiten
für
cluster
und
verteilung
um
beim
ausfall
eines
pattern_1
den
betrieb
aufrecht
zu
erhalten
kann
technology_6
in
einer
pattern_3
konfiguration
betrieben
werden
ferner
können
mehrere
pattern_1
zu
einem
requirement_3
of
pattern_1
verbunden
werden
in
einem
requirement_3
of
pattern_1
sind
component_3
und
topic
publish
subscribe
virtuell
technology_12
h
eine
component_4
ist
auf
allen
knoten
verfügbar
und
da
connector_1
findet
automatisch
statt
abbildung
skizziert
einen
virtuellen
pattern_1
den
man
mit
verteilten
technology_6
installation
realisieren
könnte
abbildung
virtueller
pattern_1
mit
weltweit
verteilten
knotenactivemq
wird
in
einigen
requirement_1
component_2
bus
produkten
wie
z
b
beim
servicemix
und
technology_13
esb
al
bus
infrastruktur
verwendet
daneben
gibt
e
noch
zahlreiche
andere
projekte
die
technology_6
für
den
transport
von
nachrichten
verwenden
technology_7
geronimo
und
tomee
die
technology_4
requirement_1
edition
de
technology_14
web
container
verwenden
technology_6
al
technology_15
implementierung
der
fuse
mq
requirement_1
pattern_1
von
progress
basiert
auf
dem
technology_7
technology_6
pattern_1
bugfix
versionen
der
fuse
variante
werden
öfter
release
al
die
technology_6
versionen
von
technology_7
seit
seinen
anfängen
in
ist
der
technology_6
pattern_1
gereift
und
hat
eine
große
verbreitung
erlangt
kinderkrankheiten
wie
speicherlöcher
sind
längst
beseitigt
für
die
meisten
pattern_4
aufgaben
arbeitet
technology_6
zuverlässig
hoch
performant
und
ressourcen
schonend
für
da
requirement_1
pattern_4
ist
technology_6
immer
noch
eine
sehr
gute
wahl
technology_6
hat
jedoch
konkurrenz
bekommen
die
mit
neueren
architekturen
besserer
performanz
und
mit
der
unterstützung
von
standardisierten
protokollen
im
revier
de
platzhirsches
wildert
technology_7
apolloupdate
wurde
technology_7
apollo
nichtoffiziell
für
tot
erklärt
eine
weitere
entwicklung
findet
nicht
statt
möglicherweise
ist
technology_7
artemis
die
nächste
version
de
technology_6
pattern_1
technology_1
bekommt
von
technology_7
apollo
konkurrenz
au
dem
eigenen
hause
apollo
ist
eine
neuentwicklung
basierend
auf
den
erfahrungen
de
technology_6
projektes
um
schneller
quality_attribute_1
und
besser
wartbar
zu
sein
al
technology_6
wurde
eine
komplett
neue
architektur
eingeführt
die
architektur
basiert
auf
der
programmiersprache
technology_16
die
gut
die
entwicklung
von
nebenläufigen
systemen
unterstützt
da
component_5
de
apollo
pattern_1
unterscheidet
sich
grundlegend
von
dem
de
technology_1
alle
aufgaben
werden
asynchron
und
nicht
blockierend
ausgeführt
be
zu
erhöhter
performanz
und
stabilität
beiträgt
dadurch
können
die
fähigkeiten
von
mehrkernprozessoren
besser
genutzt
werden
für
apollo
gibt
e
derzeit
zwei
speicher
für
persistente
nachrichten
zum
einen
über
die
technology_17
datenbank
leveldb
von
und
zum
anderen
über
die
technology_4
edition
der
berkeley
db
über
den
technology_18
technology_19
connector
kann
ein
pattern_4
component_6
direkt
in
eine
webseite
eingebunden
werden
da
folgende
connector_data_2
zeigt
wie
man
mit
technology_20
und
der
stomp
j
bibliothek
auf
einen
apollo
pattern_1
von
einer
webseite
au
zugreifen
kann
beim
verbindungsaufbau
wird
eine
pattern_5
funktion
angemeldet
die
beim
eintreffen
einer
nachricht
den
inhalt
in
einem
dialog
anzeigt
var
component_6
=
stomp
component_6
w
apollo
predic8
technology_21
component_6
connector_2
admin
pwd
frame
{
component_6
subscribe
topic
msg
{
alert
msg
body
}
}
connector_data_2
zugriff
auf
den
apollo
pattern_1
mit
stomp
und
technology_20
da
senden
von
nachrichten
au
dem
browser
heraus
kann
mit
dem
folgenden
technology_20
ein
zeiler
erfolgen
component_6
connector_3
topic
{}
inhalt
apollo
ist
zwar
in
technology_22
geschrieben
der
pattern_1
kann
aber
ohne
bedenken
in
einer
technology_4
umgebung
betrieben
werden
da
apollo
mit
technology_22
realisiert
ist
erkennt
man
nur
daran
da
die
distribution
neben
vielen
technology_4
bibliotheken
auch
einige
technology_22
bibliotheken
enthält
für
die
verwaltung
bietet
apollo
eine
einfache
web
konsole
wie
der
folgende
screenshot
zeigt
abbildung
admin
konsole
de
apollo
brokersändert
man
in
der
url
da
anhängsel
von
htmlnach
technology_23
bekommt
man
eine
technology_24
repräsentation
anstatt
einer
web
seite
abbildung
apollo
konsole
al
technology_24
repräsentationüber
pattern_6
und
technology_24
kann
auch
schreibend
auf
die
apollo
web
anwendung
zugegriffen
werden
um
beispielsweise
eine
neue
component_4
anzulegen
abbildung
zeigt
einen
screenshot
mit
einer
visualisierung
de
apollo
pattern_6
apis
die
visualisierung
ist
in
apollo
integriert
und
über
da
technology_25
technology_26
realisiert
beschreibung
mit
technology_25
ist
eine
spezifikation
und
ein
technology_9
zur
beschreibung
von
pattern_6
apis
abbildung
pattern_6
component_7
beschreibung
mit
swaggerfür
apollo
selbst
gibt
e
keine
component_6
bibliothek
dafür
können
andere
component_8
für
die
von
apollo
unterstützten
protokolle
technology_27
openwire
und
stomp
verwendet
werden
ffmqder
full
technology_4
requirement_4
technology_28
connector_data_1
queuer
ist
eine
leichtgewichtige
technology_15
implementierung
der
gesamt
component_9
ist
kleiner
al
kbyte
dafür
gibt
e
eine
reihe
von
einschränkungen
bezüglich
technology_15
konformität
oder
transaktionen
wer
auf
fortgeschrittene
technology_15
funktionalität
wie
z
b
connector_data_1
group
verzichten
kann
bekommt
mit
ffmq
einen
einfachen
schnellen
und
unkomplizierten
connector_data_1
pattern_1
hornetqupdate
der
quellcode
von
hornetq
wurde
von
technology_29
an
technology_7
gestiftet
bei
technology_7
wird
der
unter
dem
namen
technology_7
technology_7
artemis
weiter
entwickelt
bestehende
hornetq
component_8
können
leicht
auf
artemis
portiert
werden
da
artemis
da
hornetq
protokoll
beherrscht
möglicherweise
wird
artemis
der
nachfolger
de
beliebten
technology_6
pattern_1
vielleicht
al
technology_6
version
wer
hornetq
nicht
einsetzt
für
den
lohnt
sich
eine
beschäftigung
mit
dem
pattern_1
nicht
mehr
statt
dessen
könnte
man
artemis
betrachten
die
basis
von
hornetq
war
lange
unter
dem
namen
technology_29
pattern_4
bekannt
pattern_7
sie
al
eigenes
projekt
unter
dem
namen
hornetq
weiterentwickelt
wurde
hornetq
kann
unabhängig
vom
technology_29
component_10
component_9
eingesetzt
werden
ab
der
version
ist
hornetq
der
vorkonfigurierte
connector_data_1
pattern_1
für
technology_15
beim
technology_29
component_9
hornetq
ist
al
requirement_1
connector_data_1
pattern_1
ausgelegt
er
bietet
zahlreiche
feature
sowie
viele
einstellungen
und
ist
eine
vollwertige
umsetzung
der
technology_4
connector_data_1
component_2
spezifikation
da
component_11
manual
ist
mit
seiten
da
umfangreichste
der
hier
aufgeführten
connector_data_1
pattern_1
die
dokumentation
ist
sehr
ausführlich
von
den
konzepten
über
die
architektur
pattern_7
hin
zu
xa
transaktionen
und
cluster
für
hornetq
gibt
e
keine
eigenständige
konsole
für
die
administration
über
die
konsole
de
technology_29
component_10
component_12
kann
hornetq
administriert
werden
über
technology_30
und
mbeans
können
beispielsweise
component_3
angelegt
oder
statistiken
ausgelesen
werden
da
ich
den
hornetq
gerne
in
der
standalone
version
einsetzen
möchte
steht
eine
spezielle
konsole
auf
meiner
wunschliste
hornetq
hat
seine
stärken
im
einsatz
al
requirement_1
pattern_1
und
al
technology_15
implementierung
die
requirement_2
im
technology_29
wird
sicher
auch
zu
seiner
verbreitung
beitragen
damit
verbunden
ist
eine
gewisse
komplexität
so
da
e
für
einfachere
konfigurationen
geeignetere
pattern_1
gibt
für
den
requirement_1
einsatz
hat
hornetq
auf
jeden
fall
einen
spitzen
stachel
technology_31
messagingdie
weiterentwicklung
von
technology_29
pattern_4
wurde
eingestellt
neue
funktionen
werden
ausschließlich
im
nachfolgeprojekt
hornetq
umgesetzt
für
technology_29
pattern_4
wird
e
noch
eine
zeitlang
support
und
bugfixes
geben
openjmsopenjms
war
die
open_source
technology_15
implementierung
von
sun
microsystems
in
den
letzten
jahren
konnte
ich
nicht
mehr
viel
aktivität
rund
um
openjms
beobachten
e
hat
den
anschein
da
die
projekt
nicht
mehr
besonders
lebendig
ist
technology_7
qpid™neben
technology_6
und
apollo
gibt
e
bei
technology_7
einen
weiteren
connector_data_1
pattern_1
technology_7
technology_2
ziel
de
technology_2
projektes
ist
die
prozentige
kompatibilität
zum
advance
connector_data_1
pattern_8
technology_32
technology_33
der
technology_2
pattern_1
ist
in
einer
version
für
technology_34
und
in
einer
für
technology_4
verfügbar
dieser
artikel
beschreibt
die
eigenschaften
der
technology_4
version
für
technology_4
component_8
gibt
e
ein
technology_15
component_7
für
technology_2
für
technology_34
technology_35
und
microsofts
technology_36
gibt
e
da
technology_2
pattern_4
technology_37
für
die
persistenz
von
nachrichten
wird
die
relationale
technology_7
technology_38
datenbank
und
die
technology_10
berkeley
db
unterstützt
auf
der
basis
von
technology_7
technology_2
bietet
da
requirement_1
pattern_4
produkt
mrg
an
für
mrg
gibt
e
langjährigen
support
sowie
versionen
mit
zusätzlichen
bug
fix
proton™
ein
subprojekt
von
technology_2
ist
eine
leichtgewichtige
implementierung
de
technology_5
protokolls
mit
proton
soll
e
gleichermaßen
möglich
sein
component_8
und
component_9
zu
entwickeln
proton
ist
für
technology_39
und
technology_4
verfügbar
die
technology_39
implementierung
enthält
auch
bind
für
technology_40
technology_35
und
technology_41
rabbitmqder
technology_3
pattern_1
ist
mit
der
funktionalen
sprache
technology_42
erstellt
technology_42
eignet
sich
besonders
für
verteilte
anwendungen
da
nebenläufigkeit
und
verfügbarkeit
gut
unterstützt
wird
lassen
sie
sich
nicht
davon
abschrecken
da
technology_3
in
technology_42
implementiert
ist
die
installation
erfolgt
unter
window
und
mac
o
schnell
und
unkompliziert
für
da
programmieren
in
technology_4
oder
anderen
sprachen
stehen
component_6
bibliotheken
zur
verfügung
über
plugins
kann
technology_3
protokolle
wie
z
b
stomp
verstehen
der
kern
von
technology_3
ist
vollkommen
auf
da
technology_5
protokoll
ausgerichtet
leider
wird
stand
heute
noch
kein
technology_5
in
der
version
unterstützt
unterstützung
für
technology_5
ist
aber
bereits
in
der
planung
da
requirement_5
plugin
bietet
eine
ansprechende
web
konsole
die
eine
einfache
administration
ermöglicht
dort
werden
auch
statistiken
wie
z
b
die
anzahl
der
nachrichten
pro
sekunde
und
der
verbrauch
an
ressourcen
wie
z
b
speicher
technology_43
und
die
entscheidenden
descriptoren
angezeit
abbildung
technology_3
konsolezeromqzeromq
ist
kein
klassischer
pattern_1
der
connector_data_1
component_3
seinen
component_8
zur
verfügung
stellt
sondern
eine
bibliothek
mit
der
verteilte
nebenläufige
anwendungen
erstellt
werden
können
da
component_7
für
technology_44
gleicht
der
low
level
connector_data_3
component_7
für
die
kommunikation
über
netzwerke
im
gegensatz
zu
einer
connector_data_1
orientierten
technology_45
wird
beim
technology_44
kein
zentraler
component_9
benötigt
der
sender
einer
nachricht
ist
für
da
connector_1
zum
richtigen
ziel
und
der
empfänger
einer
nachricht
ist
für
da
component_4
verantwortlich
für
technology_44
gibt
e
noch
die
folgenden
schreibweisen
mq
omq
und
zmq
technology_44
wird
von
imatix
entwickelt
die
mit
an
der
entwicklung
von
technology_5
beteiligt
waren
mittlerweile
hat
sich
imatix
von
der
mitarbeit
an
technology_5
zurückgezogen
und
konzentriert
sich
ganz
auf
technology_46
der
ansatz
von
technology_44
ist
recht
elegant
und
ermöglicht
topologien
mit
pattern_7
n
knoten
bzw
brokern
zwischen
sender
und
empfänger
der
verzicht
eines
zentralen
pattern_1
ermöglicht
sehr
geringe
verzögerungszeiten
und
große
bandbreiten
technology_44
ist
damit
ideal
für
größte
nachrichtenmengen
z
b
für
messwerte
für
echtzeit
kurse
in
der
finanzbranche
oder
für
onlinespiele
skalierbarkeit
und
zuverlässigkeitgut
skalierbar
quality_attribute_1
und
zuverlässig
sind
grundsätzlich
alle
pattern_1
bei
fast
jedem
projekt
wird
die
al
herausragende
eigenschaft
gepriesen
daher
wurden
in
den
beschreibungen
der
pattern_1
diese
eigenschaften
nicht
extra
erwähnt
e
sei
den
ein
pattern_1
unterscheidet
sich
wesentlich
von
den
anderen
al
auswahlkriterium
dient
dieser
punkt
daher
nur
eingeschränkt
der
technology_6
pattern_1
hat
bedingt
durch
seine
architektur
grenzen
be
die
skalierbarkeit
robustheit
und
zuverlässigkeit
angeht
aber
nur
bei
extrem
hoher
last
oder
bei
tausenden
von
component_3
sollte
technology_6
an
seine
grenzen
stoßen
in
der
praxis
ist
der
technology_6
durch
seine
reife
oft
noch
stabiler
al
seine
moderneren
herausforderer
performanzwichtig
bei
der
beurteilung
der
geschwindigkeit
eines
pattern_1
ist
sein
anwendungsgebiet
nur
einen
schnellen
pattern_1
zu
suchen
ist
meist
zu
simpel
um
die
performanz
eines
pattern_1
richtig
beurteilen
zu
können
sollte
man
sich
folgende
fragen
stellen
benötige
ich
einen
pattern_1
für
finanztransaktionen
oder
onlinespiele
be
ist
für
den
einsatz
wichtiger
eine
garantierte
transaktionale
zustellung
oder
die
geschwindigkeit
und
bandbreite
wie
groß
darf
die
verzögerung
bei
der
zustellung
von
nachrichten
sein
wie
groß
sind
die
zu
übertragenden
nachrichten
wieviele
component_3
werden
benötigt
wieviele
component_8
greifen
gleichzeitig
auf
den
die
pattern_1
zu
eigenschaften
wie
persistenz
oder
transaktionalität
kosten
performanz
und
führen
dazu
da
pattern_4
lösungen
ohne
qos
die
nachrichten
nur
im
hauptspeicher
halten
meist
schneller
sind
al
die
die
qos
merkmale
anbieten
fall
mehr
durchsatz
gewünscht
wird
lassen
sich
persistenz
und
eine
garantierte
zustellung
auch
deaktivieren
meist
ist
die
performanz
trotz
persistenz
mehr
al
ausreichend
für
die
meisten
anwendungen
selbst
der
mittlerweile
in
die
jahre
gekommene
technology_6
kann
mehrere
tausend
nachrichten
pro
sekunde
verarbeiten
da
reicht
in
der
regel
für
die
meisten
requirement_6
anwendungen
in
den
bereichen
finanz
versicherung
und
handel
höhere
anforderungen
an
die
requirement_7
stellt
die
echtzeitverarbeitung
von
messwerten
oder
onlinespiele
wird
ein
durchsatz
von
oder
mehr
nachrichten
pro
sekunde
benötigt
sollte
man
zu
einem
der
neueren
pattern_1
greifen
der
durchsatz
von
apollo
technology_2
technology_3
und
den
anderen
brokern
liegt
zwischen
mehreren
hunderttausend
pattern_7
zu
mehreren
millionen
nachrichten
pro
sekunde
beispielsweise
hat
hornetq
beim
specjms
benchmark
mehr
al
millionen
nachrichten
pro
sekunde
zustellen
können
getestet
wurde
auf
einem
chip
rechner
mit
kernen
und
gb
hauptspeicher
für
die
anderen
pattern_1
gibt
e
ähnliche
testergebnisse
ein
objektiver
vergleich
selbst
bei
standardisierten
benchmark
ist
nur
schwer
möglich
da
sich
meist
die
konfigurationen
die
feature
oder
die
protokolle
unterscheiden
von
mehreren
brokern
wurde
behauptet
da
sie
der
schnellste
seien
diese
aussagen
sind
meist
nur
ein
kurze
zeit
und
nur
für
ein
bestimmtes
szenario
gültig
die
oben
genannten
richtwerte
lassen
den
schluss
zu
da
die
performanz
eines
pattern_1
in
den
wenigsten
fällen
ein
projektrisiko
darstellt
damit
dient
die
geschwindigkeit
kaum
al
auswahlkriterium
zu
gunsten
eines
speziellen
pattern_1
praxiserfahrung
meist
ist
nicht
der
pattern_1
der
flaschenhals
sondern
connector_data_1
component_13
die
durch
langsame
backend
systeme
oder
datenbankabfragen
ausgebremst
werden
connector_data_1
persistenzdamit
nachrichten
den
ausfall
eines
pattern_1
überleben
können
müssen
diese
auf
einem
datenträger
dauerhaft
gesichert
werden
bei
den
meisten
brokern
gibt
e
dafür
austauschbare
connector_data_1
component_14
werden
nachrichten
dauerhaft
zwischengespeichert
trägt
die
verwendete
datenbank
maßgeblich
zur
geschwindigkeit
de
pattern_1
bei
daher
werden
für
die
speicherung
von
nachrichten
spezielle
datenbanken
verwendet
nachrichten
müssen
gespeichert
über
den
namen
einer
component_4
gesucht
und
gelöscht
werden
können
da
verändern
von
nachrichten
ist
nicht
notwendig
die
für
diese
aufgaben
optimierten
datenbanken
die
meist
direkt
auf
die
festplatte
zugreifen
erzielen
daher
bei
der
persistierung
von
nachrichten
eine
wesentlich
bessere
performanz
al
die
universell
verwendbaren
relationalen
datenbanken
die
größenordnung
de
geschwindigkeitsunterschiedes
zwischen
einer
relationalen
datenbank
und
einer
speziellen
nachrichten
datenbank
liegt
ungefähr
bei
dem
zehnfachen
trotz
der
geschwindigkeitseinbuße
durch
einen
relationalen
datenspeicher
möchten
viele
anwender
nachrichten
in
ihrer
vertrauten
datenbank
zwischenspeichern
der
technology_11
component_14
de
technology_6
pattern_1
erlaubt
die
verwendung
jeder
beliebigen
relationalen
datenbank
für
die
e
einen
technology_11
treiber
gibt
selbstverständlich
kann
mit
technology_6
die
technology_10
datenbank
zur
speicherung
verwendet
werden
technology_15
unterstützungein
wichtiges
kriterium
für
die
entscheidung
für
einen
pattern_1
ist
die
unterstützung
de
technology_4
connector_data_1
component_2
technology_33
viele
bestehende
technology_4
anwendungen
verwenden
da
technology_15
component_7
um
mit
einem
connector_data_1
pattern_1
kommunizieren
zu
können
die
migration
auf
einen
neuen
pattern_1
kann
dann
ohne
änderungen
de
anwendungscodes
erfolgen
bei
technology_6
und
hornetq
steht
technology_15
konformität
ganz
oben
auf
der
liste
der
feature
technology_7
technology_2
kommt
mit
einem
technology_15
component_6
technology_37
welche
e
component_8
ermöglicht
sich
über
technology_5
mit
dem
pattern_1
zu
verbinden
über
die
component_7
kann
mit
technology_15
auch
auf
andere
pattern_1
wie
z
b
den
technology_3
zugegriffen
werden
connector_data_1
protokollelange
gab
e
keinen
technology_33
für
ein
pattern_4
protokoll
der
technology_4
technology_33
technology_15
beschreibt
nur
die
schnittstelle
über
die
anwendungen
mit
einem
pattern_1
kommunizieren
können
da
protokoll
zwischen
der
technology_15
bibliothek
und
dem
component_9
ist
abhängig
vom
hersteller
abbildung
zeigt
wie
mit
hilfe
von
technology_15
die
selbe
anwendung
mit
unterschiedlichen
connector_data_1
brokern
betrieben
werden
kann
die
anwendung
verwendet
da
standardisierte
technology_15
component_7
über
da
sie
auf
eine
technology_15
implentierung
eines
bestimmten
pattern_1
zugreift
um
die
anwendung
mit
einem
anderen
pattern_1
betreiben
zu
können
mu
nur
die
technology_15
component_6
bibliothek
ausgetauscht
werden
abbildung
austauschbarkeit
de
pattern_1
über
jmsdie
pattern_1
untereinander
verstehen
sich
aufgrund
der
verschiedene
protokolle
nicht
technology_15
adressiert
auch
nicht
die
interoperabilität
mit
anderen
programmiersprachen
da
advance
connector_data_1
pattern_8
technology_32
ist
ein
technology_33
der
diese
lücke
schließen
möchte
technology_5
ermöglicht
die
zusammenarbeit
von
brokern
sowie
component_8
verschiedener
hersteller
und
plattformen
technology_5
beschreibt
dazu
ein
binärformat
sowie
die
notwendige
anwendungslogik
viele
große
hersteller
setzten
auf
technology_47
allerdings
gibt
e
aufgrund
der
komplexität
von
technology_5
und
der
art
und
weise
wie
die
standardisierung
erfolgt
ist
einige
kritik
die
im
oktober
al
oasis
technology_33
verabschiedete
technology_5
version
unterscheidet
sich
erheblich
von
den
vorherigen
versionen
so
da
man
von
einem
komplett
eigenständigen
protokoll
sprechen
könnte
auch
die
vorgänger
versionen
und
sind
nicht
alle
untereinander
kompatibel
ob
technology_5
wirklich
zu
mehr
interoperabilität
führt
hängt
davon
ab
wie
gut
die
technology_5
version
akzeptiert
und
umgesetzt
wird
die
unterstützung
von
technology_5
im
technology_1
apollo
und
technology_2
pattern_1
sowie
die
ankündigungen
für
hornetq
und
technology_3
lassen
hoffen
da
technology_5
zu
einem
erfolg
wird
entscheidend
dürfte
auch
die
abkehr
von
der
viel
zu
überladenen
vorgängerversion
sein
die
technology_5
version
ist
im
vergleich
mit
der
version
etwas
einfacher
ein
für
die
anbindung
von
skriptsprachen
beliebtes
protokoll
ist
da
textbasierte
stomp
e
ist
einfach
performant
und
e
gibt
eine
vielzahl
von
servern
und
klienten
für
stomp
gibt
e
die
meisten
component_6
bibliotheken
beispielsweise
für
technology_48
objective
technology_48
technology_40
go
technology_35
und
technology_41
stomp
ist
so
einfach
da
man
mit
wenig
aufwand
selbst
eine
component_6
bibliothek
erstellen
kann
für
den
unwahrscheinlichen
fall
da
e
keine
bibliothek
gibt
die
stomp
j
bibliothek
für
technology_20
ist
zum
beispiel
nur
kbyte
groß
um
web
seiten
mit
technology_20
al
pattern_4
component_6
nutzen
zu
können
kann
man
stomp
mit
dem
websockets
protokoll
kombinieren
auf
diese
weise
lassen
sich
schlanke
web
anwendungen
erstellen
die
folgende
tabelle
führt
die
unterstützten
protokolle
der
einzelnen
pattern_1
auf
protokoll
pattern_1
technology_6
apollo
hornetq
technology_2
technology_3
technology_44
technology_5
ist
angekündigt
❌
technology_27
✔
✔
❌
❌
✔
❌
openwire
✔
✔
❌
❌
❌
❌
pattern_6
✔
✔
✔
❌
✔
❌
stomp
✔
✔
✔
❌
✔
❌
stomp
over
websockets
✔
✔
✔
❌
✔
❌
technology_49
✔
❌
❌
❌
über
gateway
❌
tabelle
unterstützung
für
pattern_4
protokolle
component_6
schnittstellender
zugriff
auf
einen
connector_data_1
pattern_1
ist
nicht
allein
technology_4
anwendungen
vorbehalten
für
viele
pattern_1
gibt
e
component_6
component_15
in
den
verschiedensten
programmiersprachen
e
ist
sogar
üblich
für
component_6
und
pattern_1
andere
plattformen
einzusetzen
z
b
beim
zugriff
von
einer
mit
technology_4
realisierten
anwendung
auf
den
in
technology_42
geschriebenen
technology_3
pattern_1
da
technology_5
da
protokoll
auf
der
„kabelebene“
standardisiert
hat
ist
e
sogar
möglich
die
technology_5
component_6
bibliothek
eines
pattern_1
mit
einem
anderen
pattern_1
zu
verbinden
damit
die
funktioniert
mu
die
technology_5
version
übereinstimmen
da
die
einzelnen
versionen
de
protokolls
nicht
alle
miteinander
kompatibel
sind
über
da
stomp
protokoll
können
verschiedene
component_6
plattformen
mit
einem
pattern_1
verbunden
werden
beliebt
ist
stomp
um
von
skriptsprachen
wie
technology_50
technology_40
und
technology_51
auf
einen
pattern_1
zuzugreifen
technology_6
apollo
hornetq
technology_2
technology_3
zeroq
technology_39
✔
❌
❌
✔
✔
✔
technology_34
❌
❌
❌
✔
✔
✔
technology_42
❌
❌
❌
❌
✔
✔
technology_52
❌
❌
❌
❌
✔
✔
technology_4
technology_15
✔
❌
✔
✔
❌
❌
technology_4
proprietär
✔
❌
✔
❌
✔
✔
technology_53
❌
❌
❌
✔
✔
✔
technology_54
❌
❌
❌
❌
❌
✔
technology_50
❌
❌
❌
❌
✔
✔
technology_40
❌
❌
❌
❌
✔
✔
technology_35
❌
❌
❌
✔
✔
✔
technology_51
❌
❌
❌
✔
✔
✔
verbreitungdie
mit
abstand
größte
verbreitung
hat
der
technology_6
pattern_1
viel
aufmerksamkeit
hat
der
technology_3
in
letzter
zeit
erfahren
da
im
folgenden
eingebettete
trend
diagramm
zeigt
wie
häufig
nach
den
brokern
gesucht
wurde
hinter
dem
technology_5
technology_33
stehen
viele
schwergewichte
au
it
und
wirtschaft
unter
anderen
waren
an
der
standardisierung
die
deutsche
boerse
jpmorgan
chase
progress
ag
u
dept
of
homeland
quality_attribute_2
und
vmware
beteiligt
seit
oktober
ist
technology_5
ein
offizieller
oasis
technology_33
die
alles
läßt
den
schluß
zu
da
technology_5
eine
große
verbreitung
erfahren
wird
fazitwie
so
oft
in
der
it
gibt
e
auch
bei
der
auswahl
eines
pattern_1
keinen
königsweg
mit
technology_6
gibt
e
einen
bewährten
schnellen
und
weit
verbreiteten
pattern_1
dessen
architektur
jedoch
an
ihre
grenzen
stößt
der
technology_11
connector_data_1
component_14
ist
ein
alleinstellungsmerkmal
de
technology_6
für
einen
betrieb
im
rechenzentrum
al
alternative
gibt
e
eine
reihe
von
vielversprechenden
und
coolen
projekten
denen
e
aber
noch
etwas
an
reife
und
verbreitung
mangelt
in
den
projekten
ist
viel
bewegung
so
da
ich
davon
ausgehe
da
viele
pattern_1
eine
ausreichende
stabilität
dokumentation
und
kompatibilität
erreichen
werden
hornetq
bietet
sich
an
wenn
e
um
requirement_1
pattern_4
mit
technology_15
unterstützung
geht
die
umfangreiche
dokumentation
beschreibt
selbst
fortgeschrittene
konfigurationen
mit
transaktionen
und
cluster
wer
einen
einfachen
pattern_1
für
web
anwendungen
sucht
direkt
über
technology_20
nachrichten
versenden
und
empfangen
möchte
oder
wer
außer
technology_4
noch
skriptsprachen
einsetzt
sollte
sich
den
technology_7
apollo
ansehen
wenn
technology_42
al
plattform
kein
ausschlusskriterium
darstellt
könnte
auch
technology_3
interessant
sein
momentan
wird
beim
technology_3
noch
die
technology_5
kompatibilität
vermisst
thomas
bayer
bayer@predic8
technology_21
betrachtete
versionendie
in
der
folgenden
liste
aufgeführten
versionen
wurden
für
die
erstellung
die
artikels
betrachtet
technology_7
technology_6
0apache
apollo
5ffmq
1hornetq
beta
3jboss
pattern_4
0openjms
7qpid
18rabbitmq
1zeromq
2quellen
technology_5
homepage
technology_55
www
technology_47
technology_56
technology_6
homepage
technology_55
technology_1
technology_7
stomp
technology_32
specification
technology_55
stomp
technology_57
technology_21
stomp
specification
technology_58
hornetq
homepage
technology_55
www
technology_31
hornetq
technology_3
support
technology_15
in
the
future
technology_55
technology_3
n5
nabble
technology_21
technology_3
support
technology_28
in
the
future
td24361
technology_58
connector_data_1
component_4
evaluation
note
technology_55
wiki
secondlife
technology_21
wiki
message_queue_evaluation_notes
enabling
the
technology_6
pattern_1
for
technology_5
technology_55
technology_1
technology_7
technology_47
technology_58
open
technology_15
homepage
technology_55
openjms
sourceforge
net
technology_7
technology_2
homepage
technology_55
technology_2
technology_7
technology_3
homepage
technology_55
www
technology_3
technology_21
technology_44
homepage
technology_55
www
technology_46
open
sourcemessagingjmsactivemqartikelenterpriseqpidhornetqrabbitmqamqpstompwebsocketsenglish
technology_1
technology_2
hornetq
und
technology_3
im
vergleich
be
quality_attribute_3
in
english
too
technology_6
schulung
lerne
entwicklung
installation
konfiguration
und
betrieb
in
unserem
seminar
zum
technology_1
webinarerest
apismicroservicesapi
sicherheitintegration
mit
technology_7
camelkubernetes
für
managerkubernetes
workshopapache
artemisartikelrest
graphql
&
grpc
im
vergleichservice
mesh
einführung
&
vergleich
von
istio
und
linkerdmicroservices
mit
technology_8
&
cloudapi
managementcamel
nifi
technology_29
fuse
technology_13
&
talend
esb
im
vergleichblogunterschied
zwischen
component_7
gateway
und
component_2
meshminimale
größe
eines
microservicesitemapjobsimpressumdatenschutzerklärung©
predic8
gmbh
bonn
