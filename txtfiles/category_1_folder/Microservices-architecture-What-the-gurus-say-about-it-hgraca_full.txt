pattern_1
architecture
what
the
guru
say
about
it
–
@hgraca
skip
to
content
@hgraca
pattern_1
architecture
what
the
guru
say
about
it
hgraca
architecture
development
lecture
distillation
planet
technology_1

2017november



minute
about
a
year
ago
i
be
very
interest
in

a
much
a
possible
about
the
subject
and
gather
a
much
connector_data_1
a
i
could
about
it
i
watch
several
conference
talk
and
i
connector_1
several

from
very
knowledgeable
and
experience
people
martin
fowler
fred
george
adrian
cockcroft
or
chris
richardson
in
order
to
a
much
a
possible
about
pattern_1
and
this
coding_keyword_1
be
the
connector_data_2
of
that
this
coding_keyword_1
talk
about
pattern_2
vs
pattern_1
when
should
we
use
pattern_1
prerequisite
continuous
delivery
sophisticate
pattern_3
strong
devops
culture
characteristic
what
be
a
pattern_4
how
big
be
a
pattern_4
componentization
via
component_1
heterogeneous
human
resource
organize
around
requirement_1
capability
technology_2
not
project
smart
and
dumb
pip
decentralized
governance
decentralized
connector_data_3
requirement_2
infrastructure
automation
design
for
failure
evolutionary
design
frontend
backend
danger
technology_3
quality_attribute_1
must
be
manage
instability
must
be
manage
connector_data_3
consistency
must
be
assure
how
to
decompose
a
monolith
conclusion
a
micro
component_2
architecture
be
an
architectural
concept
that
oppose
a
monolithic
approach
on
an
component_3
architecture
this
mean
that
instead
of
have
an
component_3
with
all
it
bound
component_4
run
in
one
component_5
use
in
component_6
connector_2
we
will
have
several
small
component_3
correspond
to
each
of
the
component_3
bound
component_4
run
in
different
component_7
and
connector_3
through
the
requirement_3
probably
use
technology_4
in
other
word
the
micro
component_2
approach
pattern_5
the
bound
component_4
of
the
component_3
one
bound
component_4
in
each
micro
component_2
each
micro
component_2
in
it
own
component_5
pattern_2
vs
pattern_1
accord
to
martin
fowler
the
term
pattern_2
have
be
widely
use
in
a
very
abusive
way
and
currently
mean
many
thing
it
be
a
very
broad
term
in
martin
fowler
pattern_6
pattern_1
be
a
subsection
of
technology_5
when
should
we
use
pattern_1
a
an
academic
and
pragmatic
architect
wannabe
i
think
this
be
a
decision
too
important
to
make
base
on
myth
or
on
what
we
want
to
try
next
or
on
our
desire
to
be
in
the
cut
edge
of
technology_3
we
need
to
base
such
an
important
decision
in
pragmatic
requirement_4
off
in
line
with
what
rachel
myers
defend
rachel
myers
note
that
an
architecture
should
make
our
technology_2
more
resilient
and
fault
tolerant
encourage
understand
debug
and
connector_4
help
team
work
together
i
agree
with
rachel
however
i
also
feel
that
those
characteristic
be
achievable
in
both
monolith
and
micro
component_2
architectural
style
martin
fowler
see
several
advantage
to
both
monolith
and
micro
component_2
which
can
help
u
decide
when
we
should
use
pattern_1
advantage
monolith
pattern_4
quality_attribute_2
a
monolith
approach
be
much
quality_attribute_3
to
build
to
pattern_7
and
quality_attribute_4
a
pattern_4
approach
will
need
heavy
pattern_8
because
it
quality_attribute_4
to
several
component_5
and
us
other
pattern_1
apis
partial
deployment
use
a
pattern_4
approach
we
can
update
only
a
piece
of
the
component_3
however
in
a
monolith
architecture
we
always
need
to
redeploy
the
whole
component_3
which
involve
more
risk
consistency
in
a
monolith
component_3
it
easy
to
maintain
consistency
of
cod
error
handle
etc
while
in
a
pattern_1
approach
each
pattern_4
be
fully
manage
by
different
team
which
might
decide
on
different
technology_6
quality_attribute_5
in
a
pattern_4
architecture
quality_attribute_5
be
high
because
even
if
one
pattern_4
fail
that
mean
that
one
of
the
piece
of
the
component_3
fail
not
the
whole
component_3
inter

refactoring
a
monolith
approach
make
it
easy
to
refactor
situation
where
several
need
to
connector_3
or
when
we
want
to
move
from
one
to
another
when
move
into
a
pattern_1
approach
we
need
to
have
the
boundary
very
well
define
preserve
quality_attribute_6
keep
quality_attribute_6
and
pattern_9
can
be
quite
difficult
despite
solid
rule
however
use
a
pattern_1
architecture
we
can
further
guarantee
that
there
will
be
no
connector_5
state
between

multiple
component_8
heterogeneous
pattern_1
give
you
the
option
and
quality_attribute_1
to
use
different
technology_3
different
programming
technology_7
accord
to
the
requirement_1
need
personally
i
the
pragmatic
pattern_6
of
eric
evans
and
i
think
of
real
pragmatic
hard
and
soft
pro
of
use
micro
component_2
where
the
hard
pro
be
the
thing
that
be
not
possible
to
do
with
a
monolith
and
the
soft
pro
the
thing
that
be
possible
in
a
monolith
but
the
micro
component_2
make
it
easy
micro
component_2
hard
pro
soft
pro
independent
quality_attribute_7
each

be
in
different
component_5
technology_8
can
quality_attribute_8
horizontally
in
a
rate
independent
of
other

preserve
quality_attribute_6
keep
quality_attribute_6
and
pattern_9
be
possible
in
both
monolith
and
micro
component_2
nevertheless
it
can
be
quite
difficult
and
we
have
be
try
to
do
it
for
decade
quite
unsuccessfully
despite
solid
rule
however
use
a
pattern_1
architecture
we
can
further
guarantee
that
the
logical
component_9
of
the
component_3

be
enforce
by
it
explicit
physical
component_9
in
separate
component_5
technology_8
this
physical
isolation
make
it
unnatural
to
cross
the
bound
component_4
boundary
independent
tech
technology_9
because
each
be
in
different
component_5
technology_8
and
use
an
agnostic
connector_2
technology_7
they
can
use
completely
different
programming
technology_7
connector_2
technology_10
pattern_3
technology_10
or
connector_data_3
persistence
technology_10
this
be
great
for
choose
the
best
technology_10
for
the
at
hand
and
innovate
by
be
early
adopter
of
technology_3
independent
evolution
of
sub
component_10
a
pattern_4
can
quality_attribute_9
and
break
backwards
quality_attribute_10
without
it
connector_6
clutterred
with
to
support
old
version
because
we
can
leave
old
version
of
the
pattern_4
run
while
need
i
feel
the
hard
pro
be
the
real
pragmatic
reason
to
use
a
micro
component_2
architecture
those
be
the
only
thing
we
can
not
do
with
a
monolith
so
if
we
need
them
we
must
move
to
a
micro
component_2
architecture
otherwise
the
complexity
demand
by
a
micro
component_2
architecture
be
hardly
worth
it
i
also
think
the
partial
deployment
and
partial
quality_attribute_5
provide
my
micro
component_2
although
impossible
to
do
with
monolith
they
be
not
really
key
advantage
although
they
be
advantage
nevertheless
independently
of
what
be
our
preference
or
desire
we
should
not
start
a
project
with
a
pattern_4
approach
in
the
begin
we
must
focus
our
attention
on
understand
the
domain
and
for
that
we
can
not
be
distract
by
the
huge
complexity
of
create
a
pattern_1
ecosystem
rebecca
parson
simon
brown
prerequisite
continuous
delivery
ability
and
mindset
to
go
fast
fast
fast
one
of
the
reason
we
want
to
use
pattern_1
be
that
we
want
to
be
able
to
connector_4
rapidly
so
we
can
respond
to
requirement_1
requirement
connector_7
fast
than
the
competition
or
in
eric
evans
word
we
need
to
acknowledge
the
rough
and
tumble
of
requirement_5
the
reality
of
development
be
that
the
start
point
be
never
one
where
we
fully
understand
the
domain
we
deepen
our
understand
of
the
domain
a
we
go
and
we
have
a
constant
need
of
refactoring
so
refactoring
be
a
need
but
also
a
danger
because
can
become
confuse
messy
specially
if
bound
component_4
be
not
respect
pattern_1
reinforce
the
bound
component_4
border
and
so
they
help
maintain
the
pattern_10
clarity
isolation
and
pattern_9
of
the

in
decouple
and
cohesive

if
a

pattern_4
connector_8
messy
the
mess
be
contain
within
it
it
do
not
spread
easily
beyond
it
border
we
need
to
go
fast
in
all
stage
of
the
development
cycle
although
this
be
true
both
in
a
monolith
and
a
pattern_1
approach
the
pattern_1
approach
be
say
to
quality_attribute_11
comply
to
that
need
martin
fowler
tell
u
we
need
to
be
able
to
have
rapid
provision
we
need
to
be
able
to
quality_attribute_4
component_11
rapidly
for
development
test
acceptance
and
production
rapid
component_3
deployment
we
need
to
be
able
to
automatically
and
rapidly
quality_attribute_4
our
component_2
fred
george
tell
u
the
same
thing
there
be
a
huge
drive
need
to
go
fast
and
connector_9
ahead
of
the
competition
he
do
a
retrospective
of
the
hardware
lead
time
and
he
note
that
the
evolution
go
from
take

month
to
connector_9
a
component_5
back
in
1990s
to
30min
in

use
requirement_6
component_2
and
currently

we
aim
to
need
le
than
a
minute
to
have
a
component_5
up
and
run
use
technology_11
adrian
cockcroft
one
of
the
key
in
netflix
requirement_6
and
pattern_1
early
adoption
also
tell
u
how
important
it
be
to
have
early
adoption
of
technology_3
and
to
be
very
fast
in
provision
component_11
and
quality_attribute_4
version
of
our
component_3
he
be
a
big
fan
of
technology_11
because
it
allow
provision
and
deployment
of
development
test
and
production
component_12
in
a
matter
of
second
sophisticate
pattern_3
pattern_3
be
critical
rebecca
parson
we
need
to
when
a
component_5
be
down
when
something
become
unresponsive
when
connector_data_4
be
fail
and
we
need
the
technology_10
to
quickly
debug
it
martin
fowler
and
we
need
to
it
per
pattern_4
fred
george
strong
devops
culture
we
need
to
have
devops
exclusively
to
handle
pattern_3
and
pattern_8
and
we
need
a
proximity
relation
with
quality_attribute_11
connector_2
between
developer
and
devops
martin
fowler
in
a
pattern_1
approach
we
have
more
thing
to
quality_attribute_4
pattern_3
need
to
be
more
sophisticate
the
amount
of
thing
that
can
fail
be
much
high
a
such
have
a
strong
devops
culture
be
a
strong
requirement
rebecca
parson
characteristic
martin
fowler
and
james
lewis
tell
u
what
they
find
to
be
the
set
of
characteristic
that
define
a
micro
component_2
in
their
well

and
some
of
their
talk
martin
fowler
james
lewis
what
be
a
pattern_4
my
personal
pattern_6
on
what
a
pattern_4
align
completely
with
the
definition
give
by
adrian
cockcroft
loosely
couple
component_2
orient
architecture
with
bound
component_4
a
bound
component_4
be
an
explicit
conceptual
boundary
around
a
requirement_1
component_4
for
example
in
a
ecomm
component_13
we
can
think
of
“themes”
“payment
providers”
“orders”
“shipments”
or
“app
store”
a
bound
component_4
and
therefore
candidate
to
pattern_1
some
other
quality_attribute_11
background
connector_data_1
relate
to
pattern_1
in
general
be
the
book
“building
microservices”
author
by
sam
newman
for
which
we
can
connector_10
a
free
preview
here
james
lewis
also
tell
u
that
pattern_1
should
be
cheap
to
replace
be
quick
to
quality_attribute_8
withstand
failure
allow
u
to
go
a
fast
a
possible
how
big
be
a
pattern_4
james
lewis
co
author
of
the

pattern_1

together
with
martin
fowler
state
that
a
component_2
should
be
big
enough
to
fit
his
hand
mean
that
one
person
should
be
able
to
completely
understand
that
pattern_4
in
the

the
pattern_1
size
vary
a
lot
martin
fowler
find
requirement_7
of
requirement_8
with
ratio
that
range
from

people
per

component_1
down
to
ratio
of

people
to

component_2
the
approach
he
mention
be
the
two
pizza
team
a
pattern_4
team
should
never
go
beyond
the
amount
of
people
that
we
can
fee
with
two
pizza
fred
george
say
that
a
pattern_4
should
be
“very
very
small”
need
only
a
team
size
of
one
developer
to
develop
and
maintain
which
be
in
pattern_11
with
james
lewis
personally
i
agree
with
james
lewis
fred
george
and
adrian
cockcroft
i
feel
a
pattern_4
should
correspond
to
a
bound
component_4
that
one
person
can
fully
understand
this
mean
that
the
more
requirement_9
your
component_3
have
the
more
pattern_1
it
will
have
for
example
netflix
have
around

pattern_1
fred
george
nevertheless
either
in
the
very
begin
of
the
pattern_4
life
cycle
or
late
on
a
bound
component_4
pattern_4
might
be
too
big
to
be
understand
by
only
one
person
in
which
requirement_7
we
need
to
identify
bound
component_4
within
it
and
further
segregate
it
into
different
component_2
this
be
in
pattern_11
with
both
the
evolutionary
architecture
concept
and
ddd
where
both
of
them
defend
that
an
component_3
architecture
be
in
continuous
connector_4
refactor
a
we
more
about
the
domain
and
or
the
requirement_1
requirement
connector_4
a
rebecca
parson
say
“the
granularity
question
be
crucial”
the
most
difficult
thing
to
do
when
develop
pattern_1
be
define
the
boundary
and
we
will
surely
be
merge
and
segregate
component_1
a
we
further
understand
the
domain
and
or
the
requirement_1
requirement
connector_4
componentization
via
component_1
a
component_14
be
part
of
a
component_10
of
component_14
where
each
component_14
be
independently
replaceable
independently
upgradeable
martin
fowler
and
independently
quality_attribute_12
rebecca
parson
in
development
we
can
see
two
type
of
component_14
technology_12
which
be
piece
of
that
we
use
in
our
component_3
and
which
we
can
be
upgrade
or
replace
by
another
technology_12
hopefully
without
affect
the
rest
of
the
component_3
connector_2
be
do
through
the
technology_7
construct
however
if
the
technology_12
we
want
to
use
in
our
component_3
be
build
in
another
technology_7
we
can
not
use
that
component_14
component_2
part
of
the
component_3
which
be
in
fact
an
component_3
itself
run
in
it
own
component_6
connector_2
be
do
through
interprocess
connector_2
web
component_2
connector_data_5
component_15
connector_data_6
etc
if
we
want
to
use
a
component_2
component_14
in
our
component_3
who
be
connector_11
in
a
different
technology_7
we
can
do
it
because
it
will
be
run
in
it
own
component_6
approach
prefer
by
chad
fowler
independent
quality_attribute_7
where
each
component_2
can
be
quality_attribute_8
independently
of
the
rest
of
the
component_3
so
if
one
of
the
component_3
pattern_1
have

time
more
load
than
the
others
we
can
easily
quality_attribute_8
only
that
pattern_4
heterogeneous
be
heterogeneous
mean
the
component_10
be
able
to
be
build
use
different
programming
technology_7
this
have
several
advantage
martin
fowler
and
chad
fowler
believe
a
component_10
should
be
heterogeneous
by
default
mean
developer
should
not
only
be
allow
but
be
encourage
to
try
technology_3
an
heterogeneous
component_10
have
a
few
benefit
namely
help
prevent
tight
couple
because
there
be
different
programming
technology_7
developer
can
experiment
with

different
technology_3
which
help
in
create
requirement_10
and
maintain
developer
in
the
requirement_8
because
they
don’t
need
to
leave
in
order
to
try
thing
rule
the
unit
we
use
to
try
a
technology_3
should
be
a
small
unit
a
small

pattern_4
so
that
the
risk
be
small
rule
the
unit
we
use
to
try
a
technology_3
must
be
disposable
human
resource
organize
around
requirement_1
capability
in
the
old
day
and
in
many
requirement_7
still
today
development
team
would
organize
themselves
into
technology_3
base
sub
team
this
mean
that
in
a
project
we
have
ie
a
dba
team
a
component_5
side
team
and
a
ui
team
who
work
independently
of
each
other
this
end
up
bring
quality
problem
because
both
the
domain
knowledge
and
the
development
effort
connector_9
disperse
in
a
micro
component_2
approach
we
will
have
team
organize
into
requirement_1
capability
for
example
order
ship
or
catalog
team
each
team
would
then
have
member
specialize
in
all
the
necessary
technology_3
ie
ui
component_5
side
dba
qa
all
the
way
through
the
end
component_16
this
allow
the
team
to
gather
high
domain
knowledge
and
to
focus
all
development
effort
on
a
particular
section
of
the
component_3
their
micro
component_2
martin
fowler
eric
evans
this
approach
go
together
with
conway’s
law
which
tell
u
that
if
we
want
to
have
highly
cohesive
and
decouple
pattern_1
we
need
to
design
our
organization
connector_data_7
a
a
pattern_12
of
the
component_17
connector_data_7
we
want
to
have
organization
which
design
component_18
…
be
constrain
to
produce
design
which
be
copy
of
the
connector_2
connector_data_8
of
these
organization
melvin
conway

technology_2
not
project
the
old
approach
be
to
have
a
team
build
a
set
of
requirement_9
which
when
finish
be
give
to
another
team
to
be
maintain
in
a
micro
component_2
approach
a
team
should
own
a
technology_2
over
it
full
lifetime
all
the
way
from
development
into
quality_attribute_13
until
the
technology_2
be
take
off
line
this
approach
create
the
“product
mindset”
which
mean
a
strong
connector_12
between
the
technical
technology_2
and
it
requirement_1
capability
it
create
an
on
go
relationship
where
the
question
be
how
can
the
assist
it
component_19
to
enhance
the
requirement_1
capability
smart
and
dumb
pip
again
in
the
old
day
requirement_8
would
use
a
requirement_5
component_2
bus
architecture
which
would
both
have
the
connector_2
pattern_13
between
and
the
requirement_1
component_20
this
approach
would
then
develop
into
a
“spaghetti
box”
the
micro
component_2
architecture
move
the
requirement_1
component_20
into
the
and
us
a
quality_attribute_3
connector_2
mean
technology_4
decentralized
governance
key
decision
about
a
micro
component_2
should
be
make
by
the
people
actually
develop
the
micro
component_2
key
decision
be
decision
ie
about
the
programming
technology_7
the
persistence
technology_10
the
deployment
methodology
the
coding_keyword_2
contract
the
ui
etc
decentralized
connector_data_3
requirement_2
in
a
traditional
approach
an
component_3
will
have
only
one
component_21
and
many
of
the
different
requirement_1
component_20
component_17
of
the
component_3
will
“communicate”
through
the
component_21
mean
that
component_17
connector_1
connector_data_3
belong
to
other
component_17
directly
from
the
component_21
it
also
mean
that
all
the
component_17
use
the
same
connector_data_3
persistence
even
if
it
be
not
the
most
appropriate
to
some
component_17
martin
fowler
in
a
micro
component_2
approach
where
each
requirement_1
component_14
be
a
micro
component_2
each
component_14
will
have
it
own
component_21
inaccessible
by
other
micro
component_2
each
component_14
connector_data_3
be
only
quality_attribute_14
both
for
connector_13
and
connector_11
through
the
relate
component_14

this
also
mean
that
the
connector_data_3
persistence
type
can
also
be
different
between
requirement_1
component_17
martin
fowler
chad
fowler
for
fred
george
this
be
the
first
challenge
in
move
into
a
pattern_4
approach
infrastructure
automation
continuous
delivery
martin
fowler
rebecca
parson
chad
fowler
eric
evans
blue
green
deployment
to
quality_attribute_4
with
zero
downtime
automation
so
we
can
quality_attribute_4
to
several
component_7
with
the
press
of
a

phoenix
component_5
a
to
connector_9
component_22
to
go
down
and
up
rapidly
pattern_14
so
we
can
spot
when
thing
go
wrong
and
have
pattern_3
technology_10
to
debug
it
design
for
failure
when
we
have
an
component_3
quality_attribute_15
throughout
several
component_5
they
will
eventually
fail
specially
if
in
different
technology_8
so
we
need
to
design
our
in
a
way
that
it
be
prepare
for
those
failure
martin
fowler
chaos
monkey
be
a
technology_10
build
by
netflix
which
turn
component_7
down
in
order
to
test
the
quality_attribute_16
of
a
component_10
to
this
type
of
failure
martin
fowler
this
be
also
something
rebecca
parson
find
crucial
after
all
we
be
not
even
use
in
component_6
connector_2
between
our
component_1
any
more
we
be
use
technology_4
connector_2
which
be
not
even
remotely
a
quality_attribute_17
so
component_1
connector_2
will
fail
and
our
component_10
must
be
ready
for
it
evolutionary
design
the
design
of
the
overall
component_3
must
not
be
coding_keyword_3
it
must
be
possible
to
quality_attribute_3
to
quality_attribute_9
the
architecture
accord
to
the
requirement_1
need
for
example
we
can
quality_attribute_9
refactor
a
monolith
component_3
into
a
pattern_4
component_3
by
isolate
and
detach
a
set
of
requirement_1
component_20
bound
component_4
into
a
standalone
pattern_4
we
can
merge
exist
pattern_1
for
example
when
different
pattern_1
frequently
need
to
connector_4
at
the
same
time
we
can
segregate
exist
pattern_1
when
we
need
and
can
quality_attribute_9
them
separately
or
when
we
realize
there
be
significant
requirement_1
component_20
difference
we
can
a
temporary
feature
to
an
component_3
by
create
a
pattern_4
who
will
only
live
for
a
predetermine
time
frame
frontend
backend
there
be
two
way
of
think
about
how
to
connector_data_7
the
frontend
and
backend
in
a
pattern_1
architecture
break
up
each
piece
of
the
ui
per
pattern_4
and
keep
each
piece
together
with
the
correspond
pattern_4
this
approach
have
the
benefit
of
have
the
frontend
connector_3
in
component_6
with
the
backend
however
the
complexity
of
maintain
ui
consistency
across
pattern_1
be
very
high
if
not
impossible
and
will
lead
to
the
need
of
update
several
pattern_1
simultaneously
when
there
be
cross
boundary
connector_7
to
the
ui
couple
pattern_1
and
eliminate
the
isolation
and
independence
of
the
pattern_1
provide
by
this
architecture
style
this
actually
make
this
option
an
anti
pattern_15
break
up
the
frontend
and
backend
base
keep
the
ui
of
an
component_3
together
which
then
connector_14
with
the
pattern_1
through
technology_4
this
keep
the
pattern_1
decouple
from
each
other
and
provide
extra
decouple
between
backend
and
frontend
while
maintain
each
component_3
ui
together
make
it
trivial
to
keep
the
ui
consistent
this
be
the
connector_data_7
advise
by
rachel
myers
and
a
far
a
i’m
concern
it
the
only
way
of
do
it
in
this
requirement_7
we
have
two
option
for
the
connector_2
approach
between
frontend
and
backend
many
tiny
technology_4
pattern_16
connector_data_9
instead
of
one
big
connector_data_10
which
have
the
advantage
of
be
pattern_17
approach
prefer
by
chad
fowler
one
big
connector_data_10
to
a
specialize
component_2
gateway
aggregator
pattern_18
who
then
gather
all
connector_data_3
from
the
pattern_1
ecosystem
which
reduce
ui
complexity
danger
technology_3
quality_attribute_1
must
be
manage
one
of
the
advantage
of
the
pattern_1
be
that
we
can
use
different
technology_3
for
the
same
purpose
we
can
use
a
different
connector_data_11
requirement_11
technology_12
or
a
different
connector_data_3
persistence
technology_10
in
every
one
of
our
pattern_1
but
the
fact
that
we
can
do
it
doesn’t
mean
that
we
should
use
a
multitude
of
technology_3
and
technology_12
it
can
connector_9
out
of
hand
so
we
need
to
select
a
fundamental
set
of
technology_10
and
only
go
outside
those
technology_10
when
we
actually
need
to
rebecca
parson
instability
must
be
manage
particularly
when
in
the
begin
of
the
development
of
a
pattern_4
it
component_23
be
quite
unstable
but
even
at
late
stage
when
the
pattern_4
be
already
mature
we
will
need
to
connector_4
the
technology_13
both
it
input
and
output
when
make
those
component_23
connector_4
the
component_6
must
be
manage
carefully
because
there
will
be
rely
on
that
quality_attribute_18
rebecca
parson
connector_data_3
consistency
must
be
assure
a
when
use
pattern_1
we
will
have
each
pattern_4
with
it
own
connector_data_3
storage
and
in
many
requirement_7
connector_data_3
belong
to
one
pattern_4
will
be
partially
or
totally
duplicate
in
another
component_24
pattern_4
that
duplicate
connector_data_3
will
be
update
when
the
component_24
pattern_4
connector_15
an
connector_16
by
the
supplier
when
it
connector_data_3
be
connector_4
the
that
be
connector_16
will
go
into
a
connector_data_6
component_15
where
it
will
wait
until
it
connector_8
pick
up
by
the
component_24
pattern_4
this
mean
that
the
component_24
pattern_4
will
be
coding_keyword_4
outdated
connector_data_3
while
it
doesn’t
pick
up
the
connector_16

the
connector_data_3
be
inconsistent
nevertheless
eventually
the
connector_data_3
connector_7
will
be
propagate
to
all
the
copy
connector_data_3
will
be
great
consistent
again
and
hence
the
term
“eventual
consistency”
this
term
be
simply
an
acknowledgement
that
connector_data_3
might
be
inconsistent
for
some
short
period
of
time
the
usage
of
eventual
consistency
have
significant
implication
that
must
be
connector_17
while
develop
the
component_3
all
the
way
from
the
back
end
to
the
ux
pattern_19
rebecca
parson
how
to
decompose
a
monolith
when
start
to
build
an
component_3
we
should
still
start
by
build
a
monolith
for
it
quality_attribute_2
yet
we
must
try
to
build
it
in
such
a
way
that
it
be
very
modular
so
that
those
component_17
will
be
easy
to
detach
into
a
standalone
pattern_4
rebecca
parson
this
be
in
fact
in
pattern_11
with
simon
brown’s
idea
of
design
an
component_3
a
a
set
of
decouple
component_17
in
a
single
quality_attribute_19
unit
when
decompose
a
monolith
into
a
pattern_4
architecture
or
a
set
of
decouple
component_14
we
need
to
think
of
several
dimension
that
can
support
our
decision
think
about
bound
component_4
a
define
in
ddd
rebecca
parson
rachel
myers
each
pattern_4
should
be
a
bound
component_4
that
belong
together
in
a
conceptual
requirement_1
and
technical
pattern_6
it
should
typically
have
connector_data_3
and
or
requirement_1
component_20
connector_18
between
the
unit
in
it
but
few
connector_18
with
external
unit
think
about
requirement_1
capability
rebecca
parson
what
be
the
requirement_10
connector_19
that
exist
in
the
organization
the
requirement_1
technology_2
the
requirement_1
component_1
be
connector_20
think
about
what
component_25
need
rebecca
parson
rather
than
a
component_26
pattern_6
we
can
also
look
at
a
component_27
pattern_6
what
will
the
component_27
want
from
this
component_2
how
will
he
use
it
what
will
he
expect
think
about
connector_2
pattern_15
what
part
of
the
component_10
might
be
use
the
same
connector_data_3
what
requirement_1
component_20
will
connector_3
more
intensely
rebecca
parson
do
the
architecture
have
single
point
of
failure
because
a
micro
component_2
be
a
hard
connector_21
of
many
other
micro
component_2
rachel
myers
think
about
connector_data_3
architecture
rebecca
parson
rachel
myers
component_1
own
their
connector_data_3
they
have
their
own
component_21
and
we
need
to
think
of
thing
“eventual
consistency”
if
two
connector_data_3
connector_data_8
be
very
dependent
of
each
other
it
might
be
a
quality_attribute_11
idea
to
keep
it
in
the
same
pattern_4
so
we
don’t
have
to
create
mechanism
to
deal
with
“eventual
consistency”
think
about
correlate
connector_4
pattern_15
rebecca
parson
rachel
myers
if
two
unit
be
foreseeable
to
be
connector_4
together
then
we
should
keep
them
in
the
same
pattern_4
to
reduce
the
overhead
of
deal
with
connector_4
apis
be
prepare
to
merge
and
segregate
component_1
rebecca
parson
we
will
probably
not
connector_9
it
right
every
time
and
a
we
gain
knowledge
of
the
domain
we
will
have
a
quality_attribute_11
understand
of
where
the
bound
component_4
be
at
the
same
time
requirement_1
will
connector_4
and
we
will
need
to
adapt
to
that
connector_4
rapidly
so
we
must
deign
our
component_10
in
such
a
way
that
we
can
quickly
split
and
merge
pattern_1
tolerant
reader
rebecca
parson
we
will
always
at
some
point
need
to
make
a
backwards
quality_attribute_10
break
connector_4
however
we
can
do
our
best
to
only
do
it
a
a
last
resort
one
way
of
not
need
to
connector_4
our
component_2
whenever
another
component_2
connector_7
be
to
make
it
so
that
we
only
need
to
connector_4
when
they
connector_4
the
connector_data_3
we
actually
need
stateless
and
phoenix
technology_8
rachel
myers
chad
fowler
eric
evans
do
not
repeat
coding_keyword_3
technology_14
cs
j
img
across
component_28
and
component_2
the
ui
component_29
should
be
completely
separate
from
the
micro
component_2
ecosystem
use
disposable
technology_8
use
immutable
deployment
never
upgrade
on
an
exist
technology_8
convention
over
configuration
chad
fowler
the
architecture
connector_data_7
and
name
should
be
the
same
throughout
the
pattern_1
ecosystem
create
a
pattern_4
sandbox
generator
so
we
have
a
start
point
with
the
usual
connector_data_7
already
define
optimize
connector_2
between
pattern_1
chad
fowler
create
a
base
technology_4
pattern_20
component_24
technology_12
optimize
for
pattern_20
connector_data_5
from
where
we
can
build
specific
pattern_4
component_30
to
be
use
by
the
other
pattern_1
this
optimize
component_24
must
be
port
to
all
technology_7
use
in
the
pattern_1
ecosystem
component_2
discovery
chad
fowler
every
pattern_4
must
how
to
the
other
pattern_1
we
can
use
a
localize
per
component_2
config
that
can
be
update
in
all
pattern_1
at
once
when
there
be
a
connector_4
in
a
pattern_4
location
pattern_3
chad
fowler
measure
everything
requirement_3
component_31
component_3
when
create
a
pattern_4
it
must
be
mandatory
to
all
pattern_3
requirement_9
to
it
migrate
from
monolith
to
pattern_1
chad
fowler
favour
many
small
connector_22
over
a
few
big
connector_22
remove
join
segregate
db
build
feature
a
pattern_1
a
prototype
replace
in
the
old
component_10
by
component_23
connector_data_4
to
the
pattern_1
test
under
crazy
load
behaviour
long
term
objective
chad
fowler
make
it
work
make
it
fast
make
it
cheap
=
technology_15
spot
instance
provide
85%
to
95%
connector_23
in
component_5
technology_8
productivity
chad
fowler
use
technology_11
to
increase
development
and
deployment
quality_attribute_20
conclusion
most
of
the
project
don’t
need
a
pattern_1
architecture
what
they
need
be
a
quality_attribute_11
architecture
by
quality_attribute_11
architecture
i
mean
a
quality_attribute_11
connector_data_7
but
also
maybe
even
more
important
a
clear
definition
of
the
connector_data_7
a
clear
and
quality_attribute_21
pattern_12
of
that
connector_data_7
in
the

so
that
it
be
implicitly
connector_24
to
the
developer
so
they
can
see
the
bound
component_4
border
and
understand
when
they
should
cross
those
border
or
not
then
it
be
up
to
the
developer
to
maintain
and
quality_attribute_9
the
architectural
connector_data_7
this
involve
strictness
to
stick
to
the
plan
to
the
connector_data_7
to
the
architecture
which
be
not
always
easy
give
that
we
be
only
human
…
don’t
even
consider
pattern_1
unless
you
have
a
component_10
that’s
too
complex
to
manage
a
a
monolith
…
martin
fowler

component_32

werner
vogels
•
dec

•
eventually
consistent
–
revisit
technology_16
•
jun

•
de
mystify
“eventual
consistency”
in
quality_attribute_15
component_18
martin
fowler
&
james
lewis
•
mar

•
pattern_1
martin
fowler
•

•
microservicepremium
conference
talk
adrian
cockcroft
•
jan

•
the
state
of
the
art
in
pattern_1
chad
fowler
•
jul

•
from
homogeneous
monolith
to
radically
heterogeneous
pattern_1
architecture
eric
evans
•
dec

•
ddd
&
pattern_1
at
last
some
boundary
fred
george
•
aug

•
challenge
in
connector_25
pattern_1
james
lewis
•
oct

•
pattern_1
and
the
inverse
conway
manoeuvre
jed
wesley
smith
•
oct

•
real
world
pattern_1
martin
fowler
•
jan

•
pattern_1
rachel
myers
•
dec

•
stop
build
component_2
episode

the
phantom
menace
rebecca
parson
•
jul

•
evolutionary
architecture
&
micro
component_2
connector_26
this
twitterfacebooklike
this

loading
relate
taggedarchitecturemicroservicesthe
architecture
chronicle
publish
by
hgraca
pattern_6
all
coding_keyword_1
by
hgraca
publish

2017november


coding_keyword_1
navigation
previous
coding_keyword_1
stakeholder
engagement
the
requirement_1
requirement_12
and
domain
expertsnext
coding_keyword_1
stakeholder
engagement
the
component_6

thought
on
“microservices
architecture
what
the
guru
say
about
it”
pingback
pattern_1
architecture
what
the
guru
say
about
it
–
sb
s
sergey
bondarev
say


at


great

likelike
connector_data_12
pingback
monolithic
architecture
|
@herbertograca
pingback
pattern_1
with
technology_17
–
craft
with
ingenuity
fernando
blanco
say


at


quality_attribute_11

well
do
congratulation
this
be
one
of
the
best

about
this
topic
that
i
have
connector_1
likelike
connector_data_12
paul
say


at


quality_attribute_11
connector_1
+1
likelike
connector_data_12
sierj
khaletski
@sierjkhaletski
say


at


great
and
fundamental
work
thanks
a
lot
likelike
connector_data_12
leave
a
connector_data_12
cancel
connector_data_12
enter
your
here
fill
in
your
detail
below
or
click
an
icon
to
requirement_13
in
require
connector_17
never
make
coding_keyword_2
name
require
you
be

use
your
technology_18
technology_19
account
requirement_13
out
connector_4
you
be

use
your
twitter
account
requirement_13
out
connector_4
you
be

use
your
account
requirement_13
out
connector_4
cancel
connector_27
to
%s
connector_28
me
of

via

connector_28
me
of
coding_keyword_1
via

δ
search
for
home
dev
curriculum
pet
project
phorensic
component_33
mapper
explicit
architecture
demo
technology_20
boilerplate
coding_keyword_1
series
the
architecture
chronicle
the
containerisation
chronicle
lecture
distillation
book
distillation
domain
drive
design
by
eric
evans
lean
architecture
by
james
coplien
and
gertrud
bjornvig
pattern_15
of
requirement_5
component_3
architecture
by
martin
fowler
pattern_15
principle
and
practice
of
domain
drive
design
by
scott
millett
and
nick
tune
the
mythical
man
month
by
frederick
p
brook
about
top
coding_keyword_1
&
component_34
ddd
hexagonal
onion
clean
cqrs
…
how
i
put
it
all
together
the
architecture
chronicle
the
containerization
chronicle
pattern_1
architecture
what
the
guru
say
about
it
team
build
manage
lead
perform
ddd
europe

the

talk
i
most
enjoy
dev
curriculum
follow
via
enter
your
connector_17
to
follow
this
and
connector_29
connector_data_13
of
coding_keyword_1
by

join


other
follower
connector_17
follow
8th
lighthow
to
bootstrap
a
quality
golang
backendof
duck
and
go
misuseguilds
how
8th
light’s
consultant
connector_26
knowledge
across
project
the
clean
codespace
warfunctional
duplicationsroots
martin
fowleragile
book
club
on
refactoringhow
i
use
twitterphotostream

create
a
free
or
at
technology_18
technology_19
follow
follow
@hgraca
join


other
follower
sign
me
up
already
have
a
technology_18
technology_19
account
requirement_13
in
now
@hgraca
customize
follow
follow
sign
up
requirement_13
in
copy
shortlink
report
this
content
pattern_6
coding_keyword_1
in
reader
manage
subscription
collapse
this
bar
loading

connector_11
a

require
name
require
%d
technology_21
this
