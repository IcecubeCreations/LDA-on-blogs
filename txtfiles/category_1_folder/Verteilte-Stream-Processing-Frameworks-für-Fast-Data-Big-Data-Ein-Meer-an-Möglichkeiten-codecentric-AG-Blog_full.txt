verteilte
connector_1
component_1
technology_1
f√ºr
fast
connector_data_1
&
requirement_1
ein
meer
an
m√∂glichkeiten
codecentric
ag
leistungenkarrierewissenblogaktuelles√ºber
un
encodecentric
it
expertenwissen
von
entwicklern
f√ºr
entwickler


codecentric
blogneuesteagilit√§tarchitekturdatajavaperformancecontinuous
deliverymicroservicescloud
r
feedxmist
da
klappt
leider
noch
nicht
im
moment
testen
wir
neue
funktionen
und
du
hast
un
mit
deinem
klick
geholfen
vielen
dank
√ºbersicht
component_2
vision
techniken
in
kofax
transformation
ktm
ktd
verteilte
connector_1
component_1
technology_1
f√ºr
fast
connector_data_1
&
requirement_1
‚Äì
ein
meer
an
m√∂glichkeiten



von
matthias
niehoff
keine
kommentare
technology_2
connector_1
flink
storm
technology_3
connector_2
‚Äì
da
sind
nur
die
popul√§rsten
vertreter
einer
stetig
wachsenden
auswahl
zur
verarbeitung
von
connector_1
daten
in
gro√üen
mengen
in
diesem
artikel
soll
e
um
die
wesentlichen
konzepte
hinter
diesen
technology_1
gehen
und
die
drei
technology_4
projekte
technology_2
connector_1
flink
und
technology_3
connector_2
kurz
eingeordnet
werden
warum
connector_1
component_1
die
verarbeitung
von
connector_1
daten
gewinnt
durch
die
stetig
wachsende
anzahl
von
datenquellen
die
durchgehend
daten
produzieren
und
zur
verf√ºgung
stellen
zunehmend
an
bedeutung
neben
dem
omnipr√§senten
internet
of
thing
sind
die
zum
beispiel
klickstreams
daten
im
werbegesch√§ft
oder
auch
ger√§te
und
serverlogs
nun
sind
unendliche
und
kontinuierliche
daten
kein
neues
ph√§nomen
auch
jetzt
entsprechen
schon
viele
daten
diesem
schema
zum
beispiel
treten
auch
√§nderungen
an
stammdaten
kontinuierlich
auf
allerdings
nur
in
geringer
frequenz
stammdaten
werden
nach
dem
klassischen
connector_data_2
connector_3
verarbeitet
bei
zeitunkritischen
√§nderungen
oder
gr√∂√üeren
volumen
werden
die
daten
auch
gerne
gesammelt
gespeichert
und
dann
regelm√§√üig
durch
batchprozesse
verarbeitet
diese
laufen
dann
beispielsweise
jede
nacht
oder
auch
in
k√ºrzeren
intervallen
t√§gliche
intervalle
reichen
aber
h√§ufig
nicht
mehr
au
gefragt
ist
geschwindigkeit
analysen
und
auswertungen
werden
zeitnah
erwartet
und
nicht
minuten
oder
gar
stunden
sp√§ter
an
dieser
stelle
kommt
da
connector_1
component_1
in
spiel
daten
werden
verarbeitet
sobald
sie
dem
component_3
bekannt
sind
begonnen
hat
die
mit
der
lambda
architektur
vgl

bei
der
die
connector_1
und
pattern_1
verarbeitung
parallel
erfolgen
da
die
connector_1
verarbeitung
keine
konsistenten
ergebnisse
garantieren
konnte
mit
den
heutigen
systemen
ist
e
auch
m√∂glich
nur
mit
connector_1
verarbeitung
konsistente
ergebnisse
nahezu
in
echtzeit
zu
erreichen
vgl

time
mattersein
wichtiger
aspekt
beim
connector_4
ist
die
zeit
dabei
kann
im
wesentlichen
zwischen
drei
zeiten
unterschieden
werden
eventzeit
zeitpunkt
zu
dem
ein
tats√§chlich
auftratingestionzeit
zeitpunkt
zu
dem
da
im
component_3
beobachtet
wurdeverarbeitungszeit
zeitpunkt
zu
dem
da
vom
component_3
verarbeitet
wurdeabb

exemplarische
darstellung
von
eventzeit
und
verarbeitungszeit
mit
versp√§teten
gelb
gr√ºn
rot
und
out
of
order
blau
in
der
praxis
ist
vor
allem
eventzeit
im
vergleich
zur
ingestion
&
verarbeitungszeit
interessant
die
differenz
zwischen
der
eventzeit
und
der
verarbeitungszeit
kann
stark
schwanken
die
gr√ºnde
daf√ºr
sind
vielf√§ltig
netzwerk
latenzen
verteilte
systeme
hardware
ausf√§lle
oder
auch
eine
unregelm√§√üige
datenanlieferung
wenn
nach
der
verarbeitungszeit
verarbeitet
wird
ist
die
nicht
wichtig
die
daten
werden
auf
basis
der
systemzeit
der
verarbeitung
analysiert
wenn
ein
um

uhr
eintrifft
ist
e
irrelevant
das
e
bereits
um

uhr
aufgetreten
ist
der
normale
use
requirement_2
ist
die
aber
nicht
wenn
ein
um

uhr
auftritt
m√∂chte
ich
e
in
der
regel
auch
zeitlich
so
betrachten
die
frage
hier
ist
dann
wann
wei√ü
ich
das
ich
alle
pattern_2

uhr
bekommen
habe
wie
lange
warte
ich
auf

hier
helfen
strategien
wie
watermark
connector_5
und
akkumulatoren
watermark
wann
habe
ich
alle
daten
zusammen
connector_5
wann
soll
ich
die
berechnung
ausl√∂sen
akkumulation
wie
f√ºge
ich
einzelne
berechnungen
zusammen
beispielsweise
wenn
nachtr√§glich
daten
folgen
√ºber
diese
drei
konzepte
lie√üe
sich
problemlos
ein
eigener
artikel
schreiben
tyler
akidau
der
kopf
hinter
connector_4
bei

hat
die
bereits
hervorragend
zusammengefasst
deshalb
sei
an
dieser
stelle
f√ºr
detail
sein
artikel
empfohlen

state
&
windowjede
nicht
triviale
anwendung
wird
eingehende
miteinander
korrelieren
daf√ºr
ist
ein
zustand
n√∂tig
in
dem
vorherige
zwischengespeichert
werden
dieser
state
kann
unendlich
gespeichert
werden
oder
explizit
zeitlich
begrenzt
ein
beispiel
f√ºr
einen
unendlichen
gespeicherten
state
ist
eine
pattern_3
tabelle
mit
metadaten
ein
zeitlich
begrenzt
state
ist
beispielsweise
ein
window
bei
einem
window
werden
daten
f√ºr
einen
bestimmten
zeitraum
zusammengefasst
und
analysiert
die
ist
in
fast
jeder
anwendung
n√∂tig
da
der
datenstrom
ja
nie
endet
dabei
gibt
e
verschiedene
typen
von
window
tumble
window
nicht
√ºberlappende
fixe
zeitabschnittesliding
window
√ºberlappende
fixe
zeitabschnittesession
window
nicht
√ºberlappende
zeitabschnitte
unterschiedlicher
l√§nge
definiert
durch
bestimmte
oder
durch
√ºberschreiten
einer
bestimmten
zeit
zwischen
zwei
eventsabb

tumble
und
slide
window
bei
einem
zeitfenster
von
vier
sekunden
und
ein
slide
intervall
von
zwei
sekunden
beim
slide
window
innerhalb
eines
jeden
fensters
werden
die
werte
summiert
abb

sessionwindows
bei
einer
inaktivit√§t
von
mindestens
zwei
minuten
zwischen
zwei
f√ºr
einen
key
f√ºr
die
definition
von
window
ist
die
unterscheidung
zwischen

und
verarbeitungszeit
wichtig
window
basierend
auf
verarbeitungszeit
sind
sehr
einfach
zu
realisieren
window
basierend
auf
eventzeit
ben√∂tigen
die
oben
genannten
strategien
zur
eventzeit
um
nicht
unendlich
zu
wachsen
component_4
&
laufzeitumgebungerste
unterschiede
bei
den
technology_1
lassen
sich
bei
der
component_4
und
dem
generellen
verarbeitungsmodell
feststellen
unterscheiden
l√§sst
sich
zwischen
einem
nativen
connector_1
ansatz
und
dem
microbatching
beim
nativen
connector_4
werden
eingehende
daten
direkt
verarbeitet
wohingegen
beim
microbatching
die
eingehenden
daten
zun√§chst
f√ºr
eine
bestimmte
zeit
typischerweise

‚Äì
30
gesammelt
und
anschlie√üend
zusammen
verarbeitet
werden
der
n√§chste
microbatch
kann
dann
entweder
direkt
nach
dem
abschluss
de
vorherigen
pattern_1
gestartet
werden
oder
erst
nach
verstreichen
de
fixen
intervalls
in
beiden
f√§llen
erh√∂ht
microbatching
die
latenz
daf√ºr
ist
da
fehlerhandling
etwas
einfacher
zu
realisieren
der
fr√ºher
h√§ufig
genannte
vorteil
de
sehr
hohen
durchsatzes
kann
heute
aber
auch
von
nativen
connector_4
technology_1
erreicht
werden
zudem
bieten
diese
mehr
flexibilit√§t
bei
window
und
state
sichtbar
f√ºr
den
entwickler
ist
vor
allem
die
technology_5
auch
hier
kann
zwischen
zwei
varianten
unterschieden
werden
einer
komponentenbasierten
und
einer
deklarativen
high
level
technology_5
bei
ersterer
wird
der
flu
durch
verschiedene
komponenten
beschrieben
quelle
verarbeitung

verarbeitung

senke
bei
letzterer
werden
die
operationen
auf
daten
beschrieben
connector_data_3
pattern_4
reduce
√§hnlich
wie
bei
technology_6
collection
oder
technology_7

connector_1
die
beschreibung
von
komponenten
bietet
mehr
flexibilit√§t
bei
der
verteilung
der
datenstr√∂me
w√§hrend
die
deklarative
component_4
h√§ufig
bereits
h√∂herwertige
funktion
bereitstellt
und
automatisch
optimierungen
vornehmen
kann
zuletzt
bleibt
noch
die
frage
wo
werden
die
anwendungen
ausgef√ºhrt
auch
hier
kann
man
‚Äì
√ºberraschung
üôÇ
‚Äì
zwei
grunds√§tzliche
alternativen
unterscheiden
einige
technology_1
brauchen
ein
spezielles
cluster
bestehend
au
master
technology_8
und
component_5
technology_8
diese
cluster
k√ºmmern
sich
dann
auch
um
da
ressourcenmanagement
und
fehlerbehandlung
k√∂nnen
die
aber
auch
auslagern
an
andere
technology_9
zum
beispiel
technology_10
oder
mesos
andere
technology_1
kommen
al
einfache
bibliothek
daher
die
sich
in
die
eigene
anwendung
einbinden
l√§sst
da
ausf√ºhren
und
skalieren
der
anwendung
mus
dann
von
anderen
technology_9
√ºbernommen
werden
hier
hat
man
die
volle
flexibilit√§t
vom
ausf√ºhren
eines
jar
√ºber
technology_11
l√∂sungen
pattern_2
hin
zu
mesos
&
co
verteilte
systeme
sind
unzuverl√§ssig
alle
drei
technology_1
sind
spezialisiert
auf
die
verarbeitung
gro√üer
datenmenge
und
l√∂sen
die
durch
horizontale
skalierung
diese
verteilten
systeme
sind
inh√§rent
unzuverl√§ssig
einzelne
technology_8
k√∂nnen
ausfallen
da
netzwerk
ist
inkonstant
oder
die
datenbank
in
der
die
ergebnisse
geschrieben
werden
sollen
ist
nicht
erreichbar
au
diesem
grund
hat
jedes
technology_1
unterschiedliche
mechanismen
um
bestimmte
garantien
zu
erreichen
diese
reichen
vom
microbatching
bei
dem
kleine
pattern_1
wiederholt
werden
√ºber
acknowledge
f√ºr
einzelne
datens√§tze
pattern_2
hin
zu
transaktionalen
connector_data_4
auf
quelle
und
senke
die
erreichten
garantien
sind
dann
in
der
regal
at
least
once
also
mindestens
einmal
verarbeitet
oder
exactly
once
genau
einmal
verarbeitet
da
exactly
once
h√§ufig
nur
schwierig
und
mit
gro√üem
aufwand
zu
erreichen
ist
sind
at
least
once
garantien
mit
idempotenten
operationen
h√§ufig
ausreichend
sowohl
in
bezug
auf
geschwindigkeit
al
auch
auf
fehlertoleranz
gibt‚Äôs
da
nichts
von
technology_4
zeithandling
state
&
window
eine
laufzeitumgebung
und
da
alles
in
verteilten
systemen
connector_1
anwendungen
sind
komplex
e
gibt
eine
reihe
von
projekten
die
bei
diesen
problemen
helfen
sollen
drei
davon
kurz
vorgestellt
technology_4
technology_2
connector_1
technology_4
technology_2
ist
aktuell
eines
der
popul√§rsten
der
projekte
im
connector_1
bereich
gestartet
al
besseres
mapreduce
folgte
sp√§ter
auch
eine
unterst√ºtzung
f√ºr
connector_1
daten
technology_2
connector_4
setzt
dabei
auf
microbatching
mit
einer
deklarativen
technology_5
aktuell
wird
dabei
nur
die
verarbeitungszeit
vollst√§ndig
unterst√ºtzt
mit
der
neuen
pattern_5
connector_4
component_4
wird
seit
der
version


allerdings
auch
die
unterst√ºtzung
f√ºr
eventzeit
verarbeitung
sukzessive
ausgebaut
da
gleiche
gilt
f√ºr
die
unterst√ºtzung
von
window
der
state
wird
lokal
in
memory
oder
auf
disk
gehalten
und
per
checkpointing
regelm√§√üig
gesichert
da
technology_2
inzwischen
mit
jeder
technology_12
distribution
ausgeliefert
wird
ist
die
verbreitung
sehr
hoch
ebenso
existiert
ein
gro√ües
√∂kosystem
mit
vielen
technology_9
und
konnektoren
technology_4
flink
wenn
e
um
eventzeit
verarbeitung
geht
ist
technology_4
flink
aktuell
die
erste
wahl
unterst√ºtzt
werden
watermark
und
connector_5
ebenso
wie
unterschiedliche
window
operationen
flink
verfolgt
dabei
einen
nativen
connector_1
ansatz
und
erreicht
somit
niedrige
latenzen
ebenso
wie
bei
technology_2
connector_4
wird
eine
deklarative
component_4
genutzt
mit
der
m√∂glichkeit
sogenannte
rich
zu
nutzen
in
denen
beispielsweise
ein
state
genutzt
wird
im
gegensatz
zu
technology_2
k√∂nnen
verschiedene
state
implementierungen
genutzt
werden
in
memory
festplatte
oder
rocksdb
flink
ist
etwas
j√ºnger
al
technology_2
gewinnt
aber
zunehmend
an
verbreitung
ebenso
wachsen
die
und
da
√∂kosystem
stetig
sind
allerdings
noch
nicht
so
gro√ü
wie
bei
technology_2
technology_4
technology_3
connector_2
da
connector_4
technology_1
au
dem
technology_3
√∂kosystem
ist
der
j√ºngste
vertreter
in
dieser
√ºbersicht
e
basiert
auf
vielen
konzepten
die
bereits
in
technology_3
enthalten
sind
wie
beispielsweise
die
skalierung
durch
partitionierung
der
topic
auch
au
diesem
grund
kommt
e
al
leichtgewichtige
bibliothek
daher
die
in
eine
anwendung
eingebunden
werden
kann
die
anwendung
kann
dann
nach
belieben
betrieben
werden
standalone
in
einem
applikationsserver
al
technology_11
container
oder
√ºber
einen
resourcen
manager
wie
mesos
flink
&
technology_2
hingegen
ben√∂tigen
immer
ein
cluster
entweder
ein
mit
den
boardmitteln
der
technology_1
gebautes
oder
aber
technology_10
mesos
technology_3
connector_2
ist
allerdings
beschr√§nkt
auf
technology_3
al
quelle
und
auch
al
senke
die
konnektivit√§t
zu
anderen
systemen
wird
dann
√ºber
technology_3
connector_6
hergestellt
ansonsten
besitzt
technology_3
connector_2
neben
einer
deklarativen
auch
eine
komponentenorientierte
technology_5
eine
rudiment√§re
unterst√ºtzung
von
eventtime
sowie
rocksdb
al
state
implementierung
w√§hrend
technology_3
selbst
schon
sehr
reif
ist
und
h√§ufig
auch
in
verbindung
mit
flink
und
technology_2
genutzt
wird
ist
die
connector_1
komponente
noch
recht
jung
so
ist
auch
die
eher
klein
und
die
verbreitung
eher
gering
e
ist
aber
zu
erwarten
das
beides
zeitnah
wachsen
wird
update
technology_3
connector_2
nutzt
die
konzepte
de
technology_13
component_6
um
den
herausforderungen
de
eventzeit
handle
zu
begegnen
connector_2
wird
entwickelt
auf
dem
konzept
von
ktables
und
kstreams
welch
genutzt
wird
um
eventzeit
verarbeitung
zu
unterst√ºtzen
und
be
passt
zu
mir
nun
bleibt
zum
schluss
die
frage
welch
technology_1
passt
zu
mir
wenn
eventzeit
verarbeitung
ben√∂tigt
wird
f√ºhrt
aktuell
fast
kein
weg
an
flink
vorbei
ein
weiterer
pluspunkt
ist
die
niedrige
latenz
die
wichtigsten
umsysteme
technology_3
technology_14
elasticsearch
technology_15
datenbanken
k√∂nnen
relativ
einfach
integriert
werden
die
niedrige
latenz
und
einen
einfach
zu
nutzenden
eventzeit
support
erm√∂glicht
auch
technology_3
connector_1
wenn
also
technology_3
bereits
im
einsatz
ist
und
die
verarbeitung
eher
einfach
ist
ohne
komplexe
anforderungen
an
eventzeit
verarbeitung
ist
technology_3
connector_2
eine
gute
alternative
daf√ºr
mus
ich
hier
noch
die
umsysteme
√ºber
technology_3
connector_6
anbinden
und
mich
um
die
laufzeitumgebung
k√ºmmern
die
kann
aber
auch
ein
vorteil
sein
wenn
ich
vorhandene
technology_9
zum
beispiel
au
dem
technology_11
√∂kosystem
nutzen
kann
und
technology_2
wenn
eventzeit
nicht
relevant
ist
und
auch
latenzen
im
sekundenbereich
akzeptabel
sind
ist
technology_2
die
erste
wahl
e
ist
stabil
und
fast
jedes
beliebige
umsystem
kann
einfach
eingebunden
werden
au√üerdem
ist
e
bei
technology_12
installationen
schon
vorhanden
zudem
kann
der

der
f√ºr
pattern_1
anwendungen
genutzt
wird
bei
bedarf
auch
f√ºr
die
connector_1
anwendungen
verwendet
werden
da
die
component_4
dieselbe
ist
lediglich
bei
sehr
gro√üen
state
im
terrabyte
bereich
kann
e
bei
technology_2
zu
problemen
kommen
die
unterst√ºtzung
f√ºr
eventzeit
wird
mit
technology_2


deutlich
erweitert
fazitstream
component_1
technology_1
vereinfachen
die
verarbeitung
gro√üer
datenmengen
signifikant
die
vorgestellten
technology_1
l√∂sen
dabei
vor
allem
probleme
im
bereich
der
verteilten
verarbeitung
wodurch
einfach
zu
skalierende
l√∂sungen
entwickelt
werden
k√∂nnen
ebenso
wichtig
sind
die
unterschiedlichen
aspekte
der
zeitverarbeitung
die
alle
technology_1
unterst√ºtzen
hier
unterscheiden
sich
systeme
auch
be
deutlichsten
von
bibliotheken
wie
technology_16
connector_1
rxjava
oder
vert
x
die
vorgestellten
technology_1
sind
vor
allem
im
big
und
fast
connector_data_1
bereich
angesiedelt
w√§hrend
mit
den
bibliotheken
auch
einfach
kleinere
reaktive
anwendungen
gebaut
werden
k√∂nnen
‚Äì
dann
allerdings
in
der
regel
ohne
requirement_3
unterst√ºtzung
f√ºr
eventzeit
und
cluster
so
bleibt
festzuhalten
das
die
vorgestellten
technology_1
allesamt
bei
aktuellen
herausforderungen
im
fast
connector_data_1
bereich
unterst√ºtzen
k√∂nnen
und
dabei
auch
neue
architekturen
jenseits
der
bekannten
lambda
architektur
unterst√ºtzen
dabei
ist
die
komplexit√§t
dieser
verteilten
component_3
allerdings
keinesfalls
zu
untersch√§tzen
dennoch
ist
davon
auszugehen
das
die
verbreitung
der
systeme
ebenso
wie
die
funktionalit√§t
weiter
zunehmen
wird
dieser
artikel
erschien
zuerst
im
softwerker
dem
kostenfreien
magazin
der
codecentric
connector_7

technology_17
nathanmarz
technology_18

how
to
beat
the
cap
theorem
technology_19

technology_17
www
oreilly
technology_18
idea
question
the
lambda
architecture

technology_17
www
oreilly
technology_18
idea
the
world
beyond
pattern_1
connector_1

tagsbigdatafastdataflinkkafkasparksparkstreamingmatthias
niehoff
matthias
ist
al
connector_data_1
architect
sowie
head
of
connector_data_1
&
requirement_4
f√ºr
die
codecentric
unterwegs
und
unterst√ºtzt
kunden
bei
design
und
umsetzung
von
datenarchitekturen
dabei
liegt
sein
fokus
weniger
auf
dem
modell
sondern
viel
mehr
auf
der
notwendigen
infrastruktur
&
organisation
um
daten
&
ki
projekte
zum
erfolg
zu
verhelfen
wachse
mit
un
wir
m√∂chten
un
gerne
bei
dir
bewerben
oder
war
e
andersherum
zum
bewerberportal
techie
sch√∂n
und
gut‚Ä¶
‚Ä¶
wir
haben
noch
mehr
auf
dem
kasten
‚Äì
und
be
liebsten
l√∂sen
wir
deine
probleme
mehr
erfahren
die
neuesten
tipps
trick
technology_9
und
technologien
jede
woche
direkt
in
deine
inbox
kostenfrei
anmelden
und
immer
auf
dem
neuesten
stand
bleiben
keine
sorge
du
kannst
dich
jederzeit
abmelden
artikel
von
matthias
niehoffallgemeinmachine

in
der
praxis
eine
mate
mit
‚Ä¶
matthias
niehoff
#einematemitlookup
additional
connector_data_1
in
technology_2
streamingweitere
inhalte
zu
architektur
architektur
quality_attribute_1
engineering
in
produktion
betreiben
architektur
automatisch
skaliertes
requirement_5
requirement_3
requirement_6
in
der
requirement_5
kommentieren
antworten
abbrechendeine
e
mail
adresse
wird
nicht
ver√∂ffentlicht
erforderliche
felder
sind
mit
*
markiert
meinen
namen
meine
e
mail
adresse
und
meine
in
diesem
browser
speichern
pattern_2
ich
wieder
kommentiere
startseitekontaktdatenschutzerkl√§rungblognewsletteranmeldung
bleiben
sie
immer
auf
dem
neuesten
stand
newsletter
abonnierenkontaktformular
sie
haben
fragen
oder
anregungen
nutzen
sie
unser
kontaktformular
kontaktieren
sie
un
tweet
by
@codecentric
xleistungenkarrierewissenblogaktuelles√ºber
unsenglishhdp

administration
foundation
‚Äì
schulung
auf
anfrage
