how
to
build
pattern_1
|
atlassian
close
pattern_2
this
component_1
in
your
technology_1
all
technology_1
choose
your
technology_1
中文
deutsch
english
español
français
italiano
한국어
magyar
nederland
日本語
português
pусский
polski
back
technology_2
for
team
support
support
pattern_2
all
technology_2
atlassian
technology_3
try
now
buy
now
search
toggle
search
atlassian
technology_3
close
search
plan
track
&
support
jira
project
and
issue
track
jira
work
requirement_1
requirement_2
team
collaboration
jira
component_2
requirement_1
high
technology_4
itsm
opsgenie
modern
incident
connector_1
statuspage
incident
connector_2
jira
align
requirement_3
agile
plan
collaborate
confluence
document
collaboration
trello
collaborate
visually
on
any
project
build
&
ship
bitbucket
git
requirement_1
sourcetree
git
and
mercurial
desktop
component_3
bamboo
requirement_4
and
release
requirement_1
quality_attribute_1
&
identity
atlassian
connector_3
quality_attribute_1
and
control
for
requirement_5
crowd
component_4
requirement_1
for
self
manage
environment
pattern_2
all
technology_2
marketplace
component_5
that
enhance
atlassian
technology_2
developer
doc
and
resource
to
build
atlassian
component_5
trust
&
quality_attribute_1
compliance
privacy
component_6
roadmap
and
more
work
life
story
on
culture
tech
team
and
tip
close
dropdown
by
team
size
startup
great
for
startup
from
incubator
to
ipo
small
requirement_2
connector_4
the
right
technology_5
for
your
grow
requirement_2
requirement_3
how
we
make
big
team
successful
by
team
plan
build
&
ship
quality
technology_2
requirement_6
bring
together
a
win
strategy
hr
streamline
people
requirement_1
legal
operate
securely
and
quality_attribute_2
run
your
requirement_2
efficiently
it
provide
great
component_2
and
support
finance
simplify
all
finance
component_7
incident
connector_1
respond
resolve
&
from
incident
pattern_2
all
technology_2
marketplace
component_5
that
enhance
atlassian
technology_2
developer
doc
and
resource
to
build
atlassian
component_5
trust
&
quality_attribute_1
compliance
privacy
component_6
roadmap
and
more
work
life
story
on
culture
tech
team
and
tip
close
dropdown
resource
documentation
guide
to
all
of
our
technology_2
atlassian
migration
component_8
technology_5
and
guidance
for
migrate
requirement_5
roadmap
upcoming
feature
release
purchasing
&
license
faq
about
our
requirement_7
support
component_9
requirement_3
component_9
personal
support
for
large
team
partner
support
trust
third
party
consultant
atlassian
support
a
resource
hub
for
team
and
admins
&
connector_5
about
u
our
mission
and
history
career
opening
requirement_8
and
more
atlassian
university
train
and
certification
for
all
skill
level
atlassian
a
forum
for
connector_5
connector_6
and
marketplace
component_5
that
enhance
atlassian
technology_2
developer
doc
and
resource
to
build
atlassian
component_5
trust
&
quality_attribute_1
compliance
privacy
component_6
roadmap
and
more
work
life
story
on
culture
tech
team
and
tip
close
dropdown
development
open
and
close
the
navigation
devops
continuous
delivery
pattern_1
devops
continuous
delivery
pattern_1
pattern_1
architecture
back
overview
pattern_1
vs
monolithic
architecture
how
to
build
pattern_1
what
be
a
quality_attribute_3
component_10
technology_6
vs
technology_7
configuration
requirement_1
definition
and
benefit
requirement_5
computing
back
overview
container
vs
virtual
component_11
infrastructure
a
iac
infrastructure
a
a
component_2
iaa
component_6
a
a
component_2
pass
container
a
a
component_2
caas
requirement_5
burst
how
to
build
pattern_1
best
practice
for
transition
to
a
pattern_1
architecture
sten
pittet
technology_2
manager
say
your
component_12
be
build
on
one
and
be
quite
large
and
monolithic
it
work
well
until
it
didn’t
you
wish
it
could
quality_attribute_4
and
become
more
resilient
quality_attribute_5
and
independently
quality_attribute_6
to
do
so
you
need
to
rethink
the
connector_data_1
of
the
component_12
on
a
granular
pattern_1
level
pattern_1
have
grow
in
popularity
a
component_13
become
more
quality_attribute_3
and
complex
the
guide
principle
of
pattern_1
be
to
build
an
component_12
by
split
it
requirement_2
component_14
into
small
component_9
that
can
be
quality_attribute_7
and
operate
independently
from
each
other
the
separation
of
concern
between
component_9
be
define
a
“service
boundaries”
component_2
boundary
be
closely
tie
to
requirement_2
demand
and
organizational
hierarchy
boundary
individual
component_9
be
tie
to
separate
team
budget
and
roadmaps
some
example
component_2
boundary
might
be
“payment
processing”
and
“user
authentication”
component_2
pattern_1
differ
from
component_15
development
practice
in
which
all
component_14
be
bundle
together
this
document
will
reference
an
imaginary
pizza
startup
connector_7
“pizzup”
to
illustrate
the
component_12
of
pattern_1
to
a
modern
requirement_2
how
to
build
pattern_1
step
start
with
a
monolith
the
first
best
practice
of
pattern_1
be
that
you
probably
don’t
need
them
if
you
t
have
any
component_16
for
your
component_12
chance
be
that
the
requirement_2
requirement
be
go
to
rapidly
connector_8
while
you
re
build
your
mvp
this
be
simply
due
to
the
nature
of
development
and
the
feedback
cycle
that
need
to
happen
while
you
re
identify
the
key
requirement_2
capability
that
your
component_10
need
to
provide
pattern_1
exponential
overhead
and
requirement_1
complexity
for
this
reason
it
be
much
le
overhead
for
project
to
keep
all
the
and
component_17
within
a
single
codebase
since
it
make
it
easy
to
move
the
boundary
of
the
different
of
your
component_12
for
instance
with
pizzup
we
start
with
a
quality_attribute_8
problem
we
want
to
solve
we
want
requirement_9
to
be
able
to
order
pizza
online
relate
material
pattern_1
vs
monolithic
architecture
connector_9
more
see
solution
manage
your
component_14
with
compass
connector_9
more
a
we
start
think
of
the
pizza
order
issue
we
identify
the
different
capability
require
in
our
component_12
to
fulfill
that
need
we
ll
need
to
manage
a
connector_data_2
of
the
different
pizza
we
can
make
allow
requirement_9
to
pick
one
or
many
pizza
handle
the
payment
schedule
the
delivery
and
so
on
we
decide
that
requirement_9
create
an
account
will
facilitate
re
order
the
next
time
they
use
pizzup
after
talk
to
the
first
component_4
we
might
realize
that
live
track
of
the
delivery
and
requirement_10
support
will
give
u
an
advantage
over
the
competition
what
be
a
quality_attribute_8
need
in
the
begin
quickly
turn
into
a
connector_data_2
of
feature
pattern_1
work
well
when
you
have
a
solid
grasp
of
the
different
component_9
require
by
your
component_10
however
pattern_1
be
much
more
difficult
to
handle
if
the
core
requirement
of
an
component_12
be
not
well
define
it
s
quite
costly
to
redefine
component_2
connector_10
apis
and
connector_data_3
connector_data_4
in
pattern_1
since
there
be
typically
many
more
move
part
that
need
to
be
coordinate
our
advice
be
to
keep
thing
quality_attribute_8
until
you
have
connector_11
enough
component_4
feedback
to
give
you
confidence
that
the
basic
need
of
your
requirement_9
be
understand
and
plan
for
a
bit
of
caution
build
a
monolith
can
quickly
lead
to
complicate
that
be
challenge
to
break
down
into
small
piece
it’s
best
to
have
clear
identify
so
that
you
can
extract
them
late
out
of
the
monolith
you
can
also
start
by
separate
the
component_17
from
the
web
ui
and
ensure
that
it
connector_12
with
your
backend
via
a
pattern_3
component_18
over
technology_8
this
make
the
transition
to
pattern_1
easy
when
you
move
component_18
resource
to
different
component_2
step
organize
your
team
the
right
way
up
until
now
it
might
seem
that
build
pattern_1
be
mostly
a
technical
affair
you
need
to
split
a
codebase
into
multiple
component_2
connector_13
the
right
pattern_4
to
fail
gracefully
and
recover
from
requirement_11
issue
deal
with
connector_data_3
consistency
pattern_5
component_2
load
etc
there
will
be
numerous
concept
to
grasp
but
arguably
the
most
but
one
thing
that
must
not
be
ignore
be
that
you
ll
need
to
restructure
the
way
your
team
be
organize
conway
s
law
be
real
and
can
be
observe
in
all
type
of
team
if
a
team
be
organize
with
a
backend
team
a
frontend
team
and
an
team
work
independently
it
will
connector_14
separate
frontend
and
backend
monolith
that
connector_4
throw
over
the
wall
to
the
team
to
connector_14
into
production
this
type
of
team
connector_data_1
isn’t
a
quality_attribute_9
fit
for
pattern_1
since
each
component_2
should
be
treat
it
own
technology_2
that
need
to
be
ship
independently
of
the
others
instead
you
should
create
small
devops
team
that
have
all
the
competency
require
to
develop
and
maintain
the
component_9
they
re
in
charge
of
there
be
great
benefit
to
arrange
your
team
this
way
first
of
all
your
developer
have
a
quality_attribute_9
understand
of
the
impact
of
their
in
production
which
help
them
produce
quality_attribute_9
release
and
reduce
the
risk
of
see
issue
release
to
requirement_9
secondly
deployment
become
second
nature
for
each
team
since
they
work
together
on
improvement
to
the
a
well
a
the
automation
of
the
deployment
pipeline
step
split
the
monolith
to
build
a
pattern_1
architecture
when
you
ve
identify
the
boundary
of
your
component_9
and
you
ve
figure
out
how
to
restructure
your
team
you
can
start
split
your
monolith
to
build
pattern_1
the
follow
be
the
key
point
to
think
about
at
that
time
keep
connector_2
between
component_9
quality_attribute_8
with
a
pattern_3
component_18
if
you
re
not
already
use
a
pattern_3
component_18
now
would
be
a
quality_attribute_9
time
to
adopt
it
a
martin
fowler
explain
you
want
to
have
smart
and
dumb
pip
this
mean
that
the
connector_2
technology_9
between
your
component_9
should
be
a
quality_attribute_8
a
possible
and
only
in
charge
of
connector_15
connector_data_3
without
transform
it
the
magic
happen
in
the
themselves
–
they
connector_16
a
connector_data_5
component_19
it
and
emit
a
connector_1
in
pattern_6
architecture
strive
to
keep
thing
a
straightforward
a
possible
to
avoid
the
tight
couple
of
component_20
in
some
requirement_12
you
might
find
yourself
use
an
pattern_7
architecture
with
pattern_8
connector_data_6
base
connector_2
but
once
again
you
should
look
into
basic
connector_data_6
component_21
component_9
technology_10
and
avoid
complexity
to
the
connector_data_7
connector_17
over
the
requirement_11
divide
connector_data_3
into
bind
component_22
or
connector_data_3
domain
monolith
component_13
use
a
single
component_23
for
all
requirement_2
feature
of
the
component_12
a
a
monolith
be
break
into
pattern_1
this
singular
component_23
no
long
make
sense
a
central
component_23
can
become
a
bottleneck
for
traffic
quality_attribute_10
if
a
particular
component_2
connector_3
the
component_23
with
high
load
it
interrupt
the
component_23
connector_3
of
other
component_2
additionally
a
singular
component_23
can
become
a
collaboration
bottleneck
for
multiple
team
try
to
simultaneously
modify
the
schema
this
connector_data_8
for
the
component_23
to
be
split
up
or
additional
connector_data_3
storage
technology_5
to
support
pattern_6
connector_data_3
need
refactoring
a
monolithic
component_23
schema
can
be
a
delicate
it
s
important
to
clearly
identify
which
datasets
each
component_2
need
and
any
overlap
this
schema
plan
can
be
do
by
use
bind
component_22
which
be
a
pattern_4
from
domain
drive
design
a
bind
component_22
define
a
self
contain
component_10
include
what
can
enter
and
exit
that
component_10
in
this
component_10
when
a
component_4
connector_3
an
order
you
can
pattern_2
requirement_9
connector_data_9
in
the
component_24
which
can
also
be
use
to
populate
the
invoice
manage
by
the
bill
component_10
this
seem
logical
and
quality_attribute_8
but
with
pattern_1
the
component_9
should
be
decouple
so
that
invoice
can
be
connector_18
even
if
the
order
component_10
be
down
also
it
allow
you
to
optimize
or
quality_attribute_4
the
invoice
component_24
independent
of
others
each
component_2
might
end
up
have
it
own
component_25
to
connector_3
the
connector_data_3
it
need
this
introduce
problem
since
some
connector_data_3
will
be
duplicate
in
different
component_23
bind
component_22
can
identify
the
best
strategy
to
handle
connector_19
or
duplicate
connector_data_3
you
adopt
an
pattern_7
architecture
to
help
pattern_9
connector_data_3
across
multiple
component_2
for
instance
your
bill
and
delivery
track
component_9
might
listen
for
emit
by
the
account
component_2
when
requirement_9
update
their
personal
connector_data_9
upon
reception
of
the
these
component_9
will
update
their
component_25
accordingly
this
pattern_7
architecture
allow
the
account
component_2
component_17
to
be
keep
quality_attribute_8
a
it
doesn
t
need
to
the
other
dependent
component_2
it
simply
tell
the
component_10
what
it
do
and
other
component_9
listen
and
act
accordingly
you
can
also
choose
to
keep
all
requirement_9
connector_data_9
in
the
account
component_2
and
only
keep
a
foreign
key
reference
in
your
bill
and
delivery
component_2
these
component_9
then
connector_20
with
the
account
component_2
to
connector_4
relevant
requirement_9
connector_data_3
instead
of
duplicate
exist
component_26
since
there
isn
t
a
universal
solution
for
these
problem
you
ll
need
to
look
into
each
specific
requirement_12
to
determine
the
best
approach
build
your
pattern_1
architecture
for
failure
we
ve
see
how
pattern_1
can
provide
you
with
great
benefit
over
a
monolithic
architecture
they
re
small
in
size
and
specialize
which
make
them
easy
to
understand
they
re
decouple
which
mean
that
you
can
refactor
a
component_2
without
have
to
fear
break
the
other
component_14
of
the
component_10
or
slow
down
the
development
of
the
other
team
they
also
give
more
quality_attribute_11
to
your
developer
a
they
can
pick
different
technology_11
if
require
without
be
constrain
by
the
need
of
other
component_2
in
short
have
a
pattern_6
architecture
make
develop
and
maintain
each
requirement_2
capability
easy
but
thing
become
more
complicate
when
you
look
at
all
the
component_9
together
and
how
they
need
to
connector_20
to
complete
action
your
component_10
be
now
quality_attribute_3
with
multiple
point
of
failure
and
you
need
to
cater
for
that
you
need
to
take
into
account
not
only
requirement_12
where
a
component_2
be
not
respond
but
also
be
able
to
deal
with
slow
requirement_11
connector_1
recover
from
a
failure
can
also
be
tricky
at
time
since
you
need
to
make
sure
that
component_9
that
connector_4
back
online
do
not
connector_4
flood
by
pending
connector_data_6
a
you
start
extract
capability
out
of
your
monolithic
component_10
make
sure
that
your
design
be
build
for
failure
from
the
begin
emphasize
pattern_10
to
ease
pattern_1
test
test
be
another
drawback
of
pattern_1
compare
to
a
monolithic
component_10
an
component_12
that
be
build
a
a
single
codebase
doesn
t
need
much
to
have
a
test
environment
up
and
run
in
most
requirement_12
you
ll
have
to
start
a
backend
component_27
couple
with
a
component_23
to
be
able
to
run
your
test
suite
in
the
world
of
pattern_1
thing
be
not
a
easy
when
it
come
to
unit
test
it
will
still
be
quite
similar
to
the
monolith
and
you
shouldn
t
feel
more
pain
at
that
level
however
when
it
come
to
requirement_4
and
component_10
test
thing
will
become
much
more
difficult
you
might
have
to
start
several
component_9
together
have
different
datastores
up
and
run
and
your
setup
might
need
to
include
connector_data_6
component_28
that
you
do
not
need
with
your
monolith
in
this
situation
it
become
much
more
costly
to
run
functional
test
and
the
increasing
number
of
move
part
make
it
very
difficult
to
predict
the
different
type
of
failure
that
can
happen
pattern_10
can
identify
issue
early
and
allow
you
to
technology_12
accordingly
you
need
to
understand
the
baseline
of
different
component_9
and
technology_12
not
only
when
they
go
down
but
also
when
they
behave
unexpectedly
one
advantage
of
adopt
a
pattern_6
architecture
be
that
your
component_10
should
be
resilient
to
partial
failure
so
if
you
start
to
see
anomaly
in
the
delivery
track
component_2
of
our
pizzup
component_12
it
win
t
be
a
bad
a
if
it
be
a
monolithic
component_10
our
component_12
should
be
design
so
that
all
the
other
component_9
respond
properly
and
our
requirement_9
order
pizza
while
we
restore
live
track
embrace
continuous
delivery
to
reduce
deployment
friction
release
a
monolithic
component_10
to
production
manually
be
a
tedious
and
risky
effort
but
it
can
be
do
of
we
do
not
recommend
this
approach
and
encourage
every
team
to
embrace
continuous
delivery
for
all
type
of
development
but
at
the
begin
of
a
project
you
might
do
your
first
deployment
yourself
via
the
command
line
this
approach
be
not
quality_attribute_12
when
you
have
an
increasing
number
of
component_9
that
need
to
be
quality_attribute_7
multiple
time
a
day
so
a
part
of
your
transition
to
pattern_1
it
be
critical
that
you
embrace
continuous
delivery
to
reduce
the
risk
of
release
failure
a
well
a
ensure
your
team
be
focus
on
build
and
run
the
component_12
rather
than
be
stick
quality_attribute_7
it
practice
continuous
delivery
also
mean
that
your
component_2
pass
acceptance
test
before
go
to
production
of
bug
will
occur
but
over
time
you
will
build
a
quality_attribute_13
test
suite
that
should
increase
the
confidence
of
your
team
in
the
quality
of
the
release
run
pattern_1
be
not
a
sprint
pattern_1
be
a
popular
and
widely
adopt
requirement_13
best
practice
for
complex
project
they
offer
great
quality_attribute_11
for
build
and
quality_attribute_7
they
also
help
identify
and
formalize
the
requirement_2
component_14
of
your
component_10
which
come
in
handy
when
you
have
several
team
work
on
the
same
component_12
but
there
be
also
some
clear
drawback
to
manage
quality_attribute_3
component_10
and
split
a
monolithic
architecture
should
only
be
do
when
there
s
a
clear
understand
of
the
component_2
boundary
build
pattern_1
should
be
see
a
a
journey
rather
than
the
immediate
goal
for
a
team
start
small
to
understand
the
technical
requirement
of
a
quality_attribute_3
component_10
how
to
fail
gracefully
and
quality_attribute_10
individual
component_20
then
you
can
gradually
extract
more
component_9
a
you
gain
experience
and
knowledge
the
migration
to
a
pattern_1
architecture
do
not
need
to
be
accomplish
in
one
holistic
effort
an
iterative
strategy
to
sequentially
migrate
small
component_14
to
pattern_1
be
a
quality_attribute_14
bet
identify
the
most
well
define
component_2
boundary
within
an
establish
monolith
component_12
and
iteratively
work
to
decouple
them
into
their
own
pattern_6
in
conclusion…
to
recap
pattern_1
be
a
strategy
that
be
beneficial
to
both
the
raw
technical
development
component_19
and
overall
requirement_2
organization
strategy
pattern_1
help
organize
team
into
unit
that
focus
on
develop
and
own
specific
requirement_2
this
granular
focus
improve
overall
requirement_2
connector_2
and
quality_attribute_15
there
be
tradeoff
for
the
benefit
of
pattern_1
it
be
important
that
component_2
boundary
be
clearly
define
before
migrate
to
a
pattern_6
architecture
while
a
pattern_6
architecture
have
numerous
benefit
it
also
increase
complexity
atlassian
develop
compass
to
help
requirement_14
manage
the
complexity
of
quality_attribute_3
architecture
a
they
quality_attribute_10
it’s
an
quality_attribute_16
developer
experience
component_6
that
bring
disconnect
connector_data_9
about
all
of
the
engineering
output
and
team
collaboration
together
in
a
central
searchable
location
more
about
compass
sten
pittet
i
ve
be
in
the
requirement_2
for
year
now
in
various
role
from
development
to
technology_2
requirement_1
after
spend
the
last
year
in
atlassian
work
on
developer
technology_5
i
now
connector_21
about
build
outside
of
work
i
m
sharpen
my
father
skill
with
a
wonderful
toddler
connector_6
this
next
topic
quality_attribute_3
architecture
recommend
connector_22
bookmark
these
resource
to
about
type
of
devops
team
or
for
ongoing
connector_data_10
about
devops
at
atlassian
compass
more
create
a
component_20
more
connector_4
start
with
compass
for
free
more
sign
up
for
our
devops
newsletter
connector_23
thank
you
for
sign
up
technology_2
jira
jira
align
jira
component_2
requirement_1
confluence
trello
bitbucket
pattern_2
all
technology_2
resource
technical
support
purchasing
&
license
atlassian
knowledge
base
marketplace
my
account
create
support
ticket
expand
&
partner
train
&
certification
documentation
developer
resource
requirement_3
component_9
pattern_2
all
resource
about
atlassian
requirement_14
career
investor
relation
trust
&
quality_attribute_1
u
technology_1
choose
your
technology_1
deutsch
english
español
français
italiano
한국어
magyar
nederland
日本語
polski
português
русский
中文
privacy
requirement_7
term
impressum
copyright
©
atlassian
