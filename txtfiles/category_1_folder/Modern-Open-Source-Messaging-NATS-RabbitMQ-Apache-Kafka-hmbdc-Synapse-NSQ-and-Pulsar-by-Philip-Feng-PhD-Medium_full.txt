modern
open_source
connector_data_1
nats
technology_1
technology_2
technology_3
hmbdc
synapse
nsq
and
technology_4
|
by
philip
feng
ph
technology_5
|
mediumget
unlimited
accessopen
in
apphomenotificationslistsstorieswritephilip
feng
ph
dfollowdec

2018·9
min
readmodern
open_source
connector_data_1
nats
technology_1
technology_2
technology_3
hmbdc
synapse
nsq
and
pulsar#
nats
technology_6
then
gohttps
nats
io
technology_7
technology_8
technology_9
nats
io
nats
connector_1
servernats
be
originally
build
with
technology_6
and
achieve
a
respectable
150k
connector_data_2
per
second
the
team
rewrite
it
in
go
and
now
you
can
do
an
absurd
8–11
million
connector_data_2
per
second
it
work
a
a
pattern_1
component_1
but
you
can
also
connector_2
synthetic
component_2
pro
slogan
always
on
and
quality_attribute_1
dial
toneconcise
designlow
cpu
consumingfast
ahigh
technology_10
connector_3
bushigh
availabilityhigh
scalabilitylight
weight
it’s
tiny
a
3mb
technology_11
image
once
deploymentcons
fire
and
forget
no
persistence
nats
doesn’t
do
persistent
connector_data_1
if
you’re
offline
you
don’t
connector_2
the
connector_data_1
no
transaction
no
enhance
delivery
modesno
requirement_1
queueingin
general
nats
and
technology_12
be
quality_attribute_2
suit
to
small
connector_data_2
well
below
1mb
in
which
quality_attribute_3
tend
to
be
sub
millisecond
up
to
four
nine
nats
be
not
technology_7
it’s
it
own
very
quality_attribute_4
text
base
technology_13
pattern_2

so
it
do
not
any
coding_keyword_1
to
the
connector_data_1
envelope
nats
doesn’t
have
pattern_3
sharding
or
total
order
with
nats
component_3
be
effectively
sharded
by
technology_14
if
a
technology_14
die
it
connector_data_2
be
lose
incoming
connector_data_2
to
the
live
technology_14
will
still
go
to
connector_4
pattern_4
and
pattern_4
be
expect
to
reconnect
to
the
pool
of
quality_attribute_1
technology_14
once
a
previously
dead
technology_14
rejoin
it
will
start
connector_5
connector_data_1
nats
in
this
requirement_2
replace
something
haproxy
a
quality_attribute_4
in
memory
pattern_5
of
connector_data_3
to
backends
component_4
of
nats
include
buzzfeed
tinder
stripe
rakutan
ericsson
htc
siemens
vmware
pivotal
ge
and
baidu
among
many
one
use
requirement_2
“we’re
use
nats
for
pattern_6
connector_3
connector_6
around
10k
connector_data_2
each
second
through
it
must
say
that
the
quality_attribute_5
be
great
even
with
large
connector_data_4
over
10mb
in
size
we’re
run
it
in
production
for
a
couple
of
week
now
and
haven’t
have
any
issue
the
coding_keyword_2
limitation
be
that
there
be
no
federation
and
massive
cluster
you
can
have
a
pretty
quality_attribute_6
cluster
but
each
technology_14
can
only
connector_7
once
which
be
limit
”#
technology_1
technology_1
be
a
pattern_7
component_1
that
follow
the
technology_15



definition
of
a
pattern_8
it
follow
a
technology_16
component_5
and
connector_7
pattern_9
where
you
have
the
option
to
component_5
the
connector_data_5
in
ram
on
disk
or
both
it
support
a
variety
of
connector_data_1
connector_8
paradigm
technology_1
can
be
quality_attribute_7
in
a
cluster
fashion
for
requirement_3
and
mirror
fashion
for
high
quality_attribute_8
component_6
listen
directly
on
component_2
but
pattern_10
only
about
“exchanges
”
these
exchange
be
connector_9
to
component_3
via
bind
which
specify
the
connector_8
paradigm
among
other
thing
technology_1
do
persist
connector_data_2
to
disk
technology_7
www
technology_1
technology_9
persistence
conf
htmlunlike
nats
it’s
a
more
traditional
connector_data_1
component_2
in
the
sense
that
it
support
bind
component_3
and
pattern_11
delivery
semantics
consequently
technology_1
be
a
more
“heavyweight”
pattern_12
solution
and
tend
to
pay
an
additional
premium
with
con
rabbitmq’s
high
quality_attribute_8
support
be
terrible
it’s
a
single
point
of
failure
no
matter
how
you
turn
it
because
it
cannot
merge
conflict
component_3
that
connector_data_6
from
a
split
brain
situation
component_7
can
happen
not
on
requirement_4
outage
but
also
in
high
load
situation
#
technology_3
scalawith
technology_3
you
can
do
both
real
time
and
pattern_13
component_8
technology_3
run
on
technology_17
technology_18
to
be
specific
ingest
ton
of
connector_data_5
connector_10
via
pattern_1
or
component_2
the
pattern_8
barely

anything
about
the
component_9
all
that’s
really
component_5
be
an
“offset”
requirement_5
that
specify
where
in
the
requirement_6
the
component_9
leave
off
unlike
many
requirement_7
pattern_8
that
assume
component_6
be
mostly
online
technology_3
can
successfully
persist
a
lot
of
connector_data_5
and
support
“replay”
scenario
the
architecture
be
fairly
unique
topic
be
arrange
in
component_7
for
parallelism
and
component_7
be
replicate
across
technology_14
for
high
quality_attribute_8
technology_3
be
use
by
unicorn
startup
iot
health
and
large
financial
organization
linkedin
fb
netflix
ge
bank
of
america
fannie
mae
chase
bank
and
so
on…
nats
be
a
very
small
infrastructure
compare
to
technology_3
technology_3
be
more
mature
compare
to
nats
and
perform
very
well
with
huge
connector_data_5
connector_1
nats
component_10
have
a
subset
of
the
feature
in
technology_3
a
it
be
focus
on
a
narrow
set
of
use
requirement_2
nats
have
be
design
for
scenario
where
high
requirement_3
and
low
quality_attribute_3
be
critical
but
lose
some
connector_data_5
be
fine
if
need
in
order
to
keep
up
with
connector_data_5
what
the
nats
documentation
describe
a
“fire
and
forget”
architecturally
that’s
because
nats
doesn’t
have
a
persistence
pattern_14
to
use
to
component_5
connector_data_5
durably
while
technology_3
do
have
a
persistence
pattern_14
use
storage
on
the
cluster
to
fully
guarantee
that
a
connector_data_1
won’t
be
lose
it
look
you
need
to
declare
the
component_2
a
quality_attribute_9
+
to
mark
your
connector_data_1
a
persistent
+
use
pattern_10
confirm
and
this
cost
several
hundred
of
millisecond
of
quality_attribute_3
the
only
component_2
or
pattern_15
component_11
that
be
relatively
quality_attribute_10
from
component_7
error
be
technology_3
technology_3
be
a
really
solid
piece
of
engineering
when
you
need
5–50
component_10
with
that
many
component_10
you
can
handle
million
of
connector_data_2
per
second
that
usually
enough
for
a
mid
size
requirement_8
technology_3
be
completely
unsuitable
for
pattern_2
for
several
reason
first
it
connector_data_5
component_12
shard
component_3
into
component_7
each
of
which
can
be
connector_11
by
a
single
component_9
assume
we
have
component_7

and

p1
be
empty
p2
have
a
ton
of
connector_data_1
you
will
now
have
one
component_9
c1
which
be
idle
while
c2
be
do
work
c1
can’t
take
any
of
c2’s
work
because
it
can
only
component_8
it
own
component_7
in
other
word
a
single
slow
component_9
can
block
a
significant
portion
of
the
component_2
technology_3
be
design
for
fast
or
at
least
evenly
performant
component_9
*
nats
vs
kafkanats
recently
join
cncf
which
component_13
project
technology_19
prometheus
etc
—
look
at
the
dominance
of
golang
here
technology_13
—
technology_3
be
binary
over
technology_20
a
oppose
to
nats
be
quality_attribute_4
text
also
over
technology_20
connector_data_1
pattern_9
—
both
support
pattern_16
and
component_2
but
nats
support
connector_data_7
connector_data_8
a
well
pattern_17
and
pattern_18
nats
have
a
concept
of
a
component_2
with
a
unique
name
of

and
all
the
pattern_4
hook
on
the
same
component_2
end
up
be
a
part
of
the
same
component_2
group
only
one
of
the
potentially
multiple
pattern_4
connector_12
the
connector_data_1
multiple
such
component_2
group
would
also
connector_13
the
same
set
of
connector_data_1
this
make
it
a
hybrid
pattern_16
one
to
many
and
component_2
point
to
point
the
same
thing
be
support
in
technology_3
via
component_9
group
which
can
connector_14
connector_data_5
from
one
or
more
topic
connector_1
component_8
—
nats
do
not
support
connector_1
component_8
a
a
first
feature
technology_3
do
with
technology_3
streamskafka
component_14
use
a
pattern_19
base
technique
in
order
to
extract
connector_data_2
a
oppose
to
nats
where
the
component_10
itself
connector_15
connector_data_2
to
component_14
maintain
an
interest
graph
internally
nats
can
act
pretty
sensitive
in
the
sense
that
it
have
the
ability
to
cut
off
component_6
who
be
not
keep
pace
with
the
rate
of
production
a
well
a
component_14
who
don’t
respond
to
pattern_20
connector_data_7
the
component_9
liveness
connector_16
be
connector_17
by
technology_3
a
well
this
be
do
initiate
from
the
component_15
itself
&
there
be
complex
situation
that
can
arise
due
to
this
e
g
when
you’re
in
a
connector_data_1
component_8
loop
and
don’t
pattern_19
there
be
a
bunch
of
configuration
parameter
knob
to
tune
this
behavior
on
the
component_15
side
delivery
semantic
—
nats
support
at
most
once
and
at
least
once
with
nats
connector_1
a
oppose
to
technology_3
which
also
support
exactly
once
tough
nats
doesn’t
seem
to
have
a
notion
of
partitioning
sharding
connector_data_2
technology_3
doesno
external
connector_18
in
requirement_2
of
nats
technology_3
require
zookeepernats
connector_19
seem
to
be
similar
to
technology_3
feature
set
but
build
use
go
and
look
to
be
easy
to
set
up
nats
do
not
support
pattern_3
or
really
any
high
quality_attribute_8
setting
currently
which
be
a
major
miss
feature
when
compare
it
to
technology_3
#
hmbdc
c++https
bitbucket

hmbd
hmbdc
rel
overview
technology_7
www
hummingbirdcode
net
design
technology_7
bitbucket

hmbd
hmbdc
rel
wiki
home
requirement_3
technology_7
www
hummingbirdcode
net
p

component_16
htmltake

byte
connector_data_2
for
example
well
over
100m
connector_data_2
per
second
on
a
local
component_17
inter
component_18
or
pattern_21
and
more
than
6m
connector_data_2
per
second
over
gigabit
requirement_4
technology_7
bitbucket

hmbd
hmbdc
rel
src
default
perf
sample
txt
fileviewer=file
pattern_22
defaulthmbdc
be
not
widely
use
across
the
requirement_9
not
a
use
hmbdc
can
be
find
through
the
internet

#
synapse
c++http
open
syn3
nl
syn3
trac
default
wiki
project
synapseby
connector_20
technology_7
technology_8
technology_9
psy0rz
synapse
i
doubt
this
project
be
out
of
date

year
ago
#
nsq
golanghttp
nsq
io
easy
to
setupnsq
seem
more
quality_attribute_11
and
it
support
connector_data_1
persistence
and
also
provide
nats

ephemeral
pattern_23
for
when
persistence
be
not
a
hard
requirement
and
it
come
with
a
technology_21
admin
requirement_10
which
nats
lack
nats
be
useful
when
raw
requirement_3
be
a
priority
both
nats
and
nsq
component_3
support
for
per
connector_data_1
ttl
for
pruning
time
sensitive
connector_data_1
technology_3
be
complicate
but
guarantee
no
lose
connector_data_5
quality_attribute_2
for
order
requirement_6
nsq
lack
quality_attribute_12
and
pattern_3
it
be
incredibly
quality_attribute_4
to
operate
at
quality_attribute_13
kafka’s
requirement_3
and

guarantee
come
at
the
expense
of
be
hard
to
operate
with
technology_3
you
need
a
technology_22
cluster
in
addition
to
your
technology_3
pattern_8
technology_3
need
to
think
about
component_7
and
offset
it
s
quality_attribute_2
to
think
of
technology_3
a
a
quality_attribute_14
requirement_6
component_19
than
a
pattern_7
pattern_8
the
connector_21
ahead
requirement_6
in
a
component_20
and
not
printf
statement
nsq
be
a
much
more
traditional
buffer
pattern_7
component_11
it
have
quality_attribute_12
but
only
a
a
an
optimization
to
prevent
connector_data_1
loss
once
memory
run
out
and
b
a
a
component_9
archive
but
a
hard
loss
of
a
technology_14
mean
that
those
connector_data_2
that
have
not
be
connector_22
can
be
lose
a
there
be
no
promise
they
be
publish
somewhere
else
further
there
be
no
promise
that
the
order
of
connector_data_2
publish
to
a
topic
and
pattern_23
be
the
order
of
connector_data_2
connector_23
by
the
component_9
with
nsq
there
be
a
build
in
utility
nsq_to_file
which
become
one
additional
component_9
you’d
use
to
archive
each
connector_data_1
topic
to
disk
it
provide
dead
quality_attribute_4
archive
of
connector_data_1
but
doesn’t
provide
any
requirement_11
replay
ability
#
technology_2
technology_4
technology_4
incubator
technology_2

javait
be
design
at
yahoo
a
a
high
requirement_3
low
quality_attribute_3
quality_attribute_15
quality_attribute_9
solution
for
both
pattern_16
pattern_7
and
connector_data_1
component_2
technology_2
technology_4
combine
high
requirement_3
connector_19
which
technology_2
technology_3
pursue
and
quality_attribute_11
traditional
pattern_12
which
technology_1
pursue
into
a
unify
pattern_7
component_12
and
technology_23
technology_4
give
you
one
component_11
for
both
connector_19
and
component_2
with
the
same
high
requirement_3
use
a
unify
technology_23
to
sum
up
technology_3
aim
for
high
quality_attribute_16
technology_4
for
low
quality_attribute_3
technology_4
—
prosfeature
rich
—
persistent
nonpersistent
topic
multitenancy
acls
multi
dc
pattern_3
etc
more
quality_attribute_11
component_15
component_21
that
be
easy
to
use
—
include
completablefutures
fluent
etc
technology_24
component_15
component_22
be
component_18
quality_attribute_10
—
a
component_9
can
acknowledge
connector_data_2
from
different
component_18
technology_24
component_15
have
javadoc
technology_7
technology_4
technology_2

technology_23
component_15

—

stackoverflow
question
currently
and
technology_7
technology_4
technology_2

powered
by
technology_4
—
consmessageid
concept
tie
to
bookkeeper
—
component_6
cannot
easily
position
itself
on
the
topic
compare
to
technology_3
offset
which
be
a
continuous
sequence
of
number
a
reader
cannot
easily
connector_24
the
last
connector_data_1
on
the
topic
—
need
to
skim
through
all
the
connector_data_2
to
the
end
note
on

it
can
position
a
reader
on
the
late
connector_data_1
no
transaction

transaction
support
be
plan
for


release
high
operational
complexity
—
technology_22
+
pattern_8
technology_14
+
bookkeeper
—
all
clusteredlatency
questionable
—
there
be
one
extra
remote
connector_data_9
between
pattern_8
technology_14
and
bookkeeper
compare
to
technology_3
so
we
can
run
pattern_8
and
bookkeeper
in
the
same
technology_14
if
require
technology_3
—
prosmature
very
rich
and
useful
javadockafka
streamsmature
&
broad
communitysimpler
to
operate
in
production
—
le
component_22
—
pattern_8
technology_14
provide
also
storagetransactions
—
atomic
reads&writes
within
the
topicsoffsets
form
a
continuous
sequence
—
component_9
can
easily
seek
to
last
messagekafka
—
consconsumer
cannot
acknowledge
connector_data_1
from
a
different
threadno
multitenancyno
quality_attribute_6
multi
dc
pattern_3
—
offer
in
confluent
requirement_1
requirement_12
in
a
requirement_13
environment
be
difficult
#
reference

a
high
requirement_3
technology_25

pattern_7
lib
for
quality_attribute_3
sensitive
development
cpp
technology_7
www
reddit
technology_9
r
cpp

894y48
a_high_performance_c_14_messaging_lib_for_latency
modern
open_source
connector_data_1
technology_2
technology_3
technology_1
and
nats
in
action
—
richard
seroter’s
architecture
musing
technology_7
seroter
technology_26
technology_9



modern
open
component_23
connector_data_1
technology_2
technology_3
technology_1
and
nats
in
action
the
open_source
pattern_7
landscape
technology_7
www
slideshare
net
rseroter
the
open
component_23
connector_data_1
landscape
be
nats
io
a
real
alternative
to
technology_3
who
use
it
in
a
production
—
quora
technology_7
www
quora
technology_9
be
nats
io
a
real
alternative
to
technology_3
who
use
it
in
a
production
technology_1
vs
technology_3
vs
nsq

comparison
of
connector_data_1
component_2
|
stackshare
quality_attribute_2
side
by
side
comparisonhttps
stackshare
io
stackups
technology_3
vs
nsq
vs
technology_1
technology_3
vs
nsq

comparison
of
connector_data_1
component_2
|
stackshare
technology_7
stackshare
io
stackups
technology_3
vs
nsq
a
someone
who
have
use
technology_1
in
production
for
many
year
you
should
rather…
|
hacker
news
technology_7
news
ycombinator
technology_9
item
id=11284489
jepsen
technology_1
technology_7
aphyr
technology_9
coding_keyword_3

jepsen
technology_1
nats
&
technology_3
random
note
|
simply
quality_attribute_14
goodhttps
simplydistributed
technology_26
technology_9



technology_3
nats
random
note
technology_2
technology_4
outperform
technology_2
technology_3
by

5x
on
openmessaging
benchmark
|
requirement_14
wire
technology_7
www
businesswire
technology_9
news
home

en
technology_2
technology_4
outperform
technology_2
technology_3

5x
openmessaging
what
be
the
advantage
and
disadvantage
of
technology_3
over
technology_2
technology_4
—
technology_27
overflow
technology_7
stackoverflow
technology_9
question

what
be
the
advantage
and
disadvantage
of
technology_3
over
technology_2
technology_4
compare
technology_4
and
technology_3
unify
pattern_12
and
connector_1
goodhttps
streaml
io

technology_4
connector_1
component_2
technology_2
technology_4
be
it
a
technology_3
killer
—
bhagwan
s
soni
—

technology_7

technology_9
@bhagwanssoni
technology_2
technology_4
be
it
a
technology_3
killer
a7538afedd0b#
quality_attribute_2
benchmarking
report
benchmarking
connector_data_1
component_2
quality_attribute_3
—
brave
geek
technology_7
bravenewgeek
technology_9
benchmarking
connector_data_1
component_2
quality_attribute_3
benchmarking
nats
connector_19
and
technology_2
technology_3
—
requirement_3
technology_7

technology_9

benchmarking
nats
connector_1
and
technology_2
technology_3

11more
from
philip
feng
ph
dfollowstaff
requirement_15
engineer
at
walmart
inc
tech
lead
at
iowa
state
university
smart
home
lablove
podcast
or
audiobooks
on
the
go
with
our
component_24
try
knowablerecommended
from
mediumanna
olinternet
technology_13
technology_27
in
internet
technology_13
suite
technology_20
ip
ankurinmailgemsgetting
start
on
mailgemsdaniel
kirschnerindanonrockstartechnical
debt
and
the
idea
of
build
creditniyozbek
obidovamazon
experienceedgecastoptimizing
the
cdn
for
live
streamingmanish
sombanshbuilding
an
uber
cab
serviceroy
godsendif
your
component_1
break
up
what
should
you
do
to
prevent
it
timothy
huanginthe
startupdynamic
programming
—
minimum
cost
to
reach
the
endabouthelptermsprivacyget
the
appget
startedphilip
feng
ph
d124
followersstaff
requirement_15
engineer
at
walmart
inc
tech
lead
at
iowa
state
university
smart
home
labfollowmore
from
mediumsanil
khuranaingeek
culturereplication
in
component_20
with
technology_12
architecture
for
horizontally
quality_attribute_17
databasesdeepti
mittalredis
cluster
vs
sentinel
quality_attribute_18
vs
costmohammed
ragabinnerd
for
techmake
a
real
time
query
across
multiple
pattern_24
use
kafkadenny
lesmanawhat
be
component_20
pattern_25
helpstatuswritersblogcareersprivacytermsaboutknowable
