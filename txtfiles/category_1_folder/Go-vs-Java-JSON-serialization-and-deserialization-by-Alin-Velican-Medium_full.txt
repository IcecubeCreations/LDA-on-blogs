go
vs
technology_1
—
technology_2
serialization
and
deserialization
|
by
alin
velican
|
mediumget
unlimited
accessopen
in
apphomenotificationslistsstorieswritealin
velicanfollowdec

2019·4
min
readgo
vs
technology_1
—
technology_2
serialization
and
deserializationi
there
be
no
connector_1
between
go
technology_1
and
cat
but
who
doesn’t
cat
photo
by
raul
varzar
on
unsplashwhen
somebody
want
to
develop
a
web
component_1
no
matter
what
that
component_1
will
do
for
sure
there
will
be
a
pattern_1
where
you
will
need
to
deal
with
technology_2
serialization
and
deserialization
no
matter
what
your
requirement_1
requirement
be
you
for
sure
will
need
to
connector_2
some
connector_data_1
understand
it
do
your
magic
and
after
that
connector_3
back
for
this
you
need
to
deserialize
apply
your
requirement_1
rule
serialize
and
connector_3
back
so
for
most
of
the
time
your
component_1
will
do
this
work
even
if
you
don’t
really
see
it
because
every
technology_3
or
technology_4
try
to
hide
this
from
you
what
be
we
go
to
do
for
this
test
we
be
go
to
test
this
small
part
of
a
web
component_1
so
we
will
connector_4
some
technology_5
deserialize
it
and
serialize
it
there
will
be
no
connector_4
from
to
not
involve
any
other
move
part
technology_2
part
we
will
kiss
unexpected
resultswhen
i
start
this
test
i
admit
that
i
start
to
see
how
quality_attribute_1
go
will
do
and
how
poor
technology_1
be
but
when
i
actually
run
the

i
be
shock
not
really
shock
but
surprise
for
sure
so
let’s
see
what
happend
technology_1
codei
start
with
technology_1
deserialization
i
have
a
quality_attribute_2
technology_1
with
few
and
the
where
deserialization
happen
for
this
i
use
technology_6
technology_7
and
connector_data_2

096s
for

iterationsgo
codei
have
a
similar
go
struct
and
funcand
connector_data_3
for
go

607s
for

same
a
for
technology_1
iteration
again
unexpected
connector_data_2
seem
that
go
technology_8
technology_7
for
technology_2
be
about

time
slow
than
technology_6
technology_7
in
technology_1
serialization
testfor
technology_1
i
have
the
follow
codeand
connector_data_2

582s
for

iterationsfor
go
and
connector_data_3

428s
for

iteration
there
be
still
a
big
difference
between
technology_1
and
go
but
go
seem
to
be
recover
easyjsonintrigued
by
the
fact
that
my
expectation
be
unmet
i
start
to
find
out
what
can
be
improve
with
go
after
all
go
it
be
a
compile
technology_3
and
at
least
in
theory
should
be
fast
in
fact
it
be
a

problem
with
the
poor
requirement_2
of
go
technology_8
technology_5
technology_7
the
problem
be
that
encoding
technology_5
technology_7
use
reflexion
and
because
of
this
we
have
this
problem
i
find
out
that
there
be
actually
a
lot
of
3rd
party
technology_7
which
deal
with
technology_5
in
go
and
one
of
the
best

be
easyjson
because
this
one
use
no
pattern_2
we
need
to
work
with
generate

for
a
detail
for
easyjson
you
can
take
a
look
here
technology_9
technology_10
technology_11
mailru
easyjson
after
i
install
and
generate
the

the
only
one
modification
be
to
connector_5
technology_5
marshal
with
easyjson
marshal
or
unmarshal

connector_data_2
for
serialization
now
i
connector_6

513s
while
with
technology_8
technology_7
i
connector_6

428s
this
connector_data_2
be
similar
with
technology_1
one
where
i
connector_6

582s
for
deserialization
with
easyjson
i
connector_6

354s
while
with
technology_8
technology_7
i
connector_6

607s
still
weak
than
with
technology_1
where
for
same
thing
it
take

096s
but
technology_1
can
do
even
quality_attribute_1
if
you
use
jsoniter
with
dynamic
generation
for
more
detail
take
a
look
here
technology_9
jsoniter
technology_11
technology_1
feature
technology_12
the
point
be
that
you
need
to
have
all
and
you
have
to
use
javassist
this
be
the
codeand
connector_data_3

750s
about

time
fast
than
easyjson
go
version
final
wordseven
though
from
that
test
an
extreme
one
actually
because



iteration
for
same
thing
it
be
not
a
real
world
use
requirement_3
for
example
if
i
run
the
test
for


go
version
be
twice
fast
and
for
small
number
of
iteration
go
version
be
even
fast
this
be
happen
probably
because
of
technology_13
pattern_3
start
up
the
reason
for
technology_1
connector_7
so
fast
after
a
huge
number
of
repetition
be
because
of
it
magic
jit
optimisation
of
we
have
to
look
also
in
the
memory
consumption
for
technology_1
we
have
830mb
of
ram
while
work
and

component_2
and
for
go
we
have
only

7mbin
term
of
requirement_2
this
be
also
very
important
number
and
even
maybe
go
for
this
specific
connector_data_4
be

time
slow
it
take

time
lower
memory
if
you
want
to
see
more
comparison
between
technology_1
and
go
take
a
look
in
my
others
story
go
vs
technology_1
connector_4
from
and
count
word
use
a
connector_data_5

comgo
vs
technology_14
vs
technology_15
vs
technology_15
webfluxcomparing
the
with
the
old

technology_11
more
from
alin
velicanfollowlove
podcast
or
audiobooks
on
the
go
with
our
component_3
try
knowablerecommended
from
mediumimron
eedkerdgetting
start
with
the
unity
sdkanisha
chughdigitally
sign
a
document
use
technology_16
dev
colorinthe
compilerreal
talk
with
alan
johnsonnightaim
journey
⛰️
week
5nipun
kaveendraeverything
be
an
connector_data_6
fatos
morinahow
to
connector_5
the
default
line
delimiter
in
rubytechnologies
in
requirement_4

0indatadriveninvestorhow
to
work
with
technology_17
shubham
jaroliintech@iiit
gwaliorgo
the
programming
technology_3
of
futureabouthelptermsprivacyget
the
appget
startedalin
velican65
followersfollowmore
from
mediuma
byte
of
codinga
byte
of
cod
issue
#208ruby
valappilincodexhow
to
connector_6
start
with
golang
a
a
technology_1
developergene
zeinissingeek
culturethe
three
little
technology_18
in
go
languagejayadev
rajanget
set
go
lang
a
a
technology_1
prohelpstatuswritersblogcareersprivacytermsaboutknowable
