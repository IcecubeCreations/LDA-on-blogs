quality_attribute_1
connector_1
component_1
technology_1
–
what
they
be
and
how
they
perform
|
component_2
science
skip
to
content
component_2
science
on
component_2
science
and

topic
homeprivacy
requirement_1
project
component_3
engineering
bibliography
impressum
quality_attribute_1
connector_1
component_1
technology_1
–
what
they
be
and
how
they
perform



~
alexander
merker
this
aim
to
provide
an
overview
about
the
topic
of
connector_1
component_1
and
it
capabilites
in
a
large
quality_attribute_2
environment
the
start
with
an
introduction
to
connector_1
component_1
after
that
it
explain
how
connector_1
component_1
work
and
show
different
area
of
component_4
a
well
a
some
common
connector_1
component_1
technology_1
finally
this
will
provide
a
requirement_2
comparison
of
several
common
technology_1
base
on
benchmarking
connector_data_1
let’s
begin
with
an
introduction
to
connector_1
component_1
quality_attribute_1
connector_1
component_1
component_5
be
gain
popularity
over
the
last
year
connector_1
component_1
be
a
technology_2
that
can
query
continous
connector_2
of
connector_data_1
in
real
time
and
perform
on
the
connector_3
connector_data_1
it
also
go
by
the
name

component_1
complex
component_1
real
time
requirement_3
or
connector_1
requirement_3
it
allow
to
component_1
connector_data_1
in
real
time
a
soon
a
it
arrive
in
the
component_3
and
can
be
use
to
quickly
detect
condition
in
the
connector_3
connector_data_1
a
an
example
imagine
a
pattern_1
sensor
that
continously
connector_4
the
pattern_1
level
once
a
certain
pattern_1
level
be
reach
the
component_3
can
connector_5
an
alert
base
on
the
connector_3
connector_data_1

at
a
more
technical
level
the
connector_1
component_1
component_5
component_1
connector_data_1
in
a
pipeline

connector_data_2
connector_data_1
connector_6
component_1
in
term
of
a
direct
acyclic
graph
see
below
the
component_1
can
chain
various
together
but
never
go
back
to
an
early
point
in
the
graph
quality_attribute_3
on
the
component_1
connector_data_1
step
in
the
chain
can
be
skip
direct
acyclic
graph
component_6

the
quality_attribute_4
technology_1
approach
this
differently
some
technology_1
the
developer
define
the
graph
explicitly
thus
the
cod
be
at
a
much
lower
level
in
these
technology_1
technology_3
technology_4
or
technology_3
samza
the
developer
have
full
control
over
the
but
it
be
possible
to
connector_7
inefficient

in
other
technology_1
technology_3
flink
or
technology_3
technology_5
the
developer
can
simply
chain
together
and
the
technology_1
construct
the
graph
thus
the
be
shape
in
a
very
functional
style
a
show
in
the
example
snippet
below
the
snippet
show
a
quality_attribute_5
component_4
that
count
word
from
an
incoming
connector_1
for
five
second

technology_3
flink
word
count
example

component_6

on
the
contrary
there
be
the
“classic”
approach
of
pattern_2
component_1
component_1
happen
on
block
of
connector_data_1
that
have
be
connector_8
and
component_7
over
a
period
of
time
quality_attribute_3
on
the
size
of
the
component_4
this
can
be
a
huge
amount
of
connector_data_1
with
possibly
million
of
component_8

so
why
use
connector_1
component_1
instead
of
component_1
the
connector_data_1
in
pattern_2
and
when
some
connector_data_1
that
have
to
be
component_1
inside
an
component_4
naturally
come
a
a
never
ending
connector_1
of
connector_data_1
for
example
healthcare
sensor
connector_data_1
traffic
sensor
connector_data_1
or
almost
all
iot
component_9
produce
continously
these
type
of
connector_data_1
be
time
series
connector_data_1
for
which
the
time
of
arrival
or
the
time
at
which
the
occur
be
important
connector_1
component_1
technology_1
naturally
fit
this
component_10
of
time
series
connector_data_1
detecting
pattern_3
and
anomaly
within
connector_data_1
connector_2
become
easy
additionally
you
can
inspect
multiple
connector_data_1
connector_2
at
once

component_1
constantly
arrive
connector_9
connector_data_1
in
pattern_2
would
require
to
stop
connector_data_1
collection
at
some
point
component_7
the
connector_data_1
and
then
component_1
it
then
you’ll
have
to
worry
about
aggregation
across
multiple
pattern_2
so
use
a
technology_1
that
fit
this
component_10
make
perfect
sense

now
let’s
look
at
some
example
usecases
where
connector_9
can
be
use
beneficially
pattern_4
component_11
an
pattern_4
component_4
connector_10
from
possibly
multiple
component_12
and
perform
on
these

instead
of
connector_11
connector_data_1
to
a
pattern_5
component_13
the
connector_data_1
and
state
of
the
component_4
be
keep
on
the
local
component_3
by
keep
the
connector_data_1
on
the
local
component_3
the
requirement_2
quality_attribute_6
and
quality_attribute_7
of
the
component_4
be
improve
and
possible
requirement_4
failure
will
be
avoid
the
component_4
connector_12
checkpoint
periodically
for
fault
tolerance
but
this
can
happen
asynchronously
and
do
not
impact
requirement_2
example
for
pattern_4
component_11
can
be
fraud
detection
anomaly
detection
or
rule
base
alerting

the
follow
image
take
from
technology_3
flink
illustrate
how
the
architecture
of
an
pattern_4
component_4
be
pattern_6
technology_3
flink
will
be
describe
late
in
this

architecture
of
an
pattern_4
component_4
component_6

connector_data_1
requirement_3
component_11
a
connector_data_1
requirement_3
component_4
extract
insight
from
raw
connector_data_1
while
this
can
also
be
do
with
pattern_2
component_1
it
be
a
quality_attribute_8
usecase
for
a
connector_9
component_4
the
advantage
of
use
a
connector_1
component_1
component_14
be
the
capability
of
use
real
time
connector_data_1
and
continously
produce
connector_data_3
the
connector_data_4
can
be
persist
to
an
external
storage
and
or
show
in
a
live
report
in
real
time
a
a
connector_data_3
of
use
connector_1
component_1
the
quality_attribute_6
of
component_1
connector_6
lower
example
for
connector_data_1
requirement_3
component_11
can
be
quality
pattern_7
of
telecommunication
requirement_4
or
analysis
of
technology_6
update

the
follow
image
show
two
architecture
of
connector_data_1
requirement_3
component_11
use
technology_3
flink
pattern_2
and
connector_9
requirement_3
architecture
in
comparison
component_6

now
that
we’ve
see
an
introduction
to
connector_1
component_1
a
well
a
some
usecases
let’s
look
at
what
connector_1
component_1
technology_1
exist
an
overview
about
quality_attribute_4
technology_1
the
history
of
connector_1
component_1
begin
with
technology_3
hadoop’s
pattern_2
component_1
component_14
and
late
shift
towards
connector_1
component_1
by
now
the
follow
popular
technology_1
have
implementation
for
connector_1
component_1
technology_3
technology_5
technology_3
technology_4
technology_3
flink
technology_3
samza
technology_3
technology_7
technology_3
technology_8
in
the
meantime
connector_1
component_1
be
also
make
quality_attribute_4
a
a
manage
component_15
for
example
kinesis
let’s
look
a
bit
more
into
detail
for
some
of
these
technology_1
the
will
briefly
introduce
some
of
the
most
popular
connector_9
technology_1
technology_3
flink
technology_3
flink
be
an
open
component_6
quality_attribute_1
connector_1
component_1
component_14
it
can
do
stateful
computation
over
bound
and
unbounded
connector_1
unbounded
connector_2
equal
connector_9
connector_data_1
that
arrive
endlessly
a
it
be
generate
the
order
of
arrival
be
important
to
reason
about
completeness
and
must
be
preserve
bound
connector_2
be
comparable
to
pattern_2
component_1
they
have
a
define
start
and
end
the
order
of
arrival
be
neglectable
because
the
finite
connector_data_1
can
always
be
sort
that
way
flink
can
component_1
both
input
connector_data_1
type
of
connector_9
connector_data_1
and
pattern_2
component_1
connector_data_1

bound
and
unbounded
connector_2
processable
by
technology_3
flink
component_6

in
flink
workload
be
parallelize
to
multiple
connector_13
connector_data_5
that
be
quality_attribute_1
and
run
concurrently
it
quality_attribute_9
with
cluster
technology_9
natively
and
can
even
be
setup
a
a
standalone
cluster

technology_3
technology_4
technology_3
technology_4
introduce
itself
a
an
open
component_6
realtime
computation
component_3
it
can
component_1
connector_2
of
unbounded
connector_data_1

technology_3
technology_4
have
three
abstraction
type
spout
bolt
and
topology
a
can
be
see
in
the
architecture
diagram
below
spout
be
the
component_12
of
connector_9
connector_data_1
for
the
further
connector_data_1
component_1
they
typically
connector_14
from
a
component_16
pattern_8
technology_7
but
can
also
generate
it
own
connector_1
bolt
component_1
an
input
connector_1
and
produce
any
number
of
output
connector_1
a
topology
unite
it
all
and
represent
a
requirement_4
of
spout
and
bolt
with
their
connector_15

technology_3
technology_4
typical
dataflow
architecture
component_6

technology_3
technology_5
technology_3
technology_5
have
a
connector_9
component_17
name
technology_5
connector_1
it
can
connector_16
connector_2
of
connector_data_1
by
component_12
technology_3
technology_7
it
enable
quality_attribute_10
fault
tolerant
component_1
of
connector_data_1
in
micro
pattern_2
that
mean
technology_5
divide
the
connector_9
connector_data_1
into
small
pattern_2
package
and
then
connector_12
the
connector_data_4
to
an
output
connector_1
of
pattern_2
you
can
then
make
use
of
the
powerful
other
component_18
of
technology_5
it
requirement_5
technology_10
and
apply
it
to
the
connector_data_3
connector_data_1

technology_3
technology_5
architecture
component_6

also
tak
a
look
into
this
which
provide
a
comparison
on
the
cod
perspective
it
show
how
a
quality_attribute_5
hello
word

connector_data_6
be
do
in
different
connector_1
component_1
technology_1
so
far
we’ve
connector_17
an
overview
about
several
technology_1
and
usecases
next
up
be
an
overview
about
which
criterion
matter
when
design
a
connector_1
component_1
component_14
the
important
factor
of
a
quality_attribute_1
connector_1
component_1
component_14
for
a
component_3
that
have
to
handle
and
component_1
a
continous
flow
of
incoming
connector_data_1
any
downtime
be
fatal
if
the
component_3
be
unavailable
or
have
requirement_2
issue
connector_data_1
might
be
lose
completely
that
be
because
unlike
a
pattern_2
component_1
component_3
connector_data_1
be
not
connector_18
component_7
before
component_1
but
be
rather
component_1
immediately
and
component_7
afterwards
therefore
there
be
a
number
of
factor
that
have
to
be
consider
when
analyze
a
connector_1
component_1
component_14


think
of
connector_1
component_1
in
a
quality_attribute_1
environment
the
follow
factor
come
into
mind
delivery
guarantee
no
matter
what
happen
the
incoming
dataset
or
component_8
will
be
component_1
even
in
the
of
a
component_3
requirement_4
or
component_4
failure
the
component_14
continue
to
component_1
connector_data_1
there
be
different
type
of
delivery
guarantee
namely
at
most
once
at
least
once
exactly
oncewhile
exactly
once
be
the
desire
state
it
be
really
hard
to
achieve
in
a
quality_attribute_1
component_3
tradeoff
for
requirement_2
will
have
to
be
make
to
ensure
delivery
guarantee
peformance
quality_attribute_6
and
quality_attribute_7
quality_attribute_6
should
be
a
low
a
possible
and
quality_attribute_7
a
high
a
possible
requirement_6
of
state
connector_19
state
connector_data_7
allow
on
multiple
connector_2
join
transformation
or
aggregation

however
additional
computational
power
be
need
to
keep
the
state
update
and
component_7
fault
tolerance
in
requirement_7
of
a
component_3
or
component_17
failure
the
component_3
should
be
able
to
recover
ideally
it
should
start
component_1
from
the
point
it
fail
this
can
be
achieve
by
periodically
connector_20
checkpoint
a
we
have
see
in
the
pattern_4
component_4
example
before
this
also
guarantee
that
all
connector_data_1
will
be
component_1
and
no
component_19
connector_17
lose
quality_attribute_11
the
component_3
should
be
able
to
deal
with
vary
workload
frequency
and
inconsistent
size
of
incoming
connector_data_1
windowing

allow
to
extract
a
subset
e
g
by
grouping
base
on
a
time
window
of
an
infinite
connector_data_1
connector_1
to
pattern_9
and
component_1
this
subset
separately
the
window
can
be
define
by
creation
or
component_1
time
maturity
of
the
technology_1
how
long
the
technology_1
have
be
in
use
and
how
big
the
be


a
a
last
step
u
take
a
detail
look
at
the
capability
of
exist
technology_1
and
connector_17
some
insight
about
how
they
quality_attribute_2
upon
a
huge
workload
a
benchmarking
comparison
the
follow
chapter
us
benchmarking
connector_data_1
out
of
two
different
component_12
to
provide
a
comparison
of
the
requirement_2
of
the
most
popular
technology_1
the
first
component_6
be
a
benchmarking
comparison
of
adobe
for
their
adobe
experience
component_20
the
adobe
experience
component_20
handle
more
than
200k
per
second
adobe
evaluate
exist
technology_1
for
connector_1
component_1
to
support
the
grow
need
for
real
time
component_1
and
grow
amount
of
connector_data_1
they
evaluate
requirement_2
and
quality_attribute_12
of
the
technology_1
storm
flink
samza
and
technology_5

the
second
component_6
be
a
benchmarking
publish
by
tu
berlin
this
benchmarking
measure
the
requirement_2
of
windowed
the
basic
of
connector_data_1
requirement_3
of
technology_1
technology_3
flink
technology_3
technology_4
and
technology_3
technology_5
the
tu
berlin
team
use
setup
with
multiple
technology_11
to
measure
quality_attribute_13
and
requirement_2
on
different
hardware
setup

the
two
benchmarkings
measure
mainly
quality_attribute_6
and
quality_attribute_7
of
connector_1
component_1
technology_1
the
adobe
benchmarking
also
compare
qualitative
criterion
while
the
tu
berlin
benchmarking
factor
in
skew
connector_data_1
and
fluctuate
workload
for
more
connector_data_7
on
the
benchmark
of
these
two
team
please
head
to
their

a
connector_data_8
in
the
reference
of
this

the
adobe
benchmarking
consist
of
multiple
‘load’
test
with
one
million
for
every
technology_1
and
then
a
three
day
quality_attribute_12
test
the
follow
component_21
be
the
requirement_2
measurement
connector_data_4
of
adobe
benchmarking
with
connector_data_1
from

the
connector_data_4
be
a
follow
quality_attribute_7
99th
component_1
latency*
quality_attribute_12
storm50

per
second

msno
crash
failuresflink600

per
second

msno
crash
failuresspark500

per
second6

secondscrashes
on
every
runsamza185

per
second54
msno
crash
error
requirement_8
raise
*a
99th
percentile
quality_attribute_6
of
x
m
mean
that
every

in

connector_data_9
experience
x
m
of
delay
the
tu
berlin
benchmarking
consist
of
multiple
experiment
for
windowed
join
and
windowed
aggregation
for
connector_1
the
component_22
show
below
illustrate
the
requirement_2
measurement
for
quality_attribute_7
and
quality_attribute_6
for
further
connector_data_7
please
refer
to
this
paper

tu
berlin
benchmarking
connector_data_1
component_6

connector_data_4
of
the
benchmarkings
the
benchmarking
conduct
by
adobe
come
to
the
follow
conclusion
technology_3
flink
be
the
best
technology_1
for
their
large
quality_attribute_2
component_1
neccesities
technology_3
flink
perform
best
in
term
of
quality_attribute_6
and
throughtput
and
prove
to
have
the
best
quality_attribute_12
and
do
not
crash
at
all
during
the
conduct
test
flink
have
an
excellent
ability
of
handle
backpressure
compare
to
other
test
technology_1
furthermore
flink
have
a
quality_attribute_8
which
will
be
useful
in
development
and
quality_attribute_14
of
their
component_4

the
follow
component_21
show
their
connector_data_4
for
qualitative
and
quantitative
benchmarking
adobe
benchmarking
connector_data_3
component_6

the
tu
berlin
benchmarking
show
that
each
test
technology_1
have
a
different
set
of
usecases
that
they
in
overall
technology_3
flink
have
the
best
quality_attribute_7
and
quality_attribute_6
for
different
setup
while
technology_3
technology_5
manage
skew
connector_data_1
and
bind
quality_attribute_6
quality_attribute_8
than
it
competitor
both
technology_5
and
flink
be
very
quality_attribute_15
to
fluctuate
connector_data_1

conclusion
in
this
we
have
connector_17
an
overview
about
how
connector_1
component_1
work
we
have
see
some
example
usecases
where
use
a
connector_1
component_1
component_14
be
beneficial
connector_1
component_1
be
a
great
technology_12
to
handle
unbound
connector_2
of
connector_data_1
that
have
to
be
component_1
with
minimal
quality_attribute_6
or
at
best
in
realtime
many
component_11
with
iot
component_9
or
sensor
technology_2
can
benefit
from
this
approach
however
not
all
type
of
component_11
fit
with
connector_1
component_1
we
connector_17
a
brief
introduction
to
several
popular
connector_1
component_1
technology_1
a
well
a
some
measurement
on
requirement_2
each
technology_1
have
it
own
usecase
in
either
requirement_2
or
additional
technology_10
e
g
requirement_5
technology_10
that
it
provide
reference

technology_13

technology_14
connector_1
component_1
what
be
connector_1
component_1
1eadfca11b97

technology_13
flink
technology_3

usecases
technology_15

technology_13

technology_14
adobetech
evaluate
connector_1
technology_1
for
large
quality_attribute_2

connector_1
7209938373c8

technology_13
ci
technology_3

project
flink
flink
doc
release


dev
datastream_api
technology_15

technology_13

scottlogic
technology_14



compare
connector_1
technology_1
pt1
technology_15

technology_13

technology_14
@chandanbaranwal
technology_5
connector_1
vs
flink
vs
storm
vs
technology_7
connector_1
vs
samza
choose
your
connector_1
component_1
91ea3f04675b

technology_13
developer

technology_14




connector_1
component_1
brief
overview

technology_13
www
redaktion
tu
berlin
de
fileadmin
fg131
publikation
paper
stream_benchmarks_icde18
crc
pdf

technology_13
flink
technology_3

flink
architecture
technology_15

technology_13
storm
technology_3

index
technology_15

technology_13
storm
technology_3

about
quality_attribute_5
technology_16
technology_15

technology_13
technology_5
technology_3

doc
late
connector_1
programming
guide
technology_15
relate

in
allgemein
ultra
large
quality_attribute_2
component_23
quality_attribute_1
connector_1
processingdistributed
systemsstream
component_1
navigation
previous
isolation
and
consistency
in
databasesnext
open_source
pattern_2
and
connector_1
component_1
realtime
analysis
of
requirement_9
search
for
recent

improve
your
storage
i
o
requirement_2
today
tla+
and
pluscal
appetizer
an
overview
of
large
quality_attribute_2
deep

webassembly
da
neue
technology_17
und
noch
mehr
slog
–
deterministische
datenbanksysteme
die
lösung
für
alle*
probleme
category
allgemein
dev4cloud
game
journal
club
project
rich

component_23
quality_attribute_16
component_23
component_3
architecture
component_3
engineering
ultra
large
quality_attribute_2
component_23
a
collection
of
buzzwordsai
alexa
skill
web
component_24
architecture
requirement_10
automation
technology_18
technology_18
lambda
bluemix
ci
pipeline
ci
cd
requirement_11
requirement_11
computing
container
continuous
requirement_12
deep

devops
quality_attribute_1
component_23
technology_17
technology_17
compose
git
gitlab
gitlab
ci
bluemix
internet
of
thing
technology_19
technology_9
linux
loadbalancing
requirement_5
pattern_10
pattern_7
technology_20
privacy
technology_21
raspberry
pi
quality_attribute_13
quality_attribute_16
component_23
quality_attribute_17
social

test
drive
development
uls
vulnerability
web
requirement_2
archive



















































meta
requirement_8
in
entry
fee

fee
technology_22

proudly
powered
by
technology_22
~
theme
penscratch
by
technology_22
technology_14
loading

you
must
be
requirement_8
in
to
a

we
use

to
ensure
that
we
give
you
the
best
experience
on
our

if
you
continue
to
use
this
we
will
assume
that
you
be
happy
with
it
ok
