the
top
twelve
requirement_1
pattern_1
for
technology_1
technology_2
refcardz
over

million
developer
have
join

requirement_2
in
join
search
{{node
title}}
{{node
type}}
·
{{
technology_3
urlsource
name
}}
·
by
download
{{node
downloads}}
{{totalresults}}
search
connector_data_1
refcardz
trend
report
webinars
zone
|
agile
requirement_3
requirement_4
requirement_5
component_1
devops
requirement_1
iot
technology_4
pattern_2
open_source
requirement_6
quality_attribute_1
web
dev
{{announcement
body}}{{announcement
title}}
refcardz
the
top
twelve
requirement_1
pattern_1
for
technology_1
technology_2
refcard
#047
the
top
twelve
requirement_1
pattern_1
for
technology_1
technology_2
connector_1
in
technology_4
or
technology_5
connector_data_2
connector_2
out
the

most
common
requirement_1
pattern_1
and
implementation
for
technology_1
technology_2
free
pdf
for
easy
reference
connector_3
by
claus
ibsen
senior
principal
engineer
component_2
of
content
►
about
requirement_7
requirement_1
pattern_1
►
about
technology_1
technology_2
►
essential
pattern_1
►
conclusion
section

about
requirement_7
requirement_1
pattern_1
requirement_1
be
a
hard
problem
to
help
deal
with
the
complexity
of
requirement_1
problem
the
requirement_7
requirement_1
pattern_1
eip
have
become
the
technology_6
way
to
describe
document
and
connector_1
complex
requirement_1
problem
hohpe
&
woolf
s
book
the
requirement_7
requirement_1
pattern_1
have
become
the
bible
in
the
requirement_1
space
essential
connector_4
for
any
requirement_1
professional
technology_1
technology_2
be
an
open_source
project
for
connector_5
the
eip
easily
in
a
few
line
of
technology_4
or
technology_5
connector_data_2
configuration
this
reference
card
the
first
in
a
two
card
series
guide
you
through
the
most
common
requirement_7
requirement_1
pattern_1
and
give
you
example
of
how
to
connector_1
them
either
in
technology_4
or
use
technology_5
technology_7
this
refcard
be
target
for
developer
and
requirement_7
architect
but
anyone
in
the
requirement_1
space
can
benefit
a
well
section

about
technology_1
technology_2
technology_1
technology_2
be
a
powerful
open_source
requirement_1
component_3
base
on
requirement_7
requirement_1
pattern_1
eip
with
powerful
component_4
requirement_1
technology_2
coding_keyword_1
you
connector_5
eip
connector_6
use
technology_2
intuitive
domain
specific
technology_8
dsl
base
on
technology_4
aka
fluent
builder
or
technology_7
technology_2
us
uri
for
resolution
so
it
very
easy
to
work
with
any
kind
of
transport
such
a
technology_9
rest
technology_10
web
component_5

technology_11
technology_12
mail
jbi
component_4
pojo
and
many
others
technology_2
also
provide
connector_data_3
technology_13
for
various
popular
technology_13
such
a
csv
edi
fix
hl7
technology_14
technology_15
xstream
technology_2
be
an
requirement_1
component_6
that
can
be
embed
in
any
component_7
of
choice
such
a
j2ee
component_7
technology_16
technology_17
technology_18
or
a
standalone
technology_2
component_4
requirement_1
coding_keyword_1
you
define
loose
couple
allow
you
to
fully
separate
your
requirement_8
component_8
from
the
requirement_1
component_8
technology_2
be
base
on
a
modular
architecture
allow
you
to
plugin
your
own
component_9
or
connector_data_3
technology_13
so
they
seamlessly
blend
in
with
exist

technology_2
provide
a
test
technology_19
for
unit
and
requirement_1
test
with
strong
mock
and
assertion
capability
section

essential
pattern_1
this
group
consist
of
the
most
essential
pattern_1
that
anyone
work
with
requirement_1
must

pip
and
pattern_3
how
can
we
perform
complex
component_10
on
a
connector_data_4
while
maintain
independence
and
quality_attribute_2
problem
a
single
often
connector_7
a
sequence
of
component_10
step
solution
use
pip
and
pattern_3
to
divide
a
large
component_10
step
pattern_3
that
be
connector_8
by
pattern_4
pip
technology_2
technology_2
support
pip
and
pattern_3
use
the
pipeline
technology_3
technology_4
dsl
from
technology_10
component_11
order
in
pipeline
direct
transformorder
direct
validateorder
technology_10
component_11
order
component_10
where
technology_10
represent
the
technology_20
component_9
use
for
connector_9
technology_20
connector_data_5
on
the
technology_20
pattern_5
direct
be
use
for
combine
in
a
pattern_6
fashion
allow
you
to
divide
connector_10
into
sub
connector_10
and
or
quality_attribute_3
common
connector_10
tip
pipeline
be
the
default
mode
of
when
you
specify
multiple
output
so
it
can
be
omit
and
replace
with
the
more
common
technology_3
from
technology_10
component_11
order
in
to
direct
transformorder
direct
validateorder
technology_10
component_11
order
component_10
tip
you
can
also
separate
each
step
a
individual
to
technology_3
from
technology_10
component_11
order
in
to
direct
transformorder
to
direct
validateorder
to
technology_10
component_11
order
component_10
technology_5
dsl
connector_11
from
uri=
technology_10
component_11
order
in
pipeline
to
uri=
direct
transformorder
to
uri=
direct
validateorder
to
uri=
technology_10
component_11
order
component_10
pipeline
connector_11
connector_11
from
uri=
technology_10
component_11
order
in
to
uri=
direct
transformorder
to
uri=
direct
validateorder
to
uri=
technology_10
component_11
order
component_10
connector_11
connector_data_4
pattern_7
how
can
you
deouple
indevidual
component_10
step
so
that
connector_data_5
can
be
pass
to
different
pattern_3
quality_attribute_4
on
a
set
of
condition
problem
pip
and
pattern_3
connector_11
each
connector_data_4
in
the
same
component_10
step
how
can
we
connector_11
connector_data_5
differently
solution
pattern_3
use
predicate
to
choose
the
right
output
destination
technology_2
technology_2
support
connector_data_4
pattern_7
use
the
choice
technology_3
for
more
detail
see
the
content
base
pattern_7
pattern_1
content
base
pattern_7
how
do
we
handle
a
situation
where
the
implementation
of
a
single
logical
e
g
inventory
connector_2
be
spread
across
multiple
physical
component_12
problem
how
do
we
ensure
a
connector_data_4
be
connector_12
to
the
correct
recipient
base
on
connector_data_6
from
it
content
solution
use
a
content
base
pattern_7
to
connector_11
each
connector_data_4
to
the
correct
recipient
base
on
the
connector_data_4
content
technology_2
technology_2
have
extensive
support
for
content
base
connector_10
technology_2
support
content
base
connector_6
base
on
choice
pattern_3
or
any
other
expression
technology_4
dsl
choice
from
technology_10
component_11
order
choice
when
coding_keyword_2
type
in
widget
wiggy
to
technology_10
component_11
order
widget
when
coding_keyword_2
type
isequalto
gadget
to
technology_10
component_11
order
gadget
otherwise
to
technology_10
component_11
order
misc
end
tip
in
the
connector_11
above
end
can
be
omit
a
it
the
last
technology_3
and
we
do
not
connector_11
the
connector_data_4
to
a
destination
after
the
choice
tip
you
can
continue
connector_6
after
the
choice
end
technology_5
dsl
choice
connector_11
from
uri=
technology_10
component_11
order
choice
when
quality_attribute_5
${header
type}
in
widget
wiggy
quality_attribute_5
to
uri=
technology_10
component_11
order
widget
when
when
quality_attribute_5
${header
type}
==
gadget
quality_attribute_5
to
uri=
technology_10
component_11
order
gadget
when
otherwise
to
uri=
technology_10
component_11
order
misc
otherwise
choice
connector_11
tip
in
technology_5
dsl
you
cannot
invoke

a
oppose
to
the
technology_4
dsl
that
be
100%
technology_4
to
express
the
predicate
for
the
choice
we
need
to
use
a
technology_8
we
will
use
quality_attribute_5
technology_8
that
us
a
quality_attribute_5
expression
requirement_9
that
support
a
limit
set
of
operator
you
can
use
any
of
the
more
powerful
technology_8
support
in
technology_2
such
a
technology_21
technology_22
unify
technology_23
and
many
others
tip
you
can
also
use
a
connector_data_7
to
invoke
a
on
a
component_4
to
evaluate
the
predicate
coding_keyword_1
try
that
when

bean=
mybean
method=
isgadget
when
component_4
id=
mybean
class=
technology_24
mycomapany
mybean
coding_keyword_3
boolean
isgadget
@header
name
=
type
coding_keyword_4
type
{
coding_keyword_5
type
equal
gadget
}
notice
how
we
use
component_4
parameter
bind
to
instruct
technology_2
to
invoke
this
and
pass
in
the
type
coding_keyword_2
a
the
coding_keyword_4
parameter
this
allow
your
to
be
fully
decouple
from
any
technology_2
component_6
so
it
easy
to
connector_13
connector_3
and
unit
test
connector_data_4
pattern_8
how
can
component_13
use
different
connector_data_3
technology_13
connector_14
with
each
other
use
connector_data_4
problem
each
component_14
us
it
own
connector_data_3
technology_13
so
we
need
to
pattern_9
the
connector_data_4
into
the
connector_data_3
technology_13
the
component_14
support
solution
use
a
special
pattern_3
a
messae
pattern_8
between
pattern_3
or
component_15
to
pattern_9
one
connector_data_3
technology_13
into
another
technology_2
technology_2
support
the
connector_data_4
pattern_8
use
the
processor
component_4
or
transform
technology_3
tip
technology_2
connector_10
the
connector_data_4
a
a
chain
of
processor
technology_3
technology_4
dsl
processor
coding_keyword_3
ordertransformprocessor
connector_15
processor
{
coding_keyword_3
coding_keyword_6
component_10
exchange
exchange
throw
exception
{
do
connector_data_4
translation
here
}
}
from
direct
transformorder
component_10

ordertransformprocessor
beaninstead
of
the
processor
we
can
use
component_4
pojo
an
advantage
of
use
a
component_4
over
processor
be
the
fact
that
we
do
not
have
to
connector_1
or
use
any
technology_2
specific
or
type
this
allow
you
to
fully
decouple
your
component_16
from
technology_2
coding_keyword_3
ordertransformerbean
{
coding_keyword_3
stringtransformorder
coding_keyword_4
body
{
do
connector_data_4
translation
here
}
}
connector_data_8
transformer
=
ordertransformerbean
from
direct
transformorder
component_4
transformer
tip
technology_2
can
create
an
instance
of
the
component_4
automatically
you
can
refer
to
the
type
from
direct
transformorder
component_4
ordertransformerbean

tip
technology_2
will
try
to
figure
out
which
to
invoke
on
the
component_4
in
requirement_10
there
be
multiple

in
requirement_10
of
ambiguity
you
can
specify
which
to
invoke
by
the
parameter
from
direct
transformorder
component_4
ordertransformerbean

transformorder
transformtransform
be
a
particular
processor
allow
you
to
set
a
connector_16
to
be
coding_keyword_5
to
the
original
caller
we
use
transform
to
coding_keyword_5
a
constant
ack
connector_16
to
the
technology_12
component_17
after
we
have
copy
the
connector_data_4
to
the
technology_20
component_11
notice
we
use
a
constant
to
build
an
ack
coding_keyword_4
a
connector_16
from
mina
technology_12
localhost

textline=true
to
technology_10
component_11
order
in
transform
constant
ack
technology_5
dsl
processor
connector_11
from
uri=
direct
transformorder
component_10
ref=
transformer
connector_11
component_4
id=
transformer
class=
technology_24
mycompany
ordertransformprocessor
in
technology_5
dsl
technology_2
will
look
up
the
processor
or
pojo
component_4
in
the
registry
base
on
the
coding_keyword_7
of
the
component_4
component_4
connector_11
from
uri=
direct
transformorder
component_4
ref=
transformer
connector_11
component_4
id=
tramsformer
class=
technology_24
mycompany
ordertransformbean
transform
connector_11
from
uri=
mina
technology_12
localhost

textline=true
to
uri=
technology_10
component_11
order
in
transform
constant
ack
constant
transform
connector_11
annotation
dsl
you
can
also
use
the
@consume
annotation
for
transformation
for
example
in
the
below
we
connector_17
from
a
technology_20
component_11
and
do
the
transformation
in
regular
technology_4

notice
that
the
input
and
output
parameter
of
the
be
coding_keyword_4
technology_2
will
automatically
coerce
the
connector_data_9
to
the
expect
type
define
by
the

since
this
be
a
technology_20
example
the
connector_16
will
be
connector_12
back
to
the
technology_20
connector_data_10
to
destination
@consume
uri=
technology_10
component_11
order
transform
coding_keyword_3
coding_keyword_4
transformorder
coding_keyword_4
body
{
do
connector_data_4
translation
}
tip
you
can
use
component_4
parameter
bind
to
help
technology_2
coerce
the
connector_data_4
into
the
parameter
for
instance
you
can
use
@body
@headers
parameter
annotation
to
bind
parameter
to
the
body
and
coding_keyword_2
connector_data_4
pattern_3
how
can
a
component_9
avoid
connector_18
unwanted
connector_data_4
problem
how
do
you
discard
unwanted
connector_data_4
solution
use
a
special
kind
of
connector_data_4
pattern_7
a
connector_data_4
pattern_3
to
eliminate
undesired
connector_data_5
from
a
pattern_4
base
on
a
set
of
criterion
technology_2
technology_2
have
support
for
connector_data_4
pattern_3
use
the
pattern_3
technology_3
the
pattern_3
evaluate
a
predicate
whether
it
true
or
false
only
allow
the
true
condition
to
pass
the
pattern_3
where
a
the
false
condition
will
silently
be
ignore
technology_4
dsl
we
want
to
discard
any
test
connector_data_5
so
we
only
connector_11
non
test
connector_data_5
to
the
order
component_11
from
technology_10
component_11
inbox
pattern_3
coding_keyword_2
test
isnotequalto
true
to
technology_10
component_11
order
technology_5
dsl
for
the
technology_5
dsl
we
use
technology_25
to
evaluate
the
predicate
the
$test
be
a
special
shorthand
in
technology_2
to
refer
to
the
coding_keyword_2
with
the
give
name
so
even
if
the
connector_data_9
be
not
connector_data_2
base
we
can
still
use
technology_25
to
evaluate
predicate
connector_11
from
uri=
technology_10
component_11
inbox
pattern_3
technology_25
$test
=
false
technology_25
to
uri=
technology_10
component_11
inbox
pattern_3
connector_11
dynamic
pattern_7
problem
how
can
we
connector_11
connector_data_5
base
on
a
dynamic
connector_data_11
of
destination
solution
use
a
dynamic
pattern_7
a
pattern_7
that
can
self
configure
base
on
special
configuration
connector_data_5
from
participate
destination
technology_2
technology_2
have
support
for
dynamic
pattern_7
use
the
dynamic
recipient
connector_data_11
combine
with
a
connector_data_3
component_18
hold
the
connector_data_11
of
destination
technology_4
dsl
we
use
a
processor
a
the
dynamic
pattern_7
to
determine
the
destination
we
could
also
have
use
a
component_4
instead
from
technology_10
component_11
order
processref
mydynamicrouter
recipientlist
destination
coding_keyword_3
mydynamicrouter
connector_15
processor
{
coding_keyword_3
coding_keyword_6
component_10
exchange
exchange
{
query
a
connector_data_3
component_18
to
find
the
best
match
of
the
and
coding_keyword_5
the
destination
s
in
the
coding_keyword_2
exchange
getin
setheader
destination
connector_data_11
}
}
technology_5
dsl
connector_11
from
uri=
technology_10
component_11
order
component_10
ref=
mydynamicrouter
recipientlist
coding_keyword_2
destination
destination
recipientlist
connector_11
annotation
dsl
coding_keyword_3
mydynamicrouter
{
@consume
uri
=
technology_10
component_11
order
@recipientlist
coding_keyword_3
connector_data_11
coding_keyword_4
connector_11
@xpath
requirement_11
coding_keyword_7
coding_keyword_4
customerid
@header
location
coding_keyword_4
location
document
body
{
query
connector_data_3
component_18
find
best
match
for
the

and
coding_keyword_5
destination
s
}
}
tip
notice
how
we
use
component_4
parameter
bind
to
bind
the
parameter
to
the
connector_11
base
on
an
@xpath
expression
on
the
connector_data_2
connector_data_9
of
the
technology_20
connector_data_4
this
allow
u
to
extract
the
requirement_11
coding_keyword_7
a
a
coding_keyword_4
parameter
@header
wil
bind
a
technology_20
property
with
the
key
location
document
be
the
connector_data_2
connector_data_9
of
the
technology_20
connector_data_4
tip
technology_2
us
it
strong
type
converter
feature
to
convert
the
connector_data_9
to
the
type
of
the
parameter
we
could
use
coding_keyword_4
and
technology_2
will
convert
the
body
to
a
coding_keyword_4
instead
you
can
register
your
own
type
converter
a
well
use
the
@converter
annotation
at
the
and
level
recipient
connector_data_11
how
do
we
connector_11
a
connector_data_4
to
a
connector_data_11
of
statically
or
dynamically
specify
recipient
problem
how
can
we
connector_11
connector_data_5
base
on
a
coding_keyword_8
or
dynamic
connector_data_11
of
destination
solution
define
a
pattern_4
for
each
recipient
then
use
a
recipient
connector_data_11
to
inspect
an
incoming
connector_data_4
determine
the
connector_data_11
of
desire
recipient
and
connector_19
the
connector_data_4
to
all
pattern_4
associate
with
the
recipient
in
the
connector_data_11
technology_2
technology_2
support
the
coding_keyword_8
recipient
connector_data_11
use
the
pattern_10
technology_3
and
the
dynamic
recipient
connector_data_11
use
the
recipientlist
technology_3
technology_4
dsl
staticin
this
connector_11
we
connector_11
to
a
coding_keyword_8
connector_data_11
of
two
recipient
that
will
connector_20
a
copy
of
the
same
connector_data_4
simultaneously
from
technology_10
component_11
inbox
pattern_10
to

backup
seda
inbox
dynamicin
this
connector_11
we
connector_11
to
a
dynamic
connector_data_11
of
recipient
define
in
the
connector_data_4
coding_keyword_2
mail
contain
a
connector_data_11
of
recipient
a
url
the
component_4
processmails
be
use
to
the
coding_keyword_2
mail
to
the
connector_data_4
from
seda
confirmmails
beanref
processmails
recipientlist
destination
and
in
the
component_10
mail
component_4
we
use
@headers
component_4
parameter
bind
to
provide
a
technology_4
util
connector_data_12
to
component_18
the
recipient
coding_keyword_3
coding_keyword_6
confirm
@headers
connector_data_12
coding_keyword_2
@body
coding_keyword_4
body}
{
coding_keyword_4
recipient
=
coding_keyword_2
put
destination
recipient
}
technology_5
dsl
coding_keyword_8
connector_11
from
uri=
technology_10
component_11
inbox
pattern_10
to
uri=

backup
to
uri=
seda
inbox
pattern_10
connector_11
dynamicin
this
example
we
invoke
a
connector_data_7
on
a
component_4
to
provide
the
dynamic
connector_data_11
of
recipient
connector_11
from
uri=
technology_10
component_11
inbox
recipientlist

bean=
mydynamicrouter
method=
connector_11
recipientlist
connector_11
component_4
id=
mydynamicrouter
class=
technology_24
mycompany
mydynamicrouter
coding_keyword_3
mydynamicrouter
{
coding_keyword_3
coding_keyword_4
connector_11
coding_keyword_4
body
{
coding_keyword_5
coding_keyword_4
{

backup
}
}
}
annotation
dsl
in
the
customerservice
we
annoate
the
whereto
with
@recipientlist
and
coding_keyword_5
a
single
destination
base
on
the
requirement_11
coding_keyword_7
notice
the
quality_attribute_2
of
technology_2
a
it
can
adapt
accordingly
to
how
you
define
what
your
be
coding_keyword_5
a
single
element
a
connector_data_11
an
iterator
etc
coding_keyword_3
customerservice
{
@recipientlist
coding_keyword_3
coding_keyword_4
whereto
@header
customerid
coding_keyword_7
{
coding_keyword_5
technology_10
component_11
requirement_11
+
coding_keyword_7
}
}
and
then
we
can
connector_11
to
the
component_4
and
it
will
act
a
a
dynamic
recipient
connector_data_11
from
technology_10
component_11
inbox
component_4
customerservice

whereto
splitter
how
can
we
component_10
a
connector_data_4
if
it
contain
multiple
element
each
of
which
have
to
be
component_10
in
a
different
way
problem
how
can
we
split
a
single
connector_data_4
into
piece
to
be
connector_10
individually
solution
use
a
splitter
to
break
out
the
composite
connector_data_4
into
a
series
of
individual
connector_data_4
each
contain
connector_data_3
relate
to
one
item
technology_2
technology_2
have
support
for
splitter
use
the
split
technology_3
technology_4
dsl
in
this
connector_11
we
connector_17
from
the
inbox
folder
each
be
then
split
into
a
connector_data_4
we
use
a
tokenizer
to
split
the
content
line
by
line
base
on
line
break
from

inbox
split
body
tokenize
\n
to
seda
orderlines
tip
technology_2
also
support
split
connector_21
use
the
connector_22
technology_3
we
can
split
the
connector_23
by
use
a
comma
split
body
tokenize
connector_23
to
seda
part
tip
in
the
connector_10
above
each
individual
split
connector_data_4
will
be
connector_24
in
sequence
technology_2
also
support
parallel
connector_25
use
the
parallelprocessing
technology_3
split
body
tokenize
connector_23
parallelprocessing
to
seda
part
technology_5
dsl
in
this
connector_11
we
use
technology_25
to
split
connector_data_2
connector_data_13
connector_26
on
the
technology_20
order
component_11
connector_11
from
uri=
technology_10
component_11
order
split
technology_25
invoice
lineitems
technology_25
to
uri=
seda
processorderline
split
connector_11
and
in
this
connector_11
we
split
the
connector_data_5
use
a
regular
expression
connector_11
from
uri=
technology_10
component_11
order
split
tokenizer
token=
a
z|0

*
regex=
true
to
uri=
seda
processorderline
split
connector_11
tip
split
evaluate
an

apahce
technology_2
expression
to
provide
something
that
be
iterable
to
produce
each
individual
connector_data_4
this
allow
you
to
provide
any
kind
of
expression
such
a
a
component_4
invoke
a
a
connector_data_7
split

bean=
mysplitter
method=
splitme
to
uri=
seda
processorderline
split
component_4
id=
mysplitter
class=
technology_24
mycompany
mysplitter
coding_keyword_3
connector_data_11
splitme
coding_keyword_4
body
{
split
use
technology_4
and
coding_keyword_5
a
connector_data_11
connector_data_11
part
=
coding_keyword_5
part
}
aggregator
how
do
we
combine
the
connector_data_1
of
individual
but
relate
connector_data_5
so
that
they
can
be
component_10
a
a
whole
problem
how
do
we
combine
multiple
connector_data_5
into
a
single
combine
connector_data_4
solution
use
a
stateful
pattern_3
an
aggregator
to
connector_27
and
component_18
individual
connector_data_5
until
it
connector_28
a
complete
set
of
relate
connector_data_5
to
be
publish
technology_2
technology_2
have
support
for
the
aggregator
use
the
aggregate
technology_3
technology_2
us
a
stateful
pattern_11
processor
that
be
capable
of
aggregate
relate
connector_data_4
into
a
single
combine
connector_data_4
a
correlation
expression
be
use
to
determine
which
connector_data_5
should
be
aggregate
an
aggregation
strategy
be
use
to
combine
aggregate
connector_data_5
into
the
connector_data_14
connector_data_4
camel’s
aggregator
also
support
a
completion
predicate
allow
you
to
signal
when
the
aggregation
be
complete
technology_2
also
support
other
completion
signal
base
on
timeout
and
or
a
number
of
connector_data_5
already
aggregate
technology_4
dsl
requirement_12
quote
examplewe
want
to
update
a
every
five
minute
with
the
late
requirement_12
quote
the
quote
be
connector_26
on
a
technology_20
topic
a
we
can
connector_20
multiple
quote
for
the
same
requirement_12
within
this
time
period
we
only
want
to
keep
the
last
one
a
it
the
most
up
to
date
we
can
do
this
with
the
aggregator
from
technology_10
topic
requirement_12
quote
aggregate
technology_25
quote
@symbol
batchtimeout

*

*

to
seda
quote
a
the
correlation
expression
we
use
technology_25
to
fetch
the
requirement_12
symbol
from
the
connector_data_4
body
a
the
aggregation
strategy
we
use
the
default
provide
by
technology_2
that
pick
the
late
connector_data_4
and
thus
also
the
most
up
to
date
the
time
period
be
set
a
a
timeout
requirement_13
in
millisecond
loan
pattern_5
examplewe
aggregate
connector_16
from
various
bank
for
their
quote
for
a
give
loan
connector_data_15
we
want
to
pick
the
bank
with
the
best
quote
the
cheap
loan
therefore
we
need
to
base
our
aggregation
strategy
to
pick
the
best
quote
from
technology_10
topic
loan
quote
aggregate
coding_keyword_2
loanid
aggregationstrategy
bestquote
completionpredicate
coding_keyword_2
exchange
aggregated_size
isgreaterthan

to
seda
bestloanquote
we
use
a
completion
predicate
that
signal
when
we
have
connector_26
more
than

quote
for
a
give
loan
give
u
at
least

quote
to
pick
among
the
follow
show
the
snippet
for
the
aggregation
strategy
we
must
connector_1
to
pick
the
best
quote
coding_keyword_3
bestquotestrategy
connector_15
aggregationstrategy
{
coding_keyword_3
exchange
aggregate
exchange
oldexchange
exchange
newexchange
{
double
oldquote
=
oldexchange
getin
getbody
double

double
newquote
=
newexchange
getin
getbody
double

coding_keyword_5
the
winner
that
have
the
low
quote
coding_keyword_5
newquote
oldquote
newexchange
oldexchange
}
}
technology_5
dsl
loan
pattern_5
example
connector_11
from
uri=
technology_10
topic
loan
qoute
aggregate
strategyref=
bestquote
correlationexpression
coding_keyword_2
loanid
coding_keyword_2
correlationexpression
completionpredicate
quality_attribute_5
${header
camelaggregatedsize}

quality_attribute_5
completionpredicate
aggregate
to
uri=
seda
bestloanquote
connector_11
component_4
id=
bestquote
class=
technology_24
mycompany
bestquotestrategy
tip
we
use
the
quality_attribute_5
technology_8
to
declare
the
completion
predicate
quality_attribute_5
be
a
basic
technology_8
that
support
a
primitive
set
of
operator
${header
camelaggregatedsize}
will
fetch
a
coding_keyword_2
hold
the
number
of
connector_data_5
aggregate
tip
if
the
complete
predicate
be
more
complex
we
can
use
a
connector_data_7
to
invoke
a
component_4
so
we
can
do
the
evaluation
in
pure
technology_4

completionpredicate

bean=
quoteservice
method=
iscomplete
compledtionprediacate
coding_keyword_3
boolean
iscomplete
@header
exchange
aggregated_size
coding_keyword_9
count
coding_keyword_4
body
{
coding_keyword_5
body
equal
stop
}
notice
how
we
can
use
component_4
bind
parameter
to
connector_29
hold
of
the
aggregation
size
a
a
parameter
instead
of
look
it
up
in
the
connector_data_4
resequencer
how
can
we
connector_29
a
connector_23
of
relate
but
out
of
sequence
connector_data_5
back
into
the
correct
order
problem
how
do
we
ensure
order
of
connector_data_4
solution
use
a
stateful
pattern_3
a
resequencer
to
connector_27
and
reorder
connector_data_5
so
that
they
can
be
publish
in
a
specify
order
technology_2
technology_2
have
support
for
the
resequencer
use
the
resequence
technology_3
technology_2
us
a
stateful
pattern_11
processor
that
be
capable
of
reorder
relate
connector_data_4
technology_2
support
two
resequencing
algorithm
pattern_11
=
connector_30
connector_data_5
into
a
pattern_11
sort
the
connector_data_5
and
publish
the
connector_data_4
connector_23
=
re
order
continuously
connector_data_4
connector_21
base
on
detection
of
gap
between
connector_data_4
pattern_11
be
similar
to
the
aggregator
but
with
sorting
connector_23
be
the
traditional
resequencer
pattern_1
with
gap
detection
connector_23
require
usage
of
number
long
a
sequencer
number
enforce
by
the
gap
detection
a
it
must
be
able
to
compute
if
gap
exist
a
gap
be
detected
if
a
number
in
a
series
be
miss
e
g



with
number

miss
technology_2
will
back
off
the
connector_data_5
until
number

arrive
technology_4
dsl
pattern_11
we
want
to
component_10
connector_26
requirement_12
quote
once
a
minute
order
by
their
requirement_12
symbol
we
use
technology_25
a
the
expression
to
select
the
requirement_12
symbol
a
the
requirement_13
use
for
sorting
from
technology_10
topic
requirement_12
quote
resequence
technology_25
quote
@symbol
timeout

*

to
seda
quote
technology_2
will
default
the
order
to
ascend
you
can
provide
your
own
comparison
for
sorting
if
need
connector_23
suppose
we
continuously
pattern_12
a
directory
for
inventory
update
and
it
important
they
be
component_10
in
sequence
by
their
inventory
coding_keyword_7
to
do
this
we
enable
connector_22
and
use
one
hour
a
the
timeout
from

inventory
resequence
technology_25
inventory
@id
connector_23
timeout

*

*

to
seda
inventoryupdates
technology_5
dsl
pattern_11
connector_11
from
uri=
technology_10
topic
requirement_12
quote
resequence
technology_25
quote
@symbol
technology_25
pattern_11
config
batchtimeout=

resequence
to
uri=
seda
quote
connector_11
connector_23
connector_11
from
uri=

inventory
resequence
technology_25
inventory
@id
technology_25
connector_23
config
timeout=

resequence
to
uri=
seda
quote
connector_11
notice
that
you
can
enable
connector_22
by
specify
connector_23
config
instead
of
pattern_11
config
dead
letter
pattern_4
what
will
the
pattern_13
component_12
do
with
a
connector_data_4
it
cannot
connector_31
problem
the
pattern_13
component_12
cannot
connector_31
a
connector_data_4
solution
when
a
connector_data_4
cannot
be
connector_31
it
should
be
move
to
a
dead
letter
pattern_4
technology_2
technology_2
have
extensive
support
for
dead
letter
pattern_4
by
it
error
pattern_14
and
exception
clause
error
pattern_14
support
redelivery
requirement_14
to
decide
how
many
time
to
try
redelivering
a
connector_data_4
before
move
it
to
a
dead
letter
pattern_4
the
default
dead
letter
pattern_4
will
requirement_2
the
connector_data_4
at
error
level
and
perform
up
to

redeliveries
use
a
one
second
delay
before
each
retry
error
pattern_14
have
two
scope
global
and
per
routetip
see
exception
clause
in
the
technology_2
documentation
for
selective
interception
of
throw
exception
this
allow
you
to
connector_11
certain
exception
differently
or
even
reset
the
failure
by
mark
it
a
handle
tip
deadletterchannel
support
component_10
the
connector_data_4
before
it
connector_32
redelivered
use
onredelivery
this
allow
you
to
alter
the
connector_data_4
beforehand
i
e
to
set
any
custom
coding_keyword_2
technology_4
dsl
global
scope
errorhandler
deadletterchannel
technology_10
component_11
error
maximumredeliveries

from
connector_11
scope
from
technology_10
component_11

errorhandler
deadletterchannel
maximumredeliveries

pattern_10
to
requirement_2

seda
handleevent
in
this
connector_11
we
override
the
global
scope
to
use
up
to
five
redeliveries
where
a
the
global
only
have
three
you
can
of
also
set
a
different
error
component_11
destination
deadletterchannel
requirement_2
badevent
maximumredeliveries

technology_5
dsl
the
error
pattern_14
be
configure
very
differently
in
the
technology_4
dsl
vs
the
technology_5
dsl
the
technology_5
dsl
rely
more
on
technology_6
technology_5
component_4
configuration
whereas
the
technology_4
dsl
us
fluent
builder
global
scopethe
global
scope
error
pattern_14
be
configure
use
the
errorhandlerref
attribute
on
the
camelcontext
tag
camelcontext
errorhandlerref=
mydeadletterchannel
camelcontext
connector_11
scoperoute
scoped
be
configure
use
the
errorhandlerref
attribute
on
the
connector_11
tag
connector_11
errorhandlerref=
mydeadletterchannel
connector_11
for
both
the
error
pattern_14
itself
be
configure
use
a
regular
technology_5
component_4
component_4
id=
mydeadletterchannel
class=

technology_1
technology_2
builder
deadletterchannelbuilder
property
name=
deadletteruri
value=
technology_10
component_11
error
property
name=
redeliverypolicy
ref=
myredeliverypolicy
component_4
component_4
id=
myredeliverpolicy
class=

technology_1
technology_2
processor
redeliverpolicy
property
name=
maximumredeliveries
value=

property
name=
delay
value=

component_4
wire
tap
how
do
you
inspect
connector_data_5
that
travel
on
a
point
to
point
pattern_4
problem
how
do
you
tap
connector_data_5
while
they
be
connector_10
solution
insert
a
wire
tap
into
the
pattern_4
that
publish
each
incoming
connector_data_4
to
the
coding_keyword_10
pattern_4
a
well
a
to
a
secondary
pattern_4
technology_2
technology_2
have
support
for
wire
tap
use
the
wiretap
technology_3
that
support
two
mode
traditional
and
connector_data_4
the
traditional
mode
connector_33
a
copy
of
the
original
connector_data_4
a
oppose
to
connector_34
a
connector_data_4
all
connector_data_5
be
connector_12
a
connector_data_4
and
run
in
parallel
with
the
original
connector_data_4
technology_4
dsl
traditionalthe
connector_11
us
the
traditional
mode
to
connector_35
a
copy
of
the
original
connector_data_4
to
the
seda
tap
component_11
while
the
original
connector_data_4
be
connector_10
to
it
destination
the
component_10
order
component_4
from
technology_10
component_11
order
wiretap
seda
tappedorder
to
component_4
processorder
messagein
this
connector_11
we
tap
the
high
priority
order
and
connector_35
a
connector_data_4
contain
a
body
with
the
from
part
of
the
order
tip
a
technology_2
us
an
expression
for
evaluation
you
can
use
other
than
technology_25
for
instance
to
connector_35
a
fix
coding_keyword_4
you
can
use
constant
from
technology_10
component_11
order
choice
when
order
priority
=
‘high’
wiretap
seda
from
technology_25
order
from
to
component_4
processhighorder
otherwise
to
component_4
processorder
technology_5
dsl
traditional
connector_11
from
uri=
technology_10
component_11
order
wiretap
uri=
seda
tappedorder
to
uri=
component_4
processorder
connector_11
connector_data_4
connector_11
choice
when
technology_25
order
priority
=
high
technology_25
wiretap
uri=
seda
from
body
technology_25
order
from
technology_25
body
wiretap
to
uri=
component_4
processhighorder
when
otherwise
to
uri=
component_4
processorder
otherwise
choice
connector_11
section

conclusion
the
twelve
pattern_1
in
this
refcard
cover
the
most
use
pattern_1
in
the
requirement_1
space
together
with
two
of
the
most
complex
such
a
the
aggregator
and
the
dead
letter
pattern_4
in
the
second
part
of
this
series
we
will
take
a
further
look
at
common
pattern_1
and
transations
connector_29
more
connector_data_6
technology_2
technology_9
technology_2
technology_1

the
home
of
the
technology_1
technology_2
project
find
download

example
connector_36
start
guide
issue
tracker
roadmap
mailing
connector_data_11
irc
chat
room
and
how
to
connector_29
help
fusesource
technology_9
fusesource
technology_24
the
home
of
the
fusesource
requirement_15
the
professional
requirement_15
behind
technology_1
technology_2
with
requirement_7
offer
support
consult
and
train
about
author
technology_9
davsclaus
blogspot
technology_24
the
personal
of
the
author
of
this
reference
card
this
refcard
connector_13
more
from
free
refcard
about
u
about
connector_35
feedback
career
sitemap
advertise
advertise
with
contribute
on
submission
guideline
mvb
component_19
become
a
contributor
visit
the
writer
zone
legal
term
of
component_5
privacy
requirement_14
u

park
office
drive
suite

durham
nc

support@dzone
technology_24
+1



coding_keyword_1
s
be
friend

technology_24
be
powered
by
{{
parent
title
||
parent
coding_keyword_2
title}}
{{
parent
tldr
}}
{{
parent
linkdescription
}}
{{
parent
urlsource
name
}}
by
core
·
{{
parent
articledate
|
date
mmm
dd
yyyy
}}
{{
parent
linkdate
|
date
mmm
dd
yyyy
}}
·
{{
parent
portal
name
}}
zone
tweet
{{
parent
pattern_15
}}
viewsclicks
edit
delete
{{
parent
islocked
enable
disable
}}

{{
parent
islimited
remove
limit
enable
moderate

}}
