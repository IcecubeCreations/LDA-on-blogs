technology_1
summit
talk
recap
a
walk
through
of
the
design
and
architecture
of
technology_1
ayanda
dube
technology_2
technology_2
tour
requirement_1
documentation
support
login
connector_1
start
start
technology_1
summit
talk
recap
a
walk
through
of
the
design
and
architecture
of
technology_1
ayanda
dube



technology_1
summit

be
a
one
day
conference
which
bring
light
to
technology_1
from
a
number
of
angle
among
others
ayanda
dube
talk
about
the
internal
design
of
technology_1
a
the
use
of
technology_1
grow
there
s
a
grow
need
for
it
operator
and
engineer
to
have
a
quality_attribute_1
understand
and
appreciation
of
it
internal
design
and
how
it
sub
component_1
connector_2
to
meet
the
various
pattern_1
requirement
in
requirement_2
in
this
talk
i
walk
through
the
internal
design
of
technology_1
explain
some
of
the
key
component_2
which
attribute
to
it
quality_attribute_2
and
reputation
of
be
a
world
lead
and
well
trust
pattern_1
component_3
a
walk
through
of
the
design
and
architecture
of
technology_1
i
m
go
to
talk
about
a
challenge
topic
saskia
approach
me
and
say
hey
ayanda
we
re
have
a
technology_1
summit
with
cloudamqp
can
you
do
a
talk
this
be
after
i
have
do
a
meetup
where
i
speak
and
i
think
i
could
re
use
that
talk
for
this

and
then
after
work
with
a
whole
various
number
of
requirement_3
i
notice
that
there
s
a
need
for
people
to
understand
the
internals
of
technology_1
i
be

why
not
have
a
talk
which
be
go
a
bit
deep
on
the
internals
of
technology_1
so
today
i
m
go
to
try
and
explain
the
internal
design
well
attempt
to
explain
it
because
it
s
not
easy
with
engineering
there
s
a
common
problem
there
s
an
ever
present
need
for
quality_attribute_3
connector_3
be
it
hardware
rf
connector_3
or

you
always
have
two
component_4
that
want
to
connector_4
efficiently
i
think
technology_1
meet
this
need
for
component_5
very
effectively
you
ve
connector_1
two
component_6
quality_attribute_4
requirement_4
two
component_5
that
want
to
connector_4
and
we
plug
in
technology_1
in
there
quote
a
quote
before
i
start
there
be
a
gentleman
connector_5
frederick
barnard
i
m
sure
you
ve
hear
this
quote
a
picture
be
worth
a
thousand
word
i
be
try
to
justify
my
slide
then
i
come
up
with
a
quote
a
well
that
s
nice
a
component_3
diagram
be
worth
a
thousand
line
of

that
s
by
me
last
night
you
will
see
why
initialization
start
script
we
start
with
you
download
technology_1
you
install
it
on
your
component_7
the
directory
connector_data_1
be
generally
this
you
have
your
script
directory
in
your
script
directory
you
ve
connector_1
the
technology_1
component_7
script
which
be
basically
what
start
everything
up
you
can
connector_6
this
out
and
follow
along
a
well
technology_1
initialization
start
script
by
ayanda
dube
all
slide
what
do
the
rabbit
script
do
basically
it
ll
connector_7
the
technology_1
script
which
will
basically
initialize
your
environment
variable
it
will
set
some
default
environment
variable
you
can
override
these
on
your
o
which
i
m
sure
most
of
you
guy
have
do
after
that
it
will
connector_7
the
erl
command
which
will
basically
kickoff
the
technology_3
technology_4
that
s
the
startup
initialization
technology_3
technology_5
if
you
look
at
the
scrip
you
will
find
the
erl
command
somewhere
down
the
rabbit
component_7
script
part
of
that
command
you
ve
connector_1
all
the
argument
that
would
pass
through
that
for
technology_4
startup
one
of
the
argument
be
the
rabbitmq_start_rabbit
environment
variable
if
you
navigate
to
where
that
be
you
ll
notice
that
that
that
argument
set
a
boot

the
s
argument
will
connector_7
that
and
that

basically
the
that
will
be
connector_7
will
be
rabbit
boot
base
on
the
argument
basically
that
s
what
start
rabbit
initialization
boot
technology_1
initialization
boot
sequence
by
ayanda
dube
all
slide
and
then
what
happen
in
boot
the
first
thing
which
happen
in
boot
be
you
connector_1
your
component_6
configs
update
this
be
where
your
technology_1
config
where
you
define
all
your
component_6
configs
i
think
in


now
they
connector_1
merge
with
the
config
technology_6
and
you
connector_1
one
config
which
be
apply
a
component_6
config
and
then
you
put
a
whole
bunch
of
other
that
be
carry
out
you
ve
connector_1
hipe
compile
option
and
connector_8
cluster
consistency
in
late
version
of
technology_1
they
re
plan
to
have
different
version
be
able
to
run
together
so
you
can
have


technology_4
run
with
a

technology_4
for
example
at
the
moment
if
that
cluster
consistency
connector_6
fail
you
win
t
be
able
to
start
your
technology_4
and
then
pattern_2
start
obviously
that
be
the
next
step
initialization
pattern_2
start
technology_1
initialization
pattern_2
start
by
ayanda
dube
all
slide
what
happen
when
you
start
the
pattern_2
it
will
set
up
your
plugins
there
s
a
whole
bunch
of
that
be
do
within
that
set
of
plugins

it
will
start
all
the
component_6
the
connector_9
you
ve
connector_1
systemd
connector_data_2
if
you
start
it
a
a
component_8
and
then
you
connector_1
the
requirement_5
connector_data_3
on
your
requirement_5
initialization
boot
step
and
then
within
that
component_5
phase
there
s
an
important
step
which
rabbit
do
a
part
of
initialization
which
be
connector_7
the
boot
step
technology_1
have
connector_1
a
concept
of
boot
step
i
think
for
technology_3
developer
if
you
ve
work
with
start
phase
and
otp
it
s
a
very
similar
concept
but
this
i
find
it
a
bit
more
quality_attribute_5
because
you
re
not
tie
up
to
a
single
component_6

a
you
have
with
otp
start
phase
boot
step
be
basically
go
to
initialize
run
through
a
number
of
initialization
phase
basically
some
of
the
boot
step
there
s
quite
a
lot
if
you
look
at
the
technology_1

you
ve
connector_1
a
lot
of
boot
step
that
be
connector_7
technology_1
will
run
through
all
these
do
some
initialization
maybe
a
couple
to
point
out
be
you
ve
connector_1
your
alarm
infrastructure
then
that
will
be
initialize
all
your
memory
alarm
will
be
part
of
that
you
ve
connector_1
your
file_handle_cache
for
quality_attribute_3
usage
of
your
disk
i
o
there
s
quite
a
lot
you
can
go
into
the
rabbit
and
see
all
these
and
then
at
the
end
what
you
have
be
you
ve
connector_1
more
internal
boot
step
which
be
not
part
of
the
initial
boot
step
these
be
quality_attribute_6
across
other
in
the
codebase
and
then
after
that
you
ve
connector_1
your
plugin
bootsteps
if
you
do
incorporate
a
boot
step
in
your
plugin
that
s
when
it
will
connector_1
connector_7
initialization
internal
boot
step
part
of
the
internal
bootsteps
that
be
connector_7
you
ve
connector_1
your
pattern_3
mechanism
you
ve
connector_1
your
component_9
mirror
mode
ha
technology_4
you
ve
connector_1
your
requirement_6
validators
that
be
initialize
you
ve
connector_1
a
priority
component_9
this
be
interest
because
priority
component_10
be
enable
by
default
in
technology_1
that
be
always
enable
we
ll
connector_1
to
that
at
the
end
if
you
look
at
the
back
component_9
that
be
use
by
the
component_9
component_11
you
ll
notice
that
it
default
to
the
priority
component_9
back
component_9
pattern_4
and
then
you
ve
connector_1
runtime
parameter
and
other
thing
that
be
initialize
initialization
technology_5
state
so
you
that
it
s
initialize
the
boot
step
have
run
you
ve
connector_1
you
alarm
component_12
run
memory
pattern_5
technology_4
pattern_5
you
ve
connector_1
your
port
and
component_13
run
and
a
whole
bunch
of
other
component_12
that
be
initialize
and
then
you
ve
connector_1
some
recovery
technology_7
which
be
connector_7
a
part
of
startup
i
think
in
the

version
part
of
those
recovery
technology_7
be
to
recover
the
vhost
we
notice
an
interest
issue
quite
recently
that
there
be
some
requirement_4
where
that
recovery
phase
be
take
way
too
long
up
to
eight
hour
thankfully
that
be
fix
basically
this
be
when
your
technology_4
be
initialize
obviously
there
s
more
stuff
i
could
ve

a
whole
technology_8
of
otp
stuff
which
be
start
under
the
hood
but
we’ll
focus
on
technology_1
part
of
initialization
a
well
you
ve
connector_1
your
mnesia
component_14
that
be
start
up
you
ve
connector_1
your
rabbit
component_15
component_16
all
the
component_17
be
component_18
in
there
you
ve
connector_1
your
quality_attribute_7
component_9
component_10
which
be
basically
transient
and
quality_attribute_7
component_9
component_16
your
vhost
and
a
whole
lot
more
the
exchange
component_16
a
well
that
s
initialization
that
s
when
you
technology_1
be
start
you
haven
t
do
anything
it
s
all
plain
nothing
run
at
the
moment
in
term
of
the
that
you
re
connector_7
against
it
technology_9
connector_10
establishment
to
try
to
explain
how
stuff
work
internally
we
will
now
look
at
the
technology_10

technology_9
connector_10
establishment
by
ayanda
dube
all
slide
our
two
component_5
which
we
mention
component_19

and
component_19

they
basically
need
to
connector_11
to
the
technology_4
and
then
start
connector_2
your
technology_4
be
initialize
we
ll
take
the
first
step
connector_10
establishment
technology_10
handle
connector_10
establishment
this
be
your
component_6
everything
you
see
in
the
diagram
below
that’s
the
pattern_2
technology_10
handle
pattern_2
by
ayanda
dube
all
slide
when
your
component_6
connector_12
technology_9
connector_10
establishment
there
s
two
phase
that
take
place
which
be
abstract
to
the
developer
all
your
component_20
technology_11
will
first
open
and
then
they
will
engage
in
technology_10
handshaking
internally
in
the
component_7
you
ve
connector_1
ranch
which
be
handle
all
your
technology_12
detail
and
then
you
ve
connector_1
a
lot
of
acceptor
which
for
each
connector_10
connector_data_4
that
come
in
it
ll
handle
that
connector_data_4
the
reader
be
actually
the
component_11
that
s
go
to
handle
your
connector_data_5
come
in
from
your
connector_data_6
the
moment
that
be
start
it
ll
will
issue
a
connector_10
start
it
will
issue
a
connector_10
start
primitive
back
to
the
component_20
the
component_20
will
connector_13
back
connector_10
start_ok
part
of
that
connector_10
start_ok
contain
your
credential
username
and
password
of
the
component_6
then
there
s
connector_10
tune
and
after
that
the
pattern_2
be
go
to
connector_13
a
connector_10
open_ok
that
s
your
technology_10
connector_10
open
technology_10
handle
connector_10
establishment
if
we
then
look
at
what
actually
happen
after
the
connector_10
be
open
in
term
of
the

you
have
your
technology_1
reader
start
and
then
you
have
to
wait
for
connector_data_5
come
in
obviously
the
first
connector_data_3
will
be
the
technology_13
initialization
pack
which
will
contain
the
version
some
byte
basically
which
depict
the
version
which
the
component_20
and
the
component_7
need
to
agree
on
internally
what
happen
rabbit
will
connector_6
those
four

and
then
it
will
match
those
and
pick
the
technology_10
version
which
it
s
go
to
use
once
we
ve
set
up
and
the
technology_10
version
have
be
agree
on
the
connector_10
pid
be
register
component_7
property
be
set
up
if
you
do
a
trace
you
ll
see
a
lot
of
property
that
be
negotiate
between
the
component_20
and
component_7
technology_10
handle
connector_10
establishment
a
brief
on
the
technology_3
setup
on
the
boot
phase
you
re
go
to
have
the
technology_12
component_13
component_12
and
supervisor
be

to
the
technology_1
supervisor
all
of
this
be
be
take
care
of
by
ranch
if
you
how
ranch
work
basically
what
it
do
be
it
s
connector_1
a
whole
bunch
of
acceptor
which
rabbit
set
a

by
default
this
be
quality_attribute_8
you
can
pump
this
up
or
reduce
it
base
on
your
need
then
it
will
start
up
the
reader
setup
your
acceptor
connector_1
back
to
the
connector_14
phase
and
then
each
component_20
connector_10
that
come
in
it
will
set
up
a
reader
which
be
the
pattern_6
for
that
component_20
connector_10
you
can
have
a
many
reader
of
the
technology_1
“reader
supervision
trees”
start
a
component_20
connector_10
come
in
that
s
a
brief
on
the
connector_10
establishment
technology_10
handle
pattern_7
creation
technology_4
state
next
once
you
have
a
connector_10
you
want
to
open
or
you
create
pattern_7
pattern_7
in
technology_1
be
internal
component_12
which
be
go
to
handle
the
technology_10
connector_data_4
technology_10
handle
pattern_7
open
technology_10
handle
pattern_7
open
by
ayanda
dube
all
slide
what
happen
when
you
connector_13
or
connector_11
a
pattern_7
open
the
pattern_7
open
connector_data_4
will
be
handle
by
your
rabbit
reader
everything
else
i
mean
and
then
the
pattern_7
top
level
supervisor
will
be
start
that
will
start
another
supervisor
for
the
specific
pattern_7
then
the
pattern_7
component_11
will
be
start
the
moment
you
connector_1
that
pattern_7
component_11
start
they
will
connector_13
back
a
pattern_7
open
connector_data_3
to
the
already
start
pattern_7
that
s
for
update
the
state
of
the
pattern_7
set
it
to
run
state
after
that
the
pattern_7
open_ok
be
connector_15
to
the
rabbit
writer
component_11
you
can
go
to
the
base
and
actually
see
all
these
implementation
technology_10
handle
pattern_7
open
let’s
explain
the
which
be
take
care
of
during
pattern_7
establishment
your
pattern_7
open
connector_data_4
will
propagate
through
your
rabbit
reader
and
that
frame
will
connector_1
handle
technology_10
handle
pattern_7
open
component_11
by
ayanda
dube
all
slide
here
there
be
a
connector_6
you
re
not
permit
to
use
pattern_7

pattern_7

be
only
for
set
up
the
rabbit
reader
component_11
if
it
s
not
pattern_7

then
it
will
component_11
the
frame
all
pattern_7
their
pid
be
component_18
in
the
rabbit
reader
component_11
dictionary
and
if
you
do
a
pattern_7
pattern_8
which
be
a
ram
component_18
it
will
connector_6
if
it’s
already
exist
if
it
be
then
technology_1
basically
will
decode
that
pattern_7
open
primitive
initialize
the
state
this
can
be
connector_15
across
different
technology_4
it
will
connector_16
that
connector_data_3
and
that
will
set
the
pattern_7
to
a
run
state
and
that
s
when
your
pattern_7
be
start
if
it
didn
t
exist
it
ll
create
a
pattern_7
at
the
same
time
there
s
a
connector_6
whether
the
maximum
number
of
permit
pattern_7
be
exceed
or
not
if
they
be
obviously
your
pattern_7
open
will
fail
if
they
re
not
it
will
start
up
the
pattern_7
and
then
come
back
to
all
these

technology_10
handle
pattern_7
open
a
pattern_7
consist
of
the
supervisor
component_11
if
it
s
a
direct
pattern_7
you
will
have
a
rabbit
pattern_7
component_11
and
the
rabbit
limiter
if
it
s
a
requirement_7
pattern_7
which
probably
most
of
you
be
use
you
can
open
direct
pattern_7
connector_10
this
be
the
pattern_6
for
all
your
command
the
limiter
handle
all
your
prefetch
count
mechanism
the
role
of
the
limiter
be
to
limit
the
connector_17
between
the
component_9
component_11
and
the
pattern_7
in
connector_18
out
traffic
finally
we
have
the
technology_1
writer
component_11
which
issue
out
command
back
to
your
component_20
and
that
s
pattern_7
creation
for
you
technology_10
handle
create
declare
an
exchange
next
you
want
to
create
and
declare
an
exchange
what
happen
when
we
do
that
a
similar

your
exchange
declare
primitive
be
connector_15
to
the
rabbit
reader
it’s
connector_16
to
the
pattern_7
and
then
there
s
a
rabbit
exchange

here
technology_1
will
make
a
pattern_8
in
mnesia
in
the
component_21
and
connector_6
if
that
exchange
have
already
be
create
if
it
s
there
you
connector_1
an
okey
exchange
and
exchange
declare_ok
will
be

back
to
the
component_20
move
on
the
exchange
type
will
be
declare
and
then
the
exchange
be
insert
into
mnesia
into
your
component_21
and
exchange
declare_ok
will
be

back
to
the
component_20
pretty
straightforward
technology_10
handle
exchange
declaration
some
connector_19
be
do
when
create
exchange
to
connector_6
if
the
type
be
valid
if
it
s
within
the
direct
topic

scope
or
if
you
connector_20
your
own
plugin
which
the
consistent
hash
exchange
that
will
be
register
on
startup
and
the
connector_6
will
be
carry
out
against
that
if
it
doesn
t
exist
your
exchange
declare
will
fail
then
we
connector_6
the
permission
“does
the
exchange
have
configuration
permission
for
the
component_15
”
if
it
doesn
t
it
will
fail
basically
it
will
connector_6
for
the
permission
for
the
component_15
to
create
an
exchange
if
the
component_15
do
have
permission
to
pattern_8
the
exchange
if
it
s
there
it
will
it
if
it
s
not
there
it
will
create
it
and
insert
in
mnesia
then
to
the
component_20
technology_10
handle
component_9
declaration
now
you
ve
connector_1
your
exchange
you
ve
connector_1
your
pattern_7
you’ve
connector_1
exchange
now
you
want
to
declare
a
component_9
component_9
declaration
how
be
that
handle
when
you
create
a
component_9
obviously
you
ll
connector_13
your
component_9
declare
primitive
then
there
s
an
component_22
for
thee
rabbit
amq
component_9

that
will
do
a
pattern_8
against
the
component_21
if
the
component_9
be
already
exist
in
the
component_21
it
will
component_9
declare_ok
that
s
when
you
ve
connector_1
the
nowait
flag
set
to
true
but
if
you
have
set
it
to
true
it
will
first
confirm
that
the
component_9
be
actually
create
it
will
connector_1
some
initial
statistic
from
the
component_9
component_11
that
have
be
start
it
will
connector_13
out
a
stat
connector_data_3
which
go
through
a
bunch
of
component_12
connector_5
delegate
in
technology_1
rabbit
have
connector_1
a
pool
of
component_12
connector_5
delegate
they
split
command
whether
they
be
for
a
local
component_9
or
a
remote
component_9
and
then
if
it
s
for
a
remote
component_9
it
will
actually
ship
across
the
command
and
connector_7
it
on
the
remote
technology_4
which
be
more
quality_attribute_3
than
directly
do
remote
connector_data_7
from
this
technology_14
this
a
couple
of
stats
and
your
declare_ok
this
be
confirm
that
the
component_9
be
actually
start
whenever
you
set
that
nowait
flag
to
false
this
be
what
will
happen
if
the
component_9
wasn
t
find
in
the
component_21
on
the
initial
pattern_8
it
will
be
declare
your
component_9
name
be
it
quality_attribute_7
auto
delete
your
argument
that
you
set
from
your
component_20
component_6
they
ll
be
propagate
to
the
component_9
supervisor
which
will
start
the
component_9
component_11
and
then
the
component_9
component_11
will
initialize
the
back
component_9
which
have
be
configure
for
that
component_9
component_11
the
back
component_9
actually
determine
how
your
component_9
behave
you
ve
connector_1
a
component_11
and
behind
the
scene
there
be
a
back
component_9
which
vary
on
the
type
of
component_10
that
you
have
for
example
if
you
ve
connector_1
the
priority
component_9
the
back
component_9
will
be
the
priority
component_9
default
which
also
connector_21
with
the
variable
component_9
those
be
connector_data_8
back
at
the
back
then
that
will
connector_13
back
your
component_9
declare_ok
back
to
your
component_20
component_6
technology_10
handle
component_9
declaration
if
there
be
any
requirement_6
that
you
have
set
during
component_9
declaration
high
quality_attribute_9
requirement_6
those
will
be
set
on
the
component_9
and
if
you
ve
connector_1
any
component_9
leader
location
strategy
set
up
those
will
be
set
here
basically
you
compute
the
technology_4
on
which
the
component_9
be
go
to
reside
if
it
s
a
mirror
component_9
you
connector_6
the
leader
component_9
technology_4
usually
these
be
the
same
that’ll
then
start
up
the
component_9
supervisor
this
go
through
another
component_11
connector_5
the
prequeue
component_11
it
will
connector_6
“is
the
component_9
a
leader
component_9
or
a
follower
component_9
”
if
it
s
a
leader
component_9
it
will
start
the
leader
component_9
and
then
initialize
it
with
the
back
component_9
initialize
your
component_9
index
and
the
connector_data_3
component_18
for
technology_1


the
connector_data_3
connector_22
be
per
pattern_9
component_23
you
technology_15
have
a
transient
and
a
persistent
connector_data_3
component_18
after
that
your
component_9
component_11
will
start
i
will
connector_13
init

and
thus
the
recovery
strategy
that
s
mention
to
the
component_9
which
will
proceed
on
more
initialization
step
so
there
s
quite
a
lot
that
take
place
here
and
if
it’s
a
follower
the
follower
component_9
will
be
start
from
the
mirror
component_9
follower
component_11
technology_10
handle
bind
component_9
to
exchange
we’ve
connector_1
the
component_10
now
then
you
want
to
create
a
bind
between
your
exchange
and
your
component_9
bind
will
basically
exist
in
the
component_21
a
you
re
go
to
see
it
s
not
you
ve
connector_1
a
direct
connector_23
between
your
exchange
and
your
component_9
technology_10
handle
component_9
exchange
bind
you
issue
your
component_9
bind
command
from
your
component_20
mention
your
component_9
and
your
exchange
the
component_24
and
destination
that
will
go
to
your
pattern_7
along
to
the
rabbit
bind

it
will
connector_6
“does
that
bind
exist
in
the
rabbit
root
component_16
”
that
s
the
component_16
which
hold
all
your
bind
if
there
s
an
element
it
will
component_9
bind_ok
if
there
be
nothing
it
will
connector_20
it
to
your
component_21
there
s
actually
three
component_14
there
the
rabbit_route
rabbit_durable_route
and
rabbit_semi_durable_route
and
then
it
will
component_9
bind_ok
to
the
component_20
technology_10
handle
component_9
to
exchange
bind
initially
a
couple
of
connector_19
for
the
bind
there
be
technology_6
of
the
component_24
and
the
destination
which
be
your
component_9
name
and
the
exchange
name
for
example
strip
of
carriage
character
in
your
component_9
name
or
exchange
name
and
then
it
will
connector_20
permission
for
the
destination
then
the
rabbit
bind
will
validate
the
bind
connector_6
in
the
component_21
and
it
if
it
wasn
t
there
it
will
create
an
entry
in
the
component_21
and
then
issue
it
out
via
the
rabbit
writer
that
s
why
the
pattern_7
always
have
a
rabbit
writer
once
you
ve
connector_1
your
bind
the
next
thing
be
to
subscribe
the
component_25
to
our
component_9
technology_10
handle
connector_24
technology_10
handle
connector_24
connector_data_3
by
ayanda
dube
all
slide
here
you
issue
out
your
basic
connector_25
command
your
rabbit
pattern_7
will
connector_16
the
basic
connector_25
command
to
your
component_9
component_11
via
the
technology_14
it
will
also
mention
the
pattern_7
pid
delimiter
i
do
mention
there
be
three
component_12
for
handle
your
prefetch
count
and
all
that
the
moment
it
connector_26
to
your
component_9
the
component_9
will
basically
connector_2
with
this
rabbit
component_9
consumer’s
technology_14
it
s
not
component_26
be
stand
alone
component_12
within
the
component_7
everything
be
happen
within
that
component_9
component_11
the
connector_data_4
will
initialize
with
the
rabbit
limiter
and
give
it
the
pid
to
activate
once
activate
the
pattern_7
pid
and
the
component_25
entry
will
be

into
a
component_9
technology_6
into
a
component_27
you
ve
connector_1
a
small
priority
component_9
for
each
component_25
that
be
create
for
a
component_9
it’s

into
an
internal
component_9
in
the
component_9
component_11
so
you
have
a
component_9
of
component_26
which
be

the
reason
why
it
s
a
priority
component_9
be
because
you
can
incorporate
thing
component_25
priority
if
you
want
to
prioritize
your
component_25
it
ll
be
set
within
this
priority
component_9
in
the
component_9
component_11
then
the
basic
consume_ok
will
be

back
to
your
component_20
component_6
and
also
there
be
some
consumer_created
stats
which
be
create
technology_10
handle
connector_data_3
publish
we
ve
connector_1
our
component_26
now
everything
be
set
up
we
have
our
pattern_7
exchange
and
component_9
the
component_26
with
their
own
pattern_7
and
now
we
re
ready
to
publish
connector_data_5
from
our
component_20
component_6
to
the
component_25
technology_10
handle
connector_data_3
publish
by
ayanda
dube
all
slide
what
happen
when
you
do
basic
publish
if
you
connector_27
your
connector_data_3
it
will
be
technology_6
by
the
rabbit
basic
component_22
into
a
delivery
connector_data_9
which
be
a
component_27
then
there
s
a
connector_28
pattern_8
basically
look
at
“which
component_10
be
i
go
to
connector_29
connector_data_5
to
”
and
for
each
connector_data_3
you
connector_1
a
connector_data_10
of
component_9
if
your
exchange
be
a
direct
exchange
you
connector_1
a
single
component_9
there
if
your
exchange
be
a
fanout
you
connector_1
a
connector_data_10
of
component_9
or
if
you
have
multiple
direct
bind
which
have
connector_1
the
same
connector_30
key
you
connector_1
multiple
component_9
everything
be
base
on
the
type
of
exchange
you
choose
the
connector_data_10
of
component_10
be
then
connector_16
to
your
delegate
because
these
can
be
cross
technology_4
connector_data_8
some
component_9
can
be
local
some
component_9
can
be
remote
so
that
delivery
component_27
be
connector_16
to
the
component_9
component_11
this
be
not
connector_31
in
the
back
component_9
but
there’s
a
connector_6
to
see
if
the
connector_data_3
be
a
duplicate
at
the
moment
it

false
by
default
and
then
the
first
thing
which
rabbit
will
do
be
the
component_9
component_11
will
immediately
attempt
to
connector_29
the
connector_data_3
to
the
component_25
it
make
sense
because
if
you
connector_13
a
connector_data_3
the
first
thing
that
you
want
to
do
be
quickly
connector_6
if
a
component_25
can
connector_32
it
but
if
it
can
t
that
s
when
we
component_9
it
up
that
s
the
whole
component_9
theory
there
s
an
attempt
to
connector_29
the
connector_data_3
and
that
fail
so
the
component_9
component_11
will
publish
the
connector_data_3
to
the
back
component_9
to
insert
it
into
the
actual
component_9
connector_data_3
component_18
component_9
index
that
s
what
take
place
there
back
component_9
a
bit
on
the
on
the
back
component_9
when
it
connector_33
that
publish
command
rabbit
back
component_10
be
very
interest
basically
when
you
connector_1
a
publish
command
there’s
a
connector_6
if
it
can
be
component_18
in
the
rabbit
component_9
index
if
the
connector_data_3
connector_data_9
be
le
than
the
component_9
index
embed
size
it
will
be
component_18
in
the
rabbit
component_9
index
but
if
it
s
not
it
will
be
component_18
in
the
connector_data_3
component_18
in
the
connector_data_3
component_18
you’ve
connector_1
either
transient
and
the
persistent
mode
quality_attribute_10
on
your
delivery
mode
flag
when
you
publish
for
persistence
it
will
be
component_18
in
in
the
persistence
connector_data_3
component_18
else
it
will
be
component_18
in
your
transient
that
will
be

then
the
back
component_9
us
a
connector_data_3
status
component_27
which
all
the
action
be
act
upon
base
on
what
s
be
update
on
this
connector_data_3
status
component_27
and
after
connector_34
the
connector_data_3
the
connector_data_3
status
component_27
be
also
component_18
in
the
internal
back
component_9
component_9
you
ve
connector_1
a
whole
bunch
of
component_10
internally
which
the
back
component_9
us
you’ve
connector_1
q1
q2
q3
and
q4
and
you
ve
connector_1
connector_data_3
classification
connector_5
alpha
beta
gamma
this
be
base
on
where
the
connector_data_3
be
go
to
reside
for
example
a
beta
classification
in
your
connector_data_3
exist
on
the
disk
and
it
position
be
hold
in
ram
when
your
technology_4
go
through
memory
pressure
all
connector_data_5
that
be
in
ram
be
connector_27
to
your
delta
s
to
disk
basically
during
component_28
that
s
what
will
be
happen
it
be
shuffle
of
connector_data_5
from
certain
component_10
to
another
component_9
that
s
it
your
connector_data_5
be
now
go
through
technology_9
technology_5
state
that
s
why
we’ve
connector_1
pattern_1
now
component_19

and
component_19

be
now
connector_4
that
s
an
overview
of
what
take
place
internally
when
you’re
connector_35
connector_data_5
from
one
component_19
to
another

clustring
in
requirement_4
you
to
setup
a
technology_1
cluster
you
be
tell
technology_1
that
you
have
another
technology_4
and
what
it
will
update
the
mnesia
config
with
that
technology_4
the
mnesia
will
handle
everything
else
under
the
hood
such
a
pattern_10
to
the
other
technology_4
use
technology_3
distribution
and
synchronize
all
your
component_14
will
be
pattern_11
across
your
cluster
and
all
your
internal
connector_30
will
be
handle
across
the
cluster

high
quality_attribute_9
ha
component_10
a
quick
note
on
high
quality_attribute_9
component_9
the
moment
you
set
a
requirement_6
to
make
a
component_9
ha
the
back
component_9
connector_36
to
the
mirror
component_9
leader

the
component_9
state
will
be
update
dynamically
and
then
all
your
synchronization
will
be
handle
by
technology_3
distribution
what
actually
happen
be
you’ve
connector_1
your
leader
component_9
component_11
which
will
be
create
and
if
you
set
an
ha
requirement_6
you
connector_1
follower
component_10
which
be
create
on
the
other
technology_4
and
a
part
of
creation
the
leader
component_9
have
connector_1
a
coordinator
component_11
which
it
will
use
to
connector_2
with
the
gm
group
basically
this
be
because
the
leader
component_9
cannot
directly
connector_2
with
the
gm
instead
it
will
use
that
coordinator
each
follower
have
a
gm
component_11
which
handle
and
technology_16
to
through
and
publish
connector_data_5
across
the
cluster
this
be
your
cluster
pattern_12
and
synchronization
algorithm
conclusion
design
and
architecture
i

t
think
we
can
strictly
define
the
architecture
of
rabbit
there
s
a
whole
bunch
of
thing
that
can
cause
it
to
connector_37
plugins
be
go
to
connector_37
how
technology_1
appear
version
release
be
go
to
introduce
design
connector_37
by
the
way
you
all
be
go
to
use
it
will
affect
the
design
finally
this
be
an
attempt
to
explain
how
it
work
but
it
be
ever
connector_37
and
everything
we
ve
talk
about
can
be
find
in
these
two
pattern_13
rabbit
component_7
rabbit
common
applause
enjoy
this


t
forget
to
connector_38
it
with
others
😉
elin
vinka
developer
free
ebook
the
optimal
technology_1
guide
download
your
copy
tweet
by
technology_2
technology_2
requirement_2
lead
technology_1
a
a
component_8
start
your
manage
cluster
today
technology_2
be
100%
free
to
try
start
your
free
plan
today

000+
component_17
include
these
smart
requirement_8
home
tour
requirement_1
documentation
support
requirement_3
about
u
resource
changelog
faq
legal
and
requirement_6
quality_attribute_11
and
compliance
status
need
help
support
open

hour
a
day

day
a
week
talk
to
sale
+1



sale
inquiry
only
open


cst
bring
to
you
by
www
84codes
technology_17
our
component_29
cloudkarafka
–
technology_18
technology_19
elephantsql
–
technology_20
cloudmqtt
–
technology_21
©
copyright


cloudamqp
technology_1
and
the
technology_1
logo
be
trademark
of
vmware
inc
