why
you
should
choose
technology_1
technology_1
overview
various
connector_data_1
component_1
comparison
|
by
mina
ayoub
|
mediumget
unlimited
accessopen
in
apphomenotificationslistsstorieswritemina
ayoubfollowjan

2016·11
min
readwhy
you
should
choose
technology_1
technology_1
overview
various
connector_data_1
component_1
comparisonforeword
mq
what
be
it
what
be
a
component_1
mq
we
can
understand
a
a
connector_data_1
component_1
a
component_1
we
can
understand
a
a
pipeline
pipeline
the
way
to
do
connector_data_1
scene

in
fact
when
we
be
in
double

when
we
have
a
lot
of
spike
and
snap
up
quality_attribute_1
in
the
early
morning
and
then
go
to
checkout
we
find
that
the
would
remind
u
coding_keyword_1
u
wait
and
some
friendly
picture
text
reminder
rather
than
the
era
of
the
past
few
year
the
component_2
be
stick
the
error
be
report
etc
to
the
component_3
in
this
requirement_1
scenario
we
can
use
the
mechanism
of
the
component_1
to
deal
with
because
at
the
same
time
the
settlement
can
only
achieve
so
much

shop
in
our
usual
supermarket
be
the
same
when
we
be
at
the
time
of
settlement
we
will
not
flood
into
the
cashier
but
component_1
up
for
settlement
this
be
also
the
pattern_1
mechanism
yes
it
be
line
up
one
after
the
other
you
can’t
jump
in
the
component_1
introduction
to
rabbitmqamqp
the
advance
connector_data_1
pattern_1
technology_2
be
an
open
technology_3
for
component_4
pattern_2
technology_2
design
for
connector_data_1
orient
technology_4
connector_data_1
technology_4
be
primarily
use
for
decouple
between
component_5
and
the
sender
of
the
connector_data_1
do
not
need
to
the
existence
of
the
connector_data_1
component_6
and
vice
versa
the
coding_keyword_2
feature
of
technology_5
be
connector_data_1
orient
component_1
connector_1
include
pattern_3
and
publish
subscribe
quality_attribute_2
and
quality_attribute_3
technology_1
be
an
open_source
technology_5
implementation
the
component_7
be
connector_2
in
technology_6
and
support
a
variety
of
component_8
such
a
technology_7
technology_8
net
technology_9
technology_10
technology_11
technology_12
technology_13
technology_14
stomp
etc
support
technology_15
it
be
use
to
component_9
and
connector_3
connector_data_2
in
a
quality_attribute_4
component_10
and
perform
well
in
term
of
ease
of
use
quality_attribute_5
and
high
quality_attribute_6
the
follow
section
focus
on
some
of
the
basic
concept
in
technology_1
understand
these
concept
be
the
basis
for
use
technology_1
connectionfactory
connector_4
channelconnectionfactory
connector_4
and
pattern_4
be
the
most
basic
connector_data_3
in
the
component_11
provide
by
technology_1
connector_4
be
the
connector_data_4
connector_5
of
technology_1
which
pattern_5
the
component_12
relate
to
the
connector_data_4
technology_2
connectionfactory
be
the
manufacture
factory
of
connector_4
pattern_4
be
the
most
important
we
deal
with
technology_1
most
of
our
requirement_1
be
do
in
the
pattern_4

include
define
component_1
define
exchange
bind
component_1
and
exchange
and
publish
connector_data_1
queuethe
component_1
be
an
internal
connector_data_5
of
technology_1
that
connector_6
connector_data_2
and
be
represent
by
the
follow
figure
connector_data_1
in
technology_1
can
only
be
component_9
in
the
component_1
the
component_13
p
in
the
figure
below
produce
the
connector_data_1
and
finally
connector_7
it
to
the
component_1
the
component_6
technology_11
in
the
figure
below
can
connector_8
the
connector_data_1
from
the
component_1
and
connector_9
it
multiple
component_14
can
subscribe
to
the
same
component_1
and
the
connector_data_2
in
the
component_1
be
evenly
quality_attribute_4
to
multiple
component_14
for
component_15
rather
than
each
component_6
connector_10
all
connector_data_2
and
component_15
connector_data_1
acknowledgmentin
practical
component_4
it
happen
that
the
component_6
connector_11
the
connector_data_1
in
the
component_1
but
do
not
component_15
the
component_16
or
other
accident
in
which
requirement_2
the
connector_data_1
be
lose
in
order
to
avoid
this
we
can
ask
the
component_6
to
connector_12
a
receipt
to
technology_1
after
the
connector_data_1
be
connector_9
and
technology_1
will
remove
the
connector_data_1
from
the
component_1
after
connector_10
the
connector_data_1
acknowledgment
if
technology_1
do
not
connector_13
the
receipt
upon
detecting
that
the
consumer’s
technology_1
connector_4
be
break
technology_1
will
connector_12
the
connector_data_1
to
other
component_14
if
there
be
multiple
component_6
for
component_15
there
be
no
concept
of
timeout
here
a
component_6
component_15
a
connector_data_1
for
a
long
time
will
not
cause
the
connector_data_1
to
be
connector_14
to
other
component_14
unless
it
technology_1
connector_4
be
break
there
be
another
problem
here
if
our
developer
forget
to
connector_12
a
receipt
to
technology_1
after
component_15
the
requirement_1
component_12
this
will
lead
to
serious
bug
—
more
and
more
connector_data_2
will
be
accumulate
in
the
component_1
repeat
consumption
of
these
connector_data_2
and
repeat
requirement_1
logic…in
addition
the
pub
connector_data_1
be
not
ack
connector_data_1
durabilityif
we
want
to
lose
the
connector_data_1
even
if
the
technology_1
component_17
be
restart
we
can
set
both
component_1
and
connector_data_1
to
be
quality_attribute_7
which
will
ensure
that
most
of
our
technology_1
connector_data_2
will
not
be
lose
in
most
requirement_2
but
still
can’t
solve
the
small
probability
of
loss
such
a
the
technology_1
component_7
have
connector_15
the
producer’s
connector_data_1
but
the
technology_1
component_7
be
powered
off
before
the
connector_data_1
be
persist
if
we
need
to
have
such
a
small
probability
manage
it
then
we
need
to
use
the
transaction
since
this
be
only
a
brief
introduction
to
technology_1
technology_1
relate
transaction
will
not
be
explain
here
prefetch
countearlier
we
say
that
if
multiple
component_14
subscribe
to
connector_data_2
in
the
same
component_1
at
the
same
time
the
connector_data_2
in
the
component_1
will
be
spread
to
multiple
component_6
at
this
time
if
the
component_15
time
of
each
connector_data_1
be
different
it
cause
some
component_14
to
be
busy
all
the
time
while
other
component_14
will
quickly
handle
the
work
at
hand
and
remain
idle
we
can
set
the
prefetchcount
to
limit
the
number
of
connector_data_2
that
the
component_1
connector_16
to
each
component_6
each
time
for
example
if
we
set
prefetchcount=1
the
component_1
will
connector_12
a
connector_data_1
to
each
component_6
every
time
after
the
component_6
finish
the
connector_data_1
the
component_1
will
connector_12
a
connector_data_1
to
the
component_6
exchangein
the
previous
section
we
saw
that
the
component_13
connector_17
the
connector_data_1
to
the
component_1
in
fact
this
would
never
happen
in
technology_1
the
actual
situation
be
that
the
component_13
connector_16
the
connector_data_1
to
exchange
switch
x
in
the
figure
below
and
exchange
connector_18
the
connector_data_1
to
one
or
more
component_18
or
drop
what
component_12
do
exchange
use
to
connector_19
connector_data_2
to
the
component_1
this
will
be
introduce
in
the
bind
section
there
be
four
type
of
exchange
in
technology_1
and
different
type
have
different
connector_1
strategy
which
will
be
cover
in
the
exchange
type
section
connector_18
keywhen
a
component_13
connector_16
a
connector_data_1
to
exchange
it
usually
specify
a
connector_1
key
to
specify
the
connector_1
rule
for
the
connector_data_1
and
the
connector_1
key
need
to
be
use
in
conjunction
with
the
exchange
type
and
the
bind
key
to
be
quality_attribute_8
in
the
requirement_2
that
the
exchange
type
and
the
bind
key
be
fix
usually
fix
in
normal
use
our
component_19
can
determine
where
the
connector_data_1
flow
by
specify
the
connector_1
key
when
connector_20
a
connector_data_1
to
exchange
technology_1
limit
the
length
of
the
connector_1
key
to

byte
bindingrabbitmq
associate
exchange
with
the
component_1
through
bind
so
technology_1

how
to
properly
connector_19
connector_data_2
to
the
specify
component_1
bind
keybinding
exchange
and
component_1
generally
specify
a
bind
key
when
a
component_6
connector_16
a
connector_data_1
to
exchange
a
connector_1
key
be
usually
specify
when
the
bind
key
match
the
connector_1
key
the
connector_data_1
will
be
connector_18
go
to
the
correspond
component_1
this
will
be
explain
in
the
exchange
type
section
with
practical
example
these
bind
allow
the
same
bind
key
to
be
use
when
bind
multiple
component_18
to
the
same
exchange
the
bind
key
do
not
work
in
all
requirement_2
it
rely
on
the
exchange
type
for
example
a
fanout
type
of
exchange
ignore
the
bind
key
and
connector_18
the
connector_data_1
to
all
component_18
bind
to
the
exchange
exchange
typesrabbitmq
commonly
use
exchange
type
have
four
type
fanout
direct
topic
and
coding_keyword_3
the
technology_5
specification
also
mention
two
exchange
type
component_10
and
customization
which
be
not
describe
here
fanoutthe
fanout
type
of
exchange
connector_1
rule
be
very
quality_attribute_9
it
will
connector_19
all
connector_data_2
connector_14
to
the
exchange
to
all
component_18
bind
to
it
in
the
figure
above
all
connector_data_2
connector_14
by
the
component_13
p
to
exchange
x
be
connector_18
to
the
two
component_18
in
the
diagram
and
eventually
connector_9
by
two
component_14
c1
and
c2
directthe
direct
type
of
exchange
connector_1
rule
be
also
very
quality_attribute_9
it
will
connector_19
connector_data_2
to
the
component_1
that
exactly
match
the
bind
key
and
the
connector_1
key
for
the
configuration
of
the
above
figure
we
connector_12
a
connector_data_1
to
exchange
with
routingkey=”error”
and
the
connector_data_1
will
be
connector_18
to
queue1
technology_16
gen
s9b…
which
be
the
component_1
name
automatically
generate
by
technology_1
and
queue2
technology_16
gen
agl…
if
we
connector_12
a
connector_data_1
with
routingkey=”info”
or
routingkey=”warning”
the
connector_data_1
will
only
be
connector_18
to
queue2
if
we
connector_12
a
connector_data_1
with
another
routingkey
the
connector_data_1
will
not
be
connector_18
to
both
component_1
topicas
mention
above
the
direct
type
of
exchange
connector_1
rule
completely
match
the
bind
key
and
the
connector_1
key
but
this
strict
match
can
not
meet
the
actual
requirement_1
need
in
many
requirement_2
the
topic
type
exchange
be
extend
on
the
match
rule
it
be
similar
to
the
direct
type
exchage
it
also
connector_18
the
connector_data_1
to
the
component_1
that
match
the
bind
key
and
the
connector_1
key
however
the
match
rule
here
be
somewhat
different
it
stipulate
the
connector_1
key
be
a
coding_keyword_4
separate
by
a
period
“
”
we
will
refer
to
each
separate
coding_keyword_4
separate
by
a
period
“
”
a
a
word
such
a
“stock
usd
nyse”
“nyse
vmw”
“quick
orange
rabbit”the
bind
key
be
the
same
a
the
connector_1
key
which
be
also
a
coding_keyword_4
separate
by
a
period
“
”
there
be
two
special
character
“*”
and
“#”
in
the
bind
key
which
be
use
for
fuzzy
match
where
“*”
be
use
to
match
one
word
and
“#”
be
use
to
match
multiple
word
can
be
zero
for
the
configuration
in
the
above
figure
the
connector_data_1
routingkey=”quick
orange
rabbit”
will
be
connector_18
to
both
q1
and
q2
and
routingkey=”lazy
orange
fox”
will
be
connector_18
to
q1
and
q2
routingkey=”lazy
the
connector_data_1
“brown
fox”
will
be
connector_18
to
q2
and
the
connector_data_1
routing@=”lazy
pink
rabbit”
will
be
connector_18
to
q2
only
will
be
connector_17
to
q2
once
although
this
routingkey
match
both
bind
key
of
q2
routingkey=”
connector_data_2
for
quick
brown
fox”
routingkey=”orange”
routingkey=”quick
orange
male
rabbit”
will
be
discard
because
they
do
not
match
any
bindingkey
headersexchanges
of
the
coding_keyword_3
type
do
not
rely
on
the
match
rule
of
connector_1
key
and
bind
key
to
connector_19
connector_data_1
but
match
accord
to
the
coding_keyword_3
attribute
in
the
content
of
the
connector_14
connector_data_1
specify
a
set
of
key
requirement_3
pair
when
bind
component_1
and
exchange
when
the
connector_data_1
be
connector_14
to
exchange
technology_1
will
connector_8
the
coding_keyword_3
of
the
connector_data_1
also
a
form
of
key
requirement_3
pair
and
compare
whether
the
key
requirement_3
pair
match
component_1
exactly
the
key
requirement_3
pair
specify
when
exchange
be
bind
if
it
match
exactly
the
connector_data_1
will
be
connector_18
to
the
component_1
otherwise
it
will
not
be
connector_18
to
the
component_1
this
type
of
exchange
have
not
be
use
but
it
should
be
useful
so
i
won’t
cover
it
rpcmq
itself
be
base
on
pattern_6
connector_data_1
component_15
in
the
previous
example
all
component_19
p
will
not
if
the
component_6
©
have
succeed
or
fail
after
connector_20
the
connector_data_1
to
technology_1
even
if
there
be
no
component_6
to
component_15
this
connector_data_1
do
not
at
all
however
in
the
actual
component_4
scenario
we
be
likely
to
need
some
synchronization
component_15
and
we
need
to
wait
for
the
component_7
to
component_15
my
connector_data_1
and
then
proceed
to
the
next
step
this
be
equivalent
to
pattern_7
remote
connector_data_6
pattern_7
be
also
support
in
technology_1
pattern_7
the
mechanism
connector_21
in
technology_1
be
when
the
component_8
connector_16
a
connector_data_7
connector_data_1
two
requirement_3
​​are
set
in
the
property
of
the
connector_data_1
messageproperties
in
the
technology_5
technology_2
define
in

property
these
property
will
be
connector_14
along
with
the
connector_data_1
replyto
a
component_1
name
that
tell
the
component_7
that
the
connector_data_8
will
be
connector_22
when
the
component_15
be
complete
my
connector_data_1
be
connector_14
to
this
component_1
and
correlationid
the
identification
number
of
this
connector_data_7
the
property
need
to
be
coding_keyword_5
after
the
component_7
component_15
be
complete
the
component_8
will
which
connector_data_7
be
successfully
connector_23
or
fail
accord
to
this
coding_keyword_6
the
component_7
connector_11
the
connector_data_1
and
component_20
it
after
the
component_7
finish
component_15
the
connector_data_1
it
will
generate
a
connector_data_9
connector_data_1
to
the
replytospecified
one
component_1
with
the
correlationid
attribute
at
the
same
time
the
component_8
have
subscribe
to
the
replyto
specify
one
component_1
after
connector_10
the
connector_24
connector_data_1
from
the
component_7
it
correlationid
analyze
which
connector_data_7
be
connector_23
accord
to
the
attribute
and
perform
subsequent
requirement_1
component_15
accord
to
the
connector_25
connector_data_10
to
sum
upthis
introduce
the
technology_1
concept
that
individual
consider
to
be
the
most
important
and
take
advantage
technology_1
of
the
capability
provide
to
handle
most
of
our
pattern_6
requirement_1
technology_1
selection
and
comparison1
from
activityaccording
to
the
current
connector_data_11
on
the
internet
technology_1
activem
and
the
technology_17
three
the
overall
pattern_8
technology_1
be
the
first
choice

persistent
connector_data_1
comparisonzeromq
not
support
technology_18
and
technology_1
both
be
support
persistence
connector_data_1
mainly
refer
to
the
mechanism
that
our
component_16
hang
under
the
circumstance
of
force
majeure
and
the
connector_data_1
will
not
be
lose

comprehensive
technology_19
implementationreliability
quality_attribute_10
connector_18
cluster
transaction
highly
quality_attribute_11
component_1
connector_data_1
sequence
issue
track
visual
requirement_4
technology_20
plug
in
component_10
and
more
technology_1
technology_21
best
technology_18
second
technology_22
worst
of

technology_22
you
can
do
it
but
you
must
manually
connector_2
the
to
achieve
it
the
amount
of
be
not
small
especially
in
quality_attribute_2
persistence
delivery
confirmation
pattern_9
verification
and
high
quality_attribute_6

high
concurrencyundoubtedly
the
technology_1
high
reason
be
that
it
implementation
technology_23
be
a
technology_23
that
be
naturally
high
and
concurrently
quality_attribute_11
technology_6

comparison
of
concern
technology_1
and
kafkarabbitmq
more
technology_21
mature
than
in
term
of
quality_attribute_12
quality_attribute_13
and
quality_attribute_2
technology_1
be
quality_attribute_1
than
technology_21
theoretically
in
addition
technology_21
the
position
be
mainly
in
the
requirement_5
and
so
on
because
technology_21
the
original
intention
of
the
design
be
to
component_15
the
requirement_5
it
can
be
regard
a
an
important
component_5
of
a
requirement_5
connector_data_1
component_10
and
the
pertinence
be
very
strong
so
if
the
requirement_1
aspect
be
still
recommend
technology_1
also
technology_21
the
requirement_6
quality_attribute_14
tps
be
technology_1
much
high
than
that
final
selection
if
we
already
have
technology_21
or
technology_1
in
our
component_10
and
can
fully
satisfy
the
current
requirement_1
it
be
recommend
not
to
repeat
and
wheel
you
can
choose
one
of
technology_21
and
technology_1
for
your
team
and
requirement_1
this
be
the
most
important
however
there
be
no
doubt
that
at
this
stage
there
be
no
third
choice
for
comprehensive
consideration
more
from
mina
ayoubfollowi
m
enthusiastic
about
be
part
of
something
great
than
myself
and

from
more
experience
people
every
time
i
meet
them
love
podcast
or
audiobooks
on
the
go
with
our
component_21
try
knowableabouthelptermsprivacyget
the
appget
startedmina
ayoub830
followersi
m
enthusiastic
about
be
part
of
something
great
than
myself
and

from
more
experience
people
every
time
i
meet
them
followmore
from
mediumajin
sunnypush
cdn
vs
connector_26
cdnsujata
regotiasync
component_15
apijosué
carvajalan
overview
of
connector_data_1
brokersriker
guevara
ph
dlist
base
stackhelpstatuswritersblogcareersprivacytermsaboutknowable
