component_1
of
pattern_1
architecture
for
beginner
|
by
anubala
balasaravanakumar
|
mediumget
unlimited
accessopen
in
apphomenotificationslistsstorieswriteanubala
balasaravanakumarfollowapr

2019·6
min
readcomponents
of
pattern_1
architecture
for
beginnersas
the
name
tell
run
your
component_2
a
small
independent
separate
loosely
couple
component_3
be
connector_1
a
pattern_2
architecture
msa
each
component_4
have
it
own
functional
or
logical
boundary
so
that
it
can
be
quality_attribute_1
and
in
requirement_1
of
upgrade
a
component_5
or
fix
bug
in
a
component_5
it
not
necessary
to
restart
the
entire
component_2
only
the
component_4
which
be
modify
can
be
restart
and
particlularly
a
monolithic
component_2
be
develop
base
on
a
single
programming
technology_1
in
msa
it
possible
to
use
the
best
programming
technology_1
for
specific
requirement_2
for
example
if
you
be
make
a
requirement_3
component_2
use
technology_2
you
can
make
component_6
side
component_7
use
nodejs
since
nodejs
be
quality_attribute_2
in
deal
with
component_7
than
technology_2
which
be
quality_attribute_2
for
machine_learningcomparison
monolith
vs
pattern_2
architecturefor
a
beginner
to
quality_attribute_3
a
pattern_1
architectute
here
be
a
quick
gist
of
the
different
opensource
component_1
that
can
be
use
technology_3
technology_3
be
a
document
base
opensource
storage
quality_attribute_4
component_8
which
be
one
of
the
highly
use
db
by
fullstack
developer
connector_data_1
be
component_9
in
technology_4
technology_5
the
document
be
schema
le
mean
the
technology_4
connector_data_2
can
vary
from
document
to
document
mongodbmongodb
be
highly
quality_attribute_5
too
and
it
support
a
lot
of
programming
technology_1
technology_6
technology_7
technology_8
technology_9
technology_10
j
technology_11
technology_12
technology_2
technology_13
technology_14
go
and
technology_15
install
and
use
technology_3
from
technology_16
doc
technology_3
technology_17
manual
installation
for
documentation
technology_16
doc
technology_3
technology_17
_ga=2




1552390234elasticsearch
elasticsearch
be
a
standalone
component_8
which
make
‘search’
easy
it
be
a
full
text
search
component_10
base
on
technology_18
develop
in
technology_9
elasticsearch
can
be
cluster
in
different
technology_10
which
act
a
a
failover
mechanism
there
be
automatic
backup
in
requirement_1
of
failover
use
the
concept
of
replica
elastic
also
support
a
quality_attribute_2
number
of
programming
technology_1
technology_9
technology_2
net
technology_8
technology_12
technology_19
etc
kibana
be
a
technology_20
use
to
visualize
what
be
inside
elasticsearch
use
different
visualization
technique
graph
piecharts
histogram
sunburst
requirement_4
etc
you
can
make
your
custom
visualization
component_1
use
vega
grammar
logstash
be
a
technology_20
use
to
ingest
connector_data_1
from
different
component_11
into
elasticsearch
logstash
support
a
variety
of
input
plugins
technology_16
graphite
pattern_3
technology_21
technology_22
kinesis
technology_23
technology_24
technology_25
etc
and
a
lot
more
can
easily
ingest
connector_data_1
from
our
requirement_5
metric
datasources
component_3
etc
continuously
and
simultaneously
to
play
with
elasticsearch
refer
technology_16
www
elastic
co
technology_22
technology_22
be
an
component_12
component_13
which
work
base
on
pattern_4
technique
there
can
be
multiple
component_14
publish
to
a
topic
on
technology_22
and
there
can
be
multiple
component_15
subscribe
to
a
topic
kafkaall
transaction
happen
via
the
component_12
hence
avoid
the
web

random
connector_2
between
component_4
use
technology_22
make
the
architecture
more
clean
and
quality_attribute_6
to
more
about
technology_22
refer
technology_16
technology_22
technology_26

introjenkins
technology_27
be
an
automation
technology_20
that
enable
continuous
requirement_6
and
continuous
deployment
ci
cd
you
can
have
multiple
stage
in
a
technology_27
pipeline
to
build
test
approve
connector_3
or
quality_attribute_3
a
or
project
jenkinsjenkins
support
hundred
of
plugins
to
easily
quality_attribute_7
with
almost
every
technology_20
use
for
requirement_6
refer
technology_27
at
technology_16
technology_27
io
technology_28
all
the
component_16
you
develop
be
to
be
quality_attribute_3
a
container
there
be
many
containerize
technology_20
supergiant
portainer
sysdig
etc
but
technology_28
be
lead
the
requirement_7
when
you
develop
an
component_2
you
will
have
an
environment
when
you
quality_attribute_3
the
environment
vary
technology_28
container
act
a
virtual
component_17
there
be
many
difference
though
and
provide
a
environment
define
in
the
env

so
that
your
component_2
run
in
all
the
component_18
in
the
same
environment
avoid
deployment
issue
moreover
it
reduce
the
number
of
step
involve
in
quality_attribute_3
the
component_2
and
replace
with
a
single
step
dockeryou
will
connector_4
all
the
step
installation
and
to
be
follow
in
a
dockerfile
when
you
have
multiple
container
you
use
a
technology_28
compose
yml
to
start
all
container
simultaneously
you
can
find
many
image
in
dockerhub
you
can
use
those
image
from
technology_16
hub
technology_28
technology_17
install
and
use
technology_28
from
technology_16
www
technology_28
technology_17
technology_29
kuberneteswhen
there
be
thousand
of
component_3
run
a
container
there
need
to
be
an
component_10
to
pattern_5
the
component_19
open
component_20
the
technology_29
component_21
in

that
enable
autoscaling
of
container
automatic
deployment
and
manage
container
you
can
connector_5
about
kuberenetes
in
technology_16
technology_29
io
jaeger
jaeger
be
an
open
component_20
end
to
end
quality_attribute_4
trace
technology_20
debug
a
monolith
component_2
be
more
easy
than
a
quality_attribute_4
architecture
in
the
latter
you
have
to
figure
out
connector_6
between
the
component_4
jaegerjaeger
be
an
excellent
technology_20
to
do
that
jaeger
can
pattern_6
quality_attribute_4
transaction
find
quality_attribute_8
of
each
and
help
in
requirement_8
optimization
give
a
root
cause
analysis
give
you
the
connector_6
between
component_4
and
etc
trace
from
technology_16
www
jaegertracing
io
fluentd
requirement_5
be
very
important
in
any
component_2
but
in
a
pattern_2
architecture
where
you
have
multiple
component_3
run
independently
the
requirement_5
be
incomplete
and
discontinuous
unless
they
be
extract
into
a
single
pattern_7
fluentd
be
an
open
component_20
connector_data_1
collector
and
provide
a
single
requirement_5
pattern_7
fluentdthis
allow
you
to
understand
what
be
happen
in
the
component_2
quality_attribute_2
you
can
connector_7
requirement_5
from
anything
component_13
requirement_5
web
requirement_5
technology_30
requirement_5
sensor
connector_data_1
etc
and
aggregate
them
into
any
datasource
elasticsearch
technology_3
etc
you
can
about
fluentd
in
technology_16
www
fluentd

prometheus
pattern_6
be
very
important
when
an
component_2
be
quality_attribute_3
to
connector_8
if
everything
be
work
fine
prometheus
be
a
time
series
connector_data_1
component_9
which
scrap
metric
from
your
component_2
and
display
it
a
a
graph
prometheuspromql
be
the
query
technology_1
for
prometheus
there
be
already
exporter
for
many
component_16
elasticsearch
haproxy
statsd
etc
and
prometheus
support
inbuilt
requirement_6
to
connector_9
these
third
party
connector_data_1
there
be
also
alerting
mechanism
connector_9
prometheus
at
technology_16
prometheus
io
grafana
how
interest
it
would
be
to
have
a
lot
of
colorful
visualization
for
our
pattern_8
component_2
yes
grafana
be
a
open
component_21
for
beautiful
requirement_9
and
pattern_6
which
provide
many
visualization
technique
graph
counter
histogram
component_22
etc
for
the
metric
extract
by
prometheus
a
sample
grafana
dashboardyou
can
alert
the
component_23
if
a
metric
cross
a
threshold
there
be
many
requirement_10
quality_attribute_9
already
and
you
can
the
requirement_10
technology_31
and
use
it
connector_9
grafana
at
technology_16
grafana
technology_17
technology_30
technology_30
act
a
a
reverse
pattern_9
and
act
a
a
single
entry
point
where
all
the
component_24
connector_data_3
be
make
via
technology_30
it
help
in
load
balance
pattern_10
webserving
etc
nginxin
addition
to
it
technology_16
component_6
capability
technology_30
can
also
a
a
pattern_9
component_6
for
technology_21
pop3
and
technology_32
and
a
reverse
pattern_9
and
load
balancer
for
technology_16
technology_33
and
technology_34
component_6
—
—
—
—
—
—
—
—
—
i
have
almost
cover
all
component_1
to
build
a
single
end
to
end
pattern_2
architecture
leave
out
frontend
though
for
a
beginner
this
would
be
helpful
for
sure
and
there
be
a
lot
more
to
talk
about
msa
and
lot
more
component_1
be
require
to
support
a
pucca
pattern_2
architecture
which
you
can
a
you
develop
more
from
anubala
balasaravanakumarfollowmommy
bloggerlove
podcast
or
audiobooks
on
the
go
with
our
component_25
try
knowablerecommended
from
mediumakshay
papnejasign
in
with
in
flutter
use
getx
state
managementtyler
smallwoodday

wall
jump
in
unityborja
miguel
peñuelas
moralesdevelop
bluetooth
multirole
component_16
with
nrf5
chip
and
perform
in
circuit
debuggingenrico
portolaneasy
technology_35
setup
with
technology_36
transfer
familymehmet
batuhan
ulperinhuawei
developerswhat
huawei
requirement_9
offersdynamic
technology_2
developerinpython
in
plain
englishbashing
gitarif
khaninproandroiddevrecyclerview
pro
tip
—
part
2james
westinnerd
for
techadding
an
rpg
style
shop
part

abouthelptermsprivacyget
the
appget
startedanubala
balasaravanakumar39
followersmommy
bloggerfollowmore
from
mediumvedran
cindric11
best
practice
for
connector_10
component_24
documentationanifowoseihechiinstackanatomyokta
vs
other
pattern_11
pattern_12
managerscheulong
searwhat
be
playwright
cross
browser
automation
technology_37
for
end
to
end
testingdebajyoti
duttaincommutatushow
to
rescue
multiple
exception
with
technology_38
exceptionhelpstatuswritersblogcareersprivacytermsaboutknowable
