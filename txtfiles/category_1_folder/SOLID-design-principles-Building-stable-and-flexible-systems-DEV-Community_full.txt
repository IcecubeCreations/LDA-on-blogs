solid
design
principle
build
quality_attribute_1
and
quality_attribute_2
component_1
dev
skip
to
content
navigation
search
search
requirement_1
in
create
account
dev
close
dev
be
a
of


amaze
developer
we
re
a
place
where
coder
connector_1
stay
up
to
date
and
grow
their
career
create
account
requirement_1
in
home
connector_data_1
podcast
video
tag
faq
forem
shop
sponsor
about
other
of
conduct
privacy
requirement_2
term
of
use
twitter
technology_1
technology_2
twitch
more
copy
connector_2
copy
connector_2
copy
to
clipboard
connector_1
to
twitter
connector_1
to
linkedin
connector_1
to
reddit
connector_1
to
hacker
news
connector_1
to
report
abuse
anna
monus

on
feb


solid
design
principle
build
quality_attribute_1
and
quality_attribute_2
component_1
#java
#beginners
#designpatterns
#architecture
to
build
quality_attribute_1
and
quality_attribute_2

we
need
to
keep
design
principle
in
mind
have
error
free
be
essential
however
well
design
architecture
be
a
important
solid
be
one
of
the
most
well

set
of
design
principle
it
can
help
you
avoid
common
pitfall
and
think
about
your
apps’
architecture
from
a
high
level
what
be
solid
design
principle
solid
design
principle
be
five
design
principle
that
enable
you
to
connector_3
quality_attribute_3
connector_data_2
orient


about
oop
principle
abstraction
pattern_1
inheritance
and
polymorphism
be
important
but
how
would
you
use
them
in
your
everyday
work
solid
design
principle
have
become
so
popular
in
recent
year
because
they
answer
this
question
in
a
straightforward
way
the
solid
name
be
a
mnemonic
acronym
where
each
letter
represent
a
design
principle
a
follow
s
for
single
responsibility
principle
o
for
open
close
principle
l
for
liskov
substitution
principle
i
for
segregation
principle
technology_3
for
connector_4
inversion
principle
the
five
principle
overlap
here
and
there
and
programmer
use
them
broadly
solid
principle
lead
to
more
quality_attribute_2
and
quality_attribute_1
architecture
that’s
easy
to
maintain
and
extend
and
le
likely
to
break
single
responsibility
principle
the
single
responsibility
principle
be
the
first
solid
design
principle
represent
by
the
letter
“s”
and
define
by
robert
technology_4
martin
it
state
that
in
a
well
design
component_2
each
pattern_2

should
have
only
one
single
responsibility
responsibility
be
use
in
the
sense
of
have
only
one
reason
to
connector_5
when
a
handle
more
than
one
responsibility
any
connector_6
make
to
the
requirement_3
might
affect
others
this
be
bad
enough
if
you
have
a
small
component_3
but
can
become
a
nightmare
when
you
work
with
complex
requirement_4
level

by
make
sure
that
each
pattern_3
only
one
responsibility
you
can
connector_7
a
lot
of
test
time
and
create
a
more
quality_attribute_4
architecture
example
of
the
single
responsibility
principle
let’s
see
an
example
i’ll
use
technology_5
but
you
can
apply
solid
design
principle
to
any
other
oop
technology_6
too
say
we
be
connector_8
a
technology_5
component_2
for
a
book
component_4
we
create
a
book
that

component_5
connector_9
and
set
the
title
and
author
of
each
book
and
search
the
book
in
the
inventory
book
{
title
author
gettitle
{
title
}
settitle

title
{
this
title
=
title
}
getauthor
{
author
}
setauthor

author
{
this
author
=
author
}
searchbook
{
}
}
enter
fullscreen
mode
exit
fullscreen
mode
however
the
above
violate
the
single
responsibility
principle
a
the
book
have
two
responsibility
first
it
set
the
connector_data_3
relate
to
the
book
title
and
author
second
it
search
for
the
book
in
the
inventory
the
setter
connector_5
the
book
connector_data_2
which
might
cause
problem
when
we
want
to
search
the
same
book
in
the
inventory
to
apply
the
single
responsibility
principle
we
need
to
decouple
the
two
responsibility
in
the
refactored

the
book
will
only
be
responsible
for
connector_10
and
set
the
connector_data_3
of
the
book
connector_data_2
book
{
title
author
gettitle
{
title
}
settitle

title
{
this
title
=
title
}
getauthor
{
author
}
setauthor

author
{
this
author
=
author
}
}
enter
fullscreen
mode
exit
fullscreen
mode
then
we
create
another
connector_11
inventoryview
that
will
be
responsible
for
connector_12
the
inventory
we
move
the
searchbook
here
and
reference
the
book
in
the
constructor
inventoryview
{
book
book
inventoryview
book
book
{
this
book
=
book
}
searchbook
{
}
}
enter
fullscreen
mode
exit
fullscreen
mode
on
the
uml
diagram
below
you
can
see
how
the
architecture
connector_5
after
we
refactored
the
follow
the
single
responsibility
principle
we
split
the
initial
book
that
have
two
responsibility
into
two

each
have
it
own
single
responsibility
open
close
principle
the
open
close
principle
be
the
“o”
of
solid’s
five
design
principle
it
be
bertrand
meyer
who
coin
the
term
in
his
book
“object
orient
construction”
the
open
close
principle
state
that


pattern_4
and
other
unit
should
be
open
for
extension
but
close
for
modification
so
you
should
be
able
to
extend
your
exist
use
oop
feature
inheritance
via
subclass
and

however
you
should
never
modify


and
other
unit
that
already
exist
especially
if
you
use
them
in
production
a
it
can
lead
to
unexpected
behavior
if
you
a
feature
by
extend
your
rather
than
modify
it
you
minimize
the
risk
of
failure
a
much
a
possible
besides
you
also
don’t
have
to
unit
test
exist
requirement_3
example
of
the
open
close
principle
let’s
stay
with
our
book
component_4
example
now
the
component_4
want
to
hand
out
cookbook
at
a
discount
requirement_5
before
christmas
we
already
follow
the
single
responsibility
principle
so
we
create
two
separate

cookbookdiscount
to
hold
the
detail
of
the
discount
and
discountmanager
to
apply
the
discount
to
the
requirement_5
cookbookdiscount
{
getcookbookdiscount
{
discount
=
30%
between
dec

and

discount
}
}
discountmanager
{
processcookbookdiscount
cookbookdiscount
discount
{
}
}
enter
fullscreen
mode
exit
fullscreen
mode
this
work
fine
until
the
component_4
requirement_6
inform
u
that
their
cookbook
discount
sale
be
so
successful
that
they
want
to
extend
it
now
they
want
to
hand
out
every
biography
with
a
50%
discount
on
the
subject’s
birthday
to
the
feature
we
create
a
biographydiscount

biographydiscount
{
getbiographydiscount
{
discount
=
50%
on
the
subject
s
birthday
discount
}
}
enter
fullscreen
mode
exit
fullscreen
mode
to
component_6
the
type
of
discount
we
need
to
the
requirement_3
to
the
discountmanager

too
discountmanager
{
processcookbookdiscount
cookbookdiscount
discount
{
}
processbiographydiscount
biographydiscount
discount
{
}
}
enter
fullscreen
mode
exit
fullscreen
mode
however
a
we
connector_5
exist
requirement_3
we
violate
the
open
close
principle
although
the
above
work
properly
it
might
vulnerability
to
the
component_2
we
don’t
how
the
addition
would
connector_13
with
other
part
of
the
that
quality_attribute_5
on
the
discountmanager

in
a
real
world
component_2
this
would
mean
that
we
need
to
test
and
quality_attribute_6
our
entire
component_3
again
but
we
can
also
choose
to
refactor
our
by

an
extra
pattern_5
of
abstraction
that
represent
all
type
of
discount
so
let’s
create
a
connector_11
bookdiscount
that
the
cookbookdiscount
and
biographydiscount
will
connector_14
bookdiscount
{
getbookdiscount
}
cookbookdiscount
connector_15
bookdiscount
{
@override
getbookdiscount
{
discount
=
30%
between
dec

and

discount
}
}
biographydiscount
connector_15
bookdiscount
{
@override
getbookdiscount
{
discount
=
50%
on
the
subject
s
birthday
discount
}
}
enter
fullscreen
mode
exit
fullscreen
mode
now
discountmanager
can
refer
to
the
bookdiscount
instead
of
the
concrete

when
the
processbookdiscount
be
connector_data_4
we
can
pass
both
cookbookdiscount
and
biographydiscount
a
an
argument
a
both
be
the
implementation
of
the
bookdiscount

discountmanager
{
processbookdiscount
bookdiscount
discount
{
}
}
enter
fullscreen
mode
exit
fullscreen
mode
the
refactored
follow
the
open
close
principle
a
we
could
the
cookbookdiscount
without
modify
the
exist
base
this
also
mean
that
in
the
future
we
can
extend
our
component_3
with
other
discount
type
for
instance
with
crimebookdiscount
the
uml
graph
below
show
how
our
example
look
before
and
after
the
refactoring
on
the
leave
you
can
see
that
discountmanager
quality_attribute_5
on
the
cookbookdiscount
and
biographydiscount

on
the
right
all
three
quality_attribute_5
on
the
bookdiscount
abstract
pattern_5
discountmanager
reference
it
while
cookbookdiscount
and
biographydiscount
connector_14
it
liskov
substitution
principle
the
liskov
substitution
principle
be
the
third
principle
of
solid
represent
by
the
letter
“l”
it
be
barbara
liskov
who
introduce
the
principle
in

in
her
conference
keynote
talk
“data
abstraction”
the
original
phrasing
of
the
liskov
substitution
principle
be
a
bit
complicate
a
it
assert
that
“in
a
component_7
component_8
if
s
be
a
subtype
of
t
then
connector_data_5
of
type
t
be
replace
with
connector_data_5
of
type
s
i
e
connector_data_5
of
type
s
substitute
connector_data_5
of
type
t
without
alter
any
of
the
desirable
property
of
that
component_8
quality_attribute_7
connector_data_6
perform
etc
”
in
layman’s
term
it
state
that
an
connector_data_2
of
a
superclass
should
be
replaceable
by
connector_data_5
of
it
subclass
without
cause
issue
in
the
component_2
so
a
child
should
never
connector_5
the
characteristic
of
it
parent
such
a
the
argument
connector_data_1
and
type
you
can
connector_14
the
liskov
substitution
principle
by
pay
attention
to
the
correct
inheritance
hierarchy
example
of
the
liskov
substitution
principle
now
the
book
component_4
ask
u
to
a
delivery
requirement_3
to
the
component_2
so
we
create
a
bookdelivery
that
inform
requirement_7
about
the
number
of
location
where
they
can
connector_16
their
order
bookdelivery
{
title
userid
getdeliverylocations
{
}
}
enter
fullscreen
mode
exit
fullscreen
mode
however
the
component_4
also
sell
fancy
hardcover
they
only
want
to
connector_17
to
their
high
street
shop
so
we
create
a
hardcoverdelivery
subclass
that
extend
bookdelivery
and
override
the
getdeliverylocations
with
it
own
requirement_3
hardcoverdelivery
extend
bookdelivery
{
@override
getdeliverylocations
{
}
}
enter
fullscreen
mode
exit
fullscreen
mode
late
the
component_4
ask
u
to
create
delivery
requirement_3
for
audiobooks
too
now
we
extend
the
exist
bookdelivery
with
an
audiobookdelivery
subclass
but
when
we
want
to
override
the
getdeliverylocations

we
realize
that
audiobooks
can’t
be
connector_17
to
physical
location
audiobookdelivery
extend
bookdelivery
{
@override
getdeliverylocations
{
*
can
t
be
connector_14
*
}
}
enter
fullscreen
mode
exit
fullscreen
mode
we
could
connector_5
some
characteristic
of
the
getdeliverylocations

however
that
would
violate
the
liskov
substitution
principle
after
the
modification
we
couldn’t
replace
the
bookdelivery
superclass
with
the
audiobookdelivery
subclass
without
break
the
component_2
to
solve
the
problem
we
need
to
fix
the
inheritance
hierarchy
let’s
introduce
an
extra
pattern_5
that
quality_attribute_8
differentiate
book
delivery
type
the
offlinedelivery
and
onlinedelivery
split
up
the
bookdelivery
superclass
we
also
move
the
getdeliverylocations
to
offlinedelivery
and
create
a
getsoftwareoptions
for
the
onlinedelivery
a
this
be
more
suitable
for
online
delivery
bookdelivery
{
title
userid
}
offlinedelivery
extend
bookdelivery
{
getdeliverylocations
{
}
}
onlinedelivery
extend
bookdelivery
{
getsoftwareoptions
{
}
}
enter
fullscreen
mode
exit
fullscreen
mode
in
the
refactored

hardcoverdelivery
will
be
the
child
of
offlinedelivery
and
it
will
override
the
getdeliverylocations
with
it
own
requirement_3
audiobookdelivery
will
be
the
child
of
onlinedelivery
which
be
quality_attribute_8
news
a
now
it
doesn’t
have
to
deal
with
the
getdeliverylocations

instead
it
can
override
the
getsoftwareoptions
of
it
parent
with
it
own
implementation
for
instance
by
connector_data_1
and
embed
quality_attribute_9
audio
player
hardcoverdelivery
extend
offlinedelivery
{
@override
getdeliverylocations
{
}
}
audiobookdelivery
extend
onlinedelivery
{
@override
getsoftwareoptions
{
}
}
enter
fullscreen
mode
exit
fullscreen
mode
after
the
refactoring
we
could
use
any
subclass
in
place
of
it
superclass
without
break
the
component_2
on
the
uml
graph
below
you
can
see
that
by
apply
the
liskov
substitution
principle
we

an
extra
pattern_5
to
the
inheritance
hierarchy
while
the
architecture
be
more
complex
it
provide
u
with
a
more
quality_attribute_2
design
segregation
principle
the
segregation
principle
be
the
fourth
solid
design
principle
represent
by
the
letter
“i”
in
the
acronym
it
be
robert
technology_4
martin
who
first
define
the
principle
by
state
that
“clients
should
not
be
force
to
quality_attribute_5
on
they
don’t
use
”
by
component_9
he
mean
that
connector_14

in
other
word
shouldn’t
include
too
many
requirement_3
the
violation
of
segregation
principle
harm
readability
and
force
programmer
to
connector_3
dummy
that
do
nothing
in
a
well
design
component_2
you
should
avoid
pollution
also
connector_11
fat

the
solution
be
to
create
small
that
you
can
connector_14
more
flexibly
example
of
the
segregation
principle
let’s
some
component_10
action
to
our
online
bookstore
so
that
requirement_7
can
connector_13
with
the
content
before
make
a
purchase
to
do
so
we
create
an
connector_11
bookaction
with
three

seereviews
searchsecondhand
and
listensample
bookaction
{
seereviews
searchsecondhand
listensample
}
enter
fullscreen
mode
exit
fullscreen
mode
then
we
create
two

hardcoverui
and
an
audiobookui
that
connector_14
the
bookaction
with
their
own
requirement_3
hardcoverui
connector_15
bookaction
{
@override
seereviews
{
}
@override
searchsecondhand
{
}
@override
listensample
{
}
}
audiobookui
connector_15
bookaction
{
@override
seereviews
{
}
@override
searchsecondhand
{
}
@override
listensample
{
}
}
enter
fullscreen
mode
exit
fullscreen
mode
both
quality_attribute_5
on
they
don’t
use
so
we
have
break
the
segregation
principle
hardcover
book
can’t
be
listen
to
so
the
hardcoverui
doesn’t
need
the
listensample

similarly
audiobooks
don’t
have
second
hand
copy
so
the
audiobookui
doesn’t
need
it
either
however
a
the
bookaction
include
these

all
of
it
dependent
have
to
connector_14
them
in
other
word
bookaction
be
a
pollute
that
we
need
to
segregate
let’s
extend
it
with
two
more
specific
sub

hardcoveraction
and
audioaction
bookaction
{
seereviews
}
hardcoveraction
extend
bookaction
{
searchsecondhand
}
audioaction
extend
bookaction
{
listensample
}
enter
fullscreen
mode
exit
fullscreen
mode
now
the
hardcoverui
can
connector_14
the
hardcoveraction
and
the
audiobookui
can
connector_14
the
audioaction

this
way
both
can
connector_14
the
seereviews
of
the
bookaction
super

however
hardcoverui
doesn’t
have
to
connector_14
the
irrelevant
listensample
and
audioui
doesn’t
have
to
connector_14
searchsecondhand
either
hardcoverui
connector_15
hardcoveraction
{
@override
seereviews
{
}
@override
searchsecondhand
{
}
}
audiobookui
connector_15
audioaction
{
@override
seereviews
{
}
@override
listensample
{
}
}
enter
fullscreen
mode
exit
fullscreen
mode
the
refactored
follow
the
segregation
principle
a
neither
quality_attribute_5
on
they
don’t
use
the
uml
diagram
below
excellently
show
that
the
segregate
lead
to
quality_attribute_10
that
only
connector_14
the
they
really
need
connector_4
inversion
principle
the
connector_4
inversion
principle
be
the
fifth
solid
design
principle
represent
by
the
last
“d”
and
introduce
by
robert
technology_4
martin
the
goal
of
the
connector_4
inversion
principle
be
to
avoid
tightly
couple

a
it
easily
break
the
component_2
the
principle
state
that
“high
level
should
not
quality_attribute_5
on
low
level

both
should
quality_attribute_5
on
abstraction
”
“abstractions
should
not
quality_attribute_5
on
detail
detail
should
quality_attribute_5
on
abstraction
”
in
other
word
you
need
to
decouple
high
level
and
low
level

high
level
usually
pattern_3
complex
component_11
while
low
level
include
connector_data_3
or
utility
typically
most
people
would
want
to
make
high
level
quality_attribute_5
on
low
level

however
accord
to
the
connector_4
inversion
principle
you
need
to
invert
the
connector_4
otherwise
when
the
low
level
be
replace
the
high
level
will
be
affect
too
a
a
solution
you
need
to
create
an
abstract
pattern_5
for
low
level

so
that
high
level
can
quality_attribute_5
on
abstraction
rather
than
concrete
implementation
robert
technology_4
martin
also
mention
that
the
connector_4
inversion
principle
be
a
specific
combination
of
the
open
close
and
liskov
substitution
principle
example
of
the
connector_4
inversion
principle
now
the
book
component_4
ask
u
to
build
a
feature
that
enable
requirement_7
to
put
their
favorite
book
on
a
shelf
to
connector_14
the
requirement_3
we
create
a
lower
level
book
and
a
high
level
shelf

the
book
will
allow
component_5
to
see
review
and
connector_18
a
sample
of
each
book
they
component_4
on
their
shelf
the
shelf
will
them
a
book
to
their
shelf
and
customize
the
shelf
book
{
seereviews
{
}
readsample
{
}
}
shelf
{
book
book
addbook
book
book
{
}
customizeshelf
{
}
}
enter
fullscreen
mode
exit
fullscreen
mode
everything
look
fine
but
a
the
high
level
shelf
quality_attribute_5
on
the
low
level
book
the
above
violate
the
connector_4
inversion
principle
this
become
clear
when
the
component_4
ask
u
to
enable
requirement_7
to
dvd
to
their
shelf
too
to
fulfill
the
demand
we
create
a
dvd

dvd
{
seereviews
{
}
watchsample
{
}
}
enter
fullscreen
mode
exit
fullscreen
mode
now
we
should
modify
the
shelf
so
that
it
can
connector_19
dvd
too
however
this
would
clearly
break
the
open
close
principle
the
solution
be
to
create
an
abstraction
pattern_5
for
the
lower
level
book
and
dvd
we’ll
do
so
by
introduce
the
technology_7
that
both
will
connector_14
technology_7
{
seereviews
getsample
}
book
connector_15
technology_7
{
@override
seereviews
{
}
@override
getsample
{
}
}
dvd
connector_15
technology_7
{
@override
seereviews
{
}
@override
getsample
{
}
}
enter
fullscreen
mode
exit
fullscreen
mode
now
shelf
can
reference
the
technology_7
instead
of
it
implementation
book
and
dvd
the
refactored
also
allow
u
to
late
introduce
technology_7
type
for
instance
magazine
that
requirement_7
can
put
on
their
shelf
too
shelf
{
technology_7
technology_7
addproduct
technology_7
technology_7
{
}
customizeshelf
{
}
}
enter
fullscreen
mode
exit
fullscreen
mode
the
above
also
follow
the
liskov
substitution
principle
a
the
technology_7
type
can
be
substitute
with
both
of
it
subtypes
book
and
dvd
without
break
the
component_8
at
the
same
time
we
have
also
connector_14
the
connector_4
inversion
principle
a
in
the
refactored

high
level
don’t
quality_attribute_5
on
low
level

either
a
you
can
see
on
the
leave
of
the
uml
graph
below
the
high
level
shelf
quality_attribute_5
on
the
low
level
book
before
the
refactoring
without
apply
the
connector_4
inversion
principle
we
should
make
it
quality_attribute_5
on
the
low
level
dvd

too
however
after
the
refactoring
both
the
high
level
and
low
level
quality_attribute_5
on
the
abstract
technology_7
shelf
refer
to
it
while
book
and
dvd
connector_14
it
how
should
you
connector_14
solid
design
principle
connector_20
the
solid
design
principle
increase
the
overall
complexity
of
a
base
but
it
lead
to
more
quality_attribute_2
design
besides
monolithic
component_12
you
can
also
apply
solid
design
principle
to
pattern_4
where
you
can
treat
each
pattern_2
a
a
standalone

a
in
the
above
example
when
you
break
a
solid
design
principle
technology_5
and
other
compile
technology_6
might
throw
an
exception
but
it
doesn’t
always
happen
architecture
problem
be
hard
to
detect
but
advance
diagnostic
such
a
apm
technology_8
can
provide
you
with
many
useful
hint
discussion

subscribe
connector_21
image
template
editor
guide
personal
moderator
create
template
template
you
quickly
answer
faq
or
component_4
snippet
for
re
use
submit
preview
dismiss
collapse
expand
kamal
kamal
kamal
follow
fullstack
developer
location
indonesia
join
jun


•
feb


dropdown
copy
connector_2
hide
after
a
year
of

practice
on
my
university
this
one
finally

me
understand
the
solid
principle
thanks
anna




connector_data_7
collapse
expand
mijo
mijo
mijo
follow
lifelong
learner
◈
full
technology_9
developer
work
full
technology_9
dev
at
kraftbit
join
jan


•
feb


dropdown
copy
connector_2
hide
bookmarked
high
quality
content
thanks




connector_data_7
collapse
expand
david
jiang
david
jiang
david
jiang
follow
ever
hear
about

day
of
cod
challenge
join
feb


•
mar


dropdown
copy
connector_2
hide
best
i
have
see
in
a
while
👍👍✨✨



connector_data_7
collapse
expand
marcelo
faundez
marcelo
faundez
marcelo
faundez
follow
join


•
feb


dropdown
copy
connector_2
hide
very
quality_attribute_8
explain
thanks
so
much




connector_data_7
collapse
expand
icarus
bro
icarus
bro
icarus
bro
follow
join


•
feb


dropdown
copy
connector_2
hide
great
o



connector_data_7
of
conduct
•
report
abuse
be
you
sure
you
want
to
hide
this

it
will
become
hide
in
your

but
will
still
be
visible
via
the

s
permalink
hide
child

a
well
confirm
for
further
action
you
consider
pattern_6
this
person
and
or
report
abuse
connector_18
next
graphql
yoga


a
light
but
fully
feature
graphql
component_13
tomek
poniatowicz

connector_data_8
in
technology_10
kibet
amos

work
with
date
technology_5
8+
joao
carlos
sousa
do
vale

connector_10
the
foundation
ready
for
web3
suraj
vishwakarma

anna
monus
follow
technical
writer
and
editor
cover
web
development
frontend
&
backend
ux
design
tech
requirement_8
accessiblity
etc
location
spain
work
technical
writer
join
feb


trend
on
dev
pattern_7
should
every
developer
become
a
senior
#career
#discuss
#watercooler
which
day
of
the
week
do
you
connector_9
your
best
cod
work
do
#discuss
#productivity
discussion
what
be
your
perfect
work
environment
#os
#webdev
#programming
#productivity
dev
—
a
constructive
and
inclusive
social
requirement_9
for
developer
with
you
every
step
of
your
journey
build
on
forem
—
the
open_source
that
power
dev
and
other
inclusive

make
with
love
and
technology_11
on
rail
dev
©


forem
logo
we
re
a
place
where
coder
connector_1
stay
up
to
date
and
grow
their
career
requirement_1
in
create
account
