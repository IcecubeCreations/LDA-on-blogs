technology_1
vs
technology_2
part
two
different
take
on
pattern_1
—
jack
vanlightly
archive
connector_1
sketch
about
me
jack
vanlightly
archive
connector_1
sketch
about
me
jack
vanlightly
pattern_1
component_1
technology_1
vs
technology_2
part
two
different
take
on
pattern_1
jack
vanlightly
pattern_1
component_1
in
this
part
we
ll
explore
what
technology_1
and
technology_3
technology_2
be
and
their
approach
to
connector_data_1
each
technology_4
have
make
very
different
decision
regard
every
aspect
of
their
design
each
with
strength
and
weakness
we
ll
not
come
to
any
strong
conclusion
in
this
part
instead
think
of
this
a
a
primer
on
the
technology_4
so
we
can
dive
deep
in
subsequent
part
of
the
series
rabbitmqrabbitmq
be
a
quality_attribute_1
connector_data_1
component_2
component_3
quality_attribute_1
because
it
be
usually
run
a
a
cluster
of
technology_5
where
component_4
be
spread
across
the
technology_5
and
optionally
replicate
for
fault
tolerance
and
high
quality_attribute_2
it
natively
connector_2
technology_6
and
offer
other
technology_7
such
a
technology_6
stomp
technology_8
and
technology_9
via
plug
in
technology_1
take
both
a
classic
and
a
novel
take
on
connector_data_1
classic
in
the
sense
that
it
be
orient
around
connector_data_1
component_2
and
novel
in
it
highly
quality_attribute_3
connector_3
capability
it
be
this
connector_3
capability
that
be
it
killer
feature
build
a
fast
quality_attribute_4
quality_attribute_5
quality_attribute_1
pattern_1
component_3
be
an
achievement
in
itself
but
the
connector_data_1
connector_3
requirement_1
be
what
make
it
truly
stand
out
among
the
myriad
of
pattern_1
technology_4
out
there
exchange
and
queuesthe
super
simplify
overview
pattern_2
connector_4
connector_data_2
to
exchangesexchanges
connector_5
connector_data_2
to
component_4
and
other
exchangesrabbitmq
connector_6
acknowledgement
to
pattern_2
on
connector_data_1
receiptconsumers
maintain
persistent
technology_10
connector_7
with
technology_1
and
declare
which
component_2
s
they
consumerabbitmq
connector_8
connector_data_2
to
consumersconsumers
connector_4
acknowledgement
of
success
failuremessages
be
remove
from
component_4
once
connector_9
successfullybut
don’t
be
fool
into
think
that
an
exchange
be
a
“thing”
a
common
misconception
of
exchange
in
technology_1
be
that
they
be
thing
that
you
connector_4
connector_data_2
to
in
fact
that
be
connector_3
rule
you
connector_4
a
connector_data_1
to
a
pattern_3
component_5
it
u
the
connector_3
rule
exchange
to
decide
where
to
connector_4
the
connector_data_1
on
to
i
think
that
the
decision
to
use
the
word
exchange
be
unfortunate
i
much
prefer
rule
or
connector_10
rule
hide
in
that
connector_data_3
be
a
huge
number
of
decision
that
developer
and
admins
should
take
to
connector_11
the
delivery
guarantee
they
want
requirement_2
characteristic
etc
all
of
which
we
ll
cover
in
late
section
of
this
series
s
take
a
look
at
a
single
pattern_2
exchange
component_2
and
component_6
pattern_4
fullsize
fig
single
pattern_2
and
single
component_6
what
if
you
have
multiple
pattern_2
of
the
same
connector_data_1
also
what
if
we
have
multiple
component_7
that
each
want
to
connector_9
every
connector_data_1
pattern_4
fullsize
fig
multiple
pattern_2
multiple
independent
component_7
a
you
can
see
the
pattern_2
connector_4
their
connector_data_2
to
the
same
exchange
which
connector_5
each
connector_data_1
to
three
component_2
each
of
which
have
a
single
component_6
with
technology_1
component_4
enable
different
component_7
to
connector_9
each
connector_data_1
contrast
that
to
the
diagram
below
pattern_4
fullsize
fig
multiple
pattern_2
one
component_2
with
multiple
compete
component_7
in
figure
we
have
three
component_7
all
connector_12
from
a
single
component_2
these
be
compete
component_6
that
be
they
compete
to
connector_9
the
connector_data_2
of
a
single
component_2
one
would
expect
that
on
average
each
component_6
would
connector_9
one
third
of
the
connector_data_2
of
this
component_2
we
use
compete
component_7
to
quality_attribute_6
our
connector_data_1
component_5
and
with
technology_1
it
be
very
quality_attribute_7
or
remove
component_7
on
demand
no
matter
how
many
compete
component_7
you
have
technology_1
will
ensure
that
connector_data_2
be
connector_13
to
only
a
single
component_6
we
can
combine
figure
and
to
have
multiple
set
compete
component_7
where
each
set
connector_14
every
connector_data_1
pattern_4
fullsize
fig
multiple
pattern_2
multiple
component_4
with
compete
component_7
the
arrow
between
exchange
and
component_4
be
connector_15
bind
and
we
ll
be
take
a
much
close
look
at
those
in
part
of
this
series
guaranteesrabbitmq
offer
at
most
once
delivery
and
at
least
once
delivery
but
not
exactly
once
delivery
guarantee
we
ll
take
a
deep
look
at
connector_data_1
delivery
guarantee
in
part
of
the
series
connector_data_1
be
connector_13
in
order
of
their
arrival
to
the
component_2
that
be
the
definition
of
a
component_2
after
all
this
do
not
guarantee
the
completion
of
connector_data_1
component_5
match
that
exact
same
order
when
you
have
compete
component_6
this
be
no
fault
of
technology_1
but
a
fundamental
reality
of
component_5
an
order
set
of
connector_data_2
in
parallel
this
problem
can
be
resolve
by
use
the
consistent
hash
exchange
a
you
ll
see
in
the
next
part
on
pattern_5
and
topology
connector_8
and
component_6
prefetchrabbitmq
connector_8
connector_data_2
to
component_7
in
a
connector_16
there
be
a
connector_17
component_8
but
it
have
terrible
requirement_2
a
each
connector_data_1
require
a
connector_data_4
connector_18
round
trip
note
i
update
this
paragraph
due
to
a
from
shiva
kumar
connector_8
base
component_1
can
overwhelm
component_7
if
connector_data_2
arrive
at
the
component_2
fast
than
the
component_7
can
component_5
them
so
to
avoid
this
each
component_6
can
configure
a
prefetch
limit
also
a
a
qos
limit
this
basically
be
the
number
of
unacknowledged
connector_data_2
that
a
component_6
can
have
at
any
one
time
this
act
a
a
quality_attribute_8
cut
off
switch
for
when
the
component_6
start
to
fall
behind
why
connector_8
and
not
connector_17
first
of
all
it
be
great
for
low
quality_attribute_9
secondly
ideally
when
we
have
compete
component_7
of
a
single
component_2
we
want
to
quality_attribute_1
load
evenly
between
them
if
each
component_6
connector_19
connector_data_2
then
quality_attribute_10
on
how
many
they
connector_17
the
distribution
of
work
can
connector_11
pretty
uneven
the
more
uneven
the
distribution
of
connector_data_2
the
more
quality_attribute_9
and
the
further
the
loss
of
connector_data_1
order
at
component_5
time
for
that
reason
technology_1
s
connector_17
component_8
only
allow
to
connector_17
one
connector_data_1
at
a
time
but
that
seriously
impact
requirement_2
these
factor
make
technology_1
lean
towards
a
connector_8
mechanism
this
be
one
of
the
quality_attribute_11
limitation
of
technology_1
it
be
ameliorate
by
be
able
to
group
acknowledgement
together
routingexchanges
be
basically
connector_3
rule
for
connector_data_1
in
order
for
a
connector_data_1
to
travel
from
a
pattern_2
pattern_3
component_5
to
a
component_2
or
other
exchange
a
bind
be
need
different
exchange
require
different
bind
there
be
many
type
of
exchange
and
associate
bind
fanout
connector_10
to
all
component_4
and
exchange
that
have
a
bind
to
the
exchange
the
technology_11
pub
sub
component_9
direct
connector_10
connector_data_2
base
on
a
connector_3
key
that
the
connector_data_1
carry
with
it
set
by
the
pattern_2
a
connector_3
key
be
a
short
direct
exchange
connector_5
connector_data_2
to
component_2
exchange
that
have
a
bind
key
that
exactly
match
the
connector_3
key
topic
connector_10
connector_data_2
base
on
a
connector_3
key
but
allow
wildcard
match
technology_1
allow
for
custom
to
be
to
connector_data_1
exchange
connector_5
connector_data_2
accord
to
those
requirement_3
each
bind
include
exact
match
requirement_3
multiple
requirement_3
can
be
to
a
bind
with
any
or
all
requirement_3
require
to
match
consistent
hash
this
be
an
exchange
that
hash
either
the
connector_3
key
or
a
connector_data_1
and
connector_10
to
one
component_2
only
this
be
useful
when
you
need
component_5
order
guarantee
with
quality_attribute_6
out
component_6
pattern_4
fullsize
fig
topic
exchange
example
we
ll
be
look
more
closely
at
connector_3
in
part
but
above
be
an
example
of
a
topic
exchange
pattern_2
publish
error
requirement_4
with
a
connector_3
key
technology_12
of
level
appname
component_2
will
connector_20
all
connector_data_2
a
it
u
the
multi
word
#
wildcard
component_2
will
connector_20
any
requirement_4
level
of
the
ecommerce
webui
component_10
it
u
the
single
word
*
wildcard
that
cover
the
requirement_4
level
component_2
will
see
all
error
level
connector_data_2
from
any
component_10
it
u
the
multi
word
#
wildcard
to
cover
all
component_10
with
four
way
of
connector_3
connector_data_1
and
allow
exchange
to
connector_5
to
other
exchange
technology_1
offer
a
powerful
and
quality_attribute_3
set
of
pattern_1
pattern_5
next
we
ll
touch
on
dead
letter
exchange
ephemeral
exchange
and
component_2
and
you
ll
start
see
the
power
of
technology_1
dead
letter
exchangeswe
can
configure
component_4
to
connector_4
connector_data_2
to
an
exchange
under
the
follow
condition
component_2
exceed
the
configure
number
of
connector_data_1
component_2
exceed
the
configure
number
of
byte
connector_data_1
time
to
live
ttl
expire
the
pattern_2
can
set
the
lifetime
of
the
connector_data_1
and
also
the
component_2
can
have
a
connector_data_1
ttl
which
ever
be
short
apply
we
create
a
component_2
that
have
a
bind
to
the
dead
letter
exchange
and
these
connector_data_2
connector_11
component_11
there
until
action
be
take
in
a
separate
i
have
describe
the
topology
i
have
connector_21
where
all
dead
letter
connector_data_2
go
to
a
central
clear
house
where
the
support
team
can
decide
what
action
to
take
with
many
technology_1
requirement_1
dead
letter
exchange
give
extra
pattern_5
that
be
not
originally
consider
we
can
use
connector_data_1
ttls
and
dead
letter
exchange
to
connector_21
delay
component_4
and
retry
component_4
include
exponential
backoff
see
my
previous
on
this
ephemeral
exchange
and
queuesexchanges
and
component_4
can
be
dynamically
create
and
give
auto
delete
characteristic
after
a
certain
time
period
they
can
self
destruct
this
allow
for
pattern_5
such
a
ephermal
connector_data_5
component_4
for
connector_data_1
base
pattern_6
plug
insthe
first
plug
in
you
will
want
to
install
be
the
requirement_5
plug
in
that
provide
an
technology_9
component_12
with
web
ui
and
pattern_7
technology_13
it
be
really
easy
to
install
and
give
you
an
easy
to
use
ui
to
connector_11
you
up
and
run
script
deployment
via
the
pattern_7
component_8
be
really
easy
too
some
other
plug
in
include
consistent
hash
exchange
sharding
pluginprotocols
stomp
and
mqttweb
hooksextra
exchange
typessmtp
integrationtopthere
s
a
lot
more
to
technology_1
but
that
be
a
quality_attribute_12
primer
and
give
you
an
idea
of
what
technology_1
can
do
now
we
ll
look
at
technology_2
which
take
a
completely
different
approach
to
connector_data_1
and
also
have
amaze
feature
technology_3
kafkakafka
be
a
quality_attribute_1
replicate
connector_22
requirement_4
technology_2
do
not
have
the
concept
of
a
component_2
which
might
seem
strange
at
first
give
that
it
be
primary
use
a
a
pattern_1
component_3
component_4
have
be
synonymous
with
pattern_1
component_1
for
a
long
time
s
break
down
quality_attribute_1
replicate
connector_22
requirement_4
a
bit
quality_attribute_1
because
technology_2
be
quality_attribute_13
a
a
cluster
of
technology_5
for
both
fault
tolerance
and
scalereplicated
because
connector_data_2
be
usually
replicate
across
multiple
technology_5
component_12
connector_22
requirement_4
because
connector_data_2
be
component_11
in
component_13
append
only
requirement_4
which
be
connector_15
topic
this
concept
of
a
requirement_4
be
the
principal
killer
feature
of
technology_2
understand
the
requirement_4
topic
and
it
component_13
be
the
key
to
understand
technology_2
so
how
be
a
component_13
requirement_4
different
from
a
set
of
component_2
s
visualise
it
pattern_4
fullsize
fig
one
component_14
one
component_13
one
component_6
rather
than
put
connector_data_2
in
a
pattern_8
component_2
and
track
the
status
of
that
connector_data_1
in
the
component_2
technology_1
do
technology_2
append
it
to
the
requirement_4
and
that
be
that
the
connector_data_1
stay
put
whether
it
be
connector_9
once
or
a
thousand
time
it
be
remove
accord
to
the
connector_data_6
retention
requirement_6
often
a
window
time
period
so
how
be
a
topic
connector_9
each
component_6
track
where
it
be
in
the
requirement_4
it
have
a
pointer
to
the
last
connector_data_1
connector_9
and
this
pointer
be
connector_15
the
offset
component_7
maintain
this
offset
via
the
component_15
technology_14
and
quality_attribute_10
on
the
version
of
technology_2
the
offset
be
component_11
either
in
technology_15
or
technology_2
itself
technology_15
be
a
quality_attribute_1
consensus
technology_4
use
by
many
quality_attribute_1
component_1
for
thing
leader
election
technology_2
rely
on
technology_15
for
manage
the
state
of
the
cluster
what
be
amaze
about
this
requirement_4
component_9
be
that
it
instantly
remove
a
lot
of
complexity
around
connector_data_1
delivery
status
and
more
importantly
for
component_6
it
allow
them
to
rewind
and
go
back
and
connector_9
connector_data_2
from
a
previous
offset
for
example
imagine
you
quality_attribute_13
a
component_16
that
calculate
invoice
which
connector_14
book
place
by
component_15
the
component_16
have
a
bug
and
calculate
all
the
invoice
incorrectly
for
hour
with
technology_1
at
best
you
would
need
to
somehow
republish
those
book
and
only
to
the
invoice
component_16
but
with
technology_2
you
simply
move
the
offset
for
that
component_6
back
hour
so
s
see
what
it
look
with
a
topic
that
have
a
single
component_13
and
two
component_7
which
each
need
to
connector_9
every
connector_data_1
from
now
on
i
have
start
to
label
the
component_7
because
it
will
not
be
a
clear
a
the
technology_1
diagram
which
be
independent
and
which
be
compete
component_6
pattern_4
fullsize
fig
one
component_14
one
component_13
two
independent
component_7
a
you
can
see
from
the
diagram
two
independent
component_7
both
connector_9
from
the
same
component_13
but
they
be
connector_1
from
different
offset
perhaps
the
invoice
component_16
take
long
to
component_5
connector_data_2
than
the
connector_8
connector_data_7
component_16
or
perhaps
the
invoice
component_16
be
down
for
a
while
and
catch
up
or
perhaps
there
be
a
bug
and
it
offset
have
to
be
move
back
a
few
hour
now
s
say
that
the
invoice
component_16
need
to
be
quality_attribute_6
out
to
three
instance
because
it
cannot
keep
up
with
the
connector_data_1
technology_16
with
technology_1
we
simply
quality_attribute_13
two
more
invoice
component_16
component_17
which
connector_9
from
the
book
invoice
component_16
component_2
but
technology_2
do
not
support
compete
component_7
on
a
single
component_13
technology_2
s
unit
of
parallelism
be
the
component_13
itself
so
if
we
need
three
invoice
component_7
we
need
at
least
three
component_13
so
now
we
have
pattern_4
fullsize
fig
three
component_13
and
two
set
of
three
component_7
so
the
implication
be
that
you
need
at
least
a
many
component_13
a
the
most
quality_attribute_6
out
component_6
s
talk
about
component_13
a
bit
component_13
and
component_6
groupseach
component_13
be
a
separate
connector_data_6
connector_data_8
which
guarantee
connector_data_1
order
that
be
important
to
remember
connector_data_1
order
be
only
guarantee
within
a
single
component_13
that
can
introduce
some
tension
late
on
between
connector_data_1
order
need
and
requirement_2
need
a
the
unit
of
parallelism
be
also
the
component_13
one
component_13
cannot
support
compete
component_6
so
our
invoice
component_10
can
only
have
one
instance
connector_12
each
component_13
connector_data_1
can
be
connector_10
to
component_13
in
a
round
robin
manner
or
via
a
hash
hash
connector_data_1
key
%
number
of
component_13
use
a
hash
have
some
benefit
a
we
can
design
the
connector_data_1
key
such
that
connector_data_2
of
the
same
component_18
a
book
for
example
always
go
to
the
same
component_13
this
enable
many
pattern_5
and
connector_data_1
order
guarantee
component_6
group
be
technology_1
s
compete
component_6
each
component_6
in
the
group
be
an
instance
of
the
same
component_10
and
will
component_5
a
subset
of
all
the
connector_data_2
in
the
topic
whereas
technology_1
s
compete
component_7
all
connector_9
from
the
same
component_2
each
component_6
in
a
component_6
group
connector_14
from
a
different
component_13
of
the
same
topic
so
in
the
example
above
the
three
instance
of
the
invoice
component_16
all
belong
to
the
same
component_6
group
at
this
point
technology_1
look
a
little
more
quality_attribute_3
with
it
guarantee
of
connector_data_1
order
within
a
component_2
and
it
seamless
ability
to
cope
with
connector_23
number
of
compete
component_6
with
technology_2
how
you
component_13
your
requirement_4
be
important
there
be
a
subtle
yet
important
advantage
that
technology_2
have
from
the
start
that
technology_1
late
on
regard
connector_data_1
order
and
parallelism
technology_1
maintain
global
order
of
the
whole
component_2
but
offer
no
way
for
maintain
that
order
during
the
parallel
component_5
of
that
component_2
technology_2
cannot
offer
global
order
of
the
topic
but
it
do
offer
order
at
the
component_13
level
so
if
you
only
need
order
of
relate
connector_data_2
then
technology_2
offer
both
order
connector_data_1
delivery
and
order
connector_data_1
component_5
imagine
you
have
connector_data_2
that
show
the
late
state
of
a
component_15
s
book
so
you
want
to
always
component_5
the
connector_data_2
of
that
book
sequentially
in
temporal
order
if
you
component_13
by
the
book
then
all
connector_data_2
of
a
give
book
will
all
arrive
at
a
single
component_13
where
we
have
connector_data_1
order
so
you
can
create
a
large
number
of
component_13
make
your
component_5
highly
parallelised
and
also
connector_11
the
guarantee
you
need
for
connector_data_1
order
this
capability
exist
in
technology_1
also
via
the
consistent
hash
exchange
which
quality_attribute_1
connector_data_2
over
component_4
in
the
same
way
though
technology_2
enforce
this
order
component_5
by
the
fact
that
only
one
component_6
per
component_6
group
can
connector_9
a
single
component_13
and
make
it
easy
a
the
coordinator
technology_5
do
all
the
work
for
you
to
ensure
this
rule
be
comply
with
technology_1
offer
single
active
component_6
sac
which
prevent
more
than
one
component_6
actively
connector_12
a
component_2
at
the
same
time
even
if
multiple
component_7
have
subscribe
to
the
component_2
but
it
doesn’t
offer
coordination
of
component_7
over
multiple
“partitioned”
component_2
back
to
technology_2
there
s
also
a
gotcha
here
the
moment
you
connector_23
the
number
of
component_13
those
connector_data_2
for
order
now
go
to
a
different
component_13
so
connector_data_2
of
order
exist
in
two
component_13
quality_attribute_10
on
how
you
component_5
your
connector_data_2
this
can
introduce
a
headache
there
exist
scenario
now
where
the
connector_data_2
connector_11
component_5
out
of
order
we
ll
be
cover
this
subject
in
great
detail
in
the
part
connector_data_1
delivery
semantics
and
guarantee
section
of
the
series
connector_8
vs
pullrabbitmq
u
a
connector_8
component_9
and
prevent
overwhelm
component_7
via
the
component_6
configure
prefetch
limit
this
be
great
for
low
quality_attribute_9
pattern_1
and
work
well
for
technology_1
s
component_2
base
architecture
technology_2
on
the
other
hand
u
a
connector_17
component_9
where
component_7
connector_data_4
pattern_9
of
connector_data_2
from
a
give
offset
to
avoid
tight
loop
when
no
connector_data_2
exist
beyond
the
current
offset
technology_2
allow
for
long
pattern_10
a
connector_17
component_9
make
sense
for
technology_2
due
to
it
component_13
a
technology_2
guarantee
connector_data_1
order
in
a
component_13
with
no
compete
component_6
we
can
leverage
the
pattern_9
of
connector_data_2
for
a
more
quality_attribute_14
connector_data_1
delivery
that
give
u
high
quality_attribute_15
this
doesn
t
make
so
much
sense
for
technology_1
a
ideally
we
want
to
try
to
quality_attribute_1
connector_data_2
one
at
a
time
a
fast
a
possible
to
ensure
that
work
be
parallelised
evenly
and
connector_data_2
be
component_5
close
to
the
order
in
which
they
arrive
in
the
component_2
but
with
technology_2
the
component_13
be
the
unit
of
parallelism
and
connector_data_1
order
so
neither
of
those
two
factor
be
a
concern
for
u
publish
subscribekafka
support
basic
pub
sub
with
some
extra
pattern_5
relate
to
that
fact
it
be
a
requirement_4
and
have
component_13
the
component_19
append
connector_data_2
to
the
end
of
the
requirement_4
component_13
and
the
component_7
could
be
position
with
their
offset
anywhere
in
the
component_13
pattern_4
fullsize
fig
component_7
with
different
offset
this
style
of
diagram
be
not
a
easy
to
quickly
interpret
when
there
be
multiple
component_13
and
component_6
group
so
for
the
remainder
of
the
diagram
for
technology_2
i
will
use
the
follow
style
fig
one
component_14
three
component_13
and
one
component_6
group
with
three
component_7
we
t
have
to
have
the
same
number
of
component_7
in
our
component_6
group
a
there
be
component_13
pattern_4
fullsize
fig
sone
component_7
connector_24
from
more
than
one
component_13
component_7
in
one
component_6
group
will
coordinate
the
consumption
of
component_13
ensure
that
one
component_13
be
not
connector_9
by
more
than
one
component_6
of
the
same
component_6
group
likewise
if
we
have
more
component_7
than
component_13
the
extra
component_6
will
remain
idle
in
reserve
pattern_4
fullsize
fig
one
idle
component_6
after
and
remove
component_6
the
component_6
group
can
become
unbalance
a
rebalancing
redistribute
the
component_7
a
evenly
a
possible
across
the
component_13
pattern_4
fullsize
fig
addition
of
component_7
require
rebalancing
rebalancing
be
automatically
connector_25
after
a
component_6
join
a
component_6
groupa
component_6
leave
a
component_6
group
it
shutsdown
or
be
consider
dead
component_13
be
addedrebalancing
will
cause
a
short
period
of
extra
quality_attribute_9
while
component_7
stop
connector_1
pattern_9
of
connector_data_2
and
connector_11
assign
to
different
component_13
any
in
memory
state
that
be
maintain
by
the
component_6
now
be
invalid
one
of
the
pattern_5
of
consumption
with
technology_2
be
be
able
to
direct
all
connector_data_2
of
a
give
component_18
a
give
book
to
the
same
component_13
and
hence
the
same
component_6
this
be
connector_15
connector_data_6
locality
upon
rebalancing
any
in
memory
connector_data_6
about
that
connector_data_6
will
be
useless
unless
the
component_6
connector_26
assign
back
to
the
same
component_13
therefore
component_7
that
maintain
state
will
need
to
persist
it
externally
requirement_4
compactionthe
technology_11
connector_data_6
retention
requirement_6
be
time
and
space
base
requirement_6
component_11
up
to
the
last
week
of
connector_data_2
or
up
to
50gb
for
example
but
another
type
of
connector_data_6
retention
requirement_6
exist
requirement_4
compaction
when
a
requirement_4
be
compact
the
connector_data_9
be
that
only
the
most
recent
connector_data_1
per
connector_data_1
key
be
retain
the
rest
be
remove
s
imagine
we
connector_20
a
connector_data_1
contain
the
current
state
of
a
component_20
s
book
every
time
a
connector_23
be
make
to
the
book
a
be
generate
with
the
current
state
of
the
book
the
topic
have
a
few
connector_data_2
for
that
one
book
that
represent
the
state
of
that
book
since
it
be
create
after
the
topic
connector_26
compact
only
the
most
recent
connector_data_1
relate
to
that
book
will
be
keep
quality_attribute_10
on
the
volume
of
book
and
the
size
of
each
book
you
could
theoretically
component_11
all
book
forever
in
the
topic
by
periodically
compact
the
topic
we
ensure
we
only
component_11
one
connector_data_1
per
book
requirement_4
compaction
enable
a
few
different
pattern_5
which
we
will
explore
in
part
more
on
connector_data_1
orderingwe
ve
cover
that
quality_attribute_11
out
and
maintain
connector_data_1
order
be
possible
with
both
technology_1
and
technology_2
but
technology_2
make
it
a
lot
easy
with
technology_1
we
must
use
the
consistent
hash
exchange
and
manually
connector_21
the
component_6
group
component_21
ourselves
by
use
single
active
component_6
and
custom
hand
roll
component_21
but
technology_1
have
one
interest
capability
that
technology_2
do
not
technology_1
allow
pattern_11
to
order
arbitrary
group
of
s
dive
into
that
a
little
more
different
component_22
cannot
connector_27
a
component_2
because
then
they
would
compete
to
connector_9
the
connector_data_1
they
need
their
own
component_2
this
give
component_22
the
freedom
to
configure
their
component_2
anyway
they
see
fit
they
can
connector_5
multiple
type
from
multiple
exchange
to
their
component_2
this
allow
component_22
to
maintain
the
order
of
relate
which
it
want
to
combine
can
be
configure
differently
for
each
component_10
this
be
simply
not
possible
with
a
requirement_4
base
pattern_1
component_3
technology_2
because
requirement_4
be
connector_28
resource
multiple
component_22
connector_24
from
the
same
requirement_4
so
any
grouping
of
relate
into
a
single
topic
be
a
decision
make
at
a
wide
component_3
architecture
level
so
there
be
no
winner
take
all
here
technology_1
allow
you
to
maintain
relative
order
across
arbitrary
set
of
and
technology_2
provide
a
quality_attribute_7
way
of
maintain
order
at
quality_attribute_6
update
i
have
build
a
technology_14
connector_15
rebalanser
that
provide
component_6
group
component_21
to
technology_1
for
technology_17
component_10
connector_29
out
the
on
it
and
the
technology_18
repo
if
people
show
any
interest
then
i
technology_19
be
up
for
make
version
in
other
technology_20
me
conclusionsrabbitmq
offer
a
swiss
army
knife
of
pattern_1
pattern_5
due
to
the
variety
of
requirement_1
it
offer
with
it
powerful
connector_10
it
can
obviate
the
need
for
component_7
to
connector_30
deserialize
and
inspect
every
connector_data_1
when
it
only
need
a
subset
it
be
easy
to
work
with
quality_attribute_11
up
and
down
be
do
by
simply
and
remove
component_6
it
s
plug
in
architecture
allow
it
to
support
other
technology_7
and
feature
such
a
consistent
hash
exchange
which
be
an
important
addition
technology_2
s
quality_attribute_1
requirement_4
with
component_6
offset
make
time
travel
possible
it
s
ability
to
connector_5
connector_data_2
of
the
same
key
to
the
same
component_6
in
order
make
highly
parallelised
order
component_5
possible
technology_2
s
requirement_4
compaction
and
connector_data_6
retention
allow
pattern_5
that
technology_1
simply
cannot
connector_13
finally
yes
technology_2
can
quality_attribute_6
further
than
technology_1
but
most
of
u
deal
with
a
connector_data_1
volume
that
both
can
handle
comfortably
in
the
next
part
we
ll
take
a
close
look
at
pattern_1
pattern_5
and
topology
with
technology_1
series
introductionpart
two
different
take
on
pattern_1
high
level
design
comparison
part
pattern_1
pattern_5
and
topology
with
rabbitmqpart
pattern_1
pattern_5
and
topology
with
kafkapart
connector_data_1
delivery
semantics
and
guaranteespart
fault
tolerance
and
high
quality_attribute_2
with
rabbitmqpart
fault
tolerance
and
high
quality_attribute_2
with
technology_2
tag
connector_data_1
technology_2
technology_1
postrabbitmq
vs
technology_2
part
technology_1
pattern_1
patternsolder
postrabbitmq
vs
technology_2
series
introduction
technology_21
feature
jan
connector_31
for
others
but
mostly
for
yourself
jan
jan
dec
tweak
the
bookkeeper
technology_7
unbounded
ledger
dec
dec
dec
tweak
the
bookkeeper
technology_7
guarantee
connector_31
quorum
dec
dec
oct
about
tla+
and
the
formal
verification
of
technology_3
bookkeeper
oct
oct
oct
i
connector_31
on
the
technology_1
in
oct
oct
oct
technology_2
and
technology_1
i
connector_31
elsewhere
in
oct
oct
with
great
observation
come
great
insight
why
i
m
not
connector_32
much
on
my
these
day
sep
a
look
at
multi
topic
subscription
with
technology_3
technology_22
sep
sep
feb
build
a
quality_attribute_7
quality_attribute_1
component_3
it
s
the
requirement_4
stupid
feb
feb
feb
build
a
quality_attribute_7
quality_attribute_1
component_3
the
implementation
feb
feb
jan
build
a
quality_attribute_7
quality_attribute_1
component_3
formal
verification
jan
jan
jan
build
a
quality_attribute_7
quality_attribute_1
component_3
the
technology_7
jan
jan
jan
build
a
quality_attribute_7
quality_attribute_1
component_3
the
what
jan
jan
nov
quorum
component_4
make
technology_1
more
competitive
in
quality_attribute_5
pattern_1
nov
nov
nov
why
i
be
not
a
fan
of
the
technology_1
sharding
plugin
nov
nov
nov
test
component_14
deduplication
in
technology_3
technology_2
and
technology_3
technology_22
nov
nov
oct
how
to
not
lose
connector_data_2
on
an
technology_3
technology_22
cluster
oct
oct
oct
understand
how
technology_3
technology_22
work
oct
oct
sep
how
to
lose
connector_data_2
on
a
technology_2
cluster
part
sep
sep
sep
how
to
lose
connector_data_2
on
a
technology_2
cluster
part
sep
sep
sep
how
to
lose
connector_data_2
on
a
technology_1
cluster
sep
sep
sep
technology_1
vs
technology_2
part
fault
tolerance
and
high
quality_attribute_2
with
technology_2
sep
sep
aug
technology_1
vs
technology_2
part
fault
tolerance
and
high
quality_attribute_2
with
technology_1
cluster
aug
aug
aug
technology_23
quality_attribute_16
quality_attribute_17
your
use
of
the
technology_23
cli
and
automation
technology_24
aug
aug
jul
technology_1
work
component_2
avoid
connector_data_6
inconsistency
with
rebalanser
jul
jul
jul
create
component_6
group
in
technology_1
with
rebalanser
part
jul
jul
technology_17
core
technology_23
lambda
lifetime
after
uncontrolled
exception
technology_25
technology_17
core
and
technology_26
driver
pattern_12
architecture
component_2
vs
requirement_4
a
requirement_7
study
back
to
top
powered
by
squarespace
