technology_1
pattern_1
a
practical
guide
home
about
login
technology_1
pattern_1
a
practical
guide
last
update
on


quick
connector_1
technology_1
pattern_1
the
basic
technology_1
pattern_2
architecture
quality_attribute_1
and
test
technology_1
pattern_1
common
technology_1
pattern_2
question
conceptual
pattern_2
challenge
fin
â
top
you
can
use
this
guide
to
understand
what
technology_1
pattern_1
be
how
you
architect
and
build
them
also
a
look
at
technology_1
pattern_2
technology_2
&
common
question
editorâs
note
at
nearly


word
you
probably
don’t
want
to
try
connector_2
this
on
a
requirement_1
component_1
bookmark
it
and
come
back
late
technology_1
pattern_1
the
basic
to
connector_3
a
real
understand
of
technology_1
pattern_1
it
make
sense
to
start
with
the
very
basic
the
infamous
technology_1
monolith
what
it
be
and
what
it
advantage
or
disadvantage
be
what
be
a
technology_1
monolith
imagine
you
be
work
for
a
bank
or
a
fintech
start
up
you
provide
component_2
a
requirement_1
component_3
which
they
can
use
to
open
up
a
bank
account
in
technology_1

this
will
lead
to
a
pattern_3
that
look
simplify
the
follow
@controller
bankcontroller
{
@postmapping
component_4
register
register
registrationform
form
{
validate
form
riskcheck
form
openbankaccount
form
etc
}
}
you’ll
want
to
validate
the
registration
form
do
a
risk
connector_4
on
the
user’s
connector_5
to
decide
if
you
want
to
give
him
a
bank
account
or
not
open
up
the
bank
account
your
bankcontroller
will
be
packaged
up
with
all
your
other
component_5

into
a
bank
jar
or
bank
war
for
deployment
a
quality_attribute_2
old
monolith
contain
all
the
you
need
for
your
bank
to
run
a
a
rough
pointer
initially
your
jar
war
will
have
a
size
in
the
range
of

100mb
on
your
component_6
you
then
simply
run
your
jar
that’s
all
you
need
to
do
to
quality_attribute_1
technology_1
component_7
what
be
the
problem
with
technology_1
monolith
at
it
core
there’s
nothing
wrong
with
a
technology_1
monolith
it
be
simply
that
project
experience
have
show
that
if
you
many
different
programmer
team
consultancies…​
work
on
the
same
monolith
under
high
pressure
and
unclear
requirements…​
for
a
couple
of
years…​
then
your
small
bank
jar

turn
into
a
gigabyte
large
monster
that
everyone
fear
quality_attribute_1
how
to
connector_3
the
technology_1
monolith
small
this
naturally
lead
to
the
question
of
how
to
connector_3
the
monolith
small
for
now
your
bank
jar
run
in
one
technology_3
one
component_8
on
one
component_6
nothing
more
nothing
le
now
you
could
come
up
with
the
idea
to
say
well
the
risk
connector_4
component_9
be
be
use
by
other
department
in
my
requirement_2
and
it
doesn’t
really
have
anything
to
do
with
my
technology_4
lithic
bank
domain
so
we
could
try
and
cut
it
out
of
the
monolith
and
quality_attribute_1
it
a
it
own
technology_5
or
more
technically
run
it
a
it
own
technology_1
component_8
what
be
a
technology_1
pattern_2
in
practical
term
this
mean
that
instead
of
connector_6
the
riskcheck
inside
your
bankcontroller
you
will
move
that

component_10
with
all
it
helper
to
it
own
technology_6
gradle
project
put
it
under
component_5
control
and
quality_attribute_1
it
independently
from
your
bank
monolith
that
whole
extraction
component_8
do
not
make
your
riskcheck
a
pattern_2
per
se
and
that
be
because
the
definition
of
pattern_1
be
open
for
interpretation
which
lead
to
a
fair
amount
of
discussion
in
team
and
requirement_2
be
it
micro
if
it
only
have


inside
be

or

still
micro
have
it
even
connector_3
anything
to
do
with
the
number
of

instead
of
theorize
about
it
we’ll
keep
thing
pragmatic
and
do
two
thing
connector_data_1
all
separately
quality_attribute_3
component_11
pattern_1
independent
of
size
or
domain
boundary
focus
on
the
important
topic
of
inter
component_9
connector_7
because
your
pattern_1
need
way
to
talk
to
each
other
so
to
sum
up
before
you
have
one
technology_3
component_8
one
bank
monolith
now
you
have
a
bank
monolith
technology_3
component_8
and
a
riskcheck
pattern_2
which
run
in
it
own
technology_3
component_8
and
your
monolith
now
have
to
connector_data_1
that
pattern_2
for
risk
connector_4
how
do
you
do
that
how
to
connector_8
between
technology_1
pattern_1
you
basically
have
two
choice
pattern_4
connector_7
or
pattern_5
connector_7
technology_7
rest
pattern_4
connector_7
pattern_4
pattern_2
connector_7
be
usually
do
via
technology_7
and
rest

component_11
that
connector_data_2
or
technology_8
though
this
be
by
no
mean
require
have
a
look
at
google’s
technology_9
buffer
for
example
use
pattern_6
connector_7
when
you
need
an
immediate
connector_9
which
we
do
in
our
requirement_3
a
risk
connector_4
be
mandatory
before
opening
an
account
no
risk
connector_4
no
account
technology_10
wise
connector_4
out
which
technology_2
be
the
best
for
pattern_4
technology_1
pattern_6
connector_data_1
pattern_7
pattern_5
connector_7
pattern_5
pattern_2
connector_7
be
usually
do
through
pattern_7
with
a
technology_11
implementation
and
or
with
a
technology_9
technology_12
usually
because
the
number
of
for
example

technology_13
drive
requirement_4
be
not
to
be
underestimate
in
practice
use
it
when
you
do
not
need
an
immediate
connector_9
say
the
component_2
press
the
buy
now
and
you
want
to
generate
an
invoice
which
certainly
do
not
have
to
happen
a
part
of
the
user’s
purchase
connector_data_3
connector_9
cycle
technology_10
wise
connector_4
out
which
pattern_8
be
the
best
for
pattern_5
technology_1
connector_data_4
example
connector_6
pattern_6
component_12
in
technology_1
assume
we
choose
to
go
with
pattern_4
pattern_2
connector_7
our
technology_1
from
above
would
then
look
something
this
on
a
low
level
low
level
because
for
pattern_2
connector_7
you
usually
create
component_13
technology_2
that
abstract
the
actual
technology_7
connector_data_5
away
from
you
@controller
bankcontroller
{
@autowired
private
httpclient
httpclient
@postmapping
component_4
register
register
registrationform
form
{
validate
form
httpclient
connector_10
riskrequest
responsehandler
setupaccount
form
etc
}
}
look
at
the
it
become
clear
that
you
now
must
quality_attribute_1
two
technology_1
micro
component_9
your
bank
and
your
riskcheck
component_9
you
be
go
to
end
up
with
two
jvms
two
component_8
the
graphic
from
before
will
look
this
that’s
all
you
need
to
develop
a
technology_1
pattern_1
project
build
and
quality_attribute_1
small
piece
jar
or
war

instead
of
one
large
piece
but
that
leave
the
question
how
exactly
do
you
cut
or
setup
those
pattern_1
what
be
these
small
piece
what
be
the
right
size
let’s
do
a
reality
connector_4
technology_1
pattern_2
architecture
in
practice
there’s
various
way
that
requirement_2
try
to
design
or
architect
pattern_2
project
it
quality_attribute_4
on
if
you
be
try
to
turn
an
exist
monolith
into
a
pattern_1
project
or
if
you
be
start
out
with
a
greenfield
project
from
monolith
to
pattern_1
one
rather
organic
idea
be
to
break
pattern_1
out
of
an
exist
monolith
note
that
micro
here
do
not
actually
mean
that
the
extract
component_11
themselves
will
indeed
be
micro
they
could
still
be
quite
large
themselves
let’s
look
at
some
theory
the
idea
break
a
monolith
into
pattern_1
component_14
project
lend
themselves
to
a
pattern_1
approach
mainly
for
three
reason
they
be
often
hard
to
maintain
connector_11
extend
everyone
from
developer
ops
to
requirement_5
want
to
make
thing
quality_attribute_5
want
stuff
to
be
quality_attribute_5
you
have
somewhat
clear
domain
boundary
that
mean
you
what
your
be
suppose
to
do
this
mean
you
can
have
a
look
at
your
technology_1
bank
monolith
and
try
to
split
it
along
domain
boundary
a
sensible
approach
you
could
conclude
that
there
should
be
an
account
requirement_5
pattern_2
that
handle
component_4
connector_data_6
name
connector_5
phone
number
or
the
aforementioned
risk

that
connector_12
component_4
risk
level
and
which
could
be
use
by
many
other
project
or
even
department
in
your
requirement_2
or
an
invoice

that
connector_13
out
invoice
via
pdf
or
actual
mail
reality
someone
else
do
it
while
this
approach
definitely
look
quality_attribute_2
on
paper
and
uml

diagram
it
have
it
drawback
mainly
you
need
very
strong
technical
skill
to
connector_14
it
off
why
because
there
be
a
huge
difference
between
understand
that
it
would
be
a
quality_attribute_2
thing
to
extract
the
say
highly
couple
account
requirement_5
out
of
your
monolith
and
do
it
properly
most
requirement_6
project
reach
the
stage
where
developer
be
scar
to
say
upgrade
the

year
old
technology_14
version
to
a

one
which
be
a
technology_2
update
but
a
fair
amount
of
work
try
to
make
sure
not
to
break
anything
those
same
developer
be
now
suppose
to
dig
deep
into
old
component_14

with
unclear
component_15
transaction
boundary
and
extract
well
define
pattern_1
possible
but
often
a
real
challenge
and
not
solvable
on
a
whiteboard
or
in
architecture
meet
this
be
already
the
first
time
in
this

where
a
quote
from
@simonbrown
on
twitter
fit
in
i
ll
keep
say
this
if
people
can
t
build
monolith
properly
pattern_1
win
t
help
simon
brown
greenfield
project
pattern_2
architecture
thing
look
a
bit
different
when
develop

greenfield
jav
aprojects
now
those
three
point
from
above
look
a
bit
different
you
be
start
with
a
clean
slate
so
there’s
no
old
baggage
to
maintain
developer
would
thing
to
stay
quality_attribute_5
in
the
future
the
issue
you
have
a
much
foggier
picture
of
domain
boundary
you
don’t
what
your
be
actually
suppose
to
do
hint
agile
this
lead
to
various
way
that
requirement_2
try
and
tackle
greenfield
technology_1
pattern_1
project
technical
pattern_2
architecture
the
first
approach
be
the
most
obvious
for
developer
although
the
one
highly
recommend
against
prop
to
hadi
hariri
for
come
up
with
the
extract
pattern_2
refactoring
in
intellij
while
the
follow
example
be
oversimplify
to
the
extreme
actual
implementation
see
in
real
project
be
unfortunately
not
too
far
off
before
pattern_1
@service
userservice
{
register
component_4
component_4
{
=
component_4
getemail
username
=

substring


indexof
@
}
}
with
a
substring
technology_1
pattern_2
@service
userservice
{
@autowired
private
httpclient
component_13
register
component_4
component_4
{
=
component_4
getemail
now
connector_6
the
substring
pattern_2
via
technology_7
username
=
httpclient
connector_10
substringrequest

responsehandler
}
}
so
you
be
essentially
wrap
a
technology_1
connector_data_1
into
a
technology_7
connector_data_1
with
no
obvious
reason
to
do
so
one
reason
however
be
lack
of
experience
and
try
to
force
a
technology_1
pattern_1
approach
recommendation
don’t
do
it
workflow
orient
pattern_2
architecture
the
next
common
approach
be
to
your
technology_1
pattern_1
after
your
workflow
real
life
example
in
germany
when
you
go
to
a

doctor
he
need
to
component_16
your
appointment
in
his
health
crm
to
connector_3
pay
from
the
insurance
he
will
connector_10
in
your
treatment
connector_data_6
and
that
of
all
other
patient
he
treat
to
an
pattern_9
via
technology_15
the
pattern_9
will
have
a
look
at
that
connector_data_2
and
simplify
try
and
validate
the
that
it
be
proper
connector_data_2
try
and
validate
it
for
plausibility
do
it
make
sense
that
a

year
old
connector_3
three
tooth
clean
in
a
day
from
a
gynecologist
enhance
the
connector_data_2
with
some
other
bureaucratic
connector_data_6
connector_15
the
connector_data_2
to
the
insurance
to
connector_16
payment
and
component_17
the
whole
way
back
to
the
doctor
include
a
success
connector_data_4
or
please
re
connector_10
that
connector_data_6
entry
again
once
it
make
sense
if
you
now
try
and
component_17
this
workflow
with
microservives
you
will
end
up
with
at
least
note
connector_7
between
pattern_1
be
irrelevant
in
this
example
but
could
well
be
do
asynchronously
with
a
connector_data_4
pattern_8
technology_16
a
the
doctor
do
not
connector_3
immediate
feedback
anyway
again
this
be
something
that
look
quality_attribute_2
on
paper
but
immediately
lead
to
several
question
do
you
feel
the
need
to
quality_attribute_1
six
component_18
to
component_8

technology_15

be
these
pattern_1
really
independent
from
each
other
they
can
be
quality_attribute_1
independently
from
each
other
with
different
version
and
component_19
technology_17
what
do
the
plausibility
pattern_2
do
if
the
validation
pattern_2
be
down
be
the
component_20
then
still
run
do
these
pattern_1
now
connector_17
the
same
component_15
they
sure
need
some
common
connector_data_6
in
a
component_15
component_21
or
be
you
go
to
take
the
even
big
hammer
of
give
them
all
their
own
component_15
and
a
ton
of
other
infrastructure

question
interestingly
for
some
architect
the
above
diagram
connector_18
quality_attribute_5
because
every
component_9
now
have
it
exact
well
define
purpose
before
it
look
this
scary
monolith
while
argument
can
be
make
about
the
quality_attribute_6
of
those
diagram
you
now
definitely
have
these
additional
operational
challenge
to
solve
you…​
don’t
need
to
quality_attribute_1
one
component_7
but
at
least
six
might
even
need
to
quality_attribute_1
multiple
component_15
quality_attribute_4
on
how
far
you
want
to
take
your
pattern_2
architecture
have
to
make
sure
that
every
component_20
be
online
healthy
and
work
have
to
make
sure
that
your
connector_data_5
between
pattern_1
be
actually
resilient
see
how
to
make
a
technology_1
pattern_2
resilient
and
everything
else
this
setup
imply
from
local
development
setup
to
requirement_4
test
recommendation
unless
you
be
netflix
you
be
not
…​
you
have
super
strong
skill
you
open
up
your
development
ide
which
connector_19
a
chaos
monkey
that
drop
your
production
component_15
which
easily
auto
recover
in

second
or
you
feel
@monzo
in
give

pattern_1
a
try
simply
because
you
can
→
don’t
do
it
in
le
hyperbole
though
try
to
component_17
pattern_1
after
domain
boundary
be
a
very
sensible
approach
but
a
domain
boundary
say
component_4
requirement_5
vs
invoice
do
not
mean
take
a
single
workflow
and
split
it
up
into
it
tiniest
individual
piece
connector_20
technology_15
validate
technology_15
connector_15
technology_15
hence
whenever
you
be
start
out
with
a
technology_1
pattern_1
project
and
the
domain
boundary
be
still
very
vague
try
to
keep
the
size
of
your
pattern_1
on
the
lower
end
you
can
always
more
late
on
and
make
sure
that
you
have
exceptionally
strong
devops
skill
across
your
team
requirement_2
division
to
support
your
infrastructure
polyglot
or
team
orient
pattern_2
architecture
there
be
a
third
almost
libertarian
approach
to
develop
pattern_1
give
your
team
or
even
individual
the
possibility
to
connector_21
component_4
story
with
a
many
technology_18
or
pattern_1
they
want
requirement_7
term
polyglot
programming
so
the
connector_data_2
validation
component_9
above
could
be
connector_22
in
technology_1
while
the
plausibility
pattern_2
be
connector_22
in
technology_19
to
make
it
mathematically
sound
and
the
insurance
connector_23
pattern_2
should
be
connector_22
in
technology_20
because
it
really
need
to
quality_attribute_7
what
might
look
fun
from
a
developer’s
perspective
develop
a
perfect
component_20
with
your
perfect
technology_18
in
an
isolate
set
be
basically
never
what
an
organization
want
homogenization
and
standardization
that
mean
a
relatively
standardize
set
of
technology_18
technology_2
and
technology_10
so
that
other
developer
can
keep
maintain
your
technology_19
pattern_2
in
the
future
once
you
be
off
to
green
pasture
what’s
interest
historically
standardization
go
way
too
far
developer
in
big
fortune

requirement_2
be
sometimes
not
even
allow
to
use
technology_21
because
it
be
not
in
the
company’s
technology_22
blueprint
but
go
full
on
polyglot
be
pretty
much
the
same
thing
the
other
side
of
the
same
coin
recommendation
if
you
be
go
polyglot
try
small
diversity
in
the
same
programming
technology_18
eco
component_20
example
technology_23
and
technology_1
technology_3
base
with
100%
quality_attribute_8
between
each
other
not
technology_19
and
technology_1
quality_attribute_1
and
test
technology_1
pattern_1
it
help
to
have
a
quick
look
back
at
the
basic
mention
at
the
begin
of
this

any
component_6
side
technology_1
component_22
hence
also
any
pattern_2
be
a
jar
war

and
there’s
this
one
great
thing
about
the
technology_1
ecosystem
or
rather
the
technology_3
you
connector_22
your
technology_1
once
you
can
run
it
basically
on
any
operate
component_20
you
want
provide
you
didn’t
compile
your
with
a

technology_1
version
than
your
target
jvm’s
version
it’s
important
to
understand
this
especially
when
it
come
to
topic
technology_24
technology_25
or
shiver
the
requirement_8
why
let’s
have
a
look
at
different
deployment
scenario
a
bare
minimum
technology_1
pattern_2
deployment
example
continue
with
the
bank
example
we
end
up
with
our
monobank
jar
the
monolith
and
our
freshly
extract
riskengine
jar
the
first
pattern_2
let’s
also
assume
that
both
component_7
any
other
component_7
in
the
world
need
a
property

be
it
the
component_15
url
and
credential
a
bare
minimum
deployment
could
hence
consist
of
two
directory
that
look
roughly
this
r
r

ubuntu
ubuntu

nov



component_7
property
r
x

ubuntu
ubuntu

nov



monobank

jar
ubuntu@somemachine
var
www
www
monobank
technology_26
java$
technology_1
jar
monobank

jar
____
_
__
_
_
\\
___
_
__
_
_
_
_
__
__
_
\
\
\
\
\___
|
_
|
_|
|
_
\
_`
|
\
\
\
\
r
r

ubuntu
ubuntu

nov



component_7
property
r
x

ubuntu
ubuntu

nov



risk
component_23

jar
ubuntu@someothermachine
var
www
risk
monobank
technology_26
java$
technology_1
jar
risk
component_23

jar
____
_
__
_
_
\\
___
_
__
_
_
_
_
__
__
_
\
\
\
\
\___
|
_
|
_|
|
_
\
_`
|
\
\
\
\
this
leave
open
the
question
how
do
you
connector_3
your
property
and
jar
onto
the
component_6
unfortunately
there’s
a
variety
of
allure
answer
to
that
question
how
to
use
build
technology_10
ssh
&
technology_27
for
technology_1
pattern_2
deployment
the
boring
but
perfectly
fine
answer
to
technology_1
pattern_2
deployment
be
how
admins
quality_attribute_1
any
technology_1
component_6
side
component_22
in
requirement_2
in
the
past

year
with
a
mixture
of
your
favorite
build
technology_10
technology_6
gradle
quality_attribute_2
old
ssh
scp
for
copy
your
jar
to
component_24
bash
script
to
manage
your
deployment
script
and
component_24
or
even
quality_attribute_2
some
technology_27
script
if
you
be
not
fixate
on
create
a
breathe
requirement_8
of
ever
auto
load
balance
component_6
chaos
monkey
nuke
your
component_25
or
the
pattern_10
and
fuzzy
feel
of
see
zookeeper’s
leader
election
work
then
this
setup
will
take
you
very
far
oldschool
boring
but
work
how
to
use
technology_24
for
technology_1
pattern_2
deployment
back
to
the
allure
choice
a
couple
of
year
ago
technology_24
or
the
topic
of
containerization
hit
the
scene
if
you
have
no
previous
experience
with
it
this
be
what
it
be
all
about
for
end
component_4
or
developer
a
container
be
simplify
a
quality_attribute_2
old
virtual
component_25
but
more
lightweight
have
a
look
at
this
stackoverflow
answer
to
understand
what
lightweight
mean
in
this
component_26
a
container
guarantee
you
that
it
be
quality_attribute_9
it
run
anywhere
do
this
sound
familiar
interestingly
with
the
jvm’s
quality_attribute_10
and
backwards
quality_attribute_8
this
doesn’t
sound
major
benefit
you
could
download
a
technology_3
zip
on
any
component_6
raspberry
pi
or
even
requirement_1
phone
unzip
it
and
run
any
jar
you
want
it
look
a
bit
different
for
technology_18
technology_28
or
technology_29
where
version
incompatibility
or
deployment
setup
historically
be
more
complex
or
if
your
technology_1
component_7
quality_attribute_4
on
a
ton
of
other
instal
component_11
with
the
right
version
number
think
of
a
component_15
postgres
or
key
requirement_9
component_27
technology_30
so
docker’s
primary
benefit
for
technology_1
pattern_1
or
rather
technology_1
component_18
lie
in
set
up
homogenize
test
or
requirement_4
environment
with
technology_10
testcontainers
make
complex
deployables
quality_attribute_5
to
install
take
the
discourse
forum

you
can
install
it
with
one
technology_24
image
that
contain
everything
you
need
from
the
discourse
connector_22
in
technology_31
to
a
postgres
component_15
to
technology_30
and
the
kitchen
connector_24
if
your
deployables
look
similar
or
you
want
to
run
a
nice
little
technology_32
component_15
on
your
development
component_25
give
technology_24
a
try
so
to
sum
thing
up
instead
of
simply
scp’ing
a
jar

you
will
now
bundle
up
your
jar
into
a
technology_24
image
transfer
that
technology_24
image
to
a
private
technology_24
registry
connector_14
and
run
that
image
on
your
target
component_28
or
scp
the
technology_24
image
directly
to
your
prod
component_20
and
run
it
how
to
use
technology_24
swarm
or
technology_25
for
technology_1
pattern_2
deployment
let’s
say
you
be
give
technology_24
a
try
every
time
you
quality_attribute_1
your
technology_1
pattern_2
you
now
create
a
technology_24
image
which
bundle
your
jar

you
have
a
couple
of
these
technology_1
pattern_1
and
you
want
to
quality_attribute_1
these
component_11
to
a
couple
of
component_25
a
cluster
now
the
question
arise
how
do
you
manage
that
cluster
that
mean
run
your
technology_24
container
do
health
connector_4
roll
out
update
quality_attribute_7
brrrr
two
possible
answer
to
that
question
be
technology_24
swarm
and
technology_25
go
into
detail
on
both
option
be
not
possible
in
the
scope
of
this
guide
but
the
reality
takeaway
be
this
both
option
in
the
end
rely
on
you
connector_25
technology_33
see
not
a
question
technology_33
indentation
tale
to
manage
your
cluster
do
a
quick
search
on
twitter
if
you
want
to
what
feel
that
invoke
in
practice
so
the
deployment
component_8
for
your
technology_1
pattern_1
now
look
a
bit
this
setup
and
manage
technology_24
swarm
technology_25
everything
from
the
technology_24
step
above
connector_22
and
connector_26
technology_33
until
your
eye
bleed
thing
be
work
how
to
test
technology_1
pattern_1
let’s
assume
you
solve
quality_attribute_1
pattern_1
in
production
but
how
do
you
requirement_4
test
your
n
pattern_1
during
development
to
see
if
a
complete
workflow
be
work
not
the
single
piece
in
practice
you’ll
find
three
different
way
with
a
bit
of
extra
work
and
if
you
be
use
technology_34
technology_21
you
can
wrap
all
your
pattern_1
into
one
launcher

and
boot
up
all
pattern_1
with
one
wrapper
technology_1
quality_attribute_4
if
you
have
enough
memory
on
your
component_25
to
run
all
of
your
pattern_1
you
can
try
to
replicate
your
technology_24
swarm
or
technology_25
setup
locally
simply
don’t
do
requirement_4
test
locally
anymore
instead
have
a
dedicate
dev
test
environment
it’s
what
a
fair
number
of
team
actually
do
succumb
to
the
pain
of
local
pattern_2
setup
furthermore
in
addition
to
your
technology_1
pattern_1
you’ll
likely
also
need
an
up
and
run
connector_data_4
pattern_8
think
technology_35
or
technology_16
or
maybe
an
component_6
or
any
other
pattern_7
component_29
that
your
technology_1
pattern_1
need
to
connector_8
with
each
other
this
lead
to
a
fair
amount
of
underestimate
complexity
on
the
devops
side
have
a
look
at
pattern_2
test
technology_2
to
mitigate
some
of
that
pain
in
any
requirement_3
this
complexity
lead
u
to
common
pattern_2
issue
common
technology_1
pattern_2
question
let’s
have
a
look
at
technology_1
specific
pattern_1
issue
from
more
abstract
stuff
quality_attribute_11
to
specific
technology_2
how
to
make
a
technology_1
pattern_2
resilient
to
recap
when
build
pattern_1
you
be
essentially
swap
out
technology_3
connector_data_5
with
pattern_4
technology_7
connector_data_5
or
pattern_5
connector_data_4
whereas
a
connector_data_1
connector_27
be
basically
guarantee
with
the
exception
of
your
technology_3
exit
abruptly
a
requirement_10
connector_data_1
be
by
default
unreliable
it
could
work
it
could
also
not
work
for
various
reason
from
the
requirement_10
be
down
or
congest
to
a
firewall
rule
be
connector_21
to
your
connector_data_4
pattern_8
explode
to
see
what
implication
that
have
let’s
have
a
look
at
an
exemplary
billingservice
example
technology_7
rest
quality_attribute_11
pattern_11
say
requirement_11
can
buy
e
book
on
your
requirement_2

for
that
you
connector_21
a
bill
pattern_2
that
your
webshop
can
connector_data_1
to
generate
the
actual
pdf
invoice
for
now
we’ll
do
that
connector_data_1
synchronously
via
technology_7
it
would
make
more
sense
to
connector_data_1
that
component_9
asynchronously
because
pdf
generation
doesn’t
have
to
be
instant
from
a
user’s
perspective
but
we
want
to
re
use
this
very
example
in
the
next
section
and
see
the
difference
@service
billingservice
{
@autowired
private
httpclient
component_13
bill
component_4
component_4
plan
plan
{
invoice
invoice
=
createinvoice
component_4
plan
httpclient
connector_10
invoicerequest
component_4
getemail
invoice
responsehandler
}
}
think
about
what
kind
of
possible
connector_data_7
that
technology_7
connector_data_1
could
have
to
generalize
you
will
end
up
with
three
possible
connector_data_8
ok
the
connector_data_1
go
through
and
the
invoice
connector_3
create
successfully
delay
the
connector_data_1
go
through
but
take
an
unusually
long
amount
of
time
to
do
so
error
the
connector_data_1
do
not
go
through
maybe
because
you
connector_28
an
incompatible
connector_data_3
or
the
component_20
be
down
handle
error
not
the
happy
requirement_3
be
expect
for
any
component_22
it
be
the
same
for
pattern_1
even
though
you
have
to
take
extra
care
to
keep
all
of
your
quality_attribute_1
component_19
version
quality_attribute_12
a
soon
a
you
start
with
individual
pattern_2
deployment
and
release
and
if
you
want
to
go
full
on
chaos
monkey
you
will
also
have
to
live
with
the
possibility
that
your
component_24
connector_3
nuke
during
connector_data_3
component_8
and
you
might
want
the
connector_data_3
to
connector_3
re
connector_29
to
another
work
instance
an
interest
warn
requirement_3
be
the
delay
requirement_3
maybe
the
responding’s
pattern_2
hard
disk
be
run
full
and
instead
of
50ms
it
take

second
to
respond
this
can
connector_3
even
more
interest
when
you
be
experience
a
certain
load
so
that
the
unresponsiveness
of
your
billingservice
start
cascade
through
your
component_20
think
of
a
slow
kitchen
slowly
start
the
block
all
the
waiter
of
a
restaurant
this
section
obviously
cannot
give
in
depth
coverage
on
the
pattern_2
quality_attribute_11
topic
but
serve
a
a
reminder
for
developer
that
this
be
something
to
actually
tackle
and
not
ignore
until
your
first
release
which
from
experience
happen
more
often
than
it
should
a
popular
technology_2
that
help
you
think
about
quality_attribute_13
and
fault
tolerance
be
netflix’s
hystrix
use
it
documentation
to
dive
more
into
the
topic
pattern_7
quality_attribute_11
pattern_11
let’s
take
a
close
look
at
pattern_5
connector_7
our
billingservice
might
now
look
something
this
provide
we
use
technology_21
and
technology_16
for
our
connector_data_4
to
create
an
invoice
we
now
connector_10
a
connector_data_4
to
our
technology_16
connector_data_4
pattern_8
which
have
some
component_30
wait
for
connector_data_4
these
component_30
create
the
pdf
invoice
and
connector_10
them
out
to
the
respective
component_4
@service
billingservice
{
@autowired
private
rabbittemplate
rabbittemplate
bill
component_4
component_4
plan
plan
{
invoice
invoice
=
createinvoice
component_4
plan
convert
the
invoice
to
for
example
technology_36
and
us
it
a
the
connector_data_4
s
body
rabbittemplate
convertandsend
exchange
routingkey
invoice
}
}
now
the
potential
error
requirement_3
look
a
bit
different
a
you
don’t
connector_3
immediate
ok
or
error
connector_9
anymore
you
do
with
pattern_4
technology_7
connector_7
instead
you’ll
roughly
have
these
three
error
requirement_3
be
my
connector_data_4
connector_30
and
connector_31
by
a
component_31
or
do
it
connector_3
lose
the
component_4
connector_32
no
invoice
be
my
connector_data_4
connector_30
once
or
connector_30
more
than
once
and
only
component_8
exactly
once
the
component_4
would
connector_3
multiple
invoice
configuration
from
do
i
use
the
right
connector_29
key
exchange
name
to
be
my
connector_data_4
pattern_8
setup
and
maintain
correctly
or
be
it
component_32
overflow
the
component_4
connector_32
no
invoice
again
it
be
not
in
the
scope
of
this
guide
to
go
into
detail
on
every
single
pattern_5
pattern_2
quality_attribute_11
pattern_11
more
so
it
be
mean
a
pointer
in
the
right
direction
especially
a
it
also
quality_attribute_4
on
the
actual
pattern_7
technology_22
you
be
use
example
if
you
be
use
technology_11
implementation
technology_37
you
could
want
to
requirement_12
quality_attribute_14
for
the
guarantee
of
two
phase
xa
connector_33
if
you
be
use
technology_16
you
at
least
want
to
make
sure
to
have
connector_34
and
understand
this
guide
and
then
think
hard
about
acknowledgement
confirm
and
connector_data_4
quality_attribute_15
in
general
and
also
have
someone
with
experience
in
set
up
e
g
active
or
technology_16
component_24
and
configure
them
properly
especially
when
use
in
combination
with
cluster
and
technology_24
requirement_10
split
anyone
which
technology_1
pattern_2
technology_34
be
the
best
on
one
hand
you
have
establish
and
very
popular
choice
technology_21
which
make
it
very
easy
to
build
jar
that
come
with
an
embed
web
component_6
technology_38
or
technology_39
and
that
you
can
immediately
run
anywhere
a
perfect
fit
for
build
pattern_2
component_7
recently
though
and
partially
inspire
by
parallel
development
reactive
programming
technology_25
or
graalvm
a
couple
of
dedicate
pattern_2
technology_34
have
arise
to
name
a
few
quarkus
micronaut
vert
x
helidon
in
the
end
you
will
have
to
make
your
own
choice
but
this
can
give
some
maybe
unconventional
guidance
with
the
exception
of
technology_21
all
pattern_1
technology_34
generally
requirement_7
themselves
a
blazingly
fast
monumentally
quick
startup
time
low
memory
footprint
able
to
quality_attribute_7
indefinitely
with
impressive
graph
compare
themselves
against
the
technology_21
behemoth
or
against
each
other
this
be
clear
hit
a
nerve
with
developer
who
be
maintain
component_14
project
that
sometimes
take
minute
to
boot
up
or
requirement_8
requirement_13
developer
who
want
to
start
stop
a
many
micro
container
a
they
now
can
or
want
they
need
in
50ms
the
issue
however
be
that
artificial
bare
metal
startup
time
and
re
quality_attribute_1
time
barely
have
an
effect
on
a
project’s
overall
success
much
le
so
than
a
strong
technology_34
ecosystem
strong
documentation
and
strong
developer
skill
you’ll
have
to
look
at
it
this
way
if
until
now
you
your
orms
run
rampage
and
generate
hundred
of
connector_35
for
quality_attribute_5
workflow
you
need
endless
gigabyte
for
your
moderately
complex
monolith
to
run
you

so
much
and
complexity
that
disregard
potentially
slow
starter
technology_14
your
component_7
now
need
minute
to
boot
up
then

additional
pattern_2
challenge
think
quality_attribute_11
requirement_10
connector_data_4
devops
infrastructure
on
top
will
have
a
much
heavy
impact
on
your
project
than
boot
up
an
empty
hello
world
and
for
pattern_12
redeploy
during
development
you
finally
might
want
to
look
into
solution
jrebel
or
dcevm
to
go
back
to
simon
brown’s
quote
if
people
cannot
build
fast
&
quality_attribute_16
monolith
they
will
be
have
a
hard
time
build
fast
&
quality_attribute_16
pattern_1
no
matter
the
technology_34
so
choose
your
technology_34
wisely
which
technology_2
be
the
best
for
pattern_4
technology_1
pattern_6
connector_data_1
on
to
the
more
practical
aspect
of
connector_6
technology_7
pattern_6
apis
on
the
low
level
technical
side
you
be
probably
go
to
end
up
with
one
of
the
follow
technology_7
component_13
technology_2
java’s
own
httpclient
since
technology_1

apache’s
httpclient
or
okhttp
note
that
i
be
say
probably
here
because
there
be
a
gazillion
other
way
a
well
from
quality_attribute_2
old
technology_40
component_33
to
modern
technology_41
component_13
in
any
requirement_3
there
be
a
trend
towards
technology_7
component_13
generation
instead
of
mess
around
with
technology_7
connector_data_5
yourself
for
that
you
want
to
have
a
look
at
the
openfeign
project
and
it
documentation
a
a
start
point
for
further
connector_34
which
pattern_8
be
the
best
for
pattern_5
technology_1
connector_data_4
start
out
with
pattern_5
connector_data_4
you
be
likely
go
to
end
up
with
either
technology_35
classic
or
artemis
technology_16
or
technology_42
again
this
be
a
popular
pick
here’s
a
couple
of
random
point
though
technology_35
and
technology_16
be
both
traditional
fully
fledge
connector_data_4
pattern_8
this
mean
a
rather
smart
pattern_8
and
dumb
component_34
technology_35
historically
have
the
advantage
of
easy
embed
for
test
which
can
be
mitigate
with
technology_16
technology_24
testcontainer
setup
technology_42
be
not
a
traditional
pattern_8
it
be
quite
the
reverse
essentially
a
relatively
dumb
connector_data_4
component_27
think
requirement_14

need
smart
component_35
for
component_8
to
connector_3
a
quality_attribute_2
understand
on
when
to
use
technology_16
or
traditional
connector_data_4
pattern_8
in
general
or
technology_42
have
a
look
at
pivotal’s
match
a
a
start
point
in
general
though
try
to
dismiss
any
artificial
requirement_15
reason
when
choose
your
pattern_8
there
be
a
time
when
team
and
online

argue
a
ton
about
how
fast
technology_16
be
and
how
slow
technology_35
be
now
you
be
have
the
same
argument
on
technology_16
be
slow
with
a
consistent

30k
connector_data_4
every
single
second
technology_42
be
cite
with
100k
connector_data_4
a
second
for
one
these
kind
of
comparison
conveniently
leave
out
that
you
be
in
fact
compare
apple
and
orange
but
even
more
so
both
quality_attribute_17
number
might
be
on
the
lower
or
side
for
alibaba
group
but
you
author
have
never
see
project
of
this
size
million
of
connector_data_9
every
minute
in
the
real
world
they
definitely
exist
but
these
number
be
nothing
to
worry
about
for
the
other
99%
of
regular
technology_1
requirement_16
project
so
ignore
the
hype
and
choose
wisely
which
technology_2
can
i
use
for
pattern_2
test
quality_attribute_4
on
your
technology_43
you
might
end
up
use
technology_21
specific
technology_10
technology_21
ecosystem
or
something
arquillian
technology_1
ecosystem
connector_4
out
e
g
this
to
connector_3
a
deep
dive
into
the
technology_21
test
ecosystem
a
ton
of
different
test
technology_2
and
the
correspond
test
drive
workflow
note
i’m
affiliate
with
the
author
you’ll
also
want
to
have
a
look
at
technology_24
and
the
really
quality_attribute_2
testcontainers
technology_2
that
help
you
for
example
easily
and
quickly
setup
an
technology_32
component_15
for
your
local
development
or
requirement_4
test
for
mock
out
whole
technology_7
component_6
have
a
look
at
wiremock
for
test
pattern_5
connector_data_4
try
to
embed
technology_37
or
dockering
technology_16
and
then
connector_25
test
with
the
awaitility
dsl
other
than
that
all
your
usual
suspect
apply
junit
testng
to
assertj
and
mockito
note
that
this
be
by
no
mean
a
comprehensive
connector_data_10
and
if
you
be
miss
your
favorite
technology_10
it
in
the

section
and
i’ll
pick
it
up
in
the
next
revision
of
this
guide
how
do
i
enable
requirement_14
for
all
my
technology_1
microserviecs
requirement_14
with
pattern_1
be
an
interest
and
rather
complex
topic
instead
of
have
one
requirement_14
that
you
can
le
or
grep
you
now
have
n
requirement_14

that
you
would
to
see
combine
a
great
start
point
for
the
whole
requirement_14
ecosystem
be
this

make
sure
to
connector_34
it
especially
the
centralized
requirement_14
section
in
term
of
pattern_1
in
practice
you’ll
find
various
approach
a
sysadmin
connector_25
some
script
that
connector_36
and
merge
requirement_14
from
various
component_6
into
one
requirement_14
and
put
them
onto
technology_44
component_24
for
you
to
download
run
cat
grep
unig
sort
combo
in
parallel
ssh
component_36
you
can
tell
your
manager
that’s
what
technology_45
do
internally
use
a
technology_10
graylog
or
the
elk
technology_43
elasticsearch
logstash
kibana
how
do
my
pattern_1
find
each
other
so
far
we
kind
of
assume
that
our
pattern_1
all
each
other
their
correspond
ip
more
of
a
setup
so
our
bank
monolith
ip=192




that
he
have
to
talk
to
the
risk
component_6
ip=192



which
be
hardcoded
in
a
property

you
can
however
choose
to
make
thing
much
more
dynamic
you
could
not
quality_attribute_1
component_7
property
with
your
pattern_1
anymore
instead
use
a
requirement_8
config
component_6
where
all
pattern_1
connector_14
their
config
from
because
your
component_9
instance
might
connector_11
their
location
dynamically
think
of
technology_46
instance
connector_37
dynamic
ip
and
you
elastic
auto
quality_attribute_7
the
hell
out
of
the
requirement_8
you
soon
might
be
look
at
a
component_9
registry
that

where
your
component_11
live
with
what
ip
and
can
connector_38
accordingly
and
now
since
everything
be
dynamic
you
have
problem
automatic
leader
election
who
be
the
master
that
work
on
certain
connector_data_11
to
e
g
not
component_8
them
twice
who
replace
the
leader
when
he
fail
with
whom
in
general
term
this
be
what’s
connector_39
pattern_2
pattern_13
and
another
huge
topic
by
itself
technology_2
eureka
or
technology_47
try
to
solve
these
problem
component_33
or
pattern_14

which
component_11
be
quality_attribute_18
where
on
the
other
hand
they
introduce
a
whole
lot
of
additional
complexity
ask
anyone
who
ever
run
a
technology_47
setup
how
to
do
pattern_15
and
pattern_16
with
technology_1
pattern_1
another
huge
topic
worth
it
own
essay
again
option
range
from
hardcoded
technology_7
basic
auth
with
self
cod
quality_attribute_19
technology_34
to
run
an
oauth2
setup
with
your
own
pattern_15
component_6
how
do
i
make
sure
that
all
my
environment
look
the
same
what’s
true
for
non
pattern_2
deployment
be
also
true
for
pattern_2
deployment
you
will
try
a
combination
of
technology_24
testcontainers
a
well
a
script
technology_27
try
and
keep
it
quality_attribute_5
not
a
question
technology_33
indentation
tale
make
a
hard
cut
from
specific
technology_2
question
let’s
have
a
quick
look
at
technology_33
it
be
the
technology_48
be
use
a
the
de
facto
technology_48
to
connector_22
configuration
a

from
quality_attribute_5
technology_10
technology_27
to
the
mighty
technology_25
to
experience
technology_33
indentation
pain
yourself
try
and
connector_22
a
quality_attribute_5
technology_27
and
see
how
often
you
need
to
re
edit
the
to
connector_3
indentation
work
properly
despite
various
level
of
ide
support
and
then
come
back
to
finish
off
this
guide
technology_33
be
so
great
what
about
quality_attribute_20
transaction
requirement_15
test
other
topic
unfortunately
those
topic
didn’t
make
it
in
this
revision
of
this
guide
stay
tune
for
more
conceptual
pattern_2
challenge
in
addition
to
the
specific
technology_1
pattern_2
issue
there’s
also
issue
that
come
with
any
pattern_2
project
these
be
more
from
an
organizational
team
or
requirement_5
perspective
frontend
backend
mismatch
something
that
occur
in
many
pattern_2
project
be
what
i
would
connector_data_1
the
frontend
backend
pattern_2
mismatch
what
do
that
mean
that
in
quality_attribute_2
old
monolith
frontend
developer
have
one
specific
component_5
to
connector_3
connector_data_6
from
in
pattern_2
project
frontend
developer
suddenly
have
n
component_5
to
connector_3
connector_data_6
from
imagine
you
be
build
some
technology_1
iot
pattern_1
project
say
you
be
surveilling
component_25
requirement_17
oven
across
europe
and
these
oven
connector_10
you
regular
status
connector_data_12
with
their
pattern_17
etc
now
sooner
or
late
you
might
want
to
be
able
to
search
for
oven
in
an
admin
ui
maybe
with
the
help
of
a
search
oven
pattern_1
quality_attribute_4
on
how
strict
your
backend
colleague
might
interpret
domain
drive
design
or
pattern_2
law
it
could
be
that
the
search
oven
pattern_2
only

you

of
oven
no
other
connector_data_6
it
type
component_17
or
location
for
that
frontend
developer
might
have
to
do
one
or
n
additional
connector_data_5
quality_attribute_4
on
your
component_37
implementation
to
a
connector_3
oven
detail
pattern_2
with
the

they
connector_3
from
the
first
pattern_2
and
while
this
only
a
quality_attribute_5
but
take
from
a
real
life
project
example
it
demonstrate
the
follow
issue
real
life
supermarket
connector_3
huge
acceptance
for
a
reason
because
you
don’t
have
to
go
to

different
place
to
shop
vegetable
lemonade
freeze
pizza
and
toilet
paper
instead
you
go
to
one
place
it’s
quality_attribute_5
and
fast
it’s
the
same
for
frontend
developer
and
pattern_1
requirement_5
expectation
this
issue
be
something
that
be
an
unfortunate
side
effect
of
individual
developer
programming
magazine
or
requirement_8
requirement_2
connector_40
pattern_1
requirement_5
have
the
impression
that
you
now
can
pour
in
an
infinite
amount
of
developer
into
the
overarch
project
a
developer
can
now
work
completely
independent
from
each
other
everyone
on
their
own
pattern_2
with
some
tiny
requirement_4
work
need
at
the
very
end
i
e
shortly
before
go
live
let’s
see
why
this
mindset
be
such
an
issue
in
the
next
paragraph
small
piece
do
not
mean
quality_attribute_2
piece
one
rather
obvious
issue
be
that

small
piece
a
in
pattern_1
do
not
actually
mean

quality_attribute_2
piece
purely
from
a
technical
quality
perspective
it
could
mean
that
your
individual
component_11
still
connector_26

technology_14
connector_35
to
select
a
component_4
from
a
component_15
across
pattern_18
and
pattern_18
of
unmaintainable

to
go
back
to
simon
brown’s
quote
if
people
cannot
build
monolith
properly
they
will
be
have
a
hard
time
build
proper
pattern_1
especially
quality_attribute_11
and
everything
that
happen
after
the
go
live
be
such
an
afterthought
in
many
pattern_2
project
that
it
be
somewhat
scary
to
see
the
pattern_1
run
live
this
have
a
quality_attribute_5
reason
though
because
technology_1
developer
usually
be
not
interest
not
train
properly
in
quality_attribute_11
requirement_10
and
other
relate
topic
small
piece
lead
to
more
technical
piece
in
addition
there’s
the
unfortunate
tendency
for
component_4
story
to
connector_3
more
and
more
technical
and
therefore
stupid
the
more
micro
and
abstract
away
from
the
component_4
they
connector_3
imagine
your
pattern_2
team
be
ask
to
connector_22
a
technical
login
against
a
component_15
pattern_2
which
be
roughly
this
@controller
logincontroller
{
@postmapping
login
boolean
login

username
password
{
component_4
component_4
=
userdao
findbyusername
username
if
component_4
==

{
handle
non
exist
component_4
requirement_3
false
}
if
component_4
getpassword
equal
hash
password
{
handle
wrong
password
requirement_3
false
}
yay
requirement_14
in
set
some

do
whatever
you
want
true
}
}
now
your
team
might
decide
and
maybe
even
convince
businesspeople
that
be
way
too
quality_attribute_5
and
boring
instead
of
a
login
component_9
let’s
connector_22
a
really
capable
userstatechanged
pattern_2
without
any
real
tangible
requirement_16
requirement
and
because
technology_1
be
currently
out
of
fashion
let’s
connector_22
the
userstatechanged
pattern_2
in
technology_20
and
let’s
try
to
use
red
black
tree
somewhere
because
steve
yegge
connector_22
you
need
to
them
inside
out
to
apply
for

from
an
requirement_4
quality_attribute_21
and
overall
project
perspective
this
be
a
bad
a
connector_25
pattern_18
of
spaghetti
inside
the
same
monolith
fabricate
and
over
the
top
example
yes
unfortunately
also
not
uncommon
in
real
life
small
piece
lead
to
small
understand
then
there’s
this
topic
of
understand
the
complete
component_20
it
component_38
and
workflow
if
you
a
a
developer
be
only
responsible
to
work
on
isolate
pattern_2

login

updateuserprofile
it
blend
in
with
the
previous
paragraph
but
quality_attribute_4
on
your
organization
trust
and
connector_7
level
this
can
lead
to
a
lot
of
shoulder
shrug
and
blame
if
a
random
part
of
the
whole
pattern_2
chain
break
down
with
no
one
connector_41
full
responsibility
anymore
not
insinuate
bad
faith
but
the
problem
that
it
actually
be
really
difficult
to
understand
n
amount
of
isolate
piece
and
their
place
in
the
big
picture
connector_7
&
quality_attribute_21
which
blend
in
with
the
last
issue
here
connector_7
&
quality_attribute_21
which
obviously
quality_attribute_4
heavily
on
requirement_2
size
with
the
general
rule
the
big
the
more
problematic
who
be
work
on
pattern_2
number

do
they
quality_attribute_1
a

incompatible
pattern_2
version
where
be
this
document
who
do
i
need
to
talk
to
for
a
feature
connector_data_3
who
be
go
to
maintain
that
technology_20
pattern_2
after
max
leave
the
requirement_2
all
our
pattern_2
team
work
not
only
in
different
programming
technology_18
but
also
in
different
time
zone
how
do
we
coordinate
properly
the
overarch
theme
here
be
that
similarly
to
devops
skill
a
full
on
pattern_1
approach
in
a
big
maybe
even
international
requirement_2
come
with
a
ton
of
additional
connector_7
challenge
a
a
requirement_2
you
need
to
be
prepare
for
that
fin
have
connector_34
this
you
might
conclude
that
your
author
be
recommend
strictly
against
pattern_1
this
be
not
entirely
true
i
be
mainly
try
to
highlight
point
that
be
forget
in
the
pattern_1
frenzy
pattern_1
be
on
a
pendulum
go
full
on
technology_1
pattern_1
be
one
end
of
a
pendulum
the
other
end
would
be
something
hundred
of
quality_attribute_2
old
technology_6
in
a
monolith
you’ll
have
to
strike
the
right
balance
especially
in
greenfield
project
there
be
nothing
stop
you
from
take
a
more
conservative
monolithic
approach
and
build
few
quality_attribute_2
define
technology_6
instead
of
immediately
start
out
with
twenty
requirement_8
ready
pattern_1
pattern_1
generate
a
ton
of
additional
complexity
keep
in
mind
that
the
more
pattern_1
you
have
and
the
le
really
strong
devops
talent
you
have
no
connector_26
a
few
technology_27
script
or
quality_attribute_1
on
technology_49
do
not
count
the
more
issue
you
will
have
late
on
in
production
connector_2
through
the
common
technology_1
pattern_2
question
section
of
this
guide
be
already
exhaust
then
think
about
connector_42
solution
for
all
these
infrastructure
challenge
you’ll
suddenly
realize
that
none
of
this
have
to
do
with
requirement_16
programming
anymore
what
you
be
pay
for
but
rather
with
a
fixation
of
more
technology_22
on
even
more
technology_22
siva
sum
it
up
perfectly
on
his

i
canât
explain
how
horrible
it
feel
when
the
team
spend
70%
of
the
time
fight
with
this
modern
infrastructure
setup
and
30%
of
the
time
on
actual
requirement_16
component_39
siva
prasad
reddy
should
you
create
technology_1
pattern_1
to
answer
that
question
i’d
to
end
this
with
a
very
cheeky


teaser
if
you
the
answer
to
this
question
by
experience
even
though
it
seemingly
have
nothing
to
do
with
pattern_1
then
you
might
be
ready
for
a
pattern_1
approach
scenario
imagine
you
have
a
technology_1
monolith
run
solo
on
the
small
hetzner
dedicate
component_25
the
same
go
for
your
component_15
component_6
it
also
run
on
a
similar
hetzner
component_25
and
let’s
also
assume
that
your
technology_1
monolith
can
handle
workflow
component_4
registration
and
you
do
not
spawn
hundred
of
component_15
connector_35
per
workflow
but
only
a
reasonable
handful

question
how
many
component_15
connector_43
should
your
technology_1
monolith
connector_43
pool
open
up
to
your
component_15
component_6
why
and
to
how
many
concurrently
active
component_2
do
you
think
your
monolith
can
roughly
quality_attribute_7
answer
your
connector_data_13
to
these
question
in
the
section
i’m
look
connector_15
to
all
answer
now
make
up
your
own
mind
if
you
be
still
here
with
me
thanks
for
connector_34
there
s
more
where
that
come
from
i
ll
connector_10
you
an
update
when
i
publish
guide
no
spam
ever
unsubscribe
anytime
hp
i
want
more
connector_17

mut
author
=
i
m
@marcobehler
and
i
connector_17
everything
i
about
make
awesome
through
my
guide
screencasts
talk
and

follow
me
on
twitter
to
find
out
what
i
m
currently
work
on
privacy
&
term
imprint
â©

marco
behler
gmbh
