design
pattern_1
for
pattern_2
pattern_2
pattern_2
zone
thanks
for
visit
today
edit
profile
manage
subscription
how
to
to
submission
guideline
sign
out
pattern_3
profile
an
manage
my
draft
over
million
developer
have
join
requirement_1
in
join
refcardz
trend
report
webinars
zone
|
agile
requirement_2
requirement_3
requirement_4
component_1
devops
requirement_5
iot
technology_1
pattern_2
open_source
requirement_6
quality_attribute_1
web
dev
pattern_2
zone
design
pattern_1
for
pattern_2
design
pattern_1
for
pattern_2
a
detail
description
of
many
design
pattern_1
for
pattern_2
by
madhuka
udantha
core
·
jul
·
pattern_2
zone
·
analysis
connector_1
tweet
32k
pattern_3
join
the
and
connector_2
the
full
member
experience
join
for
free
pattern_2
can
have
a
positive
impact
on
your
requirement_7
therefore
it
be
worth
how
to
handle
pattern_4
architecture
msa
and
some
design
pattern_1
for
pattern_2
a
well
a
general
goal
or
principle
for
a
pattern_4
architecture
here
be
the
four
goal
to
consider
in
the
pattern_4
architecture
approach
reduce
cost
msa
will
reduce
the
overall
cost
of
design
connector_3
and
maintain
it
component_2
increase
release
quality_attribute_2
msa
will
increase
the
quality_attribute_2
from
idea
to
deployment
of
component_2
improve
quality_attribute_3
msa
will
improve
the
quality_attribute_3
of
our
component_2
requirement_8
enable
visibility
msa
support
for
quality_attribute_4
visibility
on
your
component_2
and
requirement_8
you
need
to
understand
what
principle
pattern_4
architecture
have
be
build
quality_attribute_5
quality_attribute_6
resiliency
quality_attribute_7
independent
autonomous
decentralized
governance
failure
isolation
auto
provision
continuous
delivery
through
devops
adhere
to
the
above
principle
bring
several
challenge
and
issue
while
bring
your
solution
or
component_3
to
live
those
problem
be
common
for
many
solution
those
can
overcome
with
use
correct
and
match
design
pattern_1
there
be
design
pattern_1
for
pattern_2
and
those
can
be
divide
into
five
pattern_1
each
contain
many
pattern_1
decomposition
pattern_1
decompose
by
requirement_9
capability
pattern_2
be
all
about
make
component_4
loosely
couple
and
apply
the
single
responsibility
principle
it
decompose
by
requirement_9
capability
define
component_4
correspond
to
requirement_9
capability
a
requirement_9
capability
be
a
concept
from
requirement_9
architecture
component_5
it
be
something
that
a
requirement_9
do
in
order
to
generate
requirement_10
a
requirement_9
capability
often
correspond
to
a
requirement_9
connector_data_1
e
g
order
requirement_11
be
responsible
for
order
requirement_12
requirement_11
be
responsible
for
requirement_12
decompose
by
subdomain
decompose
an
component_6
use
requirement_9
capability
might
be
a
quality_attribute_4
start
but
you
will
come
across
so
connector_data_2
“god
classes”
which
will
not
be
easy
to
decompose
these
will
be
common
among
multiple
component_2
define
component_4
correspond
to
domain
drive
design
ddd
subdomains
ddd
refer
to
the
application’s
problem
space
—
the
requirement_9
—
a
the
domain
a
domain
be
consist
of
multiple
subdomains
each
subdomain
correspond
to
a
different
part
of
the
requirement_9
subdomains
can
be
classify
a
follow
core
—
key
differentiator
for
the
requirement_9
and
the
most
valuable
part
of
the
component_6
support
—
relate
to
what
the
requirement_9
do
but
not
a
differentiator
can
be
connector_3
in
house
or
outsource
generic
—
not
specific
to
the
requirement_9
and
be
ideally
connector_3
use
off
the
shelf
the
subdomains
of
an
order
requirement_11
include
technology_2
catalog
component_2
inventory
requirement_11
component_4
order
requirement_11
component_4
delivery
requirement_11
component_4
decompose
by
transaction
two
phase
connector_4
2pc
pattern_1
this
pattern_1
can
decompose
component_4
over
the
transaction
then
there
will
be
multiple
transaction
in
the
component_3
one
of
the
important
participant
in
a
quality_attribute_8
transaction
be
the
transaction
coordinator
the
quality_attribute_8
transaction
consist
of
two
step
prepare
phase
—
during
this
phase
all
participant
of
the
transaction
prepare
for
connector_4
and
connector_5
the
coordinator
that
they
be
ready
to
complete
the
transaction
connector_4
or
rollback
phase
—
during
this
phase
either
a
connector_4
or
a
rollback
command
be
issue
by
the
transaction
coordinator
to
all
participant
the
problem
with
2pc
be
that
it
be
quite
slow
compare
to
the
time
for
of
a
single
pattern_4
coordinate
the
transaction
between
pattern_2
even
if
they
be
on
the
same
requirement_8
can
really
slow
the
component_3
down
so
this
approach
isn’t
usually
use
in
a
high
load
scenario
strangler
pattern_1
the
first
three
design
pattern_1
that
you
go
through
be
decompose
component_7
for
greenfield
but
80%
of
the
work
you
do
be
with
brownfield
component_6
which
be
big
monolithic
component_7
component_8
codebase
the
strangler
pattern_1
come
to
the
rescue
or
solution
this
create
two
separate
component_7
that
live
side
by
side
in
the
same
uri
space
over
time
the
newly
refactored
component_6
“strangles”
or
replace
the
original
component_6
until
finally
you
can
shut
off
the
monolithic
component_6
the
strangler
component_6
step
be
transform
coexist
and
eliminate
transform
—
create
a
parallel
with
modern
approach
coexist
—
leave
the
exist
where
it
be
for
a
time
redirect
from
the
exist
to
the
one
so
the
requirement_13
be
connector_3
incrementally
eliminate
—
remove
the
old
requirement_13
from
the
exist
bulkhead
pattern_1
this
pattern_1
isolate
element
of
an
component_6
into
pool
so
that
if
one
fail
the
others
will
continue
to
this
pattern_1
be
name
bulkhead
because
it
resemble
the
section
component_9
of
a
ship’s
hull
component_9
component_2
instance
into
different
group
base
on
component_10
load
and
quality_attribute_6
requirement
this
design
help
to
isolate
failure
and
allow
you
to
sustain
component_2
requirement_13
for
some
component_10
even
during
a
failure
sidecar
pattern_1
this
quality_attribute_9
component_11
of
an
component_6
into
a
separate
processor
container
to
provide
isolation
and
pattern_5
this
pattern_1
can
also
enable
component_7
to
be
compose
of
heterogeneous
component_11
and
technology_3
this
pattern_1
be
name
sidecar
because
it
resemble
a
sidecar
attach
to
a
motorcycle
in
the
pattern_1
the
sidecar
be
attach
to
a
parent
component_6
and
provide
support
feature
for
the
component_6
the
sidecar
also
connector_6
the
same
lifecycle
a
the
parent
component_6
be
create
and
retire
alongside
the
parent
the
sidecar
pattern_1
be
sometimes
refer
to
a
the
sidekick
pattern_1
and
be
the
last
decomposition
pattern_1
that
we
show
in
the
requirement_5
pattern_1
component_12
gateway
pattern_1
when
an
component_6
be
break
down
to
small
pattern_2
there
be
a
few
concern
that
need
to
be
connector_7
there
be
multiple
connector_data_3
for
multiple
pattern_2
by
different
pattern_6
there
be
a
need
for
handle
different
type
of
technology_4
different
component_13
might
need
a
different
technology_5
of
the
connector_8
an
component_12
gateway
help
to
connector_7
many
of
the
concern
raise
by
the
pattern_4
implementation
not
limit
to
the
one
above
an
component_12
gateway
be
the
single
point
of
entry
for
any
pattern_4
connector_data_2
it
can
work
a
a
pattern_7
component_2
to
connector_9
a
connector_data_4
to
the
concern
pattern_4
it
can
aggregate
the
connector_data_5
to
connector_10
back
to
the
component_10
this
solution
can
create
a
fine
grain
component_12
for
each
specific
type
of
component_14
it
can
also
convert
the
technology_4
connector_data_4
and
respond
it
can
also
offload
the
pattern_8
pattern_9
responsibility
of
the
pattern_4
aggregator
pattern_1
when
break
the
requirement_9
requirement_13
into
several
small
logical
piece
of
it
become
necessary
to
think
about
how
to
collaborate
the
connector_data_6
by
each
component_2
this
responsibility
cannot
be
leave
with
the
component_10
the
aggregator
pattern_1
help
to
connector_7
this
it
talk
about
how
we
can
aggregate
the
connector_data_6
from
different
component_4
and
then
connector_10
the
final
connector_8
to
the
component_10
this
can
be
do
in
two
way
a
composite
pattern_4
will
make
connector_data_3
to
all
the
require
pattern_2
consolidate
the
connector_data_6
and
transform
the
connector_data_6
before
connector_11
back
an
component_12
gateway
can
also
component_9
the
connector_data_4
to
multiple
pattern_2
and
aggregate
the
connector_data_6
before
connector_11
it
to
the
component_10
it
be
recommend
if
any
requirement_9
component_15
be
to
be
apply
then
choose
a
composite
pattern_4
otherwise
the
component_12
gateway
be
the
establish
solution
pattern_7
pattern_1
component_12
gateway
connector_12
pattern_2
over
component_12
gateway
in
this
example
the
component_12
gateway
have
three
component_12
requirement_14
technology_6
which
connector_13
the
component_12
for
the
ftgo
requirement_14
component_14
browser
technology_6
which
connector_13
the
component_12
to
the
technology_7
component_6
run
in
the
browser
technology_6
which
connector_13
the
component_12
for
third
party
developer
gateway
connector_14
pattern_1
the
component_12
gateway
be
responsible
for
connector_data_4
connector_15
an
component_12
gateway
connector_13
some
component_12
by
connector_14
connector_data_7
to
the
correspond
component_2
when
it
connector_16
a
connector_data_4
the
component_12
gateway
consult
a
connector_14
connector_data_8
that
specify
which
component_2
to
connector_9
the
connector_data_4
to
a
connector_14
connector_data_8
might
for
example
connector_data_8
an
technology_8
and
path
to
the
technology_8
url
of
component_2
this
be
identical
to
the
reverse
proxying
feature
provide
by
web
component_16
such
a
technology_9
chain
pattern_4
pattern_1
there
will
be
multiple
connector_17
of
for
single
component_4
or
pattern_4
eg
sale
pattern_4
have
connector_17
technology_2
pattern_4
and
order
pattern_4
chain
pattern_4
design
pattern_1
will
help
you
to
provide
the
consolidate
outcome
to
your
connector_data_4
the
connector_data_4
connector_18
by
a
pattern_4
which
be
then
connector_19
with
pattern_4
and
it
be
connector_19
with
pattern_4
all
these
component_4
be
pattern_10
connector_data_2
branch
pattern_1
a
pattern_4
need
to
connector_2
the
connector_data_6
from
multiple
component_17
include
other
pattern_2
branch
pattern_4
pattern_1
be
a
mix
of
aggregator
and
chain
design
pattern_1
and
allow
simultaneous
connector_data_4
connector_8
component_18
from
two
or
more
pattern_2
the
invoke
pattern_4
can
be
chain
of
pattern_2
branch
pattern_1
can
also
be
use
to
invoke
different
chain
of
pattern_2
or
a
single
chain
base
on
your
requirement_9
need
component_14
side
ui
composition
pattern_1
when
component_4
be
develop
by
decompose
requirement_9
capability
subdomains
the
component_4
responsible
for
requirement_15
have
to
connector_20
connector_data_6
from
several
pattern_2
in
the
monolithic
world
there
use
to
be
only
one
connector_data_2
from
the
ui
to
a
backend
component_2
to
connector_21
all
connector_data_6
and
refresh
submit
the
ui
component_19
however
now
it
won’t
be
the
same
with
pattern_2
the
ui
have
to
be
design
a
a
skeleton
with
multiple
section
region
of
the
screen
component_19
each
section
will
make
a
connector_data_2
to
an
individual
backend
pattern_4
to
connector_20
the
connector_data_6
technology_10
technology_11
and
technology_12
help
to
do
that
easily
these
screen
be
a
single
component_19
component_7
spa
each
team
develop
a
component_14
side
ui
component_20
such
an
technology_11
directive
that
connector_13
the
region
of
the
component_19
screen
for
their
component_2
a
ui
team
be
responsible
for
connector_22
the
component_19
skeleton
that
build
component_19
screen
by
compose
multiple
component_2
specific
ui
component_20
component_1
pattern_1
define
the
component_1
architecture
for
pattern_2
we
need
to
consider
the
below
point
component_4
must
be
loosely
couple
they
can
be
develop
quality_attribute_9
and
quality_attribute_10
independently
requirement_9
transaction
enforce
invariant
that
span
multiple
component_2
some
requirement_9
transaction
need
to
query
connector_data_6
that
be
owned
by
multiple
component_2
component_1
must
sometimes
be
replicate
and
connector_23
in
order
to
quality_attribute_10
different
component_4
have
different
connector_data_6
storage
requirement
component_1
per
component_2
to
solve
the
above
concern
one
component_1
per
pattern_4
must
be
design
it
must
be
private
to
that
component_2
only
it
should
be
connector_24
by
the
pattern_4
component_12
only
it
cannot
be
connector_24
by
other
component_4
directly
for
example
for
relational
component_1
we
can
use
private
component_21
per
component_2
schema
per
component_2
or
component_1
component_22
per
component_2
connector_23
component_1
per
component_2
we
have
talk
about
one
component_1
per
component_2
be
ideal
for
pattern_2
it
be
an
anti
pattern_1
for
pattern_2
but
if
the
component_6
be
a
monolith
and
try
to
break
into
pattern_2
denormalization
be
not
that
easy
in
the
late
phase
we
can
move
to
db
per
component_2
pattern_1
a
connector_23
component_1
per
component_2
be
not
ideal
but
that
be
the
work
solution
for
the
above
scenario
most
people
consider
this
an
anti
pattern_1
for
pattern_2
but
for
brownfield
component_6
this
be
a
quality_attribute_4
start
to
break
the
component_6
into
small
logical
piece
this
should
not
be
apply
for
greenfield
component_6
command
query
responsibility
segregation
cqrs
once
we
connector_3
component_1
per
component_2
there
be
a
requirement
to
query
which
require
joint
connector_data_6
from
multiple
component_2
it’s
not
possible
cqrs
suggest
split
the
component_6
into
two
part
—
the
command
side
and
the
query
side
the
command
side
handle
the
create
update
and
delete
connector_data_4
the
query
side
handle
the
query
part
by
use
the
materialize
pattern_3
the
component_23
pattern_1
be
generally
use
along
with
it
to
create
for
any
connector_data_6
connector_25
materialize
pattern_3
be
keep
update
by
subscribe
to
the
connector_26
of
component_23
most
component_7
work
with
connector_data_6
and
the
typical
approach
be
for
the
component_6
to
maintain
the
current
state
for
example
in
the
traditional
create
connector_27
update
and
delete
crud
component_5
a
typical
connector_data_6
component_18
be
to
connector_27
connector_data_6
from
the
component_24
it
contain
limitation
of
lock
the
connector_data_6
often
use
transaction
component_23
pattern_1
the
component_23
pattern_1
define
an
approach
to
handle
on
connector_data_6
that’s
drive
by
a
sequence
of
each
of
which
be
component_25
in
an
append
only
component_24
component_6
connector_28
a
series
of
that
imperatively
describe
each
action
that
have
occur
on
the
connector_data_6
to
the
component_24
where
they’re
persist
each
represent
a
set
of
connector_29
to
the
connector_data_6
such
a
addeditemtoorder
the
be
persist
in
an
component_24
that
act
a
the
component_3
of
component_25
typical
u
of
the
publish
by
the
component_24
be
to
maintain
materialize
pattern_3
of
component_26
a
action
in
the
component_6
connector_25
them
and
for
requirement_5
with
external
component_3
for
example
a
component_3
can
maintain
a
materialize
pattern_3
of
all
requirement_12
order
that
be
use
to
populate
part
of
the
ui
a
the
component_6
order
or
remove
connector_data_9
on
the
order
and
ship
connector_data_10
the
that
describe
these
connector_29
can
be
handle
and
use
to
update
the
materialize
pattern_3
the
figure
show
an
overview
of
the
pattern_1
component_23
pattern_1
saga
pattern_1
when
each
component_2
have
it
own
component_1
and
a
requirement_9
transaction
span
multiple
component_2
how
do
we
ensure
connector_data_6
consistency
across
component_2
each
connector_data_4
have
a
compensate
connector_data_4
that
be
connector_30
when
the
connector_data_4
fail
it
can
be
connector_3
in
two
way
choreography
—
when
there
be
no
central
coordination
each
component_2
produce
and
listen
to
another
service’s
and
decide
if
an
action
should
be
take
or
not
choreography
be
a
way
of
specify
how
two
or
more
party
none
of
which
have
any
control
over
the
other
parties’
component_18
or
perhaps
any
visibility
of
those
component_27
—
can
coordinate
their
activity
and
component_27
to
connector_31
connector_data_10
and
requirement_10
use
choreography
when
coordination
across
domain
of
control
visibility
be
require
you
can
think
of
choreography
in
a
quality_attribute_11
scenario
a
a
requirement_8
technology_4
it
dictate
acceptable
pattern_1
of
connector_data_7
and
connector_8
between
party
saga
pattern_1
—
choreography
pattern_11
—
an
orchestrator
connector_data_1
take
responsibility
for
a
saga’s
decision
make
and
sequence
requirement_9
component_15
when
you
have
control
over
all
the
actor
in
a
component_18
when
they’re
all
in
one
domain
of
control
and
you
can
control
the
flow
of
activity
this
be
of
most
often
when
you’re
specify
a
requirement_9
component_18
that
will
be
enact
inside
one
organization
that
you
have
control
over
sage
pattern_1
—
pattern_11
observability
pattern_1
requirement_1
aggregation
consider
a
use
requirement_16
where
an
component_6
consist
of
multiple
component_2
connector_data_7
often
span
multiple
component_2
instance
each
component_2
instance
generate
a
requirement_1
in
a
standardize
technology_5
we
need
a
centralized
requirement_1
component_2
that
aggregate
requirement_1
from
each
component_2
instance
component_28
can
search
and
analyze
the
requirement_1
they
can
configure
alert
that
be
connector_32
when
certain
connector_data_11
appear
in
the
requirement_1
for
example
pcf
do
have
requirement_1
aggregator
which
connector_33
requirement_1
from
each
component_20
pattern_12
pattern_13
diego
etc…
of
the
pcf
component_29
along
with
component_6
technology_13
requirement_4
watch
also
do
the
same
requirement_6
metric
when
the
component_2
portfolio
increase
due
to
a
pattern_4
architecture
it
become
critical
to
keep
a
watch
on
the
transaction
so
that
pattern_1
can
be
pattern_14
and
alert
connector_34
when
an
issue
happen
a
metric
component_2
be
require
to
gather
statistic
about
individual
it
should
aggregate
the
metric
of
an
component_6
component_2
which
provide
report
and
alerting
there
be
two
component_30
for
aggregate
metric
connector_35
—
the
component_2
connector_35
metric
to
the
metric
component_2
e
g
newrelic
appdynamics
connector_20
—
the
metric
component_4
connector_36
metric
from
the
component_2
e
g
prometheus
quality_attribute_8
trace
in
a
pattern_4
architecture
connector_data_7
often
span
multiple
component_2
each
component_2
handle
a
connector_data_4
by
perform
one
or
more
across
multiple
component_2
while
in
troubleshoot
it
be
worth
to
have
trace
we
trace
a
connector_data_4
end
to
end
the
solution
be
to
introduce
a
transaction
follow
approach
can
be
use
assign
each
external
connector_data_4
a
unique
external
connector_data_4
pass
the
external
connector_data_4
to
all
component_2
include
the
external
connector_data_4
in
all
requirement_1
connector_data_12
health
connector_37
when
pattern_4
architecture
have
be
connector_3
there
be
a
chance
that
a
component_2
might
be
up
but
not
able
to
handle
transaction
each
component_2
need
to
have
an
that
can
be
use
to
connector_37
the
health
of
the
component_6
such
a
health
this
component_12
should
o
connector_37
the
status
of
the
component_31
the
connector_38
to
other
component_2
infrastructure
and
any
specific
component_15
cross
cut
concern
pattern_1
external
configuration
a
component_2
typically
connector_data_3
other
component_4
and
component_1
a
well
for
each
environment
dev
qa
uat
prod
the
url
or
some
configuration
property
might
be
different
a
connector_25
in
any
of
those
property
might
require
a
re
build
and
re
quality_attribute_9
of
the
component_2
to
avoid
modification
configuration
can
be
use
externalize
all
the
configuration
include
url
and
credential
the
component_6
should
load
them
either
at
startup
or
on
the
fly
these
can
be
connector_24
by
the
component_6
on
startup
or
can
be
refresh
without
a
component_22
restart
component_2
discovery
pattern_1
when
pattern_2
come
into
the
picture
we
need
to
connector_7
a
few
issue
in
term
of
connector_39
component_2
with
container
technology_3
ip
connector_7
be
dynamically
allocate
to
the
component_2
instance
every
time
the
connector_7
connector_25
a
component_10
component_2
can
break
and
need
manual
connector_25
each
component_2
url
have
to
be
remember
by
the
component_10
and
become
tightly
couple
a
component_2
registry
need
to
be
create
which
will
keep
the
metadata
of
each
component_32
component_2
and
specification
for
each
a
component_2
instance
should
register
to
the
registry
when
start
and
should
de
register
when
shut
down
there
be
two
type
of
component_2
discovery
component_14
side
eg
netflix
eureka
component_22
side
eg
technology_13
alb
component_2
discovery
circuit
breaker
pattern_1
a
component_2
generally
connector_data_3
other
component_4
to
connector_21
connector_data_6
and
there
be
the
chance
that
the
downstream
component_2
be
down
there
be
two
problem
with
this
first
the
connector_data_4
will
keep
go
to
the
down
component_2
exhaust
requirement_8
resource
and
slow
requirement_6
second
the
requirement_15
will
be
bad
and
unpredictable
the
component_10
should
invoke
a
remote
component_2
via
a
pattern_7
that
behave
in
a
similar
fashion
to
an
electrical
circuit
breaker
when
the
number
of
consecutive
failure
cross
a
threshold
the
circuit
breaker
trip
and
for
the
duration
of
a
timeout
period
all
attempt
to
invoke
the
remote
component_2
will
fail
immediately
after
the
timeout
expire
the
circuit
breaker
allow
a
limit
number
of
test
connector_data_7
to
pass
through
if
those
connector_data_7
succeed
the
circuit
breaker
resume
normal
otherwise
if
there
be
a
failure
the
timeout
period
begin
again
this
pattern_1
be
suit
to
prevent
an
component_6
from
try
to
invoke
a
remote
component_2
or
connector_40
a
connector_23
resource
if
this
be
highly
likely
to
fail
circuit
breaker
pattern_1
blue
green
deployment
pattern_1
with
pattern_4
architecture
one
component_6
can
have
many
pattern_2
if
we
stop
all
the
component_4
then
quality_attribute_9
an
enhance
version
the
downtime
will
be
huge
and
can
impact
the
requirement_9
also
the
rollback
will
be
a
nightmare
blue
green
deployment
pattern_1
avoid
this
the
blue
green
deployment
strategy
can
be
connector_3
to
reduce
or
remove
downtime
it
achieve
this
by
run
two
identical
production
environment
blue
and
green
let’s
assume
green
be
the
exist
live
instance
and
blue
be
the
version
of
the
component_6
at
any
time
only
one
of
the
environment
be
live
with
the
live
environment
serve
all
production
traffic
all
requirement_4
component_33
provide
option
for
connector_22
a
blue
green
deployment
blue
green
deployment
pattern_1
reference
“microservice
architecture
align
principle
practice
and
culture”
book
by
irakli
nadareishvili
matt
mclarty
and
michael
amundsen
technology_8
pattern_2
io
pattern_1
decomposition
decompose
by
requirement_9
capability
technology_14
technology_8
www
baeldung
technology_15
transaction
across
pattern_2
technology_8
developer
technology_15
cl
strangler
component_6
pattern_1
pattern_2
component_34
trs
technology_8
doc
technology_15
en
u
technology_16
architecture
pattern_1
bulkhead
technology_8
technology_15
design
pattern_1
for
pattern_2
technology_8
doc
technology_15
en
u
technology_16
architecture
pattern_1
cqrs#event
component_23
and
cqrs
technology_8
doc
technology_15
en
u
technology_16
architecture
pattern_1
component_23
technology_8
www
dineshonjava
technology_15
pattern_2
with
technology_17
boot
technology_8
doc
technology_15
en
u
technology_16
architecture
pattern_1
circuit
breaker
pattern_4
web
component_2
component_1
requirement_14
component_35
design
relational
component_1
connector_data_7
circuit
breaker
pattern_1
connector_data_6
computing
component_12
publish
at
with
permission
of
madhuka
udantha
mvb
see
the
original
here
opinion
express
by
contributor
be
their
own
popular
on
best
practice
to
do
functional
test
on
the
requirement_4
refactoring
technology_1
component_6
connector_data_1
orient
and
functional
approach
the
engineer’s
guide
to
create
a
technical
debt
proposal
why
requirement_6
project
fail
pattern_2
partner
resource
x
about
u
about
connector_10
feedback
career
sitemap
advertise
advertise
with
contribute
on
submission
guideline
mvb
component_36
become
a
contributor
visit
the
writer
zone
legal
term
of
component_2
privacy
requirement_17
u
park
office
drive
suite
durham
nc
support@dzone
technology_15
+1
s
be
friend
technology_15
be
powered
by
