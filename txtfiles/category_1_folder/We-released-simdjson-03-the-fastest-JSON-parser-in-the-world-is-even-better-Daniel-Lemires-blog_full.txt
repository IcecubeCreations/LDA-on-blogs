we
release
simdjson


the
fast
technology_1
requirement_1
in
the
world
be
even
quality_attribute_1
–
daniel
lemire
s
skip
to
content
daniel
lemire
s
daniel
lemire
be
a
component_1
science
professor
at
the
university
of
quebec
teluq
in
montreal
his
research
be
focus
on
requirement_2
and
connector_data_1
engineering
he
be
a
techno
optimist
and
a
free
speech
advocate
coding_keyword_1
and
widget
my
home
component_2
my
paper
my
subscribejoin


pattern_1
connector_1
you
can
also
follow
this
on
telegram
search
for
support
my
work
i
do
not
connector_2
any
advertisement
however
you
can
support
the
with
donation
through
paypal
please
consider
connector_3
in
touch
if
you
be
a
supporter
so
that
i
can
thank
you
you
can
also
support
my
work
on
technology_2
recent
coding_keyword_2
requirement_3
technology_1
fast
with
intel
avx

avoid
exception
throw
in
requirement_2
sensitive
fast
bitset
decoding
use
intel
avx

fast
bitset
decoding
use
intel
avx

remove
character
from
coding_keyword_3
fast
with
avx

recent
commentsme
on
avoid
exception
throw
in
requirement_2
sensitive
codedaniel
lemire
on
avoid
exception
throw
in
requirement_2
sensitive
codejoern
engel
on
avoid
exception
throw
in
requirement_2
sensitive
codegrid
on
be
your
coding_keyword_3
immutable
krytyczna
on
should
component_1
scientist
keep
the
lena
picture
component_2
a
short
history
of
technology_3
about
me
book
recommendation
cognitive
bias

and
talk
my
bet
my
favorite

my
favorite
quote
my
reader
my
say
prediction
recommend
video
game
term
of
use
connector_4
quality_attribute_1
paper
archive
archive
select
month


















































































































































































































































































































































































































































boring
stuff
requirement_4
in
entry
fee

fee
technology_4

we
release
simdjson


the
fast
technology_1
requirement_1
in
the
world
be
even
quality_attribute_1
last
year

we
release
the
simjson
technology_5
it
be
a
technology_6
technology_5
quality_attribute_2
under
a
liberal
license
technology_7
that
can
requirement_3
technology_1
document
very
fast
how
fast
we
reach
and
exceed

gigabyte
per
second
in
many
instance
it
can
also
requirement_3
million
of
small
technology_1
document
per
second
the
version
be
much
fast
how
much
fast
last
year
we
could
requirement_3
a
simdjson
at
a
quality_attribute_3
of


gb
s
and
then
we
reach


gb
s
we
be
now
reach


gb
s
why
go
so
fast
in
comparison
a
fast
disk
can
reach

gb
s
and
the
best
requirement_5
adapter
be
even
fast
the
follow
plot
present
the

simdjson
technology_5
version


compare
with
the
fast
technology_8
compliant
technology_6
technology_1
requirement_1
rapidjson
and
sajson
it
run
on
a
single
intel
skylake
core
and
the
be
compile
with
the
gnu
technology_9

compiler
all
test
be
reproducible
use
technology_10
container
in
this
plot
rapidjson
and
simjson
have
exact
number
requirement_3
while
rapidjson
fast
float
and
sajson
use
approximate
number
requirement_3
furthermore
sajson
have
only
partial
unicode
validation
whereas
other
requirement_1
offer
exact
encoding
utf8
validation
if
we
only
improve
the
requirement_2
it
would
already
be
amaze
but
our
release
pack
a
whole
lot
of
improvement
multi
document
requirement_3
connector_5
a
bundle
of
technology_1
document
ndjson

4x
fast
than
do
it
individually
simplify
technology_11
the
component_3
have
be
completely
revamp
for
ease
of
use
include
a
technology_1
navigation
component_3
and
fluent
support
for
error
and
exception
style
of
error
handle
with
a
single
technology_11
in
the
past
use
simdjson
be
a
bit
of
a
chore
the
approach
be
definitively
modern
see
for
yourself
auto
cars_json
=
r
{
make
toyota
component_4
camry
year

tire_pressure




}
{
make
kia
component_4
soul
year

tire_pressure




}
{
make
toyota
component_4
tercel
year

tire_pressure




}
_padded
dom
requirement_1
requirement_1
dom
coding_keyword_4
car
=
requirement_1
requirement_3
cars_json
connector_6
dom
coding_keyword_4
iterate
through
an
coding_keyword_4
of
connector_data_2
for
dom
connector_data_3
car
car
{
connector_7
a
by
name
cout
make
component_4
car
make
car
component_4
endl
cast
a
technology_1
element
to
an
coding_keyword_5
uint64_t
year
=
car
year
cout
this
car
be

year
year
old
endl
iterate
through
an
coding_keyword_4
of
float
double
total_tire_pressure
=

for
double
tire_pressure
car
tire_pressure
{
total_tire_pressure
+=
tire_pressure
}
cout
average
tire
pressure
total_tire_pressure

endl
connector_8
out
all
the
connector_data_4
about
the
car
for
auto
key
requirement_6
car
{
cout
key
requirement_6
endl
}
}
exact
float
requirement_3
simdjson
par
float
flawlessly
at
high
quality_attribute_3
fallback
implementation
simdjson
now
have
a
non
simd
fallback
implementation
and
can
run
even
on
very
old

bit
component_5
this
mean
that
you
no
long
need
to
connector_9
whether
the
component_6
support
simdjson
automatic
allocation
a
part
of
component_3
simplification
the
requirement_1
no
long
have
to
be
preallocated
it
will
adjust
automatically
when
it
encounter
large

runtime
selection
technology_11
we
have
connector_10
simdjson’s
runtime
cpu
detection
and
implementation
selection
a
an
technology_11
so
you
can
tell
what
implementation
we
detected
and
test
with
other
implementation
error
handle
your
way
whether
you
use
exception
or
connector_9
error
cod
simdjson
coding_keyword_6
you
handle
error
in
your
style
component_7
that
can
fail
coding_keyword_7
simdjson_result
coding_keyword_6
you
connector_9
the
error
before
use
the
connector_data_5
but
if
you
be
more
comfortable
with
exception
skip
the
error
and
cast
straight
to
the
requirement_6
you
need
and
exception
will
be
throw
automatically
if
an
error
happen
use
the
same
component_3
either
way
error
chain
we
also
work
to
keep
non
exception
error
handle
short
and
sweet
instead
of
have
to
connector_9
the
error
after
every
single

now
you
can
chain
technology_1
navigation
connector_data_6
look
up
an
connector_data_3
or
coding_keyword_4
element
or
cast
to
a
coding_keyword_3
so
that
you
only
have
to
connector_9
the
error
once
at
the
very
end
we
now
have
a
dedicate
web
technology_12
simdjson

in
addition
to
the
technology_13
technology_12
technology_2
technology_14
simdjson
simdjson
credit
many
people
contribute
to
simdjson
but
john
keiser
play
a
substantial
role
worthy
of
mention
publish
by
daniel
lemire
a
component_1
science
professor
at
the
university
of
quebec
teluq
pattern_2
all
coding_keyword_2
by
daniel
lemire
coding_keyword_2
on

2020april

2020author
daniel
lemirecategories

thought
on
“we
release
simdjson


the
fast
technology_1
requirement_1
in
the
world
be
even
quality_attribute_1
”
claude
say


at


be
congratulation
be
de
rigueur
here
i
guess
the
next
challenge
will
be
an
component_3
to
quality_attribute_3
up
technology_15
requirement_3
technology_15
be
an
important
part
of
quality_attribute_4
pytorch
on
most
component_8
it
will
be
worth
see
if
you
can
easily
adapt
this
technology_5
to
this
type
of
requirement_3
connector_data_7
michal
lazo
say


at


be
be
there
any
simd
accelerate
connector_data_8
requirement_1
connector_data_7
daniel
lemire
say


at


pm
there
have
be
some
connector_data_8
requirement_1
at
least
at
the
prototype
level
that
have
use
simd
instruction
deliberately
however
i
do
not
think
that
there
have
ever
be
something
simdjson
for
technology_16
connector_data_7
josé
duarte
say


at


be
the
parabix
connector_data_8
project
connector_data_7
daniel
lemire
say


at


pm
the
parabix
connector_data_8
project
yes
we
of
parabix
but
no
it
be
nothing
simdjson
for
technology_16
connector_data_7
josé
duarte
say


at


pm
and
how
do
it
compare
it
look
innovative
be
simdjson’s
approach
applicable
to
connector_data_8
too
connector_data_7
daniel
lemire
say


at


pm
please
see
the
paper
where
it
be
discuss
in
detail
if
you
have
question
after
connector_11
the
paper
i
will
be
happy
to
answer
them
connector_data_7
joe
duarte
say


at


pm
okay
i
connector_5
it
very
nice
work
q1
why
do
you
use

byte
to
encode
thing
coding_keyword_8
true
false
etc
couldn’t
you
use
one
byte
or
even
a
few
bit
after
all
there’s
a
coding_keyword_8
codepoint
in
ascii
utf

—
it’s
the
first
one
the
binary
zero
byte


do
you
need
everything
to
be
eight
byte
for
some
reason
q2
why
be
you
focus
only
on
huge

over

kb
for
technology_1
that’s
huge
the
most
common
use
of
technology_1
be
sling
around
connector_data_9
and
connector_12
on
the
web
with
small
connector_data_10
for
example
a
pattern_3
component_3
for
payment
might
involve
technology_1
connector_data_11
that
be
about

to

kb
each
graphql
rest
also
us
technology_17
see
paypal’s
technology_11
or
here’s
an
example
of
a
typical
connector_data_12
connector_data_10
technology_12
doc
gopay
technology_14
en
lang=shell#standard
payment
q3
what
do
you
do
if
you
can’t
use
tzcnt
to
count
trail
zero
that
instruction
be
part
of
bmi
which
come
out
in
haswell
ivy
bridge
and
sandy
bridge
won’t
have
it
and
there
be
still
a
lot
of
component_9
run
on
those
family
how
far
back
do
you
go
on
simd
be
something
westmere
or
nehalem
you’re
floor
they
would
have
sse4

carryless
multiplication
and
i
think
aes
you
might
be
understate
simdjson
requirement_2
with
all
those
number
heavy

since
number
requirement_3
should
be
your
slow
fyi
i
open
an
issue
on
technology_13
ask
about
cpu
and
memory
overhead
that’s
an
important
dimension
that
the
paper
and
the
don’t
connector_1
it’s
also
important
to
if
it
cause
core
to
throttle
down
when
you
use
avx2
or
whatever
i
think
skylake
and
cascade
lake
might
be
okay
on
that
front
but
there
might
be
an
issue
use
avx
or
avx2
on
early
family
if
so
use
simdjson
would
slow
down
all
the
other
component_10
and
workload
on
the
component_11
i
that
avx512
throttle
core
but
i
don’t
remember
about
avx2
connector_data_7
daniel
lemire
say


at


pm
why
do
you
use

byte
to
encode
thing
coding_keyword_8
true
false
etc
couldn’t
you
use
one
byte
or
even
a
few
bit
the
tape
us
a
flat

byte
per
element
with
some
exception
number
use
two

byte
entry
why
be
you
focus
only
on
huge

over

kb
for
technology_1
that’s
huge
that
be
what
the
paper
benchmark
but
you
can
find
other
connector_data_13
on
technology_2
include
on
tiny

what
do
you
do
if
you
can’t
use
tzcnt
to
count
trail
zero
that
instruction
be
part
of
bmi
which
come
out
in
haswell
ivy
bridge
and
sandy
bridge
won’t
have
it
and
there
be
still
a
lot
of
component_9
run
on
those
family
how
far
back
do
you
go
on
simd
be
something
westmere
or
nehalem
you’re
floor
they
would
have
sse4

carryless
multiplication
and
i
think
aes
the
simdjson
rely
on
runtime
dispatch
it
run
on
every
x64
component_12
under
a

bit
component_6
it
be
open_source
fyi
i
open
an
issue
on
technology_13
ask
about
cpu
and
memory
overhead
that’s
an
important
dimension
that
the
paper
and
the
don’t
connector_1
it’s
also
important
to
if
it
cause
core
to
throttle
down
when
you
use
avx2
or
whatever
i
think
skylake
and
cascade
lake
might
be
okay
on
that
front
but
there
might
be
an
issue
use
avx
or
avx2
on
early
family
if
so
use
simdjson
would
slow
down
all
the
other
component_10
and
workload
on
the
component_11
i
that
avx512
throttle
core
but
i
don’t
remember
about
avx2
we
do
not
support
avx

no
downclocking
be
expect
we
do
not
use
avx2
instruction
require
it
e
g
fma
but
in
any
requirement_7
a
the
component_13
you
be
in
charge
of
kernel
that
run
so
you
can
select
ssse3
be
you
prefer
even
when
your
component_6
support
avx2
the
simdjson
have
a
non
allocation
requirement_8
for
requirement_3
so
you
can
requirement_3
terabyte
of
connector_data_1
without
allocate
memory
connector_data_7
joe
duarte
say


at


be
okay
so
on
the
issue
of
cpu
overhead
you
say
on
technology_13
that
quality_attribute_3
be
cpu
overhead
or
something
that’s
not
quite
right
the
equation
be
overhead
=
technology_17
gb
requirement_3
quality_attribute_3
×
cpu
usage
where
cpu
usage
be
the
percentage
of
cpu
there
could
also
be
a
form
that
us
cpu
clock
cycle
per
byte
or
something
it’s
not
enough
to
how
fast
some
be
–
we
normally
have
to
it
cost
in
resource
cpu
and
memory
it
look
you’re
quality_attribute_1
on
memory
since
you
don’t
allocate
but
i’m
surprise
that
you’re
unwilling
to
report
cpu
overhead
another
suggestion
it
would
be
great
to
some
thing
about
simdjson’s
quality_attribute_5
property
to
have
some
basic
assurance
this
be
a
strange
era
for
computing
give
how
insecure
and
primitive
our
programming
technology_18
and
technology_19
be
technology_6
be
an
unsafe
technology_18
where
exploitable
memory
bug
be
inevitable
on
to
large
project
one
light
assurance
would
be
if
you
follow
the
technology_6
core
guideline
much
strong
assurance
would
be
to
pass
something
coverity
scan
it’s
free
for
open_source
project
a
technology_1
requirement_1
might
requirement_3
untrusted
input
which
can
be
malformed
or
not
technology_1
at
all
ideally
a
requirement_1
would
be
formally
verify
but
hardly
anyone
do
that
since
popular
programming
technology_18
technology_6
aren’t
design
to
facilitate
verification
and
the
technology_19
suck
so
coverity
be
about
a
quality_attribute_1
a
it
connector_6
connector_1
sanitizer
and
memory
sanitizer
in
the
llvm
project
be
interest
too
the
engineering
institute
at
carnegie
mellon
have
a
quality_attribute_6
technology_6
cod
guideline
too
technology_12
insight
sei
cmu
edu
sei_blog


cert
technology_20
quality_attribute_6
cod
guideline
technology_21
if
you
have
some
kind
of
formal
assurance
those
it
would
be
pretty
distinctive
connector_data_7
daniel
lemire
say


at


pm
i’m
surprise
that
you’re
unwilling
to
report
cpu
overhead
if
you
have
interest
requirement_2
metric
you
would
to
propose
we
be
always
invite
connector_13
connector_data_12
the
simdjson
technology_5
be
a

base
project
please
connector_4
up
some

and
we
shall
be
glad
to
discus
it
connector_data_7
marcel
weiher
say


at


be
awesome
work
when
i
look
at
quality_attribute_7
the
previous
version
into
a
high
level
requirement_1
it
didn’t
look
it
handle
connector_14
be
that
impression
correct
and
if
so
have
that
connector_15
thanks
connector_data_7
daniel
lemire
say


at


pm
we
do
handle
long
input
contain
multiple
technology_1
document
e
g
line
separate
we
even
have
a
nifty
component_3
for
it
see
“parse_many”
if
you
mean
connector_16
a
in
“reading
from
a
technology_6
istream”
then
no
we
do
not
support
this
and
won’t
it
be
too
slow
we
be
fast
than
getline
apply
to
an
in
memory
istream
connector_data_7
marcel
weiher
say


at


pm
don’t
care
about
technology_6
istream
in
order
to
connector_14
the
requirement_1
must
be
able
to
deal
with
partial
incomplete
input
and
with
resume
such
an
incomplete
requirement_3
feed
it
be
then
somebody
else’s
problem
one
of
the
thing
i

early
on
in
build
high
perf
component_14
be
that
have
the
component_15
itself
be
fast
be
at
most
half
the
bette
the
crucial
bit
be
that
it
must
be
possible
preferably
easy
straightforward
to
use
it
in
such
a
way
the
the
whole
ensemble
be
fast
a
lot
of
the
“fast”
connector_data_8
requirement_1
tend
to
fall
flat
in
that
regard
connector_data_7
marcel
weiher
say


at


pm
battle
of

i
blame
autocorrect…
connector_data_7
daniel
lemire
say


at


pm
the
way
simdjson
be
currently
design
be
that
it
won’t
coding_keyword_6
you
connector_17
a
document
at
all
unless
it
have
be
fully
validate
the
rationale
behind
this
be
that
many
people
do
not
want
to
start
ingest
document
that
be
incorrect
and
of

you
can
only
that
a
document
be
valid
if
you
have
see
all
of
it
for
line
separate
technology_1
document
it
be
not
an
issue
because
you
connector_6
to
see
the
whole
technology_1
document
before
coding_keyword_7
it
to
the
component_13
it
be
that
you
have
a
long
connector_14
of
them
we
plan
to
offer
more
option
in
future
release
connector_data_7
pawel
terlecki
say


at


pm
the
requirement_3
quality_attribute_3
be
impressive
great
work
i
second
marcel’s
point
the
current
work
well
if
a
component_12
pipeline
start
with
a

however
the
requirement_1
cannot
be
use
in
the
middle
of
a
pipeline
in
a
large
component_6
without
support
connector_16
input
materialize
large
intermediate
connector_data_5
clog
the
flow
download
a
from
requirement_9
storage
or
component_13
define
document
transformation
be
common
scenario
here
the
requirement_1
would
not
have
to
output
incorrect
or
incomplete
document
it
would
wait
for
another
chunk
of
input
to
continue
requirement_3
a
document
that
be
in
flight
connector_data_7
daniel
lemire
say


at


pm
you
connector_4
“materializing
large
intermediate”
and
with
that
constraint
i
agree
but
be
mindful
that
large
mean
“out
of
cache”
and
we
have
megabyte
of
pattern_4
on
current
processor
core
for
small
to

query
pattern_4
line
through
an
be
an
anti
design
note
that
we
have
since
release
version


which
introduce
a
component_3
that
we
connector_data_14
on
demand
technology_11
so
this
coding_keyword_2
be
somewhat
obsolete
at
this
point
connector_data_7
eb
say


at


be
minor
inconsistency
in
the
example
the
average
tire
pressure
of
the
car
will
not
be
what
one
would
expect
only
half
of
it
connector_data_7
alex
mikhalev
say


at


pm
any
plan
for
technology_22
bind
connector_data_7
daniel
lemire
say


at


pm
there
be
technology_22
bind
but
help
be
need
to
connector_6
it
update
technology_12
technology_2
technology_14
sundoge
simdjson
technology_22
connector_data_7
catherine
say


at


pm
congrats
what
about
a
mooc
levure
on
requirement_3
with
technology_6
connector_data_7
daniel
lemire
say


at


pm
@catherine
i
have
a
talk
on
youtube
do
that
count
technology_12
www
youtube
technology_14
watch
v=wlvkat7sziq
connector_data_7
catherine
say


at


pm
thanks
great
talk
and
aha
moment
connector_data_7
josé
duarte
say


at


be
by
the
way
it
would
be
neat
to
have
an
ultrafast
simd
technology_1
minifier
something
very
light
in
term
of
cpu
and
memory
use
this
would
presumably
be
much
quality_attribute_8
than
a
requirement_1
since
all
it
would
have
to
do
be
strip
space
tab
newlines
and
carriage
coding_keyword_7
well
it
would
have
to
not
to
touch
the
content
of
quote
coding_keyword_3
there’s
an
enormous
amount
of
waste
with
all
the
unminified
technology_1
people
be
sling
around
you
can
connector_18
10%
most
of
the
time
by
minify
but
there
aren’t
any
quality_attribute_1
minifiers
out
there
connector_data_7
daniel
lemire
say


at


pm
by
the
way
it
would
be
neat
to
have
an
ultrafast
simd
technology_1
minifier
something
very
light
in
term
of
cpu
and
memory
use
but
we
do
have
that
it
be
part
of
simdjson
connector_data_7
josé
duarte
say


at


pm
oh
nice
do
it
minify
by
default
or
be
it
a
flag
connector_data_7
daniel
lemire
say


at


pm
oh
nice
do
it
minify
by
default
or
be
it
a
flag
it
be
a
that
you
connector_data_14
on
technology_1
coding_keyword_3
it
do
not
requirement_3
it
be
highly
optimize
it
be
not
currently
very
well
connector_10
or
document
since
it
have
be
update
to
be
multiplatform
only
recently
connector_data_7
daniel
ryan
say


at


be
how’s
the
requirement_2
for
requirement_10
e
g
technology_23
and
io
component_16
i’m
currently
use
rapidjson
for
a
technology_5
that’s
use
for
requirement_10
component_17
and
wonder
if
i
should
move
over
to
simjson
if
it’s
fast
and
easy
to
use
connector_data_7
daniel
lemire
say


at


be
we
support

bit
arm
component_18
with
accelerate
kernel
see
technology_12
lemire
me




a

release
of
simdjson
runtime
dispatch

bit
arm
support
and
more
connector_data_7
leave
a
connector_data_7
cancel
replyyour
connector_1
will
not
be
publish
the
form
expect
plain
text
if
you
need
to
technology_24
your
text
you
can
use
technology_21
element
such
strong
blockquote
cite
and
em
for
technology_24
a
technology_21
automatically
i
recommend
tohtml
technology_14

*
name
*
*
connector_18
my
name

and
in
this
browser
for
the
next
time
i

connector_19
connector_data_15
no
do
not
subscribe
yes
connector_data_16
to
my
yes
all

connector_data_7
instantly
hourly
digest
daily
digest
weekly
digest
or
you
can
subscribe
without

δ
you
subscribe
to
this
by

coding_keyword_2
navigation
previous
previous
coding_keyword_2
science
and
technology_3
connector_20

28th

next
next
coding_keyword_2
science
and
technology_3
connector_20

4th

term
of
use
proudly
powered
by
technology_4
