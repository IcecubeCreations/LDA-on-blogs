Fluentd vs Logstash: A Comparison of Log Collectors | Logz.io                                                                                     Platform           Platform Overview         Log Management Based on the ELK Stack      Infrastructure Monitoring Based on Prometheus     Cloud SIEM Based on the ELK Stack      Distributed Tracing Based on Jaeger Features Alerts  Application Insights  Cognitive Insights  Data Optimizer  ELK Apps  Live Tail  Log Parsing  Security and Compliance  Log Patterns   Solutions            Solutions Industry  Gaming   Financial Services   eCommerce   Digital Media & Entertainment   IoT   Energy  Use Case  AWS Observability   Azure Observability   Container Monitoring   Security Operations Center   ELK Migration   Reduce Noisy Data   Pricing   Resources          Resources Videos  Blog  Case Studies  OpenTelemetry Guide  ELK Guide  Open Source  Docs  Webinars  Support   Company          Company About us  Customers  Partners  Careers  Contact us  Newsroom   About Logz.io           Login      Sign Up    Get a DemoFree Trial Login Sign Up  Home/Blog/ELK Stack/Fluentd vs Logstash: A Comparison of Log Collectors  #Comparison   #Fluentd   #Logstash Fluentd vs Logstash: A Comparison of Log Collectors  Noni Peri Updated on: Jun 3, 2020 The unsung heroes of log analysis are the log collectors. They are the hard-working daemons that run on servers to pull server metrics, parse loogs, and transport them to systems like Elasticsearch or PostgreSQL. While visualization tools like Kibana or re:dash bask in the glory, log collectors’s routing making it all possible. Here, we will pit the two of the most popular data collectors in the open source world: Fluentd vs Logstash.Logstash is most known for being part of the ELK Stack while Fluentd has become increasingly used by communities of users of software such as Docker, GCP, and Elasticsearch.The goal here is a no-frills comparison and matchup of Elastic’s Logstash vs Fluentd, which is owned by Treasure Data. The goal is to collect all of the facts about these excellent software platforms in one place so that readers can make informed decisions for their next projects.More on the subject:Grafana Templates for Elasticsearch, Prometheus and InfluxDBWhat Are the Hardest Parts of Kubernetes to Learn?Cognitive & Application Insights Logz.io supports Logstash and Fluentd. On a related note, we see a growing number of customers using Fluentd to ship logs to us. As a result, it was important for us to make this comparison. The following charts of the differences between Logstash and Fluentd, and then we go into more detail below. Fluentd vs Logstash: Platform ComparisonOne of Logstash’s original advantages was that it is written in JRuby, and hence it ran on Windows.Fluentd, on the other hand, did not support Windows until recently due to its dependency on a *NIX platform-centric event library. Not anymore. As of this pull request, Fluentd now supports Windows. You can also input this in_windows_eventlog plugin to track Windows event logs.Logstash: Linux and Windows Fluentd: Linux and WindowsEvent Routing ComparisonOne of the key features of log collectors is event routing. Both log collectors support routing, but their approaches are different.Logstash Event RoutingLogstash routes all data into a single stream and then uses algorithmic if-then statements to send them to the right destination. Here is an example that sends error events in production to PagerDuty:output {
if [loglevel] == "ERROR" and [deployment] == "production" {
pagerduty {
...
}
}
}Vs Fluentd Event RoutingFluentd relies on tags to route events. Each Fluentd event has a tag that tells Fluentd where it wants to be routed. For example, if you are sending error events in production to PagerDuty, the configuration would look something like this:<match production.error>
type pagerduty
…
</match>A more complete example looks like:  

<source>
  @type forward
</source>

<filter app.**>
  @type record_transformer
  <record>
    hostname "#{Socket.gethostname}"
  </record>
</filter>

<match app.**>
  @type file
  # ...
</match>
#In order to have more than one sort of input, add another and @type with a specific tag, 
<source>
  @type tail
  tag system.logs
  # ...
<source>

then mark that tag in the area: 
<match {app.**,system.logs}>
You can re-route Fluentd events in three ways: 1) by tag using the fluent-plugin-route plugin, 2) by label with the out_relabel plugin, or 3) by record content with the fluent-plugin-rewrite-tag filter.Fluentd’s approach is more declarative whereas Logstash’s method is procedural. Therefore, programmers trained in procedural programming might see Logstash’s configuration as easier for getting started. On the other hand, Fluentd’s tag-based routing allows complex routing to be expressed clearly. For example, the following configuration applies different logic to all production and development events based on tag prefixes.<match production.**>
# production pre-processing
</match>
<match development.**>
# development pre-processing
</match>Logstash: Uses algorithmic statements to route events and is good for procedural programmers Fluentd: Uses tags to route events and is better at complex routingPlugin Ecosystem ComparisonBoth Logstash and Fluentd have rich plugin ecosystems covering many input systems (file and TCP/UDP), filters (mutating data and filtering by fields), and output destinations (Elasticsearch, AWS, GCP, and Treasure Data)Logstash PluginsOne key difference is how plugins are managed. Logstash manages all its plugins under a single GitHub repo. While the user may write and use their own, there seems to be a concerted effort to collect them in one place. As of this writing, there are 199 plugins under logstash-plugins GitHub repo.A list of examples includes:logstash-output-beatslogstash-output-csvlogstash-output-elasticsearchlogstash-output-elasticsearch_javalogstash-output-google_cloud_storagelogstash-output-google_pubsublogstash-output-graphitelogstash-output-jiralogstash-output-mongodblogstash-output-nagioslogstash-output-rabbitmqlogstash-output-s4logstash-output-slacklogstash-output-solr_httplogstash-output-stdoutlogstash-output-sysloglogstash-output-webhdfslogstash-output-zabbixlogstash-output-zeromqlogstash-output-zookeeperFluentd PluginsFluentd, on the other hand, adopts a more decentralized approach.  There are 8 types of plugins in Fluentd—Input, Parser, Filter, Output, Formatter, Storage, Service Discovery and Buffer. Although there are 516 plugins, the official repository only hosts 10 of them. In fact, among the top 5 most popular plugins (fluent-plugin-record-transformer, fluent-plugin-forest, fluent-plugin-secure-forward, fluent-plugin-elasticsearch, and fluent-plugin-s3), only one is in the official repository! (The Logzio plugin is among the top 30 downloaded by Fluentd users with over 260,000)A list of examples includes:elasticsearchs3kinesiskafkagoogle-cloudforestsecure-forwardrecord-reformercloudwatch-logsprometheusaws-elasticsearch-servicesystemdec2-metadataroutebigqueryremote_sysloggcloud-pubsub-customlogziowebhdfskinesis-aggregationslackLogstash: Centralized plugin repository Fluentd: Decentralized plugin repositoryTransport ComparisonLogstash lacks a persistent internal message queue: Currently, Logstash has an on-memory queue that holds 20 events (fixed size) and relies on an external queue like Redis for persistence across restarts. This is a known issue for Logstash, and it is actively worked on this issue where they aim to persist the queue on-disk.Fluentd, on the other hand, has a highly easy-to-configure buffering system. It can be either in-memory or on-disk with more parameters that you ever care to know.The upside of Logstash’s approach is simplicity: the mental model for its sized queue is very simple. However, you must deploy Redis alongside Logstash for improved reliability in production. Fluentd has built-in reliability, but its configuration parameters take some getting used to.Logstash: Needs to be deployed with Redis to ensure reliability Fluentd: Built-in reliability, but its configuration is more complicatedPerformance ComparisonThis is a nebulous topic. As discussed in this talk at OpenStack Summit 2015, both perform well in most use cases and consistently grok through 10,000+ events per second.That said, Logstash is known to consume more memory at around 120MB compared to Fluentd’s 40MB. Considering modern machines, this isn’t a big difference between the two aggregators. For leaf machines, it’s a different story: Spread across 1,000 servers, this can mean 80GB of additional memory use, which is significant. (This hypothetical number comes from the 80MB difference between Logstash and FluentD on a single machine multiplied by 1,000 machines.)Don’t worry, Logstash has a solution. Instead of running the fully featured Logstash on leaf nodes, Elastic recommends that you run Elastic Beats, resource-efficient, purpose-built log shippers. Each Beat focuses on one data source only and does that well. On Fluentd’s end, there is Fluent Bit, an embeddable low-footprint version of Fluentd written in C, as well as Fluentd Forwarder, a stripped down version of Fluentd written in Go.Logstash: Slightly more memory use. Use Elastic Beats for leaf machines. Fluentd: Slightly less memory use. Use Fluent Bit and Fluentd Forwarder for leaf machines.So Much Information! What’s Next?While there are several differences, the similarities between Logstash and Fluentd are greater than their differences. Users of either Logstash or Fluentd are miles ahead of the curve when it comes to log management.Observability at scale, powered by open source See
 PlansYou might also likeNews  Keep Calm and Simplify Managing your SIEM events with Siemplify  DevOps  Why We Chose the M3DB Data Store for Logz.io Prometheus-as-a-Service  ELK Stack  A Quick Guide to Log Shipping To Logz.io: Collectors, Code, and Clouds       Back to Blog    6 responses to “Fluentd vs Logstash: A Comparison of Log Collectors”  Ory Band says: November 22, 2015 at 10:01 amnice read!might be worth mentioning logstash-forwarder and it’s filebeat successor as elastic’s “primary” file log shipper. written in go and is pretty efficient  AlexH says: September 28, 2016 at 1:53 pmThank you. Good overview before deep dive to one(or both) of them. P.S. FluentD impressed me slighly more 😉  BrunoBronosky says: October 20, 2016 at 10:02 pmNeither fluentd nor logstash support Linux? Only Mac & Windows? Interesting. #SMH  Daniel Berman says: October 23, 2016 at 8:55 amThanks for the feedback – this post will be updated ASAP.  Cameron Kerr says: March 23, 2017 at 10:31 pmI feel this post really misses out on some significant aspects. 1) it should compare abilities to process and enrich logs, not just route them; while perhaps not quite so much an issue for log clients (with the exception of multiline logs, which often gets tricky when scaling out the reception layer), this is where a lot of value gets injected. 2) I’ve found it useful to break-down functionality into reception and enrichment layers on the (log) server. Similarly, leaf nodes and server nodes are very different, and I felt this could have said a lot more about the architectural / philosophical approach of each. For example, filebeat (the Beat for sending log files to Logstash or Elasticsearch) doesn’t really offer much, if any, filtering. I would have liked to see the extent to which Fluent Bit or Fluent Forwarder offer to reduce the amount of log traffic being sent centrally.Thanks for the post though, it did give me some introduction to Fluentd.  John Knepper says: June 1, 2017 at 7:27 pmI think this article is outdated so I’ll add that most modern architectures are shipping to logstash as a centralized logging agent, but collecting / shipping with filebeat.  Don’t use logstash-forwarder it’s old and deprecated.  Filebeat works very well especially under heavy load, and can even ship directly to ES if you don’t need sophisticated filtering which logstash provides.InternalPlatformLog ManagementCloud SIEMInfrastructure MonitoringDistributed TracingSolutionsInfrastructure MonitoringAPMSecurity AnalyticsCloud Monitoring DevOps AnalyticsContainer MonitoringComplianceFeaturesAlertsApplication InsightsCognitive InsightsData OptimizerELK AppsLive TailLog ParsingSecurity and ComplianceLog PatternsPricingPlansRequest DemoResourcesBlogELK GuideCase StudiesLogz.io Open SourceDocsCompanyAbout usCustomersPartnersCareersContact UsNewsroom                                Privacy PolicyTerms Of UseTrademarks Legal NoticeLogz.io SLAAll Rights Reserved © 2015, Logshero Ltd.      Logz.io Live. Join the weekly live demo.  Register Now  DevOps Pulse 2022: Observability Trends and Challenges.  Download Report >  Forrester Observability Snapshot.  Download Report > Consolidate Your AWS Data In One Place  Learn More Search Logz.io   ×     