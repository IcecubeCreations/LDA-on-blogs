Kafka vs RabbitMQ. what is kafka, what is RabbitMQ, and‚Ä¶ | by Brachi Packter | ITNEXTOpen in appHomeNotificationsListsStoriesWritePublished inITNEXTBrachi PackterFollowDec 2, 2018¬∑6 min readSaveKafka vs RabbitMQwhat is Kafka, what is RabbitMQ, and what are the strength and weakness of each frameworkPhoto by Markus Spiske on Unsplash**Disclaimer : I‚Äôm not using Kafka or RabbitMq in production (yet), so this article isn‚Äôt based on some deep experience , just FYI***Kafka vs RabbitMQThere are countless articles on the internet comparing among these two leading frameworks, most of them just telling you the strength of each, but not providing a full wide comparison of features supports and specialties.When I make a decision about which technology to choose, I always wish to see a comparison table, then I can quickly check what are the key features of my specific scenario, and get a decision.RabbitMQ in a nutshellWho are the players:1. Consumer2. Publisher3. Exchange4. RouteThe flow starts from the Publisher, which send a message to exchange, Exchange is a middleware layer that knows to route the message to the queue, consumers can define which queue they are consuming from (by defining binding), RabbitMQ pushes the message to the consumer, and once consumed and acknowledgment has arrived, message is removed from the queue.Any piece in this system can be scaled out: producer, consumer, and also the RabbitMQ itself can be clustered, and highly available.KafkaWho are the players1. Consumer / Consumer groups2. Producer3. Kafka source connect4. Kafka sink connect5. Topic and topic partition6. Kafka stream7. Broker8. ZookeeperKafka is a robust system and has several members in the game. but once you understand well the flow, this becomes easy to manage and to work with.Producer send a message record to a topic, a topic is a category or feed name to which records are published, it can be partitioned, to get better performance, consumers subscribed to a topic and start to pull messages from it, when a topic is partitioned, then each partition get its own consumer instance, we called all instances of same consumer a consumer group.In Kafka messages are always remaining in the topic, also if they were consumed (limit time is defined by retention policy)Also, Kafka uses sequential disk I/O, this approach boosts the performance of Kafka and makes it a leader option in queues implementation, and a safe choice for big data use cases.Let‚Äôs compare:1. Distribution and parallelismBoth give a good distribution solution, but with some difference.Let‚Äôs talk about consumers, in RabbitMQ, you can scale out the number of consumers, this means, for each queue instance you will have many consumers, this called competitive consumers because they compete to consume the message, in this form the message processing work is spread by all the active consumers, but still message can be procced only once.In Kafka, the way to distribute consumers is by topic partitions, and each consumer from the group is dedicated to one partition.You can use the partition mechanism to send each partition different set of messages by business key, for example, by user id, location, etc.2. High AvailabilityBoth solutions are highly available.Kafka does it by using Zookeeper to manage the state of the clusterRabbitMQ has provided clustering and highly available queues for several major versions. Version 3.8.0 shipped with ‚ÄúQuorum Queues‚Äù which use the Raft consensus algorithm to provide data replication with higher performance than ‚Äúclassic‚Äù HA queues.3. PerformanceKafka leverages the strength of sequential disk I/O and requires less hardware, this can lead to high throughput: several millions of messages in a second, with just a tiny number of nodes.RabbitMQ also can process a million messages in a second but requires 30+ nodes.4. ReplicationKafka has replicated the broker by design, and if the master broker is down, automatically all the work is passed to another one which has a full replica of the died one, no message lost.In RabbitMQ queues aren‚Äôt automatically replicable, this need to be configured. (Version 3.8.0 simplifies this. If your cluster has at least three nodes, all you must do is declare your queue as a Quorum Queue and replication is taken care of for you)5. Multi subscriberIn Kafka messages can be subscribed by multi consumers, means, many consumer types not many instances of the same one.In RabbitMQ messages can be routed to numerous queues depending on the exchange type (such as fanout or topic) and the queue bindings. In each queue, only one consumer of that queue can process the message, but if the message goes to multiple queues it can be processed by multiple consumers.6. Message orderingBecause Kafka has partitions, you can get messages ordering in this unit.messages are routed to topics by message key, so, when choosing a correct key, you will get one partition for any key, with ordered messages.This can‚Äôt be achieved in RabbitMQ, only by trying by mimic this behavior by defining many queues and sending each message to a different queue, at scale, this can be hard to get. compaction log: if the same message key has arrived multiple times, then Kafka saves only the last value in the log, and delete old messages.7. Message protocolsRabbitMQ supports any standard queue protocols like AMQP, STOMP (Text-based), MQTT (lightweight publish/subscribe messaging) and HTTP, while Kafka supports primitives (int8, int16, int32, int64, string, arrays) and binary messages.8. Message lifetimeBecause Kafka is a log, messages are always there, you can control this by defining a message retention policy.RabbitMQ is a queue, messages removed once consumed and acknowledgment arrived.In RabbitMQ you can configure messages to be persistent, mark the queue as durable and messages as persistent.9. Message acknowledgmentIn both frameworks, producers get confirmation that the message arrives in the queue/topic and also the consumer sends an acknowledgment when the message consumed successfully. so you can be sure that messages didn‚Äôt get lost in the way.10. Flexible routing to a topic/queueIn Kafka message is sent to a topic by key, in RabbitMQ there are more options, for example by regular expression and wildcard, check the docs for more information.11. Message priorityIn RabbitMQ, you can define message priorities, and consumed message with high priority first. for more information look in https://www.rabbitmq.com/priority.htmlhard to achieve in Kafka (can be done by message keys, but on large scale, this can be hard)12. MonitoringIn Kafka you have 3rd party tools:License for a production environmentConfluent https://www.confluent.io/product/control-center/Landoop http://www.landoop.com/freeBurrow https://github.com/linkedin/BurrowKafka Tool http://www.kafkatool.com/In RabbitMQ you have a built-in management UI (default <host_name>:15672).Also, note that version 3.8.0 supports external monitoring via Prometheus and Grafana13. Transaction supportBoth support atomic writes, means if you write a bunch of messages to queue and one failed, all the transaction is rollbacked, this extremely used in Kafka stream processing.Let‚Äôs recapUse Kafka if you needTime travel/durable/commit logMany consumers for the same messageHigh throughput (millions of messages per second)Stream processingReplicabilityHigh availabilityMessage orderUse RabbitMq if you need:flexible routingPriority QueueA standard protocol message queueConclusion:Actually, RabbitMQ is enough for simple use cases, with low traffic of data, you have certain benefits like a priority queue and flexible routing options. But for massive data and high throughput use Kafka without debates.If you need a commit log or multiple consumers for the same messages, then go to Kafka because RabbitMQ can‚Äôt assist you with it.--15----15More from ITNEXTFollowITNEXT is a platform for IT developers & software engineers to share knowledge, connect, collaborate, learn and experience next-gen technologies.Read more from ITNEXTRecommended from MediumLachlan EvensoninMicrosoft AzureKubernetes Policy‚Ää‚Äî‚ÄäTurning CNCF projects into products, responsiblyVermaNikitaLaunch an AWS-EC2 instance using Terraform CodeWendy Raven McNairinGeek CultureFizzBuzzJim LaiMVVM without VM with CombineLukasz LazewskiRunning LUKSO node on M1 MacGokuMarket ExchangeinGokuMarketAirdrop Alert: üíù Love for Community Feb-Mar Month Airdrop is Now Live üíü ü™ÇTed MartinStart Using Your Mac Like a ProChinmay Venkata SabbaminArt of CodingDeeper insights of Thread-pool & Need of Asynchronous programming  in Java¬†‚Ä¶.(part-1)AboutHelpTermsPrivacyGet the Medium appGet startedBrachi Packter556 FollowersI love everything related to code and techFollowMore from MediumOlga ShafraninDev GeniusKafka Cluster on Docker ComposeShaaf, SyedCreate SQL cache stores and more in Data Grid 8.3Rob GolderinLydtech ConsultingKafka Transactions: Part 1: Exactly-Once MessagingYasser KarimiEnterprise Application‚Ää‚Äî‚Ääpart 2 -PerformanceHelpStatusWritersBlogCareersPrivacyTermsAboutKnowable





































