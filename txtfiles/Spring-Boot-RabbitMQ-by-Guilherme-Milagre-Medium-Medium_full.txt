Spring Boot + RabbitMQ | by Guilherme Milagre | Medium | MediumGet unlimited accessOpen in appHomeNotificationsListsStoriesWriteGuilherme MilagreFollowApr 26, 2020·5 min readSpring Boot + RabbitMQProcessamento assíncrono com filas para aumentar a performance, a confiabilidade e a escalabilidade de seus microserviços.Arquitetura assíncrona com filas de mensagensSpring Boot 2.x + Apache Camel + RabbitMQNeste artigo mostrarei para você sobre a arquitetura assíncrona com filas de mensagens podem simplificar bastante a codificação de microserviços e aumentar a performance, a confiabilidade e a escalabilidade.Bom começarei explicando um pouco sobre as tecnologias usadas e te ajudará caso você ainda não tenha tido nenhuma experiência anterior.O que é uma fila de mensagens?Uma fila de mensagens é uma forma de comunicação assíncrona entre serviços. As mensagens são armazenadas na fila até serem processadas e excluídas. Cada mensagem é processada uma única vez, por um único consumidor.Utilizaremos como intermediário o RabbitMQ.O que é RabbitMQ?É um intermediário de mensagens: aceita e encaminha mensagens. Você pode pensar nisso como uma agência postal. Por exemplo, quando você coloca no correio o que deseja postar em uma caixa postal, pode ter certeza de que o Sr. ou a Sra Person acabarão entregando o correio ao seu destinatário. Nesta analogia, o RabbitMQ é uma caixa postal, uma agência postal e um carteiro.O RabbitMQ e as mensagens em geral usam um jargão. Produzir e Consumir.Produzir: um programa que envia mensagens é um produtor.Consumir: um consumidor é um programa que espera principalmente para receber mensagens.Produtor > FILA < ConsumidorO RabbitMQ é o intermediário de mensagens de código aberto mais amplamente implantado, é um dos mais populares brokers de mensagens de código aberto, é leve e fácil de implantar no local e na nuvem.Ele suporta vários protocolos de mensagens que podem ser implantado em configurações distribuídas e federadas para atender aos requisitos de alta disponibilidade e alta escala.Saiba mais sobre o RabbitMQ.O que é Apache Camel?Camel é um estrutura de integração de código aberto que permite integrar rápida e facilmente vários sistemas que consomem ou produzem dados, suporta a maioria dos padrões de integração que Embalado com várias centenas de componentes que são usados ​​para acessar bancos de dados, filas de mensagens, APIs ou basicamente qualquer coisa. Ajudando você a se integrar com tudo.Como o próprio nome diz é ele que carrega o trabalho pesado. tenha em mente como O Apache Camel é a faca suíça de integração.Saiba mais sobre o Apache Camel.Requisitos:Java 11SpringBoot 2.2.x (Consumer) Acesse o projeto no GitHub- camel-rabbitmq-starter 3.2.0- camel-jackson 3.2.0- lombokPython 3.6 (Producer) Acesse o projeto no GitHub- pikaDocker 18.09RabbitMQ 3.7Docker compose do RabbitMQ:execute com docker-compose.rabbitmq-service:  image: "rabbitmq:3.7-management"   environment:     RABBITMQ_DEFAULT_USER: "admin"    RABBITMQ_DEFAULT_PASS: "admin"    RABBITMQ_DEFAULT_VHOST: "/"  ports:    - "15672:15672"    - "5672:5672"   volumes:    - "./rabbitmq:/var/lib/rabbitmq"Consumer (person-queue-consumer-service) em SpringBoot 2.x:Configuraremos o pom.xml:<parent>   <groupId>org.springframework.boot</groupId>   <artifactId>spring-boot-starter-parent</artifactId>   <version>2.2.6.RELEASE</version>   <relativePath/> <!-- lookup parent from repository --></parent><groupId>com.guilhermebmilagre</groupId><artifactId>person-queue-consumer-service-rabbitmq</artifactId><version>0.0.1-SNAPSHOT</version><name>person-queue-consumer-service-rabbitmq</name><description>Demo project consumer queue RabbitMQ</description><properties>   <java.version>11</java.version></properties><dependencies>   <dependency>      <groupId>org.apache.camel.springboot</groupId>      <artifactId>camel-rabbitmq-starter</artifactId>      <version>3.2.0</version>   </dependency>   <dependency>      <groupId>org.apache.camel</groupId>      <artifactId>camel-jackson</artifactId>      <version>3.2.0</version>   </dependency>   <dependency>      <groupId>org.projectlombok</groupId>      <artifactId>lombok</artifactId>      <optional>true</optional>   </dependency></dependencies>class main RabbitmqApplication.java:@SpringBootApplicationpublic class RabbitmqApplication {   public static void main(String[] args) {      SpringApplication.run(RabbitmqApplication.class, args);   }}Configuraremos uma rota do Camel para que toda mensagem execute em um processador PersonConsumerRoute.java:@Component@RequiredArgsConstructorpublic class PersonConsumerRoute extends RouteBuilder {    private final PersonProcessor personProcessor;    @Override    public void configure() throws Exception {        from("{{application.rabbitmq.queues.person}}")                .unmarshal()                .json(JsonLibrary.Jackson, Person.class)                .process(personProcessor);    }}Nosso processador(process) PersonProcessor.java:@Slf4j@Service@RequiredArgsConstructorpublic class PersonProcessor implements Processor {    @Override    public void process(Exchange exchange) throws Exception {        Person person = exchange.getIn().getBody(Person.class);        Thread.sleep(100);        log.info("processing queue, id: {} personName: {}", person.getId(), person.getName());}}classe de dominío Person.java@Datapublic class Person {    private Long id;    private String name;}application.ymlserver:  servlet:    context-path: /person-queue-consumer-servicespring:  application.name: person-queue-consumer-serviceapplication:  rabbitmq:    queues:      person: rabbitmq:personExchange?queue=person&concurrentConsumers=20&threadPoolSize=20&prefetchCount=10&prefetchSize=0&prefetchGlobal=false&prefetchEnabled=truecamel:  component:    rabbitmq:      host: localhost      port: 5672      username: admin      password: admin      channel-pool-max-size: 20      durable: true      auto-delete: false      auto-ack: false  health:    enabled: true    check:      routes:        enabled: true  springboot:    main-run-controller: true    name: person-queue-consumer-servicemanagement:  info:    camel:      enabled: trueEstrutura do projeto:Acesse o projeto no GitHubProducer (person-queue-producer-service) em Python 3.6 com Pika:#!/usr/bin/env pythonimport jsonimport pikacredentials = pika.PlainCredentials('admin', 'admin')connection = pika.BlockingConnection(pika.ConnectionParameters(host='localhost', credentials=credentials))channel = connection.channel()channel.queue_declare(queue='person', durable="true")for i in range(0, 100):    item = dict(id=str(i), name="User" + str(i))    channel.basic_publish(exchange='personExchange',                          routing_key='',                          body=json.dumps(item))    print(" [x] Sent 'User' messageId: " + str(i))connection.close()Acesse o projeto no GitHubExecutando o producer temos o seguinte resultado na console:Podemos conferir na console de gerenciamento da rabbitmq as mensagens para serem consumidas:http://localhost:15672/Clique na fila e abrirá um overview da fila:Note que temos 100 mensagens para ser consumidas, então executaremos nosso consumidor:Fim do processamento, voltaremos ao overview:Foram todas consumidas com sucesso! Muito bom!!!!!O RabbitMQ é um broker muito poderoso e flexível. Neste artigo vimos uma forma de configurar, porém existem outras formas que o torna ele uma broker fantástico. Com o RabbitMQ podemos desacoplar fluxos de microserviços garantindo assim escalabilidade e performance.Bom pessoal é isso aí, espero ter ajudado.Comente o que você achou… Até a próxima!!!!Ficou com alguma dúvida? me chama aí pra gente trocar uma ideia…Meus Canais:Linkedin: https://www.linkedin.com/in/guilhermemilagre/GitHub: https://github.com/guilhermemilagre------More from Guilherme MilagreFollowSoftware EngineerLove podcasts or audiobooks? Learn on the go with our new app.Try KnowableAboutHelpTermsPrivacyGet the Medium appGet startedGuilherme Milagre6 FollowersSoftware EngineerFollowMore from MediumRoberto Muñoz HuitrónBuilding Microservices Application Using Spring BootPASpring Boot Microservices — Part1 — Eureka Discivery ServiceAdeogo OladipoSpring Security, Powered by MSAL Part 2 (Resource Server)Anuja HerathSpring vs Spring BootHelpStatusWritersBlogCareersPrivacyTermsAboutKnowable






































