











Advanced Architecture for ASP.NET Core Web API
































































BT









Attend QCon San Francisco (Oct 24-28) and find practical inspiration from software leaders.

                            Register
                        



Close
                    





Toggle Navigation 





                        Facilitating the Spread of Knowledge and Innovation in Professional Software Development
                    

English edition 




English edition
Chinese edition
Japanese edition
French edition






                        Contribute
                    





Search








Sign Up / Login











Email



Password





Forgot password ?




InfoQ Account Email





Back to login




Resend Activation





Back to login




Login with:

Google
Microsoft
Twitter
Facebook



Don't have an InfoQ account?
Sign Up







Notifications1




Login to unlock InfoQ's new features





Stay up to date and get notified
Like your favorite content
Follow your favorite editors and peers

Sign Up / Login
Don't have an account? Register Here









                        Logo - Back to homepage
                    

		
			
			
			
		2,429,182 Apr unique visitors
	


News
Articles
Presentations
Podcasts
Guides



Topics


Development


Java
Kotlin
.Net
C#
Swift
Go
Rust
JavaScript




Featured in  Development







Reproducible Development with Containers

Avdi Grimm describes the future of development, which is already here. Get a tour of a devcontainer, and contrast it with a deployment container.








All in  development




Architecture & Design


Architecture
Enterprise Architecture
Scalability/Performance
Design
Case Studies
Microservices
Service Mesh
Patterns
Security




Featured in  Architecture & Design







Oren Eini on RavenDB, including Consistency Guarantees and C# as the Implementation Language

Wesley Reisz talks to Oren Eini about the history of RavenDB. RavenDB is a fully transactional NoSQL Document database that implements both CP and AP guarantees at different times. The two discuss those CP/AP distributed systems challenges, the choice of implementation language (C#), and the current plans for RavenDB 6.0, which includes a server-side sharding implementation.








All in  architecture-design




AI, ML & Data Engineering


Big Data
Machine Learning
NoSQL
Database
Data Analytics
Streaming




Featured in  AI, ML & Data Engineering







Machine Learning at the Edge

Katharine Jarmul discusses utilizing new distributed data science and machine learning models, such as federated learning, to learn from data at the edge.








All in  ai-ml-data-eng




Culture & Methods


Agile
Diversity
Leadership
Lean/Kanban
Personal Growth
Scrum
Sociocracy
Software Craftmanship
Team Collaboration
Testing
UX




Featured in  Culture & Methods







How to Run Your Product Department Like a Coach

Having found what I thought was my calling as an agile coach, I took the tough decision to move sideways into Product Management in the hope of using what I’d learned to one day run my own department. I believed that coming from coaching would allow me to see things others could not and create something special. Time will tell if I have succeeded, this is the story of where I am up to so far.








All in  culture-methods




DevOps


Infrastructure
Continuous Delivery
Automation
Containers
Cloud
Observability




Featured in  DevOps







Panel: Secure Systems

The panelists discuss the security for the software supply chain and software security risk measurement.








All in  devops




EventsNew




Helpful links



                About InfoQ
            



                InfoQ Editors
            



                Contribute
            



                About C4Media
            


Diversity




Choose your language

En
中文
日本
Fr










InfoQ Live June
Learn how cloud architectures achieve cost savings, improve reliability & deliver value. Register Now.





InfoQ Live July
Learn how to migrate an application to serverless and what are the common mistakes to avoid. Register Now.





QCon San Francisco
Understand the emerging software trends you should pay attention to. Attend in-person on Oct 24-28, 2022.















InfoQ Homepage
Articles
Advanced Architecture for ASP.NET Core Web API






            .NET
        





Microsoft JDConf ’22: Cloud Native Java, JVM Configuration, GraalVM, Spring Boot, and More - Watch All Sessions On-Demand 







							Advanced Architecture for ASP.NET Core Web API
						



					This item in
					

						japanese
					





Like

Print
Bookmarks











Jun 01, 2018
								
								
								
									
									16
									min read
								
							


by





Chris Woodruff






reviewed by





Jeff Martin







Write for InfoQ Join a community of experts. Increase your visibility.  Grow your career.Learn more







Key Takeaways

ASP.NET Core's new architecture offers several benefits as compared to the legacy ASP.NET technology
ASP.NET Core benefits from incorporating support for dependency injection from the start
Single Responsibility Principle simplifies implementation and design
The Ports and Adapter Pattern decouples business logic from other dependencies
Decoupled architecture makes testing much easier and more robust

 


With the release of .NET Core 2.0, Microsoft has the next major version of the general purpose, modular, cross-platform and open source platform that was initially released in 2016. .NET Core has been created to have many of the APIs that are available in the current release of .NET Framework. It was initially created to allow for the next generation of ASP.NET solutions but now drives and is the basis for many other scenarios including IoT, cloud and next generation mobile solutions. In this series, we will explore some of the benefits .NET Core and how it can benefit not only traditional .NET developers but all technologists that need to bring robust, performant and economical solutions to market.
This InfoQ article is part of the series ".NET Core". You can subscribe to receive notifications via RSS.
 
The Internet is a very different place from five years ago, let alone 20when I first started as a professional developer. Today, Web APIs connect the modern internetand drive both web applications and mobile apps. The skill of creating robust Web APIs that other developers can consume is in high demand. Our API’s that drive most modern web and mobile apps need to have the stability and reliability to stay servicing even when traffic is at the performance limits.
The purpose of this article is to describe the architecture of an ASP.NET Core 2.0 Web API solution using the Hexagonal Architecture and Ports and Adapters Pattern. First, we will look at the new features of .NET Core and ASP.NET Core that benefit modern Web API’s.
The solution and all code from this article’s examples can be foundin my GitHub repository ChinookASPNETCoreAPIHex.
.NET Core and ASP.NET Core for Web API
ASP.NET Core is a new web framework that Microsoft built on top of .NET Core to shed the legacy technology that has been around since .NET 1.0.  By comparison, ASP.NET 4.6 still uses the System.Webassembly that contains all the WebForms libraries and as a result is still broughtinto more recent ASP.NET MVC 5 solutions. By shedding these legacy dependencies and developing the framework from scratch, ASP.NET Core 2.0 gives the developer much better performance and is architected for cross-platform execution. With ASP.NET Core 2.0, your solutions will work as well on Linux as they do on Windows.
You can read more about the benefits of .NET Core and ASP.NET Core from the three other articles in this series. The first is Performance isa .NET Core Feature by Maarten Balliauw, ASP.NET Core - The Power of Simplicity by Chris Klug and finally, Azure and .NET Core Are Beautiful Together by Eric Boyd.
Architecture
Building a great API depends ongreatarchitecture. We will be looking at many aspects of our API design and development from the built-infunctionality of ASP.NET Core to architecture philosophy and finally design patterns. There is muchplanning and thought behind this architecture, so let’s get started.
Dependency Injection
Before we dig into the architecture of our ASP.NET Core Web API solution, I want to discuss what I believe is a singlebenefit which makes .NET Core developers lives so much better; that is, DependencyInjection (DI). Now, I know you will say that we had DI in .NET Framework and ASP.NET solutions. I will agree, butthe DI we used in the past would be from third-party commercial providers or maybe open source libraries. They did a good job, butfor a good portion of .NET developers, there was a big learning curve, andall DI libraries had their uniqueway of handling things. Today with .NET Core, we have DI built right into the framework from the start. Moreover,it is quite simple to work with, andyou get it out of the box.
The reason we need to use DI in our API is that it allows usto have the best experience decoupling our architecture layers and also to allowus to mock the data layer, or have multiple data sources built for our API.
To use the .NET Core DI framework, justmake sure your project references the Microsoft.AspNetCore.AllNuGet package (which contains a dependency on Microsoft.Extnesions.DependencyInjection.Abstractionspackage). This package gives access to the IServiceCollection interface, which has a System.IServiceProvider interface that you can call GetService<TService>. Toget the services you need from the IServiceCollection interface, you will need to add the services your project needs. 
To learn more about .NET Core Dependency Inject, I suggest you review the following document on MSDN: Introduction to Dependency Injection in ASP.NET Core. 
We will now look at the philosophy of why we architected our API as I did. The two aspects of designing any architecture dependon these two ideas: allowing deep maintainability and utilizing proven patterns and architectures in your solutions.
Maintainability of the API
Maintainability for any engineering process is the ease with which a product can be maintained: finding defects, correcting found defects, repairing or replacing defective components without having to replace still-working parts, preventing unexpected malfunctions, maximizing a product's useful life, having the ability to meet new requirements, make future maintenance easier, or cope with a changing environment.Thiscan be a difficult road to go down without a well planned and executed architecture.
Maintainability is a long-term issue and should be lookedat with a vision of your API in the far distance. With that in mind,you need to make decisions that lead to this future vision and not to short-termshortcuts that seem to make life easier right now. Making hard decisions at the start will allow your project to have a long life and provide benefits that users demand.
What makes a software architecture have high maintainability? How do we evaluate if our API canbe maintained?

Does our architecture allow for changes that have minimal if not zero impact onother areas of the system?
Debugging of the API should be easy and not have to difficult set up to be done. We should have established patterns and be through common methods (such as browser debugging tools).
Testing should be automated as possible and be clear and not complicated.

Interfaces and Implementations
The key to my API architecture is the use of C# interfaces to allow for alternative implementations. If you have written .NET code with C#,you have probably used interfaces. I use interfaces in my solution to build out a contract in my Domain layer that guarantees that any Data layer I develop for my API adheres to the contract for data repositories. It also allows the Controllers in my API project to adhere to another established contract for getting the correct methods to process the API methods in the domain project’s Supervisor. Interfaces are very important to .NET Core and if you need a refresher go here for more information.
Ports and Adapter Pattern
We want our objects throughout our API solution to have single responsibilities. Thiskeeps our objects simple and easily changed if we need to fix bugs or enhance our code. If you have these “code smells” in your code,then you might be violating the single responsibility principle. As a general rule, I look at the implementations of the interface contracts for length and complexity. I do nothave a limit to the lines of code in my methods,butif you passeda single view in your IDE,it might be too long. Also,check the cyclomatic complexity of your methods to determine the complexity of your project’s methods and functions.
The Ports and Adapter Pattern (aka Hexagonal Architecture) is a way to fix this problem of having business logic coupled too tightly to other dependencies such as data access or API frameworks. Using this pattern will allow your API solution to have clear boundaries, well-namedobjects that have single responsibilities and finally allow easier development and maintainability.
We can see the pattern best visually like an onion with ports located on the outside of the hexagon and the adapters and business logic located closer to the core. I see the external connections of the architecture as the ports. The API endpoints that are consumedor the database connection used by Entity Framework Core 2.0 would be examples of ports while the internal data repositories would be the adapters.
 

 
Next,let’s look at the logical segments of our architecture and some demo code examples.
 

 
Domain Layer
Before we look at the API and Domain layers, we need to explain how we build out the contracts through interfaces and the implementations for our API business logic. Let’s look at the Domain layer. The Domain layer has the following functions:

Defines the Entities objects that will be usedthroughout the solution. These models will represent the Data layer’s DataModels.
Defines the ViewModels which will be used by the API layer for HTTP requests and responses as single objects or sets of objects.
Defines the interfaces through which our Data layer can implement the data access logic
Implements the Supervisor that will containmethods called from the API layer. Each method will represent an API call and will convert data from the injected Data layer to ViewModels to be returned

Our Domain Entity objects are a representation of the database that we are using to store and retrieve data used for the API business logic. Each Entity object will contain the properties represented in our case the SQL table. As an exampleis the Album entity.


public sealed class Album

{

    public int AlbumId { get; set; }

    public string Title { get; set; }

    public int ArtistId { get; set; }

        

    public ICollection<Track> Tracks { get; set; } = new HashSet<Track>();

    public Artist Artist { get; set; }

}


The Album table in the SQL database has threecolumns: AlbumId, Title, andArtistId. These three properties are part of the Album entity as well as the Artist’s name, a collection of associated Tracks and the associated Artist. As we will see in the other layers in the API architecture, we will build upon this entity object’s definition for the ViewModels in the project.
The ViewModels are the extension of the Entities and help give more information for the consumer of the APIs. Let'slook at the Album ViewModel. It is very similar to the Album Entity but with an additional property. In the design of my API, I determined that each Album should have the name of the Artist in the payload passed back from the API. Thiswill allow the API consumer to have that crucial piece of information about the Album without having to have the Artist ViewModel passed back in the payload (especially when we are sending back a large set of Albums). An example of our AlbumViewModel is below.


public class AlbumViewModel

{

    public int AlbumId { get; set; }

    public string Title { get; set; }

    public int ArtistId { get; set; }

    public string ArtistName { get; set; }



    public ArtistViewModel Artist { get; set; }

    public IList<TrackViewModel> Tracks { get; set; }

}


The other area that is developedinto the Domain layer isthe contracts via interfaces for each of the Entities defined in the layer. Again, we will use the Album entity to show the interface that is defined. 


public interface IAlbumRepository : IDisposable

{

	Task<List<Album>> GetAllAsync(CancellationToken ct = default(CancellationToken));

Task<Album> GetByIdAsync(int id, CancellationToken ct = default(CancellationToken));

       Task<List<Album>> GetByArtistIdAsync(int id, CancellationToken ct = default(CancellationToken));

       Task<Album> AddAsync(Album newAlbum, CancellationToken ct = default(CancellationToken));

       Task<bool> UpdateAsync(Album album, CancellationToken ct = default(CancellationToken));

       Task<bool> DeleteAsync(int id, CancellationToken ct = default(CancellationToken));

}


As shown in the above example, the interface definesthe methods needed to implement the data access methods for the Album entity. Each entity object and interface are well defined and simplistic that allows the next layer to be well defined.
Finally, the core of the Domain project is the Supervisor class. Itspurpose is to translate to and from Entities and ViewModels and perform business logic away from either the API endpoints and the Data access logic. Having the Supervisor handle this also will isolate the logic to allow unit testing on the translations and business logic.
Looking at the Supervisor method for acquiring and passing a single Album to the API endpoint, we can see the logic in connecting the API front end to the data access injected into the Supervisor but still keeping each isolated.


public async Task<AlbumViewModel> GetAlbumByIdAsync(int id, CancellationToken ct = default(CancellationToken))

{

    var albumViewModel = AlbumCoverter.Convert(await _albumRepository.GetByIdAsync(id, ct));

    albumViewModel.Artist = await GetArtistByIdAsync(albumViewModel.ArtistId, ct);

    albumViewModel.Tracks = await GetTrackByAlbumIdAsync(albumViewModel.AlbumId, ct);

    albumViewModel.ArtistName = albumViewModel.Artist.Name;

    return albumViewModel;

}


Keeping most of the code and logic in the Domain project will allow every project to keep and adhere to the single responsibility principle. 
Data Layer
The next layer of the API architecture we will look at is the Data Layer. In our example solution,we are using Entity Framework Core 2.0. Thiswill mean that we have the Entity Framework Core’s DBContext defined but also the Data Models generated for each entity in the SQL database. If we look at the data model for the Album entity as an example, we will see that we have three properties that are storedin the database along with a property that contains a list of associated tracks to the album, in addition to a property that contains the artist object.
While you can have a multitude of Data Layer implementations, justremember that it must adhere to the requirements documented on the Domain Layer; each Data Layer implementation must work with the View Models and repository interfaces detailed in the Domain Layer. The architecture we are developing for the API uses the Repository Pattern for connecting the API Layer to the Data Layer. Thisis done using Dependency Injection (as we discussed earlier) for each of the repository objects we implement. We will discuss how we use Dependency Injection and the code when we look at the API Layer. The key to the Data Layer is the implementation of each entity repository using the interfaces developed in the Domain Layer. Looking at the Domain Layer’s Album repository as an example shows that it implements the IAlbumRepository interface. Each repository will inject the DBContext that will allow for access to the SQL database using Entity Framework Core.


public class AlbumRepository : IAlbumRepository

{

    private readonly ChinookContext _context;



    public AlbumRepository(ChinookContext context)

    {

        _context = context;

    }



    private async Task<bool> AlbumExists(int id, CancellationToken ct = default(CancellationToken))

    {

return await GetByIdAsync(id, ct) != null;

    }



    public void Dispose()

    {

        _context.Dispose();

    }



    public async Task<List<Album>> GetAllAsync(CancellationToken ct = default(CancellationToken))

    {

        return await _context.Album.ToListAsync(ct);

    }



    public async Task<Album> GetByIdAsync(int id, CancellationToken ct = default(CancellationToken))

    {

        return await _context.Album.FindAsync(id);

    }



    public async Task<Album> AddAsync(Album newAlbum, CancellationToken ct = default(CancellationToken))

    {

        _context.Album.Add(newAlbum);

        await _context.SaveChangesAsync(ct);

        return newAlbum;

    }



    public async Task<bool> UpdateAsync(Album album, CancellationToken ct = default(CancellationToken))

    {

        if (!await AlbumExists(album.AlbumId, ct))

            return false;

        _context.Album.Update(album);



        _context.Update(album);

        await _context.SaveChangesAsync(ct);

        return true;

    }



    public async Task<bool> DeleteAsync(int id, CancellationToken ct = default(CancellationToken))

    {

        if (!await AlbumExists(id, ct))

 	     return false;

        var toRemove = _context.Album.Find(id);

        _context.Album.Remove(toRemove);

        await _context.SaveChangesAsync(ct);

        return true;

    }



    public async Task<List<Album>> GetByArtistIdAsync(int id, CancellationToken ct = default(CancellationToken))

    {

        return await _context.Album.Where(a => a.ArtistId == id).ToListAsync(ct);

    }

}


Having the Data Layer encapsulating all data access will allow facilitating a better testing story for your API. We can build multiple data access implementations: one for SQL database storage, another for maybe a cloud NoSQL storagemodel and finally a mock storage implementation for the unit tests in the solution. 
API Layer
The final layer that we will look at is the area that your API consumers will interact. This layer contains the code for the Web API endpoint logic including the Controllers. The API project for the solution will have a single responsibility, andthat is only to handlethe HTTP requests received by the web server and to return the HTTP responses with either success or failure. There will be a very minimal business logic in this project. We will handle exceptions and errors that have occurred in the Domain or Data projects to effectively communicate with the consumer of APIs. This communication will use HTTP response codes and any data to be returnedlocated in the HTTP response body.
In ASP.NET Core 2.0 Web API, routing is handled using Attribute Routing. If you need to learn more about Attribute Routing in ASP.NET Core go here.We are also using dependency injection tohave the Supervisor assigned toeach Controller. Each Controller’s Action method has a corresponding Supervisor method that will handle the logic for the API call. I have a segment of the Album Controller below to show these concepts.


[Route("api/[controller]")]

public class AlbumController : Controller

{

    private readonly IChinookSupervisor _chinookSupervisor;



    public AlbumController(IChinookSupervisor chinookSupervisor)

    {

        _chinookSupervisor = chinookSupervisor;

    }



    [HttpGet]

    [Produces(typeof(List<AlbumViewModel>))]

    public async Task<IActionResult> Get(CancellationToken ct = default(CancellationToken))

    {

        try

        {

            return new ObjectResult(await _chinookSupervisor.GetAllAlbumAsync(ct));

        }

        catch (Exception ex)

        {

            return StatusCode(500, ex);

        }

    } 



    ...

}


The Web API project for the solution is very simple and thin. I strive to keep as little of code in this solution as it could be replacedwith another form of interaction in the future.
Conclusion
As I have demonstrated, designing and developing a great ASP.NET Core 2.0 Web API solution takes insight in order tohave a decoupled architecture that will allow each layer to be testable and follow the Single Responsibility Principle.  I hope my information will allow you to create and maintain your production Web APIs for your organization’s needs.
About the Author
Chris Woodruff (Woody) has a degree in Computer Science from Michigan State University’s College of Engineering. Woody has been developing and architecting software solutions for over 20 years and has worked in many different platforms and tools. He is a community leader, helping such events as GRDevNight, GRDevDay, West Michigan Day of .NET and CodeMash. He was also instrumental in bringing the popular Give Camp event to Western Michigan where technology professionals lend their time and development expertise to assist local non-profits. As a speaker and podcaster, Woody has spoken and discussed a variety of topics, including database design and open source. He has been a Microsoft MVP in Visual C#, Data Platform and SQL and was recognized in 2010 as one of the top 20 MVPs world-wide. Woody is a Developer Advocate for JetBrains and evangelizes .NET, .NET Core and JetBrains' products in North America.
 
With the release of .NET Core 2.0, Microsoft has the next major version of the general purpose, modular, cross-platform and open source platform that was initially released in 2016. .NET Core has been created to have many of the APIs that are available in the current release of .NET Framework. It was initially created to allow for the next generation of ASP.NET solutions but now drives and is the basis for many other scenarios including IoT, cloud and next generation mobile solutions. In this series, we will explore some of the benefits .NET Core and how it can benefit not only traditional .NET developers but all technologists that need to bring robust, performant and economical solutions to market.
This InfoQ article is part of the series ".NET Core". You can subscribe to receive notifications via RSS.


Inspired by this content? Write for InfoQ.
Becoming an editor for InfoQ was one of the best decisions of my career. It has challenged me and helped me grow in so many ways. We'd love to have more people join our team.

Thomas BettsLead Editor, Software Architecture and Design @InfoQ; Senior Principal Engineer

Write for InfoQ












Rate this Article


Adoption










Style


































 Author Contacted










                
                
                    
                This content is in the .NET topic
            

Related Topics:


Development


ASP.NET Core


.NET Core


.NET Core Series


Web API


.NET


API


Microsoft


Architecture










Related Editorial





Related Sponsored Content





Related Sponsor




Protect Identities. Secure Digital Services. Enable scalable and secure user access to web and mobile applications. Start free trial.









Related Content





Creating and Using HTTP Client SDKs in .NET 6











Colors in .NET: an In-Depth Guide











Getting Started with gRPC and .NET











SoundCloud Chronicles the End of the Public API Strangler








HashiCorp Vault Improves Eventual Consistency with Server-Side Consistent Tokens








Microsoft Announces the General Availability of Azure Container Apps at Build 2022








Machine Learning at the Edge











How Getting Feedback from Angry Users Helps to Develop Better Products








JEP 405: Record Classes to Extend Pattern Matching in Java








Cloudflare D1 Provides Distributed SQLite for Cloudflare Workers








Amazon Releases 51-Language AI Training Dataset MASSIVE








Java News Roundup: OpenJDK, Spring Updates and CVEs, Payara Platform, Apache Tomcat Updates








How to Run Your Product Department Like a Coach











Kalix: Build Serverless Cloud-Native Business-Crtical Applications with No Databases








Google Jetpack Brings Updated Architectural and UI Components and Improved Performance Tools








Microsoft Releases Azure DNS Private Resolver in Public Preview








Amazon EC2 Supports NitroTPM and UEFI Secure Boot








Architecting for the Edge











Google Cloud Introduces PostgreSQL-Compatible AlloyDB for Enterprise Database Workloads








AI for Software Developers: a Future or a New Reality?











Adaptability by Agreement: Valuing Outcomes over Imposed Solutions











AWS Lambda Now Has Support for Node.js 16 Runtime








Effectively Monitoring Your Monitoring - Miedwar Meshbesher on Using Vigilance Controls








Meta AI’s New Data Set to Accelerate Renewable Energy Catalyst Discovery for Hydrogen Fuel








DeepMind Introduces Gato, a New Generalist AI Agent








Mammoths Stumping in the Cloud Era: Meeting EU Regulations by Being Cloud Native and Cloud Agnostic








Go Native with Spring Boot and GraalVM











Dealing with Thundering Herd at Braintree








How Norway's Largest Bureaucracy Optimises for Fast Flow








How to Prepare for the Unexpected: an InfluxData Outage Story Told at KubeConEU 22








The What and Why of Programmable Proxies











State of the Java Ecosystem Report from New Relic








Microsoft + Java = ♡:  a Story Told by Martijn Verburg at Devoxx UK








Trust-Driven Development: Building Cognitive and Emotional Pillars








LAION Releases Five Billion Image-Text Pair Dataset LAION-5B








Why You Should Care about Software Architecture











MicroStream 7.0 Delivers Support for CDI








Java News Roundup: JEPs for JDK 19, Project Lilliput Milestone, Spring Framework, Quarkus 2.9.0








Flutter 3 Now Stable on All Supported Platforms, Extends Material Design 3








Connecting Goals to Daily Teamwork











The InfoQ Newsletter


        A round-up of last week’s content on InfoQ sent out every Tuesday. Join a community of over 250,000 senior developers.

        

			View an example




Enter your e-mail address








Select your country

Select a country





I consent to InfoQ.com handling my data as explained in this Privacy Notice.





We protect your privacy.

















Hello stranger!
You need to Register an InfoQ account or  Login or login to post comments. But there's so much more behind being registered.
Get the most out of the InfoQ experience.





Tell us what you think







Allowed html: a,b,br,blockquote,i,li,pre,u,ul,p





 Email me replies to any of my messages in this thread
                            










Community comments


Watch thread




Single Responsibility
by Philipp Rößner, 


Re: Single Responsibility
by Chris Woodruff, 


Re: Single Responsibility
by Philipp Rößner, 


Re: Single Responsibility
by Chris Woodruff, 




Re: Single Responsibility
by Jonathan Loscalzo, 


Re: Single Responsibility
by Chris Woodruff, 




Advanced Architecture for ASP.NET Core Web API
by JOel MAmedov, 


Re: Advanced Architecture for ASP.NET Core Web API
by Chris Woodruff, 


Re: Advanced Architecture for ASP.NET Core Web API
by Charles Cherry, 


Re: Advanced Architecture for ASP.NET Core Web API
by Chris Woodruff, 





Domain
by Arman Kurtagić, 


domain
by Tomasz Rzepecki, 


Re: domain
by Tomasz Rzepecki, 



Where does cache fit?
by Ali Roshan, 


Re: Where does cache fit?
by Tomasz Rzepecki, 



Request Permission
by Yongmin Lee, 


Re: Request Permission
by Roxana Bacila, 



3-tier architecture for Dapper.
by saurav karna, 


IChinookSupervisor
by Zion Bokobza, 


Great Article
by Rajendra Verma, 


One question?
by Syam Ss, 







Single Responsibility
by
                                        Philipp Rößner,
                                        


Your message is awaiting moderation. Thank you for participating in the discussion.
Nice Article! I am always checking out different types of architectures and what I like about this is that the domain-layer is implemented as the real core and one important dependency in the solution. But I am struggling with your supervisor-class. From my point of view it is violating the single responsibility principle. I am always splitting my domain-logic into classes, related to use-cases. Then you have to inject sometimes more than 1 dependency into the controller, but it feels way more controllable than having the whole domain inside of one class.What do you think?


Like
Reply


Back to top










Advanced Architecture for ASP.NET Core Web API
by
                                        JOel MAmedov,
                                        


Your message is awaiting moderation. Thank you for participating in the discussion.
Thanks for the article. I think domain layer is redundant. Your domain entities should be represented by data layer. Too many layers and lot of objects/dependencies and code. I miss old client/server days that things was much simpler. You have front end and back end.


Like
Reply


Back to top










Re: Advanced Architecture for ASP.NET Core Web API
by
                                        Chris Woodruff,
                                        


Your message is awaiting moderation. Thank you for participating in the discussion.
Thanks for the response and comment. The reason for having a three-tier architecture is to allow injecting a different data access implementation and for testing. As you can see from my ASP.NET Core Web API solution I can use Dependency Injection to inject a different data access based on my needs.


Like
Reply


Back to top










Re: Single Responsibility
by
                                        Chris Woodruff,
                                        


Your message is awaiting moderation. Thank you for participating in the discussion.
I do agree that my Supervisor class is quite large and does not adhere to an SRP as I would want it. The reason why I had to go down that path is, so I did not get circular-references. If you look at the relationships between the data model you will see that there are tables that have associations that would cause this to happen. One example is the relationship between Artists and Albums.I appreciate your comment, and I am always trying to find a way to have my architecture have single responsibilities when I create classes. Just was not able to for this instance.


Like
Reply


Back to top










Re: Single Responsibility
by
                                        Philipp Rößner,
                                        


Your message is awaiting moderation. Thank you for participating in the discussion.
Isn't it possible to to get a single incstance per Request from .Net Core DI? So you could get the same instance of the entity framework dbcontext to all your repository classes. That should avoid circular-references. Or did I get you wrong there?


Like
Reply


Back to top










Re: Single Responsibility
by
                                        Chris Woodruff,
                                        


Your message is awaiting moderation. Thank you for participating in the discussion.
That was one of my paths that I went down and failed. I had each entity repository get the DBContext injected for the data access and ran into the circular reference. I am looking other possible solutions for the Supervisor class. Thanks


Like
Reply


Back to top










Domain
by
                                        Arman Kurtagić,
                                        


Your message is awaiting moderation. Thank you for participating in the discussion.
Hi Chris! Thank you for the article, good job!Suggestion to reconsider implementation of the domain entities or just remove them or make comment on that pointing that this is just an example of hex. arch. style showing no domain logic code which is one of the important things. Right now there is no logic in domain and they are representing anemic domain model.That is one of the top things I see when working with junior developers. There is a risk that such implementation leads to procedural style of coding while working in oop language, meaning that important logic is likely to be scattered over the layers....


Like
Reply


Back to top










domain
by
                                        Tomasz Rzepecki,
                                        


Your message is awaiting moderation. Thank you for participating in the discussion.
Why domain layer instead of businessLogic layer? The domain layer might suggest usage of DDD principles which are not included in this example.


Like
Reply


Back to top










Re: Advanced Architecture for ASP.NET Core Web API
by
                                        Charles Cherry,
                                        


Your message is awaiting moderation. Thank you for participating in the discussion.
RE: Separating the data access layerI do this with the EF Core in-memory database provider. Using JSON files I can load just the data I need for testing, and then I can test out all of my data access  without hitting the actual database.


Like
Reply


Back to top










Re: Single Responsibility
by
                                        Jonathan Loscalzo,
                                        


Your message is awaiting moderation. Thank you for participating in the discussion.
I think that a "use-case" implementation would be better than supervisor. For me, Supervisor Class is a kind of Facade Service Pattern. And... I can't see the HexArchitecture... ¿where are ports and adapters?For me, it's a simple n-layered architecture, with an entry point call Supervisor. On the other hand, it is a cool architecture for teaching. It could continue with transactional features, interceptions, logging, etc...Could I take it, and adapt to a class for my friends?


Like
Reply


Back to top










Re: Advanced Architecture for ASP.NET Core Web API
by
                                        Chris Woodruff,
                                        


Your message is awaiting moderation. Thank you for participating in the discussion.
Thanks and that is also a great way to have test data for unit tests. I just wanted to show a very simple technique but if I was doing more advanced testing your method would be at the top of the list. Thanks


Like
Reply


Back to top










Re: Single Responsibility
by
                                        Chris Woodruff,
                                        


Your message is awaiting moderation. Thank you for participating in the discussion.
Yes, I started this architecture, and it is not the best representation of the Hex Architecture. I am glad you liked what I did, and I appreciate your comment.


Like
Reply


Back to top










Re: domain
by
                                        Tomasz Rzepecki,
                                        


Your message is awaiting moderation. Thank you for participating in the discussion.
I found team which used style from article and refused to go futher into DDD practices. They found anemic domain model as state of the art of DDD. I think its important to mention that this article is not DDD related.


Like
Reply


Back to top










Where does cache fit?
by
                                        Ali Roshan,
                                        


Your message is awaiting moderation. Thank you for participating in the discussion.
This is a very informative article. Where does the cache layer fit in? I use built-in memory cache and I am rewriting our .net api into .net core 2.1. I am thinking about passing cache as dependency injection at service start up. Cache will be used with in business logic, data layer, and the api layer. Any tips regarding that?


Like
Reply


Back to top










Re: Where does cache fit?
by
                                        Tomasz Rzepecki,
                                        


Your message is awaiting moderation. Thank you for participating in the discussion.
If your business talks about cache so put it in business logic. But usually it is infrastructure concern, layer that is not mentioned in this article. Please find something about domain driven design to find how and why keep your business logic clear from infrastructure and technical concerns.


Like
Reply


Back to top










Request Permission
by
                                        Yongmin Lee,
                                        


Your message is awaiting moderation. Thank you for participating in the discussion.
Hello Chris, I need your Permission to copy the content of this article to my blog. My blog is just a personal blog with a collection of good stuff like this. I am not making any profit out of this. So, I would like to ask your permission to use the content of this article. I want to translate it into Korean and post it on my blog. For your information, my blog is just for a personal use and I am not making any profit out of it. I am definitely going to show the original link. Waiting for your comment:


Like
Reply


Back to top











Re: Request Permission
by
                                        Roxana Bacila,
                                        


Your message is awaiting moderation. Thank you for participating in the discussion.
Hi Yongmin, InfoQ does not agree to any third party copying the content we publish to another platform in its entirely. We agree to posting of a summary and a link back to the InfoQ original article. We are fine with you posting a translation into Korean, if Chris is also fine with it. Thanks, Roxana BacilaCommunity ManagerInfoQ Enterprise Software Development CommunityInfoQ.com | InfoQ China | InfoQ Japan | InfoQ Brazil | InfoQ France | QCon


Like
Reply


Back to top










3-tier architecture for Dapper.
by
                                        saurav karna,
                                        


Your message is awaiting moderation. Thank you for participating in the discussion.
Hi Chris,I ought to create an API and I chose dapper over Entity Framework because I needed performance.And I was wondering what to use with Dapper, single tier or n-tier? It's a simple API that converts data from SQL to JSON for an Angular UI. But, maybe many other functionalities will be added to the API, in the future. I am relatively new here, so any suggestions?


Like
Reply


Back to top










IChinookSupervisor
by
                                        Zion Bokobza,
                                        


Your message is awaiting moderation. Thank you for participating in the discussion.
First Thanks Chris,some remarks I have:1. Can you please supply the interface and implementation of the above interface?   I think you meant to use IAlbumRepository.2. You can save some roundtrip to the database in DeleteAsync function    public async Task<bool> DeleteAsync(int id, CancellationToken ct = default(CancellationToken))    {        var toRemove = _context.Album.Find(id);        if (toRemove == null)           return fasle;        _context.Album.Remove(toRemove);        await _context.SaveChangesAsync(ct);        return true;    }3. I think the save changes should be done in another function if you want to handle transactions. maybe you want to do some changes and at the end of all changes you should call SaveChangesAsync.Zion Bokobza


Like
Reply


Back to top










Great Article
by
                                        Rajendra Verma,
                                        


Your message is awaiting moderation. Thank you for participating in the discussion.
It's a great article.Thanks


Like
Reply


Back to top










One question?
by
                                        Syam Ss,
                                        


Your message is awaiting moderation. Thank you for participating in the discussion.
In this sample all the layers are part of single project,otherwise data layer wont get reference of domain models. So you are preferring 3 layers in single project.


Like
Reply


Back to top












Close





Your Reply


Quote original message








Allowed html: a,b,br,blockquote,i,li,pre,u,ul,p





 Email me replies to any of my messages in this thread
                    






                        Cancel
                    






Close





Your Reply








Allowed html: a,b,br,blockquote,i,li,pre,u,ul,p





 Email me replies to any of my messages in this thread
                    







                        Cancel
                    






Close




                   OK
                



21 












Development




How to Prepare for the Unexpected: an InfluxData Outage Story Told at KubeConEU 22


Reproducible Development with Containers


Green Software Development: Terminology and Climate Commitments Explained by Microsoft at Devoxx UK






Architecture & Design




Oren Eini on RavenDB, including Consistency Guarantees and C# as the Implementation Language


Kalix: Build Serverless Cloud-Native Business-Crtical Applications with No Databases


Architecting for the Edge






Culture & Methods




How Getting Feedback from Angry Users Helps to Develop Better Products


How to Run Your Product Department Like a Coach


Building a Culture of Accountability and Curiosity






AI, ML & Data Engineering




Machine Learning at the Edge


Amazon Releases 51-Language AI Training Dataset MASSIVE


AI for Software Developers: a Future or a New Reality?






DevOps




HashiCorp Vault Improves Eventual Consistency with Server-Side Consistent Tokens


Cloudflare D1 Provides Distributed SQLite for Cloudflare Workers


Effectively Monitoring Your Monitoring - Miedwar Meshbesher on Using Vigilance Controls












The InfoQ Newsletter
	
A round-up of last week’s content on InfoQ sent out every Tuesday. Join a community of over 250,000 senior developers.
		
			View an example


Get a quick overview of content published on a variety of innovator and early adopter technologies
Learn what you don’t know that you don’t know
Stay up to date with the latest information from the topics you are interested in




Enter your e-mail address








Select your country

Select a country





I consent to InfoQ.com handling my data as explained in this Privacy Notice.





We protect your privacy.








QCon Software Development Conference 



Real-world technical talks. No product pitches.Practical ideas to inspire you and your team.QCon San Francisco - Oct 24-28, In-person.QCon San Francisco brings together the world's most innovative senior software engineers across multiple domains to share their real-world implementation of emerging trends and practices.Uncover emerging software trends and practices to solve your complex engineering challenges, without the product pitches.Save your spot now








Home
Create account
Login
QCon Conferences
Events
Contribute
InfoQ Editors
About InfoQ
About C4Media

            Media Kit
        
InfoQ Developer Marketing Blog
Diversity



Events




InfoQ Live

JUNE 21, 2022





InfoQ Live

JULY 19, 2022





							InfoQ Live
							
AUGUST 23, 2022





QCon San Francisco

OCTOBER 24-28, 2022





								QCon Plus
							
NOVEMBER 29 - DECEMBER 9, 2022





Follow us on 

Youtube212K Followers
Linkedin18K Followers
RSS19K Readers
Twitter50k Followers
Facebook20K Likes
AlexaNew



Stay in the know

The InfoQ Podcast
Engineering Culture Podcast
The Software Architects' Newsletter









						General Feedback
						feedback@infoq.com


						Advertising
						sales@infoq.com


						Editorial
						editors@infoq.com


						Marketing
						marketing@infoq.com




InfoQ.com and all content copyright © 2006-2022 C4Media Inc. InfoQ.com hosted at Contegix, the best ISP we've ever worked with.
Privacy Notice, Terms And Conditions, Cookie Policy








BT














