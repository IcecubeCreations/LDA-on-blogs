








How fast can you parse JSON? – Daniel Lemire's blog






















































Skip to content



Daniel Lemire's blog
Daniel Lemire is a computer science professor at the University of Quebec (TELUQ) in Montreal. His research is focused on software performance and data engineering. He is a techno-optimist and a free-speech advocate.
Menu and widgets




My home page
My papers
My software
 

SubscribeJoin 12,500 subscribers:





Email Address














You can also follow this blog on telegram.


Search for:



Support my work!I do not accept any advertisement. However, you can support the blog with donations through paypal. Please consider getting in touch if you are a supporter so that I can thank you.
You can also support my work on GitHub.

Recent Posts


Parsing JSON faster with Intel AVX-512


Avoid exception throwing in performance-sensitive code


Faster bitset decoding using Intel AVX-512


Fast bitset decoding using Intel AVX-512


Removing characters from strings faster with AVX-512


Recent CommentsDaniel Lemire on Avoid exception throwing in performance-sensitive codeme on Avoid exception throwing in performance-sensitive codeDaniel Lemire on Avoid exception throwing in performance-sensitive codeJoern Engel on Avoid exception throwing in performance-sensitive codegrid on Are your strings immutable?Pages

A short history of technology
About me
Book recommendations
Cognitive biases
Interviews and talks
My bets
My favorite articles
My favorite quotes
My readers
My sayings
Predictions
Recommended video games
Terms of use
Write good papers

Archives Archives

Select Month
 May 2022  (4)
 April 2022  (4)
 March 2022  (2)
 February 2022  (4)
 January 2022  (3)
 December 2021  (2)
 November 2021  (7)
 October 2021  (12)
 September 2021  (5)
 August 2021  (2)
 July 2021  (4)
 June 2021  (5)
 May 2021  (8)
 April 2021  (6)
 March 2021  (5)
 February 2021  (4)
 January 2021  (6)
 December 2020  (11)
 November 2020  (10)
 October 2020  (6)
 September 2020  (6)
 August 2020  (4)
 July 2020  (6)
 June 2020  (7)
 May 2020  (6)
 April 2020  (7)
 March 2020  (8)
 February 2020  (7)
 January 2020  (7)
 December 2019  (10)
 November 2019  (6)
 October 2019  (7)
 September 2019  (9)
 August 2019  (9)
 July 2019  (10)
 June 2019  (9)
 May 2019  (10)
 April 2019  (8)
 March 2019  (15)
 February 2019  (9)
 January 2019  (10)
 December 2018  (9)
 November 2018  (8)
 October 2018  (10)
 September 2018  (9)
 August 2018  (10)
 July 2018  (14)
 June 2018  (9)
 May 2018  (11)
 April 2018  (11)
 March 2018  (10)
 February 2018  (7)
 January 2018  (15)
 December 2017  (9)
 November 2017  (16)
 October 2017  (13)
 September 2017  (20)
 August 2017  (12)
 July 2017  (8)
 June 2017  (9)
 May 2017  (10)
 April 2017  (11)
 March 2017  (11)
 February 2017  (6)
 January 2017  (8)
 December 2016  (8)
 November 2016  (4)
 October 2016  (6)
 September 2016  (10)
 August 2016  (6)
 July 2016  (4)
 June 2016  (6)
 May 2016  (5)
 April 2016  (10)
 March 2016  (9)
 February 2016  (8)
 January 2016  (5)
 December 2015  (8)
 November 2015  (4)
 October 2015  (8)
 September 2015  (5)
 August 2015  (6)
 July 2015  (5)
 June 2015  (2)
 May 2015  (4)
 April 2015  (4)
 March 2015  (5)
 February 2015  (5)
 January 2015  (3)
 December 2014  (6)
 November 2014  (4)
 October 2014  (3)
 September 2014  (5)
 August 2014  (5)
 July 2014  (4)
 June 2014  (2)
 May 2014  (6)
 April 2014  (7)
 March 2014  (3)
 February 2014  (5)
 January 2014  (6)
 December 2013  (8)
 November 2013  (5)
 October 2013  (5)
 September 2013  (5)
 August 2013  (3)
 July 2013  (4)
 June 2013  (4)
 May 2013  (3)
 April 2013  (7)
 March 2013  (6)
 February 2013  (6)
 January 2013  (8)
 December 2012  (2)
 November 2012  (5)
 October 2012  (4)
 September 2012  (6)
 August 2012  (4)
 July 2012  (4)
 June 2012  (3)
 May 2012  (3)
 April 2012  (6)
 March 2012  (5)
 February 2012  (3)
 January 2012  (9)
 December 2011  (3)
 November 2011  (5)
 October 2011  (5)
 September 2011  (4)
 August 2011  (8)
 July 2011  (3)
 June 2011  (5)
 May 2011  (6)
 April 2011  (6)
 March 2011  (5)
 February 2011  (4)
 January 2011  (10)
 December 2010  (7)
 November 2010  (6)
 October 2010  (3)
 September 2010  (3)
 August 2010  (5)
 July 2010  (4)
 June 2010  (7)
 May 2010  (5)
 April 2010  (7)
 March 2010  (8)
 February 2010  (5)
 January 2010  (7)
 December 2009  (4)
 November 2009  (6)
 October 2009  (10)
 September 2009  (8)
 August 2009  (11)
 July 2009  (9)
 June 2009  (7)
 May 2009  (7)
 April 2009  (7)
 March 2009  (7)
 February 2009  (14)
 January 2009  (14)
 December 2008  (16)
 November 2008  (25)
 October 2008  (13)
 September 2008  (15)
 August 2008  (14)
 July 2008  (15)
 June 2008  (14)
 May 2008  (15)
 April 2008  (20)
 March 2008  (18)
 February 2008  (12)
 January 2008  (19)
 December 2007  (24)
 November 2007  (23)
 October 2007  (19)
 September 2007  (13)
 August 2007  (23)
 July 2007  (18)
 June 2007  (15)
 May 2007  (19)
 April 2007  (9)
 March 2007  (7)
 February 2007  (27)
 January 2007  (20)
 December 2006  (20)
 November 2006  (18)
 October 2006  (9)
 September 2006  (11)
 August 2006  (25)
 July 2006  (10)
 June 2006  (18)
 May 2006  (27)
 April 2006  (25)
 March 2006  (11)
 February 2006  (11)
 January 2006  (39)
 December 2005  (23)
 November 2005  (25)
 October 2005  (20)
 September 2005  (26)
 August 2005  (39)
 July 2005  (17)
 June 2005  (16)
 May 2005  (9)
 April 2005  (13)
 March 2005  (30)
 February 2005  (20)
 January 2005  (30)
 December 2004  (11)
 November 2004  (19)
 October 2004  (14)
 September 2004  (17)
 August 2004  (13)
 July 2004  (16)
 June 2004  (16)
 May 2004  (12)


Boring stuff

Log in
Entries feed
Comments feed
WordPress.org

 







How fast can you parse JSON? 

JSON has become the de facto standard exchange format on the web today. A JSON document is quite simple and is akin to a simplified form of JavaScript:
{

     "Image": {

        "Width":  800,

        "Height": 600,

        "Animated" : false,

        "IDs": [116, 943, 234, 38793]

      }

}


These documents need to be generated and parsed on a large scale. Thankfully, we have many fast libraries to parse and manipulate JSON documents.
In a recent paper by Microsoft (Mison: A Fast JSON Parser for Data Analytics), the researchers report parsing JSON document at 0.1 or 0.2 GB/s with common libraries such as RapidJSON. It is hard to tell the exact number as you need to read a tiny plot, but I have the right ballpark. They use a 3.5 GHz processor, so that’s 8 to 16 cycles per input byte of data.
Does it make sense? 
I don’t have much experience processing lots of JSON, but I can use a library. RapidJSON is handy enough. If you have a JSON document in a memory buffer, all you need are a few lines:
rapidjson::Document d;

if(! d.ParseInsitu(buffer).HasParseError()) {

 // you are done parsing

}


This “ParseInsitu” approach modifies the input buffer (for faster handling of the strings), but is fastest. If you have a buffer that you do not want to modify, you can call “Parse” instead. 
To run an example, I am parsing one sizeable “twitter.json” test document. I am using a Linux server with a Skylake processor. I parse the document 10 times and check that the minimum and the average timings are close.


 ParseInsitu 
 Parse


 4.7 cycles / byte 
 7.1 cycles / byte


This is the time needed to parse the whole document into a model. You can get even better performance if you use the streaming API that RapidJSON provides.
Though I admit that my numbers are preliminary and partial, they suggest to me that Microsoft researchers might not have given RapidJSON all its chances, since their numbers are closer to the “Parse” function which is slower. It is possible that they do not consider it acceptable that the input buffer is modified but I cannot find any documentation to this effect, nor any related rationale. Given that they did not provide their code, it is hard to tell what they did exactly with RapidJSON.
The Microsoft researchers report results roughly 10x better than RapidJSON, equivalent to a fraction of a cycle per input byte. The caveat is that they only selectively parse the document, extracting only subcomponents of the document. As far as I can tell, their software is not freely available.
How would they fare against an optimized application of the RapidJSON library? I am not sure. At a glance, it does not seem implausible that they might have underestimated the speed of RapidJSON by a factor of two.
In their paper, the Java-based JSON libraries (GSON and Jackson) are fast, often faster than RapidJSON even if RapidJSON is written in C++. Is that fair? I am not, in principle, surprised that Java can be faster than C++. And I am not very familiar with RapidJSON… but it looks like performance-oriented C++. C++ is not always faster than Java but in the hands of the right people, I expect it to do well.
So I went looking for a credible performance benchmark that includes both C++ and Java JSON libraries and found nothing. Google is failing me.
In any case, to answer my own question, it seems that parsing JSON should take about 8 cycles per input byte on a recent Intel processor. Maybe less if you are clever. So you should expect to spend 2 or 3 seconds parsing one gigabyte of JSON data.
I make my code available.


Published by

 

Daniel Lemire

A computer science professor at the University of Quebec (TELUQ). 
View all posts by Daniel Lemire 




Posted on May 3, 2018Author Daniel LemireCategories  



11 thoughts on “How fast can you parse JSON?” 





 Geoff Langdale says: 

May 3, 2018 at 1:33 am 


Another question (open to debate): should the cost of parsing include validation? Is it reasonable to quietly return “reasonable’ results of a query on something that isn’t valid JSON?
This is a query that affects Mison more (as far as I can tell). Mison’s ability to skip fields might allow it to pass over JSON syntax errors without noticing (they didn’t publish code, so I can tell for sure).

Reply 





 Andriy Plokhotnyuk says: 

May 3, 2018 at 4:34 am 


How fast? It depends…
If you consider Jackson from the JVM world then, please, try jsoniter-scala:
https://github.com/plokhotnyuk/jsoniter-scala
It parses from input streams or byte arrays immediately to Scala data structures without any intermediate representation like strings, hash maps, etc.
So jsoniter-scala is much safer and efficient than any other JSON-parser for Scala.
It has methods for scanning through multi-Gb value streams or JSON arrays and parse values without need to hold them all in memory:
https://github.com/plokhotnyuk/jsoniter-scala/blob/master/core/src/main/scala/com/github/plokhotnyuk/jsoniter_scala/core/package.scala#L79
Also, it has outstanding features like fast skipping of not needed fields (key/value pairs) or crazily fast parsing and serialization of java.time.* classes.
Just see benchmark results below. BTW, they include results for parsing and serialization of messages from the Twitter API:
http://jmh.morethan.io/?source=https://plokhotnyuk.github.io/jsoniter-scala/jdk8.json
All results for JDK 8/10 and GraalVM CE/EE on the one page:
https://plokhotnyuk.github.io/jsoniter-scala/
WARNING: Results of GraalVM CE/EE are only for a rough evaluation of possible potential of this new tech.
Final results can be changed significantly after JMH tool and GraalVM developers will provide mutual compatibility.
In most cases jsoniter-scala works on par with best binary serializers for Java and Scala:
https://github.com/dkomanov/scala-serialization/pull/8

Reply 





 Andriy Plokhotnyuk says: 

September 11, 2018 at 4:03 pm 


For some limited kind of work like parsing with projection or parsing of arrays of UUIDs jsoniter-scala can archive 2 bytes per cycle (or ~2Gb per second on contemporary desktops) that is quite competitive with the state of art filter/parsers like Mison or Sparser.
Results and code of projection benchmark:
https://github.com/guillaumebort/mison/pull/1
Results (need to scroll down to ArrayOfUUIDsBenchmark section) and code of benchmark for parsing of UUID arrays:
http://jmh.morethan.io/?source=https://plokhotnyuk.github.io/jsoniter-scala/oraclejdk11.json
https://github.com/plokhotnyuk/jsoniter-scala/blob/master/jsoniter-scala-benchmark/src/main/scala/com/github/plokhotnyuk/jsoniter_scala/macros/ArrayOfUUIDsBenchmark.scala

Reply 







 Vincent Bernat says: 

May 3, 2018 at 6:37 am 


Using a loop with the same input may give an unfair advantage to Java as the JIT may kick in and optimize the code for the input. The effect could exist in C++ at a smaller scale with the branch prediction getting better. As an example of such flawed benchmark: https://github.com/nodejs/node/pull/1457#issuecomment-94188258.
I didn’t read the Microsoft paper, so this is pure speculation on my side.

Reply 





 stegua says: 

May 3, 2018 at 6:50 am 


I am a happy user of RapidJSON, selected after looking at this nice benchmarks: nativejson-benchmark.
Unfortunately, that benchmark does not include Java libraries.

Reply 





 Jan says: 

May 3, 2018 at 8:02 am 


It does make a lot of sense!
Does it look like they claim 16 cycles per byte and you think it is 4? You may be right. Benchmarking is hard. But take a look at the abstract – 10x improvement for “analytical”, “FSM” (and probably some SIMD)?
Analytical? Dom style parser will always loose reading 3 out of 20 (per record). I would expect streaming parser to do 2x+ better. No allocations, copying or parsing digits into numbers nobody will use.
How are streaming parsers implemented? Which one is not a loop reading character by character (byte by byte)? Can any compiler vectorize that? (and remove branching?)
Modern regexp libraries (like hyperscan) show great results with vectorized FSM. I believe such techniques would speed up analytical query over json (scanning for 50 bytes out of 1000 bytes record).
Does it matter? Json is de facto standard format for data exchange between companies these days. Many open datasets and just about every startup use json extensively. So yeah, if someone (Microsoft?) spend the time doing it, please open source it! I would greatly appreciate having it in spark!
BTW: No, you will not get 10x in practice. Nobody does json, everybody does json.gz. But gzip is very slow. Thanks to Amdahl’s law you will get only 2x improvement with vectorized FSM json parser. Gunzip will take 90% cpu then.

Reply 





 Leonid Boytsov says: 

May 11, 2018 at 5:27 pm 


Great pointer: it’s fast and header-only. Thanks a lot!
Regarding Java vs C++. They are pretty close. In the land of the search engines, we see more carefully implemented Java engines beat C++ implementations. We all know Lucene is very fast and hard to beat. There is another example: Galago is a Java re implementation of Indri. So, it uses a similar query evaluation paradigm, but it is nevertheless about 2x faster.

Reply 





 Daniel Lemire says: 

May 11, 2018 at 8:43 pm 


Yes. I am not assuming that Java is slower than C++ in actual systems, but RapidJSON is C++ written with performance in mind.
When parsing bytes, there are tricks that are easy in C++ but hard in Java.

Reply 







 Lewis Cowles says: 

June 4, 2018 at 7:38 am 


Surely being stringly makes JSON inefficient from a processor standpoint anyway?
Also are those 8 cycles / byte a simplification because of amortised costs? (unless it’s unique to Skylake lines).

Reply 





 Daniel Lemire says: 

June 5, 2018 at 3:54 am 


Surely being stringly makes JSON inefficient from a processor standpoint anyway?
Not necessarily.
Also are those 8 cycles / byte a simplification because of amortised costs? (unless it’s unique to Skylake lines).
It is specific to the machine I tested on.

Reply 







 Andriy Plokhotnyuk says: 

September 11, 2018 at 2:35 pm 


For some limited kind of work like parsing with projection or parsing of arrays of UUIDs jsoniter-scala can archive 2 bytes per cycle (or ~2Gb per second on contemporary desktops) that is quite competitive with the state of art filter/parsers like Mison or Sparser.
Results and code of projection benchmark:
https://github.com/guillaumebort/mison/pull/1
Results (need to scroll down to ArrayOfUUIDsBenchmark section) and code of benchmark for parsing of UUID arrays:
http://jmh.morethan.io/?source=https://plokhotnyuk.github.io/jsoniter-scala/oraclejdk11.json
https://github.com/plokhotnyuk/jsoniter-scala/blob/master/jsoniter-scala-benchmark/src/main/scala/com/github/plokhotnyuk/jsoniter_scala/macros/ArrayOfUUIDsBenchmark.scala

Reply 



Leave a Reply Cancel replyYour email address will not be published. The comment form expects plain text. If you need to format your text, you can use HTML elements such strong, blockquote, cite, code and em. For formatting code as HTML automatically, I recommend tohtml.com.Comment * Name * 
Email * 
Website 
 Save my name, email, and website in this browser for the next time I comment.






 Receive Email Notifications?


no, do not subscribe
yes, replies to my comment
yes, all comments/replies


instantly
hourly digest
daily digest
weekly digest


Or, you can subscribe without commenting.


 

Δ 
You may subscribe to this blog by email.


Post navigation
Previous Previous post: Is software prefetching (__builtin_prefetch) useful for performance?Next Next post: Science and Technology links (May 5th, 2018)






Terms of use 
Proudly powered by WordPress 
















