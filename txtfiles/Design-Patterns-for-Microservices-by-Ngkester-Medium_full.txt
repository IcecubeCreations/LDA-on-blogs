Design Patterns for Microservices | by Ngkester | MediumGet unlimited accessOpen in appHomeNotificationsListsStoriesWriteNgkesterFollowOct 28, 2020·9 min readDesign Patterns for MicroservicesImage taken from https://www.thebroadcastbridge.com/home/category/services/entry/12321/migrating-to-microservices-rohde-schwarz-has-a-viewMicroservices have certainly taken the software development scene by storm over the recent years. It boasts low coupling between different components and services, supports reusability, scalability and extensibility. Many firms have begun transforming their monolithic applications into a microservice based applications. Microservices are good for intensive and complicated applications but not very good for small applications (due to overhead and over-complexity). However, it is important to know that just like monolithic architectures, there are recurrent problems when implementing a microservice architecture. Therefore, this article will explain the common problems and the design patterns associated with them. Below contains the patterns that will be thoroughly discussed in this article.ContentsDecomposition PatternsIntegration PatternsDatabase PatternsMiscellaneous PatternsDecomposition PatternsHow do we decompose a business solution or a monolithic architecture into a working microservices architecture? This section attempts to explain a few common design methods that can be used to solve this problem!Decompose based on business capabilitiesIt is a good strategy to decompose a product or software into well-defined and separate business capabilities. And these capabilities form a service itself. For instance, take a shopping application for instance. It contains perhaps seller capabilities, buyer capabilities, advertising capabilities, payment capabilities and other miscellaneous capabilities. Each of these capabilities can form a specific service.Decompose based on subdomainsThis pattern makes use of Domain driven design (DDD). DDD is the business domain or problem space itself and it contains several subdomains that corresponds to a certain part in the problem space. There are several types of subdomains:Core subdomains: the key differentiator for the business and is the distinguishes the product from other companies. They are the most valuable part.Supporting subdomains: Supports the core subdomainsGeneric subdomains: Not a defining part of the application.An example would make it easier to understand this decomposition pattern. Imagine you have a shop that includes inventory management, delivery management, order management, online store management. Each of this corresponds to a subdomain in the domain (a specific part in the shop). Hence the architectural diagram for the above example would look something like this:DDD architectureIn addition, each subdomain is mapped to a bounded context. Bounded contexts each contains each own models, architecture and ubiquitous language. And bounded contexts can only interact with each other via an interface or at its boundaries.Strangler patternThe above few patterns are more suitable for greenfield projects but not for brownfield projects. As it is difficult to break the monolithic application into microservices while the application is still being deployed. Hence the straggler pattern comes into play.The pattern essentially entails incrementally breaking down individual services or functionalities into microservices and remove those services from the monolithic application. There are 3 steps involved in this process:Transform: Develop the new microservice component while all requests are routed to the legacy component or old component.Co-exist: Let both the old component and new component exist for a period of time. This time is used to test the new microservice component in parallel with the old component.Eliminate: Replace old component with a new one and remove the old component from the software. Route requests to the new microservice component.Below is a diagram that illustrates the strangler pattern. Courtesy of (https://microservices.io/patterns/refactoring/strangler-application.html). Do take a look at their articles as they do provide a much in-depth analysis and description!Straggling the monolithAs seen above, the monolithic application is incrementally being decomposed into microservices and new microservices (new functionalities) are also developed at the same time. Hence progressively decomposing it into a microservice architectural application.Integration PatternsAnother problem occurs. How do we integrate all microservices into a working application? This section discusses several ways of integrating microservices.API GatewayWhen an application and its functionalities are broken down into microservices, there are many concerns that needs to be addressed:How do I call upon these services?How to handle multiple protocol requests?Different UI may require different data from the same microservice.These concerns can be addressed using an API gateway pattern. An API gateway pattern can be viewed as a proxy or router that routes incoming requests to its relevant microservice. The API gateway also acts as an entry point for all the available microservices and provides a well-defined API for clients.In addition, an API gateway can be used for authentication and traffic control. It can also be used to convert one protocol request to another and thereby supporting multiple protocol requests.Image taken from https://www.edureka.co/blog/microservices-design-patterns#APIGatewayAs seen from the above diagram, client requests are passed through the gateway where it passes to the load balancer and then passed to its respective microservices.Aggregator PatternThis pattern is very useful when we desire the combination of multiple data returned from various microservices. For instance, let’s say an order has been confirmed. An order has 3 microservices:Product: Microservice to get product detailsMerchant: Microservice to get merchant detailsPayment: Make payment and return statusThe UI may want to combine all this data and display for the users. But we do not want the UI or the client’s end to handle this combination of data as it violates the Single Responsibility Principle (SRP). Hence, we can deploy the aggregator pattern that aggregates all related microservices’ return data and combine them into a single aggregated data to be returned to the client.The following pattern can be done in the following ways:Using API Gateway: The gateway can be responsible for grouping related requests together and then combine the return results which is to be sent to the requestor.Composite microservice: This microservice send requests to all microservices involved (payment, merchant and product with respect to the above example), and then also aggregates all the data and send completed data back to the requestor.Client Side UI Composition PatternWith respect to UI, how do we request multiple microservices while displaying all the relevant data for the users? In monolithic applications, one API call will be enough to gather all the data needed. But this no longer works with microservice architectures.The idea of this pattern is to separate the UI into specific regions that are handled by one or more components. Each component is responsible for making the request to the correct microservice to grab the right data to display for the user.This can be done easily using AngularJS or ReactJS. In addition, changes or updates in a specific data will cause that specific region to be re-rendered instead of the whole page.Chained Microservice PatternVisual representation of Chained Microservice PatternThis pattern involves chaining multiple microservices in a chain and goes through them one at a time synchronously. Imagine the above example involving orders where we need to use merchants, products and payments microservices. In this pattern, each microservice will be used one at a time.So suppose a client sends an order request, what happens is that it requests the merchants service first. Then once the merchants service is done, it will then request product service and then finally payments service. Essentially it is like a step-by-step process. Then the aggregated response will be directed back to the client.However, it is important to take note that the whole process is synchronous. So products service will not be used until merchants service is done and the client will be blocked till the aggregated response is received. So do not have too long of a chain, if not the client will be blocked for a long period of time!Database PatternEvery microservice may need to deal with a specific database. Therefore this section explains the possible database patterns that can be used for a microservice architecture.Database for every microserviceThis pattern also formerly known as database per service tackles these following set of problems:Data may be replicated or inconsistentEach service must be scaled independently of other servicesEach service has its own database requirements for it to function properlyEssentially, we can have a separate database for each service. And the database can only be accessed by its associated service only and this can be done through database IDs. In this way, each database is tailored for the current microservices itself, reducing replication and inconsistency. In addition, it tackles the other two problems as the database can be modified to fit its scaling or its requirements.Shared DatabaseShared databaseThis pattern is more suitable for greenfield projects that has a monolithic architecture. It is difficult to completely de-normalize all the data available. We can deploy the shared database pattern where several microservices are using one particular database. However, do take note that it is best to have 2 to 3 microservices using one database as if we have too many microservices depending on a single database, scaling individual microservices will be a problem (see above pattern).CQRSYou may be familiar with this pattern! It’s called Command Query Responsibility Segregation (CQRS). There is a problem with regards to Database per service. What if the application requires a query that involves multiple separate tables? This would not be possible at all as all the tables are kept private to one service only.To tackle this, we can use CQRS pattern. We can split the architecture into command and queries. Commands such as write, delete and update can be handled by individual databases or services. Queries (eg getting data) will instead use materialized views as a datasource. In fact, this pattern is commonly implemented with the event sourcing design pattern.Miscellaneous PatternsThis section contains patterns that are worth taking a look at when developing microservices application.Circuit Breaker PatternThis have nothing to do with the current circuit breakers :P! Let’s assume this situation! Imagine one of the services are down. Then the client will keep trying to request from that service as it does not have any information regarding the current state of that service instance. This wastes network resources and time.To prevent such a thing, we can use a circuit breaker pattern. See below image for better understanding:Image taken from https://www.nginx.com/blog/microservices-reference-architecture-nginx-circuit-breaker-pattern/Resizer 1 is down. So if the number of failed requests for that services reaches a threshold (let’s say 50), then the circuit breaker will “trip”. In this case, all requests to Resizer 1 will automatically fail and will not be sent out at all. So for a period of time, all requests for Resizer 1 will not be processed and will warrant an automatic failure. This saves on network resources and costs.Blue-Green DeploymentImagine that a service is being upgraded and developed. The act of stopping the application to integrate this upgraded service may not be a very wise choice as it may introduce a long downtime and user annoyance. Even so, if the upgraded service crashes or a bug has been found, going back to the old one will cause more downtime.Hence in this case we use blue-green deployment! Let’s take a look at the image below for a clearer explanation.Image taken from https://dzone.com/articles/blue-green-deployment-for-cloud-native-applicationFrom the image above (courtesy of dzone), we have two production environments: blue and green. The current one that user requests are being routed to is the green environment. In the meantime, the blue environment hosts the new upgraded service being integrated and can be tested. Once satisfied, we can trigger the router to now route all user requests to the blue environment instead. This greatly reduces downtime. In addition, if we need to rollback due to major bugs, simply redirect users back to the green environment! A great way to ensure constant low downtime!ConclusionWith the increasing popularity of microservices, understanding such patterns and design principles are important in developing a robust, scalable and extensible microservices application! Thank you for reading everything and hope you are able to take away something!--1----1More from NgkesterFollowLove podcasts or audiobooks? Learn on the go with our new app.Try KnowableRecommended from MediumGianmario SpacagnainVademecum of Practical Data ScienceWordPress Blog Posts Recommender in Spark, Scala, and the Spark NotebookBhagyesh PatelTorrent Download Vs Direct DownloadAmar Jyoti KachariMachine Learning in briefNadia GarcíainSawyer EffectLet me open a ticketMohamed HijaziinLevel Up CodingTip of the Day: Loot System 101 in UnityGavin CockremJob Vacancy: Middleweight to Senior Full Stack / Back-end DeveloperZaid KaziinA Mobile Development JourneyAndroid Animations/Transitions Part 2: Drawable Animations with Vector ImagesElias NordlinderHow to implement Row Level Security in Power BI (Part I)AboutHelpTermsPrivacyGet the Medium appGet startedNgkester4 FollowersFollowMore from MediumFathan MuthahhariBuilding a Modern Monolithic AppEd WentworthResource Oriented Architecture and DesignKedernath Mallick.Adapter Design PatternSemaCommunication Best Practices — Giving and Receiving FeedbackHelpStatusWritersBlogCareersPrivacyTermsAboutKnowable






































