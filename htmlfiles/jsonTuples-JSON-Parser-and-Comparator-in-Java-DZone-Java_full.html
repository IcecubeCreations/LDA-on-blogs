
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Learn more about the jsonTuples library that parses JSON text to immutable JSON values, which can then be converted to List or Map for CRUD operations and back.">
  <meta name="keywords" content="JSON, java, unit test, object, parser, element">

  <meta property="og:description" content="Learn more about the jsonTuples library that parses JSON text to immutable JSON values, which can then be converted to List or Map for CRUD operations and back.">
  <meta property="og:site_name" content="dzone.com">
  <meta property="og:title" content="jsonTuples: JSON Parser and Comparator in Java - DZone Java">
  <meta property="og:url" content="https://dzone.com/articles/jsontuples-json-parser-and-comparator-in-java">
  <meta property="og:image" content="https://dz2cdn3.dzone.com/storage/article-thumb/12243434-thumb.jpg">
  <meta property="og:type" content="article">

  <meta name="twitter:site" content="@DZoneInc">
  <meta name="twitter:image" content="https://dz2cdn3.dzone.com/storage/article-thumb/12243434-thumb.jpg">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:description" content="Learn more about the jsonTuples library that parses JSON text to immutable JSON values, which can then be converted to List or Map for CRUD operations and back.">
  <meta name="twitter:title" content="jsonTuples: JSON Parser and Comparator in Java - DZone Java">

  <meta name="referrer" content="origin-when-cross-origin">
  <meta name="google-site-verification" content="kndbhxcupfEqWmZclhCpB6vlgOs7QSmx2UHAGGnP2mA">
  <meta name="df-verify" content="df0d76632b4543">

  <link rel="icon" type="image/x-icon" href="https://dz2cdn1.dzone.com/themes/dz20/images/favicon.png">
  <link rel="image_src" href="https://dz2cdn3.dzone.com/storage/article-thumb/12243434-thumb.jpg">
  <link rel="canonical" href="https://dzone.com/articles/jsontuples-json-parser-and-comparator-in-java">

  <title>jsonTuples: JSON Parser and Comparator in Java - DZone Java</title>

  <link rel="preload" href="https://fonts.dzone.com/themes/dz20/font/fontello.woff?11773374" as="font" type="font/woff" crossorigin="anonymous">

  <link rel="stylesheet" media="all" href="https://dz2cdn1.dzone.com/themes/dz20/ftl/icons.css">
  <link rel="stylesheet" media="all" href="https://dz2cdn1.dzone.com/themes/dz20/lib/static/bootstrap/bootstrap.min.css">
  <link rel="stylesheet" media="all" href="https://dz2cdn1.dzone.com/themes/dz20/ftl/article/global.css">
  <link rel="stylesheet" media="all" href="https://dz2cdn1.dzone.com/themes/dz20/ftl/header/styles.css">
</head>
<body>
<div id="ftl-header">
  <div class="container-fluid header">
    <div class="row">
      <div class="col-md-12" style="padding: 0;">
        <div class="header-top">
          <div class="header-container">
            <div class="pull-left logo-container">
              <div class="logo">
                <a class="inner" href="/">
                  <picture>
                    <source srcset="https://dz2cdn1.dzone.com/themes/dz20/images/dz_logo_2021_cropped.webp" type="image/webp">
                    <source srcset="https://dz2cdn1.dzone.com/themes/dz20/images/dz_logo_2021_cropped.png" type="image/png">
                    <img src="https://dz2cdn1.dzone.com/themes/dz20/images/dz_logo_2021_cropped.png" width="160" height="52" alt="DZone">
                  </picture>
                </a>
              </div>

                <div class="active-portal"><a href="/java-jdk-development-tutorials-tools-news">Java Zone</a></div>
            </div>

            <div class="pull-right login-and-search">
              <div id="authenticated-block" class="logged-in">
                <div class="welcome-back">Thanks for visiting DZone today,</div>
                <div id="user-header" class="user-info">
                  <button class="user-avatar">
                    <span id="header-username" class="username"></span>
                    <img id="header-avatar" src="" alt="user avatar">
                  </button>
                  <div id="user-dropdown" class="browse-user-menu">
                    <div class="user-content">
                      <a id="header-user-plug" href="#" class="user-description"></a>
                      <a id="header-user-edit" href="#" class="edit-profile">Edit Profile</a>
                    </div>
                    <ul class="user-actions">
                      <li id="first-user-action"><a id="header-dropdown-manage-email" href="#">Manage Email Subscriptions</a></li>
                      <li>
                        <a href="/articles/how-to-submit-a-post-to-dzone?utm_source=DZone&utm_medium=user_dropdown&utm_campaign=how_to_post">
                          How to Post to DZone
                        </a>
                      </li>
                      <li>
                        <a href="/articles/dzones-article-submission-guidelines">
                          Article Submission Guidelines
                        </a>
                      </li>
                    </ul>
                    <div class="bottom">
                      <a href="/users/logout.html" class="sign-out">Sign Out</a>
                      <a id="dropdown-view-profile" href="#" class="view-profile">View Profile</a>
                    </div>
                  </div>
                </div>

                <div class="post-content">
                  <button id="post-button" class="post-content--button">
                    <span class="post-class">Post</span>
                    <i class="icon-plus"></i>
                  </button>

                  <div id="post-menu" class="posting-links">
                    <div class="posting-links-menu">
                      <ul>
                        <li>
                          <img src="/themes/dz20/images/dz-postarticle.svg">
                          <a href="/content/article/post.html">Post an Article</a>
                        </li>
                        <li>
                          <a id="drafts-link" href="#">Manage My Drafts</a>
                        </li>
                      </ul>
                    </div>
                  </div>
                </div>
              </div>

              <div id="unauthenticated-block">
                <div class="dz-intro">Over 2 million developers have joined DZone.</div>
                <div class="mobile-invisible sign-in-join">
                  <a href="/users/login.html">Log In</a>
                  <span class="dz-intro-span">/</span>
                  <a href="/static/registration.html">Join</a>
                </div>
                <a class="join-icon" href="/users/login.html"><i class="icon-user"></i></a>
              </div>
              <div class="headerSearch">
                <a class="icon-search dropdown-toggle" href="/search"></a>
              </div>
            </div>
          </div>
        </div>

        <div class="header-bottom">


          <ul class="portals header-container scrollable-ul">
            <li>
              <a href="/refcardz" id="header-refcardz">
                <em>Refcardz</em>
              </a>
            </li>
            <li>
              <a href="/trendreports" id="header-research">
                <em>Trend Reports</em>
              </a>
            </li>
            <li>
              <a href="/webinars" id="header-webinars">
                <em>Webinars</em>
              </a>
            </li>
            <li class="last-portal-link">
              <a href="#" id="header-portals">
                <em>
                  Zones
                  <span id="zone-arrow" class="collapsible-toggle">
                    <i class="icon-angle-down"></i>
                    <i class="icon-angle-up"></i>
                  </span>
                </em>
              </a>
            </li>

            <li class="separator" aria-hidden="true" style="color: #d9dcdd;">|</li>
            <li id="portal-list" class="portal-topics">
              <ul>
                  <li>
                    <a href="/agile-methodology-training-tools-news" id="header-2">Agile</a>
                  </li>
                  <li>
                    <a href="/artificial-intelligence-tutorials-tools-news" id="header-4001">AI</a>
                  </li>
                  <li>
                    <a href="/big-data-analytics-tutorials-tools-news" id="header-3">Big Data</a>
                  </li>
                  <li>
                    <a href="/cloud-computing-tutorials-tools-news" id="header-4">Cloud</a>
                  </li>
                  <li>
                    <a href="/database-sql-nosql-tutorials-tools-news" id="header-5">Database</a>
                  </li>
                  <li>
                    <a href="/devops-tutorials-tools-news" id="header-6">DevOps</a>
                  </li>
                  <li>
                    <a href="/enterprise-integration-training-tools-news" id="header-7">Integration</a>
                  </li>
                  <li>
                    <a href="/iot-developer-tutorials-tools-news-reviews" id="header-8">IoT</a>
                  </li>
                  <li>
                    <a href="/java-jdk-development-tutorials-tools-news" id="header-1">Java</a>
                  </li>
                  <li>
                    <a href="/microservices-news-tutorials-tools" id="header-6001">Microservices</a>
                  </li>
                  <li>
                    <a href="/open-source-news-tutorials-tools" id="header-7001">Open Source</a>
                  </li>
                  <li>
                    <a href="/apm-tools-performance-monitoring-optimization" id="header-10">Performance</a>
                  </li>
                  <li>
                    <a href="/application-web-network-security" id="header-2001">Security</a>
                  </li>
                  <li>
                    <a href="/web-development-programming-tutorials-tools-news" id="header-11">Web Dev</a>
                  </li>
              </ul>
            </li>
          </ul>
        </div>
      </div>
    </div>
  </div>
</div>

<script async src="https://dz2cdn1.dzone.com/themes/dz20/ftl/header/bundle.js"></script><link rel="stylesheet" media="all" href="https://dz2cdn1.dzone.com/themes/dz20/ftl/article/styles.css">




<div id="ftl-article" >
  <div class="container-fluid body">
    <div class="row">
      <div class="col-md-12">
        <div class="articles-wrap">
              <div class="ad-container">
                <div id="div-gpt-ad-1435246566686-0" class="ads-billboard-article" data-gpt-slot="top"></div>
              </div>


          <div class="article-stream widget-top-border">
                <div class="content-right-images">
                  <div id="div-gpt-ad-1435246566686-2" class="sidebar-ad" data-gpt-desktop="true" data-gpt-slot="sidebar1"></div>
                </div>

                <script type="application/ld+json">
                  {
                    "@context": "http://schema.org",
                    "@type": "Article",
                    "headline": "jsonTuples: JSON Parser and Comparator in Java",
                    "author": {
                      "@type": "Person",
                      "name": "William JIANG"
                    },
                    "audience": "software developers",
                    "keywords": "java,json,parser,data science tools,tutorial",
                    "timeRequired": "PT17M",
                    "commentCount": 0,
                    "wordCount": "4136",
                    "accessMode": "textual, visual",
                    "dateCreated": "2019-07-26T12:54:26Z",
                    "datePublished": "2019-07-26T00:00:00Z",
                    "dateModified": "2021-08-16T20:27:18Z",
                    "articleSection": "java-jdk-development-tutorials-tools-news",
                    "publisher": {
                      "@type": "Organization",
                      "name": "DZone",
                      "url": "https://dzone.com",
                      "logo": {
                        "@type": "ImageObject",
                        "url": "https://dzone.com/themes/dz20/images/dz_logo_2021_cropped.png"
                      }
                    },
                    "articleBody": "The jsonTuples library parses JSON text to immutable JSON values, which can then be converted to List or Map for CRUD operations, and then back to JSON values. As a unique feature, jsonTuples can compare two JSON texts, or compare ANY two Java Objects to get their minimum deltas in seconds. Background Before this project, inspired with the concepts of the functional programming paradigm, another Java library, functionExtensions, was published to make data immutable, refer Java methods without caring if they throw Exceptions or not, and enable complex business logic based on Map-based, run-time evaluation. When I tried to develop a prototype REST API testing framework by using JSON texts as templates to compose requests or match responses automatically, I found the JSON parsers available are either too complex to set up, or not fast or convenient enough to convert JSON to/from Java objects as I have expected. Considering the simplicity of JSON syntax, I tried to implement this JSON parser with a simplified class architecture over Tuple from the functionExtensions library to exploit the benefits of the pure function and immutable objects. Once the JSON parser was done, I tried to find a way to compare two JSON texts to get their minimum differences. Thankfully, this attempt turned out satisfactory by comparing two big Java objects in seconds to get the deltas. Getting Started Add the following dependency to your pom.xml: &lt;dependency&gt; &lt;groupId&gt;io.github.cruisoring&lt;/groupId&gt; &lt;artifactId&gt;jsonTuples&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;/dependency&gt; Alternatively, you can get the package from Maven Central directly. Mapping Between JSON Values and Java Objects The JSON values here refers to classes/interfaces defined in thejsonTuples project. The Java objects refer to common Java types like primitive values or objects, as well as generic Map, Collection, and Arrays. The jsonTuples is implemented based on the information from json.org with direct mappings between JSON values (or interfaces/classes defined in jsonTuples) and Java objects, as shown below: Interfaces Classes Constants/Sub-Classes Java Equivalents JSON Sample Notes IJSONValue&lt;T&gt; JSONValue&lt;T&gt; Null null null \"Null\" is invalid True true true Case sensitive, thus True is not accepted False false false \"False\" is invalid JSONString String \"A string\" special chars like '\\n' or '\\t' would be trimmed by default JSONNumber Integer, BigInteger, Double, BigDecimal 123.45e5 the actual Object saved doesn't affect equals() which would compare by toString() IJSONValue&lt;NamedValue&gt;, Map&lt;String, Object&gt; JSONObject Map&lt;String, Object&gt; {\"id\":12,\"name\":\"Tom\"} JSONObject has implemented Map&lt;String, Object&gt;, the NamedValueis used internally IJSONValue&lt;IJSONValue&gt;, List&lt;Object&gt; JSONArray Object[] or Collection [null,true,1,\"abc\",{},[]] JSONArray can hold any number of IJSONValue All these types extend the generic Tuple type and are thus immutable. The major interface defined here is IJSONValue for any JSON values with solid meanings except NamedValue that is similar to Map.Entry and used as building blocks of JSONObject by assigning a JSONValue with a name of JSONString. Of the seven types represented by IJSONValue, the first five simple types (Null, True, False, JSONString, JSONNumber) are referred as leaf nodes since their Java counterparts cannot be split further, and while JSONObject and JSONArray contain zero to multiple of them, the IJSONable.getLeafCount() reflects how many leaf nodes it has by counting the occurrence of the first 5 simple types. The two major JSON values are JSONObject and JSONArray that could be treated as Java Map&lt;String, Object&gt; and Collection&lt;Object&gt; or Object[] naturally. Under the hood, theJSONObject retains the orders of its elements with LinkedHashMap. Parsing JSON Text and Consuming the Parsed JSON Values The jsonTuples can parse given JSON texts to any of the seven typesIJSONValues in the above table. Then calling the getObject() or asMutableObject()would return the contained Java values as immutable or mutable Java objects for convenient processing. APIs Used to Parse JSON Text Constructors of all above JSON values in bold (Null, True, False, JSONString, JSONNumber, JSONObject, and JSONArray) are protected, and would be created by calling the following APIs: The strict JSON Syntax checking is not activated by default. Static methods to parse a given String or part of a CharSequence to a specific type of IJSONValue: IJSONValue Parser.parse(CharSequence): generate IJSONValue based on the given JSON text content. If the JSON text is of right syntax, the IJSONValue result shall be cast to one of Null, True, False, JSONString, JSONNumber, JSONObject, or JSONArray. JSONString.parseString(String jsonText): the given JSON text must be wrapped by a pair of quotation marks (\"). JSONValue.parse(CharSequence, Range): expect and parse a part of the given JSON context as one of Null, True, False, JSONString, JSONNumber. JSONObject.parse(String valueString): expect the valueString is enclosed by '{' and '}', and cast the result of Parser.parse() to be JSONObject. JSONArray.parse(String valueString): expect the valueString is enclosed by '[' and ']', and cast the result of Parser.parse() to be JSONArray. Static method IJSONValue jsonify(Object object) of Utilities.java is the only API used to convert Java Objects to JSON values defined in jsonTuples, it would check the type of the given object to call a method above. For types not covered above, by default, the asJSONStringFromOthers(Object object) would be called to generate a JSONString, but it is possible to inject serialization/de-serialization methods into Utilities.classConverters that is a Map&lt;Class, Tuple2&gt; where the value of a given class includes both serialization and de-serialization for a concerned type of object, then the serialization method would be called to convert the matched instance to its text equivalent. The above methods have multiple variations to accept optional arguments. Basic Example of Parsing JSON Text There is no config needed before calling the static methods. The unit test below shows how IJSONValue Parser.parse(CharSequence) can be used to parse different text to corresponding IJSONValue types. @Test public void parseText_getRightIJSONValue() { //parse texts of null, true or false assertAllTrue(JSONValue.Null == Parser.parse(false, \"null\")); assertAllTrue(JSONValue.True == Parser.parse(false, \"true\")); assertAllTrue(JSONValue.False == Parser.parse(false, \"false\")); //text of a number to JSONNumber JSONNumber number = (JSONNumber) Parser.parse(false, \" 12.345 \"); assertEquals(12.345, number.getObject()); //text enclosed by '\"\"s would be parsed as JSONString JSONString string = (JSONString) Parser.parse(false, \" \\\" abc \\n \\t\\\"\\r\"); assertEquals(\" abc \", string.getObject()); //If JSONString.forbidUnescapedControls is set to false, then special characters like \\n, \\r would not be removed try { Revokable.register(() -&gt; JSONString.forbidUnescapedControls, v -&gt; JSONString.forbidUnescapedControls = v, false); string = (JSONString) Parser.parse(false, \" \\\" abc \\n \\t\\\"\\r\"); assertEquals(\" abc \\n \\t\", string.getObject()); }finally { Revokable.revokeAll(); } //Map alike text would be parsed as JSONObject JSONObject object = (JSONObject) Parser.parse(false, \"{\\\"id\\\":123,\\\"name\\\":null,\\\"courses\\\":[\\\"English\\\", \\\"Math\\\", \\\"Science\\\"]}\"); assertEquals(123, object.get(\"id\")); assertAllNull(object.get(\"name\")); assertEquals(new Object[]{\"English\", \"Math\", \"Science\"}, object.get(\"courses\")); //Array alike text would be parsed as JSONArray JSONArray array = (JSONArray) Parser.parse(false, \"[1, null, true, \\\"abc\\\", [false, null], {\\\"id\\\":123}]\"); assertEquals(1, array.get(0)); assertAllTrue( array.size() == 6, array.contains(null), array.containsAll(Arrays.asList(true, \"abc\")) ); assertEquals(new Object[]{false, null}, array.get(4)); Map mapAt5 = (Map)array.get(5); assertEquals(123, mapAt5.get(\"id\")); } The assertTrue()and assertEquals() are helper methods added in Asserts.java of functionExtensions 2.1.0 to assert multiple expressions or compare elements of two Arrays or Collections. The above test illustrates how JSONObject can be referred to as a Map&lt;String,Object&gt; while JSONArray can refer its elements as a List. However, all WRITE operations on them would get UnsupportedOperationException due to the immutable nature inherited from Tuple. Parsing in Lenient or Strict Mode With Error Highlighted By assuming the JSON texts to be syntax correct, the Parser would work in lenient mode by default to get a bit higher throughput and neglect any errors that bring no ambiguities, as the unit test below: @Test public void validateLenientParsing_withUnexpectedChars_ignoreIfNoConfusion() { assertEquals(\"{\\\"id\\\":222,\\\"name\\\":\\\"Alice\\\"}\", Parser.parse(false, \"XXX{\\\"id\\\"XXX:222, \\\"name\\\":\\\"Alice\\\"}\").toJSONString(null)); assertEquals(\"{\\\"id\\\":222,\\\"name\\\":\\\"Alice\\\"}\", Parser.parse(false, \"XXX{\\\"\\\":\\\"id\\\":222, \\\"name\\\":\\\"Alice\\\"}XXX\").toJSONString(null)); assertEquals(\"{\\\"id\\\":222,\\\"name\\\":\\\"Alice\\\"}\", Parser.parse(false, \"{XXX\\\"id\\\":222, XXX \\\"name\\\":\\\"Alice\\\"}\").toJSONString(null)); assertEquals(\"{\\\"id\\\":222,\\\"name\\\":\\\"Alice\\\"}\", Parser.parse(false, \"{\\\"id\\\":222, \\\"name\\\":\\\"Alice\\\"}, null\").toJSONString(null)); } Notice there are many illegal XXXs would be neglected when people can still \"guess\" out the intended content. On the other hand, it is possible to enforce more strict syntax checking by calling IJSONValue parse(boolean isStrictly, CharSequence jsonText) with \"isScritly=true\" (with a overhead of 1-5%), then the same JSON texts would cause errors thrown: @Test public void validateStrictParsing_withUnexpectedChars_throwExceptions() { assertException(() -&gt; Parser.parse(true, \"\\\"id\\\":\\\"id\\\":222, \\\"name\\\":\\\"Alice\\\"}\"), NullPointerException.class, \"COLON(':') shall only present in JSONObject\"); assertException(() -&gt; Parser.parse(true, \"{\\\"id\\\":\\\"id\\\":222, \\\"name\\\":\\\"Alice\\\"}\"), IllegalStateException.class, \"Wrong state before COLON(':'): lastName=\\\"id\\\", lastStringValue=\\\"id\\\"\"); assertException(() -&gt; Parser.parse(true, \"XXX{\\\"id\\\"XXX:222, \\\"name\\\":\\\"Alice\\\"}\"), IllegalStateException.class, \"Only white spaces are expected\"); assertException(() -&gt; Parser.parse(true, \"{\\\"id\\\"XXX:222, \\\"name\\\":\\\"Alice\\\"}\"), IllegalStateException.class, \"Only white spaces are expected\"); assertException(() -&gt; Parser.parse(true, \"{\\\"id\\\"\\\"\\\":222, \\\"name\\\":\\\"Alice\\\"}\"), IllegalStateException.class, \"two JSONStrings must be seperated by a control char\"); assertException(() -&gt; Parser.parse(true, \"{\\\"id\\\":222, \\\"name\\\":\\\"Alice\\\"}xxx\"), IllegalStateException.class, \"Only white spaces are expected\"); assertException(() -&gt; Parser.parse(true, \"{\\\"id\\\":222, , \\\"name\\\":\\\"Alice\\\"}\"), IllegalStateException.class, \"Missing value string\"); } By changing the static variable of Parser.PARSE_STRICTLY to true to turn off the default lenient parsing, calling IJSONValue parse(CharSequence jsonText) would enforce the strict syntax checking automatically. When there is syntax errors found when parsing in either lenient or strict mode, the problematic text would be highlighted for further correction: Stringify JSON Values With Indent Instruction In the IJSONable interface that is the super interface of IJSONValue, the indent argument within String toJSONString(String indent) determines how to generate a string representation of an IJSONValue instance: Empty String (\"\") would result in the common indented beautiful form that is easy to identify the layered structure of JSON elements, the \"toString()\" would produce the same things. null would produce the most condensed form: all SPACEs out of JSONString would be removed. Other String composed of WhiteSpaces (like \" \") only would fill each lines of the Strings with the specified leading SPACEs. The unit test below shows how it works: @Test public void toJSONString() { JSONObject obj = JSONObject.parse(\"{ \\\"age\\\": 123, \\\"other\\\": \\\"none\\\", \\\"name\\\": null }\"); assertEquals(\"{\\\"age\\\":123,\\\"other\\\":\\\"none\\\",\\\"name\\\":null}\", obj.toJSONString(null)); assertEquals(\"{\\n \\\"age\\\": 123,\\n \\\"other\\\": \\\"none\\\",\\n \\\"name\\\": null\\n}\", obj.toJSONString(\"\")); assertEquals(\"{\\n \\\"age\\\": 123,\\n \\\"other\\\": \\\"none\\\",\\n \\\"name\\\": null\\n }\", obj.toJSONString(\" \")); assertEquals(\"{\\n \\\"age\\\": 123,\\n \\\"other\\\": \\\"none\\\",\\n \\\"name\\\": null\\n }\", obj.toJSONString(\" \")); } Since JSON texts representing Map or Array are used most, JSONObject.parse(String valueString) and JSONArray.parse(String valueString) act as syntactic sugar to cast the IJSONValue to JSONObject or JSONArray behind the scenes. Accessing Parsing Result as Java Objects As shown in the basic parsing example, the parsed JSONArray and JSONObject can be accessed as immutable List&lt;Object&gt; and Map&lt;String, Object&gt; respectively by calling the Object getObject() defined in the IJSONValue interface, and the Object returned would composed by common Java objects (nulls, Booleans, Strings, Numbers, and combinations of them as Arrays or Maps), but they cannot be modified. To perform CRUD operations, theObject asMutableObject() of IJSONValue shall be called to get the modifiable versions like the example below suggested: @Test public void testAsMutableObject_canBeUpdated() { JSONObject obj = JSONObject.parse(\"{ \\\"age\\\": 123, \\\"other\\\": \\\"none\\\", \\\"name\\\": null, \\\"members\\\":[\\\"Alice\\\", \\\"Bob\\\"] }\"); Map&lt;String, Object&gt; map = (Map&lt;String, Object&gt;)obj.asMutableObject(); assertEquals(123, map.get(\"age\")); assertEquals(null, map.get(\"name\")); map.put(\"age\", 23); map.remove(\"name\"); List members = (List)map.get(\"members\"); members.remove(\"Alice\"); members.add(0, \"Alan\"); members.add(\"Carter\"); JSONObject updated = Utilities.asJSONObject(map); assertEquals(\"{\\\"age\\\":23,\\\"other\\\":\\\"none\\\",\\\"members\\\":[\\\"Alan\\\",\\\"Bob\\\",\\\"Carter\\\"]}\", updated.toJSONString(null)); } At the end of the above codes, the Utilities.asJSONObject(map) would turn the Java Map to a JSONObject that might be suitable for big Java Objects. For small ones, as you can find from the unit tests of this project, I tend to initialize a Map or List by parsing a String, then calling getObject() would save some typings. Convert any Java Objects to IJSONValues As the above example illustrated, the Utilities.asJSONObject(Object) would convert a Java Map to a JSONObject, a more generic API is IJSONValue jsonify(Object object). By default, it enables the following conversions in order: Java null to JSONValue.Null; An IJSONValue instance to itself directly; Java true/false to JSONValue.True or JSONValue.False respectively; Java String Objects to JSONString Objects; Java Number Objects to JSONNumber Objects; Java Map to JSONObject; Java Collection or Array to JSONArray; For unknown types of Java Objects, JSONString would be used to represent their toString(). You might have noticed that converting unknown Java objects to their toString()s is not quite reasonable, that is mainly due to missing something like AutoMapper to serialize/deserialize Java classes to/from JSON Strings that is out of the scope of this project, but the following unit test shows how it can be supported if helper methods are defined: public class Student{ public String name; public int age; public Student(String name, int age){ this.name = name; this.age = age; } public String toJSON() { return String.format(\"{\\\"name\\\":\\\"%s\\\", \\\"age\\\":%d}\", name, age); } } @Test public void testJsonify_withStudentInstances(){ FunctionThrowable&lt;Object, IJSONValue&gt; studentToJSON = student -&gt; Parser.parse(((Student)student).toJSON()); Utilities.classConverters.put(Student.class, Tuple.create(studentToJSON, null)); Map studentInClass = new HashMap(){ put(\"year\", \"Year7\"); put(\"active\", true); put(\"students\", Arrays.asList( new Student(\"Alice\", 12), new Student(\"Bob\", 13) )); }; assertEquals(\"{\\\"year\\\":\\\"Year7\\\",\\\"active\\\":true,\\\"students\\\":[{\\\"name\\\":\\\"Alice\\\",\\\"age\\\":12},{\\\"name\\\":\\\"Bob\\\",\\\"age\\\":13}]}\", Utilities.jsonify(studentInClass).toJSONString(null)); } Though not in the scope of jsonTuples, if there is an AutoMapper alike library to parse the POJOs in your working projects, then it shall be quite convenient to handle literately any Java objects to and from JSON texts. Performance of jsonTuples Unlike other JSON parsers, the jsonTuples applies a simplified high-level state-machine to process the characters of JSON text under parsing in three steps: Delimit the scopes of Strings enclosed by QUOTEs(\"), and neglect any chars inside including the escaped QUOTEs that are behind of an opening (\") with BACK-SLASH(\\) ahead, extract any JSONStrings directly. Neglect all chars except control chars used in JSON (that is LEFT_BRACE('{'), RIGHT_BRACE('}'), LEFT_BRACKET('['), RIGHT_BRACKET(']'), COMMA(','), COLON(':')), perform strict syntax checking if needed. Only the above control chars would be fed into a state-machine to harvest the parsed results recursively with only the previous control char considered. Unless there is any syntax error encountered and then the Parser needs to revisit the start of the text causing the error, the processing of JSON text would hardly revisit the previous content before the last control, and even the control chars identified earlier would be consumed without evaluating for the second time. When running the unit test below from my 4-cores i7-7700HQ @ 2.8G laptop to parse the 6.1M JSON text 10 times: @Test public void test6104KJson() { String jsonText = ResourceHelper.getTextFromResourceFile(\"catalog.json\"); int jsonTextLength = jsonText.length(); String sortedString = null; for (int i = 0; i &lt; 10; i++) { JSONObject result = Logger.M(Measurement.start(\"Parsing JSON text of %dk\", jsonTextLength/1024), () -&gt; (JSONObject) Parser.parse(false, jsonText)); int leafCount = checkNotNull(result, \"Failed to parse the JOSN text.\").getLeafCount(); IJSONValue sortedValue = Logger.M(Measurement.start(\"Sorting JSONObject with %d leaf nodes\", leafCount), () -&gt; result.getSorted(Comparator.naturalOrder())); sortedString = Logger.M(Measurement.start(\"ToJSONString(null)\"), () -&gt; sortedValue.toJSONString(null)); } Measurement.purge(LogLevel.warning); } The screenshot below shows the average and max time to parse the 6.1M file are 279ms and 306ms respectively: almost 20M/s throughput for such middle-sized JSON texts. It is not so ideal when parsing huge JSON file. For the 181M JSON file, if you save it as \"C:\\temp\\citylots.json\", then the following test: @Test @Ignore public void test181MJson() { String jsonText = Logger.M(Measurement.start(\"Load JSON as String\"), () -&gt; ResourceHelper.getTextFromResourceFile(\"c:/temp/citylots.json\")); int jsonTextLength = jsonText.length(); String sortedString = null; JSONObject result = Logger.M(Measurement.start(\"Parsing JSON text of %dk\", jsonTextLength / 1024), () -&gt; (JSONObject)Parser.parse(true, jsonText)); assertNotNull(result, \"Failed to parse the JSON text.\"); Measurement.purge(LogLevel.warning); } The logging shows it might take 2-4 seconds to process 1 Megabyte payload intermittently that might happen because of Java Garbage collections. Though running the same test from a slow PC with 8G memory only would crash the JVM when it took exponentially longer time to process 1 Megabytes after 100M, as shown in the [log](images/Parse 181M JSON from PC with 8G Mem.txt), the jsonTuples shall be responsive enough to handle JSON of normal sizes. Comparing Two IJSONValues or Comparing Two Java Objects After implementing the parsing functions, I started to exploit the possibility of comparing two IJSONValue instances to show their differences. It turned out to be more difficult than implementing the parsing. Scenarios to Be Compared Actually, it is not always difficult, the combinations of IJSONValues to be compared can be classified as the following scenarios: Between simple IJSONValue types, namely Null, True, False, JSONString, JSONNumber that are also leaf nodes of composing any JSON content, comparing their toString() would be fair enough, so: Thus JSONNumber(null)orJSONString(null)would be equal to JSONValue.Null. The JSONNumber(Integer.valueOf(1)) would be equal to JSONNumber(1L). Between different types of IJSONValue, like comparing a JSONNumber with a JSONString, or JSONObject vs JSONArray, then a JSONArray composed by these two IJSONValue instances would explain everything. Between two JSONObject instances, their names, like the keys of two Maps, can associate their entries easily to allow further comparisons of the corresponding values. Between two JSONArray instances, now comes the interesting part: If the positions of their elements matter, then it is straight-forward like comparing two JSONObject instances with their positions as the implicit keys. If the positions of their elements doesn't matter, then binding their elements to get the least difference sets before further comparing. The first three and a half scenarios are quite simple and worth no discussions, but the last case of comparing two JSONArray instances when their orders are neglected is the real challenge, especially when both of them contain hundreds or thousands of similar elements. However, I believe it is also quite using when considering them as two Sets, or two Lists created from identical sets of elements when one of them get one or several elements in the middle removed. Immutable Tuples With Immutable hashCodes and Signatures The Tuple classes defined in functionExtensions are extended to summarize its contents as a set of Integers. Since these strong-typed Objects whose constructors accept only arguments decorated with final, their elements shall be immutable with fixed orders IF extended properly, thus their and their children's hashCodes are also fixed thus can be buffered as Set that could be the least-cost items to be compared in Java. A unit test shows how the getSignatures() inherited from Tuple can reveal the common points and potential differences of two JSONObjects: @Test public void testGetSignatures() { String text = \"{\\\"address\\\": null, \\\"scores\\\": {\\\"English\\\":80,\\\"Science\\\":88,\\\"Math\\\":90}, \\\"name\\\": \\\"test name\\\" ,\\\"id\\\" :123456, \\\"isActive\\\": true, \\\"class\\\": \\\"7A\\\"}\"; JSONObject object1 = JSONObject.parse(text); NamedValue address = object1.getValue(0); NamedValue scores = object1.getValue(1); NamedValue name = object1.getValue(2); NamedValue id = object1.getValue(3); NamedValue isActive = object1.getValue(4); NamedValue classNamedValue = object1.getValue(5); Set&lt;Integer&gt; signature1 = object1.getSignatures(); Logger.I(object1.toJSONString(null)); Logger.D(\"address: %s\\tscores: %s\\tname: %s\\tid: %s\\tisActive: %s\\tclass: %s\\n\\tobject1: %s\\n\", address.hashCode(), scores.hashCode(), name.hashCode(), id.hashCode(), isActive.hashCode(), classNamedValue.hashCode(), deepToString(signature1)); assertAllTrue(signature1.size() == 7, signature1.containsAll(Arrays.asList(object1.hashCode(), address.hashCode(), scores.hashCode(), name.hashCode(), id.hashCode(), isActive.hashCode(), classNamedValue.hashCode()))); JSONObject object2 = object1.getSorted(Comparator.naturalOrder()); Logger.I(object2.toJSONString(null)); Set&lt;Integer&gt; signature2 = object2.getSignatures(); NamedValue sortedScores = NamedValue.parse(\"\\\"scores\\\": {\\\"English\\\":80,\\\"Math\\\": 90,\\\"Science\\\": 88}\"); Logger.D(\"address: %s\\tsortedScores: %s\\tname: %s\\tid: %s\\tisActive: %s\\tclass: %s\\n\\tobject2: %s\\n\", address.hashCode(), sortedScores.hashCode(), name.hashCode(), id.hashCode(), isActive.hashCode(), classNamedValue.hashCode(), deepToString(signature2)); assertAllTrue(signature2.size() == 7, signature2.containsAll(Arrays.asList(object2.hashCode(), address.hashCode(), name.hashCode(), id.hashCode(), isActive.hashCode(), classNamedValue.hashCode())), signature2.contains(sortedScores.hashCode())); } Its output is marked with different colors to highlight why it is called signatures: The object1 and object2 share same set of NamedValues except the embedded JSONObject identified by scores, by comparing their signatures along, it is quite easy to see that pair of elements shall be compared together while other pairs identified by address, name, id, and ect would conclude as no differences quickly. Checking the two pairs of scores JSONObjects, clearly they are referring to the same thing if defined as Java Maps, wasting time to compare these JSONObjects with the same elements of different orders would be a waste of time, that is why comes the sorting that is usually not supported by JSON Parsers. Sorting With StringComparator The ISortable getSorted(Comparator) method inherited by IJSONValue wold re-arrange the elements of JSONObject with desirable orders, and it would also be used by the JSONArray to pass to all its children JSONObjects. Consequently, two JSONObjects or JSONArrays sharing the same Comparator&lt;String to sorting the names of their JSONObject would represent their children of the same elements with identical signatures. To ensure a preferred order or retain the original orders of the embedded JSONObjects, an OrdinalComparator can be constructed easily and supplied to either Parser.parse(...) or IJSONValue.getSorted(Comparator) to get array3, which would be shown as: @Test public void getSortedWithOrderedNames() { JSONObject obj = JSONObject.parse(\"{ \\\"age\\\": 123, \\\"name\\\": null, \\\"other\\\": \\\"none\\\" }\"); JSONObject naturalOrdered = (JSONObject) obj.getSorted(\"name\", \"other\"); String string = naturalOrdered.toString(); assertEquals(\"{\\n\" + \" \\\"name\\\": null,\\n\" + \" \\\"other\\\": \\\"none\\\",\\n\" + \" \\\"age\\\": 123\\n\" + \"}\", string); JSONObject naturalReversed = obj.getSorted(naturalOrdered.nameComparator.reversed()); string = naturalReversed.toString(); assertEquals(\"{\\n\" + \" \\\"age\\\": 123,\\n\" + \" \\\"other\\\": \\\"none\\\",\\n\" + \" \\\"name\\\": null\\n\" + \"}\", string); } Get the Least Different Pairs When Orders Are Neglected To compare two JSONArrays when their element's order doesn't matter, the logic behind would use the signatures to pair elements by finding out the least different pairs that is a quite complex procedure with acceptable performance. The following test would load the 6M JSON file, change 1000 of its leaf nodes, then compare their differences for 10 times: @Test @Ignore public void testDeltaWith_ofLargeObjects() { String jsonText = ResourceHelper.getTextFromResourceFile(\"catalog.json\"); int changes = 1000; int jsonTextLength = jsonText.length(); JSONObject original = Logger.M(Measurement.start(\"Parse JSON of %dk\", jsonTextLength/1024), () -&gt; JSONObject.parse(jsonText)); int originalLeafCount = original.getLeafCount(); try(Revokable revokable = Logger.setLevelInScope(LogLevel.debug)) { for (int i = 0; i &lt; 10; i++) { Map&lt;String, Object&gt; modifiableMap = (Map&lt;String, Object&gt;) Logger.M(Measurement.start(\"Get Modifiable Map\"), () -&gt; original.asMutableObject()); Object packagesList = modifiableMap.get(\"packages\"); Logger.M(Measurement.start(\"Modify %d leaf values\", changes), () -&gt; modifyAndShuffle(packagesList, changes)); Object shuffledArray = Logger.M(Measurement.start(\"Shuffle packages list as array\"), () -&gt; ArrayHelper.shuffle(((List) packagesList).toArray())); modifiableMap.put(\"packages\", shuffledArray); JSONObject modifiedObject = Logger.M(Measurement.start(\"jsonify() back to JSONObject\"), () -&gt;(JSONObject) Utilities.jsonify(modifiableMap)); int modifiedLeafCount = modifiedObject.getLeafCount(); Logger.D(\"Save modified JSONObject with %d leaves to %s\", modifiedLeafCount, Logger.M(Measurement.start(\"save modified JSON\"), () -&gt;ResourceHelper.saveTextToTargetFile(modifiedObject.toString(), \"modified.json\"))); IJSONValue delta = Logger.M(Measurement.start(\"deltaWith() between Object with %d leafs and another with %d leafs\", originalLeafCount, modifiedLeafCount), () -&gt; original.deltaWith(modifiedObject, \"pos\")); assertNotNull(delta, \"Failed to get result.\"); String deltaString = delta.toString(); Matcher matcher = Pattern.compile(\"changedValue\\\\d{3}\").matcher(deltaString); int count = 0; while (matcher.find()){ count++; } String timeStamp = DateTimeHelper.asString(LocalDateTime.now(), \"MMddHHmmss\"); String modifedFile = ResourceHelper.saveTextToTargetFile(modifiedObject.toString(), String.format(\"modified%s.json\", timeStamp)); String deltaFile = ResourceHelper.saveTextToTargetFile(delta.toString(), String.format(\"delta%s.json\", timeStamp)); Logger.I(\"There are %d changed values found, the modified file is saved as %s, and delta is saved as %s.\", count, modifedFile, deltaFile); } }finally { Measurement.purge(LogLevel.warning); } } The output from my laptop shows it usually takes 2-3 seconds to identify all 1000 differences by comparing two JSONObjects with 275K leaf nodes. Comparing Two IJSONValues With Optional Instruction The IJSONValue deltaWith(IJSONValue other, String indexName) defined in IJSONValue accepts a String parameter to instruct how to compare: When indexName is null, then the JSONArrays would be converted to JSONObjects with their index as the names explicitly. Otherwise, when indexName is not null, then the positions of their elements would not affect how they are paired to compare: When indexName is \"\", that is also the default setting of JSONArray.defaultIndexName, would shows only the differences without their position information. When indexName is a String containing +, would not only shows the differences of paired elements with their indexes, but also shows the index differences of identical elements at different positions. Otherwise, only shows the differences of paired elements with their indexes. There are many unit tests created and one example is below: @Test public void compareTwoArrays_difSizeWithElementDifferences_returnNonEmpty(){ JSONArray array = new JSONArray(alice, bob, ellen); JSONArray array2 = new JSONArray( alice.withDelta(\"{\\\"age\\\":13,\\\"class\\\":\\\"7F\\\"}\"), ellen ); Logger.D(\"array2: %s\", array2); IJSONable delta1 = array.deltaWith(array2, \"\"); IJSONable delta2 = array2.deltaWith(array, \"index\"); IJSONable delta3 = array2.deltaWith(array, \"+pos\"); Logger.D(\"delta1: %s\\ndelta2: %s\\ndelta3: %s\", delta1, delta2, delta3); assertEquals(\"[{\\\"age\\\":[12,13],\\\"class\\\":[\\\"7N\\\",\\\"7F\\\"]},[{\\\"name\\\":\\\"Bob\\\",\\\"gender\\\":\\\"M\\\",\\\"age\\\":13,\\\"class\\\":\\\"7C\\\",\\\"scores\\\":{\\\"english\\\":76,\\\"science\\\":62,\\\"humanity\\\":62,\\\"math\\\":80},null]]\", delta1.toJSONString(null)); assertEquals(\"[{\\\"index\\\":[0,0],\\\"age\\\":[13,12],\\\"class\\\":[\\\"7F\\\",\\\"7N\\\"]},{\\\"-1\\\":null,\\\"1\\\":{\\\"name\\\":\\\"Bob\\\",\\\"gender\\\":\\\"M\\\",\\\"age\\\":13,\\\"class\\\":\\\"7C\\\",\\\"scores\\\":{\\\"english\\\":76,\\\"science\\\":62,\\\"humanity\\\":62,\\\"math\\\":80}}]\", delta2.toJSONString(null)); assertEquals(\"[{\\\"+pos\\\":[0,0],\\\"age\\\":[13,12],\\\"class\\\":[\\\"7F\\\",\\\"7N\\\"]},{\\\"+pos\\\":[1,2]},{\\\"-1\\\":null,\\\"1\\\":{\\\"name\\\":\\\"Bob\\\",\\\"gender\\\":\\\"M\\\",\\\"age\\\":13,\\\"class\\\":\\\"7C\\\",\\\"scores\\\":{\\\"english\\\":76,\\\"science\\\":62,\\\"humanity\\\":62,\\\"math\\\":80}}]\", delta3.toJSONString(null)); } Comparing Two Java Objects With jsonTuples Since Java Objects can be converted to JSON values by jsonTuples, and these JSON values can be compared to get their differences, there are two static methods defined in the Utilities.java to compare two Java objects directly: IJSONValue deltaWith(Object obj1, Object obj2, String indexKey): convert both Objects to IJSONValues, then get the delta with strategy identified by the indexKey. IJSONValue deltaWith(Object obj1, Object obj2): just a simplified version using the default JSONArray.defaultIndexName. The unit test below shows how it works: @Test public void testJsonify_withDifferentObjects_getRightIJSONValues(){ assertEquals(JSONValue.Null, Utilities.jsonify(null)); assertEquals(JSONValue.False, Utilities.jsonify(false)); assertEquals(new JSONString(\"string\"), Utilities.jsonify(\"string\")); assertEquals(33.4, Utilities.jsonify(33.4).getObject()); Set&lt;Object&gt; complexSet = new LinkedHashSet&lt;&gt;(Arrays.asList( new Character[]{'a', 'b'}, true, new int[]{1, 2}, new double[][]{new double[]{-1.2, 0}, new double[]{3.3}, new Object[]{\"OK\", null})); JSONArray array = (JSONArray) Utilities.jsonify(complexSet); Object object = array.getObject(); assertEquals(new Object[] { new Object[]{\"a\", \"b\"}, true, new Object[]{1, 2}, new Object[]{new Object[]{-1.2, 0d}, new Object[]{3.3}, new Object[]{\"OK\", null}, object); Map&lt;String, Object&gt; map = new LinkedHashMap&lt;&gt;(); map.put(\"purpose\", \"test\"); map.put(\"array\", array); map.put(\"other\", null); JSONObject jsonObject = (JSONObject)Utilities.jsonify(map); assertEquals(\"{\\\"purpose\\\":\\\"test\\\",\\\"array\\\":[[\\\"a\\\",\\\"b\\\"],true,[1,2],[[-1.2,0.0],[3.3]],[\\\"OK\\\",null]],\\\"other\\\":null}\", jsonObject.toJSONString(null)); } Conclusion As a conclusion, the following objects have been met: Defines limited JSON classes to enable JSON string processing as outlined in json.org, especially JSONObject and JSONArray. Parses big JSON text block and saves the contents as JSONObject/ JSONArray that are immutable. Serialize JSONObject/JSONArray to JSON text in some different formats. Sort the orders of JSONObject elements with StringComparator recursively to get JSON texts of unified forms. Convert a Collection or Array to/from JSONArray, or a Map&lt;String,Object&gt; to/from JSONObject with immutable Tuples to keep the data. The JSON values, like JSONObject and JSONArray, can be converted to modifiable Map&lt;String,Object&gt; or ArrayList for CRUD. The JSON values can be used as media to compare Java Objects to get their minimum differences as another JSON Object. For example, find out the differences between an Array and a Set whose elements may or may not be consistent. Some desirable features are not included: Mapping Java classes to/from JSON as GSON or Jackson is not supported in the current version. When converting JSONObject/JSONArray to a customized Map or Collection, they would be mapped to LinkedHashMap and ArrayList for modifications. Expressions to locate the element of JSON, like JsonPath, are not supported yet. For me, working out this library is a really challenging and rewarding experience. I hope this can help you to solve some real problems associated with JSON, and even data analysis.",
                    "mainEntityOfPage": {
                      "@type": "WebPage",
                      "@id": "https://dzone.com/articles/jsontuples-json-parser-and-comparator-in-java"
                    },
                    "image": {
                      "@type": "ImageObject",
                      "url": "https://dzone.com//dz2cdn3.dzone.com/storage/article-thumb/12243434-thumb.jpg"
                    }
                  }
                </script>

                  <script type="application/ld+json">
                    {
                      "@context": "https://schema.org",
                      "@type": "BreadcrumbList",
                      "itemListElement": [{
                        "@type": "ListItem",
                        "position": 1,
                        "name": "DZone",
                        "item": "https://dzone.com"
                      }, {
                        "@type": "ListItem",
                        "position": 2,
                        "name": "Java Zone",
                        "item": "https://dzone.com/java-jdk-development-tutorials-tools-news"
                      }, {
                        "@type": "ListItem",
                        "position": 3,
                        "name": "jsonTuples: JSON Parser and Comparator in Java",
                        "item": "https://dzone.com/articles/jsontuples-json-parser-and-comparator-in-java"
                      }]
                    }
                  </script>

            <article>
              <div class="content">
                <div class="header">
                  <div class="col-xs-12 breadcrumb-padding">
                    <a href="/">DZone</a>
                    >
                      <a href="/java-jdk-development-tutorials-tools-news">Java Zone</a>
                      >
                      <a href="#">jsonTuples: JSON Parser and Comparator in Java</a>
                  </div>


                  <div class="header-title">
                    <div class="title">
                      <h1 class="article-title">jsonTuples: JSON Parser and Comparator in Java</h1>
                    </div>

                    <div class="subhead">
                      <h3>Learn more about the jsonTuples library that can parse JSON text to immutable values.</h3>
                    </div>

                    <div class="publish-meta">
                        <div class="article-author-meta">
                          <img src="https://secure.gravatar.com/avatar/3794880a04ddde001f92905870d1ae00?d=identicon&r=PG" class="avatar" alt="William JIANG user avatar" width="40">
                          by

                          <div class="author-info">
                            <span class="author-name">
                              <a href="/users/3694239/williamj.html" rel="nofollow">William JIANG</a>
                            </span>
                          </div>




                          &middot;
                        </div>
                      <span class="author-date">
                        Jul. 26, 19
                      </span>
                      &middot;
                        <a href="/java-jdk-development-tutorials-tools-news" id="portal-name">
                          <span class="portal-name">Java Zone</span>
                        </a>
                      &middot;
                      <span>Tutorial</span>
                    </div>
                  </div>
                </div>

                <div class="author-n-useraction">
                  <div class="like action">
                    <div id="activity-like-icon" class="dz-like icon-thumbs-up">
                      <span class="action-label">
                        <span id="activity-like-text">Like</span>
                      </span>
                      <a href="#">
                        <span id="activity-like-counter">(4)</span>
                      </a>
                    </div>
                  </div>

                  <div class="action">

                    <button class="comment">
                      <i class="icon-comment"></i>
                      Comment
                      <span id="activity-comment-counter" class="comment-count"></span>
                    </button>
                  </div>

                  <div class="save action">
                    <div id="activity-save-icon" class="save icon-star-empty">
                      <span id="activity-save-text" class="action-label">Save</span>
                    </div>
                  </div>

                  <div class="tweet action">
                    <a id="tweet-link" href="" class="title" target="_blank">
                      <span><i class="icon-twitter"></i></span>
                      <span class="action-label">Tweet</span>
                    </a>
                  </div>

                  <div class="pull-right">
                    <div id="activity-view-container" class="article-views action">
                      <i class="icon-eye"></i> 38.56K
                      <span class="action-label">Views</span>
                    </div>
                  </div>
                </div>

                    <div class="signin-prompt">
                      <p>Join the DZone community and get the full member experience.</p>
                      <a id="article-signin-prompt" href="/static/registration.html">Join For Free</a>
                    </div>
                    <div class="arrow-down"></div>

                  <div id="top-bumper-container"></div>

                <div>
                  <div class="content-html"><p>The <code>jsonTuples</code> library parses JSON text to immutable JSON values, which can then be converted to List or Map for CRUD operations, and then back to JSON values. As a unique feature,&nbsp;<code>jsonTuples</code> can compare two JSON texts, or compare ANY two Java Objects to get their minimum deltas in seconds.</p>
<h2>Background</h2>
<p>Before this project, inspired with the concepts of the&nbsp;<a href="https://en.wikipedia.org/wiki/Functional_programming" target="_blank">functional programming paradigm</a>, another Java library,&nbsp;<a href="https://github.com/Cruisoring/functionExtensions" target="_blank">functionExtensions</a>,&nbsp;was published to <a href="https://github.com/Cruisoring/functionExtensions/tree/master/src/main/java/io/github/cruisoring/tuple" target="_blank">make data immutable</a>, <a href="https://github.com/Cruisoring/functionExtensions/tree/master/src/main/java/io/github/cruisoring/throwables" target="_blank">refer Java methods without caring if they throw Exceptions or not</a>, and enable complex business logic based on <a href="https://github.com/Cruisoring/functionExtensions/tree/master/src/main/java/io/github/cruisoring/repository" target="_blank">Map-based, run-time evaluation</a>.</p>
<p>When I tried to develop a prototype REST API testing framework by using JSON texts as templates to compose requests or match responses automatically, I found the JSON parsers available are either too complex to set up, or not fast or convenient enough to convert JSON to/from Java objects as I have expected. Considering the simplicity of JSON syntax, I tried to implement this JSON parser with a simplified class architecture over&nbsp;<code>Tuple</code> from the<strong>&nbsp;<code>functionExtensions</code> library</strong> to exploit the benefits of the pure function and immutable objects. Once the JSON parser was done, I tried to find a way to compare two JSON texts to get their minimum differences. Thankfully, this attempt turned out satisfactory by comparing two big Java objects in seconds to get the deltas.</p>
<h2>Getting Started</h2>
<p>Add the following dependency to your pom.xml:</p>
<pre><code lang="application/xml">&lt;dependency&gt;
    &lt;groupId&gt;io.github.cruisoring&lt;/groupId&gt;
    &lt;artifactId&gt;jsonTuples&lt;/artifactId&gt;
    &lt;version&gt;1.0.0&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
<p><br></p>
<p>Alternatively, you can get the package from Maven Central directly.</p>
<h2>Mapping Between JSON Values and Java Objects</h2>
<p>The <strong>JSON values</strong> here refers to classes/interfaces defined in the<code>jsonTuples</code> project. The Java objects refer to common Java types like <strong>primitive values or objects, as well as generic Map, Collection, and Arrays</strong>.</p>
<p>The&nbsp;<code>jsonTuples</code> is implemented based on the information from <a href="http://www.json.org/" target="_blank">json.org</a> with direct mappings between JSON values (or interfaces/classes defined in <em>jsonTuples</em>) and Java objects, as shown below:</p>
<table width="100%">
 <tbody>
  <tr>
   <td>Interfaces</td>
   <td>Classes</td>
   <td>Constants/Sub-Classes</td>
   <td>Java Equivalents</td>
   <td>JSON Sample</td>
   <td>Notes</td>
  </tr>
  <tr>
   <td>IJSONValue&lt;T&gt;</td>
   <td>JSONValue&lt;T&gt;</td>
   <td><p><strong>Null</strong></p></td>
   <td><em>null</em></td>
   <td>null</td>
   <td>"Null" is invalid</td>
  </tr>
  <tr>
   <td><br></td>
   <td><br></td>
   <td><p><strong>True</strong></p></td>
   <td><em>true</em></td>
   <td>true</td>
   <td><p>Case sensitive, thus <em>True</em> is not accepted</p></td>
  </tr>
  <tr>
   <td><br></td>
   <td><br></td>
   <td><p><strong>False</strong></p></td>
   <td><em>false</em></td>
   <td>false</td>
   <td>"False" is invalid</td>
  </tr>
  <tr>
   <td><br></td>
   <td><br></td>
   <td><p><strong>JSONString</strong></p></td>
   <td><em>String</em></td>
   <td><p>"A string"</p></td>
   <td><p>special chars like '\n' or '\t' would be trimmed by default</p></td>
  </tr>
  <tr>
   <td><br></td>
   <td><br></td>
   <td><p><strong>JSONNumber</strong></p></td>
   <td><p><em>Integer, BigInteger, Double, BigDecimal</em></p></td>
   <td>123.45e5</td>
   <td><p>the actual Object saved doesn't affect equals() which would compare by toString()</p></td>
  </tr>
  <tr>
   <td><p>IJSONValue&lt;<em>NamedValue</em>&gt;, <strong>Map&lt;String, Object&gt;</strong></p></td>
   <td><p><strong>JSONObject</strong></p></td>
   <td><br></td>
   <td><p>Map&lt;String, Object&gt;</p></td>
   <td><p>{"id":12,"name":"Tom"}</p></td>
   <td><p>JSONObject has implemented <strong>Map&lt;String, Object&gt;</strong>, the <strong>NamedValue</strong>is used internally</p></td>
  </tr>
  <tr>
   <td><p>IJSONValue&lt;<em>IJSONValue</em>&gt;, <strong>List&lt;Object&gt;</strong></p></td>
   <td><p><strong>JSONArray</strong></p></td>
   <td><br></td>
   <td><p>Object[] or Collection</p></td>
   <td><p>[null,true,1,"abc",{},[]]</p></td>
   <td><p>JSONArray can hold any number of IJSONValue</p></td>
  </tr>
 </tbody>
</table>
<p>All these types extend the generic <a href="https://github.com/Cruisoring/functionExtensions/blob/master/src/main/java/io/github/cruisoring/tuple/Tuple.java" target="_blank">Tuple</a> type and are thus immutable.</p>
<p>The major interface defined here is&nbsp;<code>IJSONValue</code> for any JSON values with solid meanings except <strong><a href="https://github.com/Cruisoring/JsonTuples/blob/master/src/main/java/jsonTuples/NamedValue.java" target="_blank">NamedValue</a></strong> that is similar to <em><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.Entry.html" target="_blank">Map.Entry</a></em> and used as building blocks of&nbsp;<code>JSONObject</code> by assigning a&nbsp;<code>JSONValue</code> with a name of &nbsp;<code>JSONString</code>.</p>
<p>Of the seven types represented by&nbsp;<code>IJSONValue</code>, the first five simple types (<code>Null</code>,&nbsp;<code>True</code>,&nbsp;<code>False</code>,&nbsp;<code>JSONString</code>,&nbsp;<code>JSONNumber</code>) are referred as leaf nodes since their Java counterparts cannot be split further, and while&nbsp;<code>JSONObject</code> and&nbsp;<code>JSONArray</code> contain zero to multiple of them, the&nbsp;<code>IJSONable.getLeafCount()</code> reflects how many leaf nodes it has by counting the occurrence of the first 5 simple types.</p>
<p>The two major JSON values are&nbsp;<code>JSONObject</code> and&nbsp;<code>JSONArray</code> that could be treated as Java<em>&nbsp;</em><code>Map&lt;String, Object&gt;</code><span id="_tmp_pre_24">&nbsp;</span> and &nbsp;<code>Collection&lt;Object&gt;</code> &nbsp;or &nbsp;<code>Object[]</code> naturally. Under the hood, the<code>JSONObject</code> retains the orders of its elements with&nbsp;<code>LinkedHashMap</code>.</p>
<h2>Parsing JSON Text and Consuming the Parsed JSON Values</h2>
<p>The&nbsp;<code>jsonTuples</code> can parse given JSON texts to any of the seven types<code>IJSONValues</code> in the above table. Then calling the <code>getObject()</code> or <code>asMutableObject()</code>would return the contained Java values as immutable or mutable Java objects for convenient processing.</p>
<h3>APIs Used to Parse JSON Text</h3>
<p>Constructors of all above JSON values in bold (<code>Null</code>,&nbsp;<code>True</code>,&nbsp;<code>False</code>,&nbsp;<code>JSONString</code>,&nbsp;<code>JSONNumber</code>,&nbsp;<code>JSONObject</code>, and&nbsp;<code>JSONArray</code>) are protected, and would be created by calling the following APIs:</p>
<ul>
 <li>The strict JSON Syntax checking is not activated by default.</li>
 <li>Static methods to parse a given&nbsp;<code>String</code> or part of a&nbsp;<code>CharSequence</code> to a specific type of&nbsp;<code>IJSONValue</code>:
  <ul>
   <li>&nbsp;<code>IJSONValue Parser.parse(CharSequence)</code>: generate&nbsp;<code>IJSONValue</code> based on the given JSON text content. If the JSON text is of right syntax, the&nbsp;<code>IJSONValue</code> result shall be cast to one of&nbsp;<code>Null</code>,&nbsp;<code>True</code>,&nbsp;<code>False</code>,&nbsp;<code>JSONString</code>,&nbsp;<code>JSONNumber</code>,&nbsp;<code>JSONObject</code>, or&nbsp;<code>JSONArray</code>.</li>
   <li>&nbsp;<code>JSONString.parseString(String jsonText)</code>: the given JSON text must be wrapped by a pair of quotation marks (").</li>
   <li>&nbsp;<code>JSONValue.parse(CharSequence, Range)</code>: expect and parse a part of the given JSON context as one of<strong>&nbsp;</strong><code>Null</code>,&nbsp;<code>True</code>,&nbsp;<code>False</code>,&nbsp;<code>JSONString</code>,&nbsp;<code>JSONNumber</code>.</li>
   <li>&nbsp;<code>JSONObject.parse(String valueString)</code>: expect the&nbsp;<code>valueString</code> is enclosed by '{' and '}', and cast the result of &nbsp;<code>Parser.parse()</code> to be&nbsp;<code>JSONObject</code>.</li>
   <li>&nbsp;<code>JSONArray.parse(String valueString)</code>: expect the&nbsp;<code>valueString</code> is enclosed by '[' and ']', and cast the result of &nbsp;<code>Parser.parse()</code> to be&nbsp;<code>JSONArray</code>.</li>
  </ul></li>
 <li>Static method &nbsp;<code>IJSONValue jsonify(Object object)</code> of <em>Utilities.java</em> is the only API used to convert Java Objects to JSON values defined in <em>jsonTuples</em>, it would check the type of the given object to call a method above. For types not covered above, by default, the &nbsp;<code>asJSONStringFromOthers(Object object)</code> would be called to generate a&nbsp;<code>JSONString</code>, but it is possible to inject serialization/de-serialization methods into &nbsp;<code>Utilities.classConverters</code> that is a &nbsp;<code>Map&lt;Class, Tuple2&gt;</code><span id="_tmp_pre_80">&nbsp;</span>where the value of a given class includes both serialization and de-serialization for a concerned type of object, then the serialization method would be called to convert the matched instance to its text equivalent.</li>
</ul>
<p>The above methods have multiple variations to accept optional arguments.</p>
<h3>Basic Example of Parsing JSON Text</h3>
<p>There is no config needed before calling the static methods. The unit test below shows how &nbsp;<code>IJSONValue Parser.parse(CharSequence)</code> can be used to parse different text to corresponding&nbsp;<code>IJSONValue</code> types.</p>
<pre><code lang="text/x-java">    @Test
    public void parseText_getRightIJSONValue() {
        //parse texts of null, true or false
        assertAllTrue(JSONValue.Null == Parser.parse(false, "null"));
        assertAllTrue(JSONValue.True == Parser.parse(false, "true"));
        assertAllTrue(JSONValue.False == Parser.parse(false, "false"));

        //text of a number to JSONNumber
        JSONNumber number = (JSONNumber) Parser.parse(false, " 12.345  ");
        assertEquals(12.345, number.getObject());

        //text enclosed by '""s would be parsed as JSONString
        JSONString string = (JSONString) Parser.parse(false, "  \" abc \n \t\"\r");
        assertEquals(" abc  ", string.getObject());

        //If JSONString.forbidUnescapedControls is set to false, then special characters like \n, \r would not be removed
        try {
            Revokable.register(() -&gt; JSONString.forbidUnescapedControls, v -&gt; JSONString.forbidUnescapedControls = v, false);
            string = (JSONString) Parser.parse(false, "  \" abc \n \t\"\r");
            assertEquals(" abc \n \t", string.getObject());
        }finally {
            Revokable.revokeAll();
        }

        //Map alike text would be parsed as JSONObject
        JSONObject object = (JSONObject) Parser.parse(false, 
                "{\"id\":123,\"name\":null,\"courses\":[\"English\", \"Math\", \"Science\"]}");
        assertEquals(123, object.get("id"));
        assertAllNull(object.get("name"));
        assertEquals(new Object[]{"English", "Math", "Science"}, object.get("courses"));

        //Array alike text would be parsed as JSONArray
        JSONArray array = (JSONArray) Parser.parse(false, "[1, null, true, \"abc\", [false, null], {\"id\":123}]");
        assertEquals(1, array.get(0));
        assertAllTrue(
                array.size() == 6,
                array.contains(null),
                array.containsAll(Arrays.asList(true, "abc"))
        );
        assertEquals(new Object[]{false, null}, array.get(4));
        Map mapAt5 = (Map)array.get(5);
        assertEquals(123, mapAt5.get("id"));
    }</code></pre>
<p><br></p>
<p>The &nbsp;<code>assertTrue()</code>and&nbsp;<code>assertEquals()</code>&nbsp; are helper methods added in <a href="https://github.com/Cruisoring/functionExtensions/blob/master/src/main/java/io/github/cruisoring/Asserts.java" target="_blank">Asserts.java of functionExtensions 2.1.0</a> to assert multiple expressions or compare elements of two Arrays or Collections.</p>
<p>The above test illustrates how&nbsp;<code>JSONObject</code> can be referred to as a <strong>&nbsp;<code>Map&lt;String,Object&gt;</code></strong> while&nbsp;<code>JSONArray</code> can refer its elements as a&nbsp;<code>List</code>. However, all WRITE operations on them would get &nbsp;<code>UnsupportedOperationException</code> due to the immutable nature inherited from&nbsp;<code>Tuple</code>.</p>
<h3>Parsing in Lenient or Strict Mode With Error Highlighted</h3>
<p>By assuming the JSON texts to be syntax correct, the Parser would work in lenient mode by default to get a bit higher throughput and neglect any errors that bring no ambiguities, as the unit test below:</p>
<pre><code lang="text/x-java">    @Test
    public void validateLenientParsing_withUnexpectedChars_ignoreIfNoConfusion() {
        assertEquals("{\"id\":222,\"name\":\"Alice\"}",
                Parser.parse(false, "XXX{\"id\"XXX:222, \"name\":\"Alice\"}").toJSONString(null));
        assertEquals("{\"id\":222,\"name\":\"Alice\"}",
                Parser.parse(false, "XXX{\"\":\"id\":222, \"name\":\"Alice\"}XXX").toJSONString(null));
        assertEquals("{\"id\":222,\"name\":\"Alice\"}",
                Parser.parse(false, "{XXX\"id\":222, XXX \"name\":\"Alice\"}").toJSONString(null));
        assertEquals("{\"id\":222,\"name\":\"Alice\"}",
                Parser.parse(false, "{\"id\":222,  \"name\":\"Alice\"}, null").toJSONString(null));
    }
</code></pre>
<p><br></p>
<p><em>Notice there are many illegal <strong>XXX</strong>s would be neglected when people can still "guess" out the intended content.</em></p>
<p>On the other hand, it is possible to enforce more strict syntax checking by calling &nbsp;<code>IJSONValue parse(boolean isStrictly, CharSequence jsonText)</code> with "<strong>isScritly</strong>=true" <em>(with a overhead of 1-5%)</em>, then the same JSON texts would cause errors thrown:</p>
<pre><code lang="text/x-java">    @Test
    public void validateStrictParsing_withUnexpectedChars_throwExceptions() {
        assertException(() -&gt; Parser.parse(true, "\"id\":\"id\":222, \"name\":\"Alice\"}"),
                NullPointerException.class, "COLON(':') shall only present in JSONObject");
        assertException(() -&gt; Parser.parse(true, "{\"id\":\"id\":222, \"name\":\"Alice\"}"),
                IllegalStateException.class, "Wrong state before COLON(':'): lastName=\"id\", lastStringValue=\"id\"");
        assertException(() -&gt; Parser.parse(true, "XXX{\"id\"XXX:222, \"name\":\"Alice\"}"),
                IllegalStateException.class, "Only white spaces are expected");
        assertException(() -&gt; Parser.parse(true, "{\"id\"XXX:222, \"name\":\"Alice\"}"),
                IllegalStateException.class, "Only white spaces are expected");
        assertException(() -&gt; Parser.parse(true, "{\"id\"\"\":222, \"name\":\"Alice\"}"),
                IllegalStateException.class, "two JSONStrings must be seperated by a control char");
        assertException(() -&gt; Parser.parse(true, "{\"id\":222, \"name\":\"Alice\"}xxx"),
                IllegalStateException.class, "Only white spaces are expected");
        assertException(() -&gt; Parser.parse(true, "{\"id\":222, , \"name\":\"Alice\"}"),
                IllegalStateException.class, "Missing value string");
    }
</code></pre>
<p><br></p>
<p>By changing the static variable of &nbsp;<code>Parser.PARSE_STRICTLY</code> to <strong>true</strong> to turn off the default lenient parsing, calling &nbsp;<code>IJSONValue parse(CharSequence jsonText)</code> would enforce the strict syntax checking automatically.</p>
<p><a href="https://github.com/Cruisoring/JsonTuples/blob/master/images/Parser.PARSE_STRICTLY.png" rel="noopener noreferrer" target="_blank"><img alt="Parser.PARSE_STRICTLY" class="fr-fin fr-dib lazyload" title="Static variables to change the default behaviours of Parser" data-src="https://github.com/Cruisoring/JsonTuples/raw/master/images/Parser.PARSE_STRICTLY.png"></a></p>
<p>When there is syntax errors found when parsing in either lenient or strict mode, the problematic text would be highlighted for further correction:</p>
<p><a href="https://github.com/Cruisoring/JsonTuples/blob/master/images/parsing_error_highlighted.png" rel="noopener noreferrer" target="_blank"><img alt="Paring errors highlighted" class="fr-fin fr-dib lazyload" title="Parsing the 3 JSON texts with syntax errors would fail with descriptive info of why and where it failed" data-src="https://github.com/Cruisoring/JsonTuples/raw/master/images/parsing_error_highlighted.png"></a></p>
<h3>Stringify JSON Values With Indent Instruction</h3>
<p>In the&nbsp;<code>IJSONable</code> interface that is the super interface of&nbsp;<code>IJSONValue</code>, the <strong>indent</strong> argument within&nbsp;&nbsp;<code>String toJSONString(String indent)</code> determines how to generate a string representation of an&nbsp;<code>IJSONValue</code> instance:</p>
<ul>
 <li>Empty String (<strong>""</strong>) would result in the common indented beautiful form that is easy to identify the layered structure of JSON elements, the "<code>toString()</code>" would produce the same things.</li>
 <li>&nbsp;<code>null&nbsp;</code>would produce the most condensed form: all SPACEs out of&nbsp;<code>JSONString</code> would be removed.</li>
 <li>Other String composed of WhiteSpaces (like " ") only would fill each lines of the&nbsp;<code>Strings</code> with the specified leading SPACEs.</li>
</ul>
<p>The unit test below shows how it works:</p>
<pre><code lang="text/x-java">    @Test
    public void toJSONString() {
        JSONObject obj = JSONObject.parse("{ \"age\": 123, \"other\": \"none\", \"name\": null }");
        assertEquals("{\"age\":123,\"other\":\"none\",\"name\":null}", obj.toJSONString(null));
        assertEquals("{\n  \"age\": 123,\n  \"other\": \"none\",\n  \"name\": null\n}", obj.toJSONString(""));
        assertEquals("{\n    \"age\": 123,\n    \"other\": \"none\",\n    \"name\": null\n  }", obj.toJSONString("  "));
        assertEquals("{\n      \"age\": 123,\n      \"other\": \"none\",\n      \"name\": null\n    }", obj.toJSONString("    "));
    }</code></pre>
<p><br></p>
<p><em>Since JSON texts representing Map or Array are used most, &nbsp;<code>JSONObject.parse(String valueString)</code> and &nbsp;<code>JSONArray.parse(String valueString)</code> act as syntactic sugar to cast the&nbsp;<code>IJSONValue</code> to&nbsp;<code>JSONObject</code> or&nbsp;<code>JSONArray</code> behind the scenes.</em></p>
<h3>Accessing Parsing Result as Java Objects</h3>
<p>As shown in the basic parsing example, the parsed&nbsp;<code>JSONArray</code> and&nbsp;<code>JSONObject</code> can be accessed as immutable <strong>&nbsp;<code>List&lt;Object&gt;</code><span id="_tmp_pre_130">&nbsp;</span></strong>and <strong><code>Map&lt;String, Object&gt;</code><span id="_tmp_pre_134">&nbsp;</span></strong>respectively by calling the &nbsp;<code>Object getObject()</code> defined in the&nbsp;<code>IJSONValue</code> interface, and the<strong>&nbsp;<code>Object</code>&nbsp;</strong>returned would composed by common Java objects (nulls, Booleans, Strings, Numbers, and combinations of them as Arrays or Maps), but they cannot be modified.</p>
<p>To perform CRUD operations, the<code>Object</code><strong>&nbsp;</strong><code>asMutableObject<strong>()</strong></code> of&nbsp;<code>IJSONValue</code> shall be called to get the modifiable versions like the example below suggested:</p>
<pre><code lang="text/x-java">    @Test
    public void testAsMutableObject_canBeUpdated() {
        JSONObject obj = JSONObject.parse("{ \"age\": 123, \"other\": \"none\", \"name\": null, \"members\":[\"Alice\", \"Bob\"] }");
        Map&lt;String, Object&gt; map = (Map&lt;String, Object&gt;)obj.asMutableObject();
        assertEquals(123, map.get("age"));
        assertEquals(null, map.get("name"));
        map.put("age", 23);
        map.remove("name");
        List members = (List)map.get("members");
        members.remove("Alice");
        members.add(0, "Alan");
        members.add("Carter");

        JSONObject updated = Utilities.asJSONObject(map);
        assertEquals("{\"age\":23,\"other\":\"none\",\"members\":[\"Alan\",\"Bob\",\"Carter\"]}", updated.toJSONString(null));
    }
</code></pre>
<p><br></p>
<p>At the end of the above codes, the &nbsp;<code>Utilities.asJSONObject(map)</code> would turn the Java Map to a&nbsp;<code>JSONObject</code> that might be suitable for big Java Objects. For small ones, as you can find from the unit tests of this project, I tend to initialize a Map or List by parsing a String, then calling&nbsp;<code>getObject()</code>&nbsp; would save some typings.</p>
<h3>Convert any Java Objects to IJSONValues</h3>
<p>As the above example illustrated, the &nbsp;<code>Utilities.asJSONObject(Object)</code> would convert a Java Map to a JSONObject, a more generic API is &nbsp;<code>IJSONValue jsonify(Object object)</code>. By default, it enables the following conversions in order:</p>
<ul>
 <li>Java&nbsp;<code>null</code> to &nbsp;<code>JSONValue.Null</code>;</li>
 <li>An&nbsp;<code>IJSONValue</code> instance to itself directly;</li>
 <li>Java <strong>true</strong>/<strong>false</strong> to <code>JSONValue.True</code> or <code>JSONValue.False</code> respectively;</li>
 <li>Java&nbsp;<code>String</code> Objects to&nbsp;<code>JSONString</code> Objects;</li>
 <li>Java&nbsp;<code>Number</code> Objects to&nbsp;<code>JSONNumber</code> Objects;</li>
 <li>Java&nbsp;<code>Map</code> to&nbsp;<code>JSONObject</code>;</li>
 <li>Java&nbsp;<code>Collection</code> or&nbsp;<code>Array</code> to&nbsp;<code>JSONArray</code>;</li>
 <li>For unknown types of Java Objects,&nbsp;<code>JSONString</code> would be used to represent their <code>toString()</code>.</li>
</ul>
<p>You might have noticed that converting unknown Java objects to their <code>toString()</code>s is not quite reasonable, that is mainly due to missing something like&nbsp;<code>AutoMapper</code> to serialize/deserialize Java classes to/from JSON Strings that is out of the scope of this project, but the following unit test shows how it can be supported if helper methods are defined:</p>
<pre><code lang="text/x-java">    public class Student{
        public String name;
        public int age;
        public Student(String name, int age){
            this.name = name;
            this.age = age;
        }
        public String toJSON() {
            return String.format("{\"name\":\"%s\", \"age\":%d}", name, age);
        }
    }

    @Test
    public void testJsonify_withStudentInstances(){
        FunctionThrowable&lt;Object, IJSONValue&gt; studentToJSON = student -&gt; Parser.parse(((Student)student).toJSON());
        Utilities.classConverters.put(Student.class, Tuple.create(studentToJSON, null));
        Map studentInClass = new HashMap(){{
            put("year", "Year7");
            put("active", true);
            put("students", Arrays.asList(
                    new Student("Alice", 12),
                    new Student("Bob", 13)
            ));
        }};
        assertEquals("{\"year\":\"Year7\",\"active\":true,\"students\":[{\"name\":\"Alice\",\"age\":12},{\"name\":\"Bob\",\"age\":13}]}",
                Utilities.jsonify(studentInClass).toJSONString(null));
    }
</code></pre>
<p><br></p>
<p>Though not in the scope of&nbsp;<code>jsonTuples</code>, if there is an&nbsp;<code>AutoMapper</code> alike library to parse the POJOs in your working projects, then it shall be quite convenient to handle literately any Java objects to and from JSON texts.</p>
<h3>Performance of jsonTuples</h3>
<p>Unlike other JSON parsers, the&nbsp;<code>jsonTuples</code> applies a simplified high-level state-machine to process the characters of JSON text under parsing in three steps:</p>
<ol>
 <li>Delimit the scopes of Strings enclosed by QUOTEs(<strong>"</strong>), and neglect any chars inside including the escaped QUOTEs that are behind of an opening (<strong>"</strong>) with BACK-SLASH(<strong>\</strong>) ahead, extract any &nbsp;<code>JSONString</code>s directly.</li>
 <li>Neglect all chars except control chars used in JSON (that is LEFT_BRACE('<strong>{</strong>'), RIGHT_BRACE('<strong>}</strong>'), LEFT_BRACKET('<strong>[</strong>'), RIGHT_BRACKET('<strong>]</strong>'), COMMA('<strong>,</strong>'), COLON('<strong>:</strong>')), perform strict syntax checking if needed.</li>
 <li>Only the above control chars would be fed into a state-machine to harvest the parsed results recursively with only the previous control char considered.</li>
</ol>
<p>Unless there is any syntax error encountered and then the Parser needs to revisit the start of the text causing the error, the processing of JSON text would hardly revisit the previous content before the last control, and even the control chars identified earlier would be consumed without evaluating for the second time.</p>
<p>When running the unit test below from my 4-cores i7-7700HQ @ 2.8G laptop to parse the 6.1M JSON text 10 times:</p>
<pre><code lang="text/x-java">    @Test
    public void test6104KJson() {
        String jsonText = ResourceHelper.getTextFromResourceFile("catalog.json");
        int jsonTextLength = jsonText.length();

        String sortedString = null;
        for (int i = 0; i &lt; 10; i++) {
            JSONObject result = Logger.M(Measurement.start("Parsing JSON text of %dk", jsonTextLength/1024),
                    () -&gt; (JSONObject) Parser.parse(false, jsonText));
            int leafCount = checkNotNull(result, "Failed to parse the JOSN text.").getLeafCount();
            IJSONValue sortedValue = Logger.M(Measurement.start("Sorting JSONObject with %d leaf nodes", leafCount),
                    () -&gt; result.getSorted(Comparator.naturalOrder()));
            sortedString = Logger.M(Measurement.start("ToJSONString(null)"), () -&gt; sortedValue.toJSONString(null));
        }
        Measurement.purge(LogLevel.warning);
    }
</code></pre>
<p><br></p>
<p>The screenshot below shows the average and max time to parse the 6.1M file are <strong><em>279ms and 306ms</em></strong> respectively: almost 20M/s throughput for such middle-sized JSON texts.</p>
<p><a href="https://github.com/Cruisoring/JsonTuples/blob/master/images/parse6M.png" rel="noopener noreferrer" target="_blank"><img alt="test6104KJson performance" class="fr-fin fr-dib lazyload" title="Parsing 6M JSON text for 10 times" data-src="https://github.com/Cruisoring/JsonTuples/raw/master/images/parse6M.png"></a></p>
<p>It is not so ideal when parsing huge JSON file. For the <a href="https://raw.githubusercontent.com/zemirco/sf-city-lots-json/master/citylots.json" target="_blank">181M JSON file</a>, if you save it as "C:\temp\citylots.json", then the following test:</p>
<pre><code lang="text/x-java">    @Test @Ignore
    public void test181MJson() {
        String jsonText = Logger.M(Measurement.start("Load JSON as String"), () -&gt; ResourceHelper.getTextFromResourceFile("c:/temp/citylots.json"));
        int jsonTextLength = jsonText.length();

        String sortedString = null;
        JSONObject result = Logger.M(Measurement.start("Parsing JSON text of %dk", jsonTextLength / 1024),
                () -&gt; (JSONObject)Parser.parse(true, jsonText));
        assertNotNull(result, "Failed to parse the JSON text.");
        Measurement.purge(LogLevel.warning);
    }
</code></pre>
<p><br></p>
<p>The logging shows it might take 2-4 seconds to process 1 Megabyte payload intermittently that might happen because of Java Garbage collections. Though running the same test from a slow PC with 8G memory only would crash the JVM when it took exponentially longer time to process 1 Megabytes after 100M, as shown in the [log](images/Parse 181M JSON from PC with 8G Mem.txt), the&nbsp;<code>jsonTuples</code> shall be responsive enough to handle JSON of normal sizes.</p>
<p><a href="https://github.com/Cruisoring/JsonTuples/blob/master/images/parse181M.png" rel="noopener noreferrer" target="_blank"><img alt="Parsing 181M Json outcome" class="fr-fin fr-dib lazyload" title="Parsing 181M JSON text" data-src="https://github.com/Cruisoring/JsonTuples/raw/master/images/parse181M.png"></a></p>
<h2>Comparing Two IJSONValues or Comparing Two Java Objects</h2>
<p>After implementing the parsing functions, I started to exploit the possibility of comparing two &nbsp;<code>IJSONValue</code> instances to show their differences. It turned out to be more difficult than implementing the parsing.</p>
<h3>Scenarios to Be Compared</h3>
<p>Actually, it is not always difficult, the combinations of <code>IJSONValue</code>s to be compared can be classified as the following scenarios:</p>
<ol>
 <li>Between simple&nbsp;<code>IJSONValue</code> types, namely&nbsp;<code>Null</code>,&nbsp;<code>True</code>,&nbsp;<code>False</code>,&nbsp;<code>JSONString</code>,&nbsp;<code>JSONNumber</code> that are also leaf nodes of composing any JSON content, comparing their&nbsp;<code>toString()</code> would be fair enough, so:
  <ul>
   <li>Thus &nbsp;<code>JSONNumber(null)</code>or<code>JSONString(null)</code>would be equal to <strong><code>JSONValue.Null</code></strong>.</li>
   <li>The &nbsp;<code>JSONNumber(Integer.valueOf(1))</code> would be equal to &nbsp;<code>JSONNumber(1L)</code>.</li>
  </ul></li>
 <li>Between different types of&nbsp;<code>IJSONValue</code>, like comparing a&nbsp;<code>JSONNumber</code> with a&nbsp;<code>JSONString</code>, or&nbsp;<code>JSONObject</code> vs&nbsp;<code>JSONArray</code>, then a&nbsp;<code>JSONArray</code> composed by these two&nbsp;<code>IJSONValue</code> instances would explain everything.</li>
 <li>Between two&nbsp;<code>JSONObject</code> instances, their names, like the keys of two Maps, can associate their entries easily to allow further comparisons of the corresponding values.</li>
 <li>Between two&nbsp;<code>JSONArray</code> instances, now comes the interesting part:
  <ul>
   <li>If the positions of their elements matter, then it is straight-forward like comparing two&nbsp;<code>JSONObject</code> instances with their positions as the implicit keys.</li>
   <li><em><strong>If the positions of their elements doesn't matter, then binding their elements to get the least difference sets before further comparing.</strong></em></li>
  </ul></li>
</ol>
<p>The first three and a half scenarios are quite simple and worth no discussions, but the last case of comparing two<strong>&nbsp;<code>JSONArray</code>&nbsp;</strong>instances when their orders are neglected is the real challenge, especially when both of them contain hundreds or thousands of similar elements. However, I believe it is also quite using when considering them as two Sets, or two Lists created from identical sets of elements when one of them get one or several elements in the middle removed.</p>
<h3>Immutable Tuples With Immutable hashCodes and Signatures</h3>
<p>The <a href="https://github.com/Cruisoring/functionExtensions/tree/master/src/main/java/io/github/cruisoring/tuple" target="_blank">Tuple classes defined in functionExtensions</a> are extended to summarize its contents as a set of Integers.</p>
<p>Since these strong-typed Objects whose constructors accept only arguments decorated with&nbsp;<code>final</code>, their elements shall be immutable with fixed orders <strong>IF</strong> extended properly, thus their and their children's hashCodes are also fixed thus can be buffered as&nbsp;<code>Set</code> that could be the least-cost items to be compared in Java.</p>
<p>A unit test shows how the &nbsp;<code>getSignatures()</code> inherited from&nbsp;<code>Tuple</code> can reveal the common points and potential differences of two&nbsp;<code>JSONObjects</code>:</p>
<pre><code lang="text/x-java">    @Test
    public void testGetSignatures() {
        String text = "{\"address\": null, \"scores\": {\"English\":80,\"Science\":88,\"Math\":90}, \"name\": \"test name\" ,\"id\" :123456, \"isActive\": true, \"class\": \"7A\"}";
        JSONObject object1 = JSONObject.parse(text);
        NamedValue address = object1.getValue(0);
        NamedValue scores = object1.getValue(1);
        NamedValue name = object1.getValue(2);
        NamedValue id = object1.getValue(3);
        NamedValue isActive = object1.getValue(4);
        NamedValue classNamedValue = object1.getValue(5);

        Set&lt;Integer&gt; signature1 = object1.getSignatures();
        Logger.I(object1.toJSONString(null));
        Logger.D("address: %s\tscores: %s\tname: %s\tid: %s\tisActive: %s\tclass: %s\n\tobject1: %s\n",
                address.hashCode(), scores.hashCode(), name.hashCode(), id.hashCode(), isActive.hashCode(), classNamedValue.hashCode(), deepToString(signature1));
        assertAllTrue(signature1.size() == 7,
                signature1.containsAll(Arrays.asList(object1.hashCode(), address.hashCode(), scores.hashCode(), name.hashCode(), id.hashCode(), isActive.hashCode(), classNamedValue.hashCode())));

        JSONObject object2 = object1.getSorted(Comparator.naturalOrder());
        Logger.I(object2.toJSONString(null));
        Set&lt;Integer&gt; signature2 = object2.getSignatures();
        NamedValue sortedScores = NamedValue.parse("\"scores\": {\"English\":80,\"Math\": 90,\"Science\": 88}");
        Logger.D("address: %s\tsortedScores: %s\tname: %s\tid: %s\tisActive: %s\tclass: %s\n\tobject2: %s\n",
                address.hashCode(), sortedScores.hashCode(), name.hashCode(), id.hashCode(), isActive.hashCode(), classNamedValue.hashCode(), deepToString(signature2));
        assertAllTrue(signature2.size() == 7,
                signature2.containsAll(Arrays.asList(object2.hashCode(), address.hashCode(), name.hashCode(), id.hashCode(), isActive.hashCode(), classNamedValue.hashCode())),
                signature2.contains(sortedScores.hashCode()));
    }
</code></pre>
<p><br></p>
<p>Its output is marked with different colors to highlight why it is called signatures:</p>
<p><a href="https://github.com/Cruisoring/JsonTuples/blob/master/images/signatures.png" rel="noopener noreferrer" target="_blank"><img alt="Signatures of 2 JSONObjects" class="fr-fin fr-dib lazyload" title="Signatures of 2 JSONObjects with elements of different orders" data-src="https://github.com/Cruisoring/JsonTuples/raw/master/images/signatures.png"></a></p>
<p>The&nbsp;<code>object1</code> and&nbsp;<code>object2</code> share same set of&nbsp;<code>NamedValues</code> except the embedded&nbsp;<code>JSONObject</code> identified by&nbsp;<code>scores</code>, by comparing their signatures along, it is quite easy to see that pair of elements shall be compared together while other pairs identified by <em>address</em>, <em>name</em>, <em>id,</em> and <em>ect</em> would conclude as no differences quickly.</p>
<p>Checking the two pairs of <em>scores</em> <code>JSONObjects</code>, clearly they are referring to the same thing if defined as Java Maps, wasting time to compare these&nbsp;<code>JSONObject</code>s with the same elements of different orders would be a waste of time, that is why comes the sorting that is usually not supported by JSON Parsers.</p>
<h3>Sorting With StringComparator</h3>
<p>The<strong>&nbsp;<code>ISortable</code> &nbsp;<code>getSorted(Comparator)</code></strong> method inherited by&nbsp;<code>IJSONValue</code> wold re-arrange the elements of&nbsp;<code>JSONObject</code> with desirable orders, and it would also be used by the&nbsp;<code>JSONArray</code> to pass to all its children&nbsp;<code>JSONObjects</code>. Consequently, two&nbsp;<code>JSONObjects</code> or&nbsp;<code>JSONArrays</code> sharing the same <strong>&nbsp;<code>Comparator&lt;String</code></strong> to sorting the names of their&nbsp;<code>JSONObject</code> would represent their children of the same elements with identical signatures.</p>
<p>To ensure a preferred order or retain the original orders of the embedded&nbsp;<code>JSONObjects</code>, an&nbsp;<code>OrdinalComparator</code> can be constructed easily and supplied to either &nbsp;<code>Parser.parse(...)</code> or &nbsp;<code>IJSONValue.getSorted(Comparator)</code> to get&nbsp;<code><strong>array3</strong></code>, which would be shown as:</p>
<pre><code lang="text/x-java">    @Test
    public void getSortedWithOrderedNames() {
        JSONObject obj = JSONObject.parse("{ \"age\": 123, \"name\": null, \"other\": \"none\" }");
        JSONObject naturalOrdered = (JSONObject) obj.getSorted("name", "other");
        String string = naturalOrdered.toString();
        assertEquals("{\n" +
                "  \"name\": null,\n" +
                "  \"other\": \"none\",\n" +
                "  \"age\": 123\n" +
                "}", string);

        JSONObject naturalReversed = obj.getSorted(naturalOrdered.nameComparator.reversed());
        string = naturalReversed.toString();
        assertEquals("{\n" +
                "  \"age\": 123,\n" +
                "  \"other\": \"none\",\n" +
                "  \"name\": null\n" +
                "}", string);
    }
</code></pre>
<p><br></p>
<h3>Get the Least Different Pairs When Orders Are Neglected</h3>
<p>To compare two&nbsp;<code>JSONArrays</code> when their element's order doesn't matter, the logic behind would use the signatures to pair elements by finding out the least different pairs that is a quite complex procedure with acceptable performance.</p>
<p>The following test would load the 6M JSON file, change 1000 of its leaf nodes, then compare their differences for 10 times:</p>
<pre><code lang="text/x-java">    @Test @Ignore
    public void testDeltaWith_ofLargeObjects() {
        String jsonText = ResourceHelper.getTextFromResourceFile("catalog.json");
        int changes = 1000;
        int jsonTextLength = jsonText.length();
        JSONObject original = Logger.M(Measurement.start("Parse JSON of %dk", jsonTextLength/1024), () -&gt; JSONObject.parse(jsonText));
        int originalLeafCount = original.getLeafCount();

        try(Revokable revokable = Logger.setLevelInScope(LogLevel.debug)) {
            for (int i = 0; i &lt; 10; i++) {
                Map&lt;String, Object&gt; modifiableMap = (Map&lt;String, Object&gt;) Logger.M(Measurement.start("Get Modifiable Map"), () -&gt; original.asMutableObject());
                Object packagesList = modifiableMap.get("packages");

                Logger.M(Measurement.start("Modify %d leaf values", changes), () -&gt; modifyAndShuffle(packagesList, changes));

                Object shuffledArray = Logger.M(Measurement.start("Shuffle packages list as array"), () -&gt; ArrayHelper.shuffle(((List) packagesList).toArray()));
                modifiableMap.put("packages", shuffledArray);
                JSONObject modifiedObject = Logger.M(Measurement.start("jsonify() back to JSONObject"), () -&gt;(JSONObject) Utilities.jsonify(modifiableMap));
                int modifiedLeafCount = modifiedObject.getLeafCount();
                Logger.D("Save modified JSONObject with %d leaves to %s", modifiedLeafCount,
                        Logger.M(Measurement.start("save modified JSON"), () -&gt;ResourceHelper.saveTextToTargetFile(modifiedObject.toString(), "modified.json")));

                IJSONValue delta = Logger.M(Measurement.start("deltaWith() between Object with %d leafs and another with %d leafs", originalLeafCount, modifiedLeafCount),
                        () -&gt; original.deltaWith(modifiedObject, "pos"));
                assertNotNull(delta, "Failed to get result.");
                String deltaString = delta.toString();
                Matcher matcher = Pattern.compile("changedValue\\d{3}").matcher(deltaString);
                int count = 0;
                while (matcher.find()){
                    count++;
                }

                String timeStamp = DateTimeHelper.asString(LocalDateTime.now(), "MMddHHmmss");
                String modifedFile = ResourceHelper.saveTextToTargetFile(modifiedObject.toString(), String.format("modified%s.json", timeStamp));
                String deltaFile = ResourceHelper.saveTextToTargetFile(delta.toString(), String.format("delta%s.json", timeStamp));
                Logger.I("There are %d changed values found, the modified file is saved as %s, and delta is saved as %s.", count, modifedFile, deltaFile);
            }
        }finally {
            Measurement.purge(LogLevel.warning);
        }
    }
</code></pre>
<p><br></p>
<p>The output from my laptop shows it usually takes 2-3 seconds to identify all 1000 differences by comparing two &nbsp;<code>JSONObject</code>s with 275K leaf nodes.</p>
<p><a href="https://github.com/Cruisoring/JsonTuples/blob/master/images/deltaWith_performance.png" rel="noopener noreferrer" target="_blank"><img alt="Performance of comparing 2 JSONObjects" class="fr-fin fr-dib lazyload" title="Compare two JSONObjects with 275K leaves 10 times" data-src="https://github.com/Cruisoring/JsonTuples/raw/master/images/deltaWith_performance.png"></a></p>
<h3>Comparing Two IJSONValues With Optional Instruction</h3>
<p>The &nbsp;<code>IJSONValue deltaWith(IJSONValue other, String indexName)</code> defined in&nbsp;<code>IJSONValue</code> accepts a String parameter to instruct how to compare:</p>
<ul>
 <li>When&nbsp;<code>indexName</code> is <strong>null</strong>, then the&nbsp;<code>JSONArrays</code> would be converted to&nbsp;<code>JSONObjects</code> with their index as the names explicitly.</li>
 <li>Otherwise, when indexName is not <strong>null</strong>, then the positions of their elements would not affect how they are paired to compare:
  <ul>
   <li>When indexName is <strong>""</strong>, that is also the default setting of &nbsp;<code>JSONArray.defaultIndexName</code>, would shows only the differences without their position information.</li>
   <li>When&nbsp;<code>indexName</code> is a String containing <code>+</code>, would not only shows the differences of paired elements with their indexes, but also shows the index differences of identical elements at different positions.</li>
   <li>Otherwise, only shows the differences of paired elements with their indexes.</li>
  </ul></li>
</ul>
<p>There are many unit tests created and one example is below:</p>
<pre><code lang="text/x-java">    @Test
    public void compareTwoArrays_difSizeWithElementDifferences_returnNonEmpty(){
        JSONArray array = new JSONArray(alice, bob, ellen);
        JSONArray array2 = new JSONArray(
                alice.withDelta("{\"age\":13,\"class\":\"7F\"}"),
                ellen
        );
        Logger.D("array2: %s", array2);
        IJSONable delta1 = array.deltaWith(array2, "");
        IJSONable delta2 = array2.deltaWith(array, "index");
        IJSONable delta3 = array2.deltaWith(array, "+pos");
        Logger.D("delta1: %s\ndelta2: %s\ndelta3: %s", delta1, delta2, delta3);

        assertEquals("[{\"age\":[12,13],\"class\":[\"7N\",\"7F\"]},[{\"name\":\"Bob\",\"gender\":\"M\",\"age\":13,\"class\":\"7C\",\"scores\":{\"english\":76,\"science\":62,\"humanity\":62,\"math\":80}},null]]",
                delta1.toJSONString(null));
        assertEquals("[{\"index\":[0,0],\"age\":[13,12],\"class\":[\"7F\",\"7N\"]},{\"-1\":null,\"1\":{\"name\":\"Bob\",\"gender\":\"M\",\"age\":13,\"class\":\"7C\",\"scores\":{\"english\":76,\"science\":62,\"humanity\":62,\"math\":80}}}]",
                delta2.toJSONString(null));
        assertEquals("[{\"+pos\":[0,0],\"age\":[13,12],\"class\":[\"7F\",\"7N\"]},{\"+pos\":[1,2]},{\"-1\":null,\"1\":{\"name\":\"Bob\",\"gender\":\"M\",\"age\":13,\"class\":\"7C\",\"scores\":{\"english\":76,\"science\":62,\"humanity\":62,\"math\":80}}}]",
                delta3.toJSONString(null));
    }
</code></pre>
<p><br></p>
<h3>Comparing Two Java Objects With jsonTuples</h3>
<p>Since Java Objects can be converted to JSON values by&nbsp;<code>jsonTuples</code>, and these JSON values can be compared to get their differences, there are two static methods defined in the <a href="https://github.com/Cruisoring/JsonTuples/blob/master/src/main/java/jsonTuples/Utilities.java" target="_blank">Utilities.java</a> to compare two Java objects directly:</p>
<ul>
 <li>&nbsp;<code>IJSONValue deltaWith(Object obj1, Object obj2, String indexKey)</code>: convert both Objects to&nbsp;<code>IJSONValues</code>, then get the delta with strategy identified by the&nbsp;<code>indexKey</code>.</li>
 <li>&nbsp;<code>IJSONValue deltaWith(Object obj1, Object obj2)</code>: just a simplified version using the default &nbsp;<code>JSONArray.defaultIndexName</code>.</li>
</ul>
<p>The unit test below shows how it works:</p>
<pre><code lang="text/x-java">    @Test
    public void testJsonify_withDifferentObjects_getRightIJSONValues(){
        assertEquals(JSONValue.Null, Utilities.jsonify(null));
        assertEquals(JSONValue.False, Utilities.jsonify(false));
        assertEquals(new JSONString("string"), Utilities.jsonify("string"));
        assertEquals(33.4, Utilities.jsonify(33.4).getObject());

        Set&lt;Object&gt; complexSet = new LinkedHashSet&lt;&gt;(Arrays.asList( new Character[]{'a', 'b'}, true, new int[]{1, 2},
                new double[][]{new double[]{-1.2, 0}, new double[]{3.3}}, new Object[]{"OK", null}));
        JSONArray array = (JSONArray) Utilities.jsonify(complexSet);
        Object object = array.getObject();
        assertEquals(new Object[] { new Object[]{"a", "b"}, true, new Object[]{1, 2},
                new Object[]{new Object[]{-1.2, 0d}, new Object[]{3.3}}, new Object[]{"OK", null}}, object);

        Map&lt;String, Object&gt; map = new LinkedHashMap&lt;&gt;();
        map.put("purpose", "test");
        map.put("array", array);
        map.put("other", null);
        JSONObject jsonObject = (JSONObject)Utilities.jsonify(map);
        assertEquals("{\"purpose\":\"test\",\"array\":[[\"a\",\"b\"],true,[1,2],[[-1.2,0.0],[3.3]],[\"OK\",null]],\"other\":null}",
                jsonObject.toJSONString(null));
    }
</code></pre>
<h2>Conclusion</h2>
<p>As a conclusion, the following objects have been met:</p>
<ul>
 <li>Defines limited JSON classes to enable JSON string processing as outlined in <a href="http://www.json.org/" target="_blank">json.org</a>, especially&nbsp;<code>JSONObject</code> and&nbsp;<code>JSONArray</code>.</li>
 <li>Parses big JSON text block and saves the contents as &nbsp;<code>JSONObject</code>/&nbsp;<code>JSONArray</code> that are immutable.</li>
 <li>Serialize<strong>&nbsp;<code>JSONObject</code>/<code>JSONArray</code><span id="_tmp_pre_232">&nbsp;</span></strong>to JSON text in some different formats.</li>
 <li>Sort the orders of&nbsp;<code>JSONObject</code> elements with&nbsp;<code>StringComparator</code> recursively to get JSON texts of unified forms.</li>
 <li>Convert a Collection or Array to/from&nbsp;<code>JSONArray</code>, or a &nbsp;<code>Map&lt;String,Object&gt;</code><span id="_tmp_pre_240">&nbsp;</span> to/from&nbsp;<code>JSONObject</code> with immutable&nbsp;<code>Tuples</code> to keep the data.</li>
 <li>The JSON values, like&nbsp;<code>JSONObject</code> and&nbsp;<code>JSONArray</code>, can be converted to modifiable &nbsp;<code>Map&lt;String,Object&gt;</code><span id="_tmp_pre_248">&nbsp;</span> or&nbsp;<code>ArrayList</code> for CRUD.</li>
 <li>The JSON values can be used as media to compare Java Objects to get their minimum differences as another JSON Object. For example, find out the differences between an&nbsp;<code>Array</code> and a&nbsp;<code>Set</code> whose elements may or may not be consistent.</li>
</ul>
<p>Some desirable features are not included:</p>
<ul>
 <li>Mapping Java classes to/from JSON as <a href="https://github.com/google/gson" target="_blank">GSON</a> or <a href="https://github.com/FasterXML/jackson" target="_blank">Jackson</a> is not supported in the current version.</li>
 <li>When converting&nbsp;<code>JSONObject</code>/<code>JSONArray</code><span id="_tmp_pre_254">&nbsp;</span>to a customized Map or Collection, they would be mapped to&nbsp;<code>LinkedHashMap</code> and&nbsp;<code>ArrayList</code> for modifications.</li>
 <li>Expressions to locate the element of JSON, like <a href="https://github.com/json-path/JsonPath" target="_blank">JsonPath</a>, are not supported yet.</li>
</ul>
<p>For me, working out this library is a really challenging and rewarding experience.</p>
<p>I hope this can help you to solve some real problems associated with JSON, and even data analysis.</p></div>
                </div>

                  <div id="bottom-bumper-container"></div>
                  <div class="article-tag-pill-container">
                      <span class="article-tag-pill">JSON</span>
                      <span class="article-tag-pill">Java (programming language)</span>
                      <span class="article-tag-pill">unit test</span>
                      <span class="article-tag-pill">Object (computer science)</span>
                      <span class="article-tag-pill">Parser (programming language)</span>
                      <span class="article-tag-pill">Element</span>
                  </div>

                  <div class="attribution">
                      <p>Published at DZone with permission of <span>William JIANG</span>.
                        <span>
                          <a href="https://github.com/Cruisoring/JsonTuples" target="_blank">See the original article here.
                            <i class="icon-link-ext-alt"></i>
                          </a>
                        </span>
                      </p>
                    <p>Opinions expressed by DZone contributors are their own.</p>
                  </div>

                    <div class="related">
                      <h3>Popular on DZone</h3>
                        <ul>
                            <li class="relateddiv">
                              <a href="/articles/adding-authentication-to-a-web-application-with-au?fromrel=true">Adding Authentication to a Web Application with Auth0, React, and JWT</a>
                            </li>
                            <li class="relateddiv">
                              <a href="/articles/11-best-practices-to-do-functional-testing-on-the?fromrel=true">11 Best Practices to Do Functional Testing on the Cloud</a>
                            </li>
                            <li class="relateddiv">
                              <a href="/articles/how-to-design-a-crud-web-service-for-inheritable-e?fromrel=true">How to Design a CRUD Web Service for Inheritable Entity</a>
                            </li>
                            <li class="relateddiv">
                              <a href="/articles/refactoring-java-application-object-oriented-and-f?fromrel=true">Refactoring Java Application: Object-Oriented And Functional Approaches</a>
                            </li>
                        </ul>
                      </div>
<div class="comments-overlay"></div>
<div id="comment-box">
  <div class="comment-box-wrapper">
    <div id="comment-input-editor"></div>
  </div>
  <div class="info hidden"></div>
  <div class="comments-content">
    <div class="comment-header">
      <hr />
      <span class="icon-comment">
        <span class="numOfComments"></span> Comments
      </span>
    </div>
    <div class="comments"></div>
  </div>
</div>
            </article>
          </div>

            <div id="above-pr-ad" class="bottom-ad-container">
              <div id="div-gpt-ad-1435246566686-11" data-gpt-slot="bottom"></div>
            </div>
            <div class="layout-card widget-top-border partner-resources-block" style="width:100%; margin-bottom: 1em;">
              <div class="main-container">
                <div class="featured-header">
                  <h2>
                      Java<span> Partner Resources</span>
                  </h2>
                </div>
                <div class="partner-resources-container">
                  <div id="div-gpt-ad-1435246566686-5" class="resource-block" data-gpt-slot="partner" data-gpt-position="pr1"></div>
                  <div id="div-gpt-ad-1435246566686-6" class="resource-block" data-gpt-slot="partner" data-gpt-position="pr2"></div>
                  <div id="div-gpt-ad-1435246566686-7" class="resource-block" data-gpt-slot="partner" data-gpt-position="pr3"></div>
                </div>
              </div>
            </div>
        </div>
      </div>
    </div>
  </div>

    <div id="bsa-parent" class="bottom-sticky-ad-container hide">
      <div class="container">
        <div class="col-md-9">
          <div class="fixed-bottom-div">
            <div class="inline-block">
              <div id="div-gpt-ad-1635294790718-12" data-gpt-desktop="true" class="bottom-sticky-ad"></div>
            </div>
            <div class="inline-block">
              <span id="close" class="bottom-sticky-ad-close-button" onclick="removeBottomStickyAd()">
                X
              </span>
            </div>
          </div>
        </div>
      </div>
    </div>

  <div class="modal fade bd-example-modal-lg" id="modal-message" tabindex="-1" role="dialog" aria-hidden="true">
    <div class="modal-dialog">
      <div class="modal-content">
        <div class="modal-header"></div>
        <div class="modal-body"></div>
      </div>
    </div>
  </div>
</div>

<script async>const articleTitle = 'jsonTuples: JSON Parser and Comparator in Java'
const articleUrl = 'https://dzone.com/articles/jsontuples-json-parser-and-comparator-in-java'

const retweetLink = document.querySelector('#tweet-link')

function retweet(event) {
    event.preventDefault()
    event.stopPropagation()

    const twitter = 'https://twitter.com/intent/tweet'
    const params = '?text=' + encodeURIComponent(articleTitle) + '&url=' + articleUrl + '&ref=dzone.com&via=DZoneInc'
    const win = window.open(twitter + params, '_blank')
    win.focus()
}

retweetLink.addEventListener('click', retweet);

function showStatusMessage(options) {
  var modal = document.getElementById("modal-message");

  if(modal) {
    modal.classList.add(options.type);
    var modalBody = modal.querySelector(".modal-content .modal-body");
    var modalHeader = modal.querySelector(".modal-content .modal-header");

    modalHeader.innerText = options.header ? options.header : "";
    modalBody.innerText = options.body ? options.body : "" ;

    $(modal).modal("show");

    $(modal).on('hidden.bs.modal', function () {
      modal.classList.remove(options.type);
    });
  }
}

function showConfirmMessage(options) {
  var modal = document.getElementById("modal-message");

  if(modal) {
    modal.classList.add(options.type);
    var modalBody = modal.querySelector(".modal-content .modal-body");
    var modalHeader = modal.querySelector(".modal-content .modal-header");

    modalHeader.innerText = options.header ? options.header : "";
    modalBody.innerText = options.body ? options.body : "" ;

    if (options.textarea) {
      const textareaDiv = document.createElement('div')
      const textareaLabel = document.createElement('label')
      textareaLabel.setAttribute('for', 'modal-textarea')
      textareaLabel.innerText = options.textarea.label

      const textarea = document.createElement('textarea')
      textarea.id = 'modal-textarea'
      textarea.placeholder = (options.textarea.placeholder || '')
      textarea.setAttribute('rows', (options.textarea.rows || 3))
      textarea.classList.add('form-control', 'not-resizable')

      if (options.textarea.maxlength) {
        textarea.maxLength = options.textarea.maxlength
      }

      textareaDiv.appendChild(textareaLabel)
      textareaDiv.appendChild(textarea)
      modalBody.appendChild(textareaDiv)
    }

    var btnContainer = document.createElement("div");
    btnContainer.classList.add("btn-container");

    var noBtn = document.createElement("button");
    noBtn.innerText = options.noBtnText ? options.noBtnText : "No";
    noBtn.classList.add("no-btn");

    var yesBtn = document.createElement("button");
    yesBtn.innerText = options.yesBtnText ? options.yesBtnText : "Yes";
    yesBtn.classList.add("yes-btn");

    btnContainer.appendChild(noBtn);
    btnContainer.appendChild(yesBtn);

    modalBody.appendChild(btnContainer);

    $(modal).modal("show");

    $(noBtn).one("click", function() {
      $(modal).modal("hide");

      if(options.noCallback) {
        $(modal).one('hidden.bs.modal', function () {
          options.noCallback();
        });
      }
    });

    $(yesBtn).one("click", function() {
      $(modal).modal("hide");

      if(options.yesCallback) {
        $(modal).one('hidden.bs.modal', function () {
          options.yesCallback();
        });
      }
    });

    $(modal).on('hidden.bs.modal', function () {
      modal.classList.remove(options.type);
    });
  }
}
</script><link rel="stylesheet" media="all" href="https://dz2cdn1.dzone.com/themes/dz20/ftl/footer/styles.css">

<div id="ftl-footer">
  <div class="container-fluid footerOuter">
    <div class="row">
      <div class="col-md-12">
        <div class="container">
          <div class="row footer">
            <div class="col-md-12 footerWidget">
              <div class="row footerContainer footer">
                <div class="left col-xs-12 col-sm-7">
                  <div class="col-xs-12 social-media-icons footer-mobile">
                    <ul class="icons-only">
                      <li class="rss-icon" id="rss-footer-1">
                        <a href="/pages/feeds" target="_blank" rel="noreferrer noopener">
                          <i class="icon-rss-1"></i>
                        </a>
                      </li>
                      <li class="twitter-icon">
                        <a href="https://twitter.com/DZoneInc" target="_blank" rel="noreferrer noopener">
                          <i class="icon-twitter"></i>
                        </a>
                      </li>
                      <li class="facebook-icon">
                        <a href="https://www.facebook.com/DZoneInc" target="_blank" rel="noreferrer noopener">
                          <i class="icon-facebook-1"></i>
                        </a>
                      </li>
                      <li class="linkedin-icon">
                        <a href="https://www.linkedin.com/company/dzone/" target="_blank"
                           rel="noreferrer noopener">
                          <i class="icon-linkedin-1"></i>
                        </a>
                      </li>
                    </ul>
                  </div>

                  <div class="top-section col-xs-12">
                    <div class="col-xs-12 col-sm-6">
                      <p class="section-header">ABOUT US</p>
                      <ul class="link-group">
                        <li><a href="/pages/about" rel="noreferrer noopener">About DZone</a></li>
                        <li><a href="mailto:support@dzone.com" rel="noreferrer noopener">Send feedback</a></li>
                        <li><a href="https://careers.dzone.com/" target="_blank" rel="noreferrer noopener">Careers</a></li>
                          <li><a href="/sitemap" rel="noreferrer noopener">Sitemap</a></li>
                      </ul>
                    </div>
                    <div class="col-xs-12 col-sm-6">
                      <p class="section-header">ADVERTISE</p>
                      <ul class="link-group">
                        <li><a href="https://advertise.dzone.com" target="_blank" rel="noreferrer noopener">Advertise with DZone</a></li>
                      </ul>
                    </div>
                  </div>

                  <div class="bottom-section col-xs-12">
                    <div class="col-xs-12 col-sm-6">
                      <p class="section-header">CONTRIBUTE ON DZONE</p>
                      <ul class="bottom-top-list link-group">
                        <li><a href="/articles/dzones-article-submission-guidelines">Article Submission Guidelines</a></li>
                        <li><a href="/pages/mvb" rel="noreferrer noopener">MVB Program</a></li>
                        <li><a href="/pages/contribute" rel="noreferrer noopener">Become a Contributor</a></li>
                        <li><a href="/writers-zone" rel="noreferrer noopener">Visit the Writers' Zone</a></li>
                      </ul>

                      <p class="section-header">LEGAL</p>
                      <ul class="link-group">
                        <li><a href="/pages/tos" rel="noreferrer noopener">Terms of Service</a></li>
                        <li><a href="/pages/privacy" rel="noreferrer noopener">Privacy Policy</a></li>
                      </ul>
                    </div>
                    <div class="col-xs-12 col-sm-6">
                      <p class="section-header">CONTACT US</p>
                      <ul class="link-group">
                        <li>600 Park Offices Drive</li>
                        <li>Suite 300</li>
                        <li>Durham, NC 27709</li>
                        <li><a href="mailto:support@dzone.com" rel="noreferrer noopener">support@dzone.com</a></li>
                        <li><a href="tel:+19196780300" rel="noreferrer noopener">+1 (919) 678-0300</a></li>
                      </ul>
                    </div>
                  </div>
                </div>

                <div class="right col-xs-12 col-sm-5">

                  <p class="connect-text">Let's be friends:</p>
                  <div class="col-xs-12 social-media-icons footer-wide">
                    <ul class="icons-only">
                      <li class="rss-icon" id="rss-footer-1">
                        <a href="/pages/feeds" target="_blank" rel="noreferrer noopener">
                          <i class="icon-rss-1"></i>
                        </a>
                      </li>
                      <li class="twitter-icon">
                        <a href="https://twitter.com/DZoneInc" target="_blank" rel="noreferrer noopener">
                          <i class="icon-twitter"></i>
                        </a>
                      </li>
                      <li class="facebook-icon">
                        <a href="https://www.facebook.com/DZoneInc" target="_blank" rel="noreferrer noopener">
                          <i class="icon-facebook-1"></i>
                        </a>
                      </li>
                      <li class="linkedin-icon">
                        <a href="https://www.linkedin.com/company/dzone/" target="_blank"
                           rel="noreferrer noopener">
                          <i class="icon-linkedin-1"></i>
                        </a>
                      </li>
                    </ul>
                  </div>

                  <div class="col-xs-12 powered-by">
                    <p>DZone.com is powered by&nbsp;</p>
                    <a href="https://devada.com/answerhub/" rel="noreferrer noopener">
                      <img src=""
                           data-src="https://dz2cdn1.dzone.com/themes/dz20/images/answerhub_logo_white_footer.png"
                           width="150"
                           height="56"
                           class="lazyload"
                           alt="AnswerHub logo">
                    </a>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>
  <script async src="https://securepubads.g.doubleclick.net/tag/js/gpt.js"></script>

  <script async>
      (function(w, d, s, l, i) {
          w[l] = w[l] || [];
          w[l].push({'gtm.start': new Date().getTime(), event: 'gtm.js'});
          var f = d.getElementsByTagName(s)[0], j = d.createElement(s), dl = l != 'dataLayer' ? '&l=' + l : '';
          j.async = true;
          j.src = 'https://www.googletagmanager.com/gtm.js?id=' + i + dl;
          f.parentNode.insertBefore(j,f);
      })(window, document, 'script', 'dataLayer', 'GTM-K25QL22');
  </script>

  <script>
      window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
      ga('create', 'UA-410289-1', 'auto');
      ga('require', 'linkid', 'linkid.js');
      ga('require', 'GTM-TSD9TZP');
      ga('set', 'siteSpeedSampleRate', 25);
  </script>
  <script async src="https://www.google-analytics.com/analytics.js"></script>
  <script async>const analytics = {
    'dimension1': 'java',
    'dimension2': 'article/tutorial',
    'dimension3': '2019-07-26',
    'dimension4': '0',
    'dimension5': '',
    'dimension7': 'JSON, java, unit test, object, parser, element',
    'dimension8': 'WilliamJ',
    'dimension9': 'undefined',
    'dimension10': 'Contract'
}

if (window.ga) {
    Object.keys(analytics).forEach(function(key) {
        window.ga('set', key, analytics[key])
    })

    window.ga('send', 'pageview')
}</script>

  <script>
      !function (e, o, n, i) {
          if (!e) {
              e = e || {}, window.permutive = e, e.q = [];
              var t = function () {
                  return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, function (e) {
                      return (e ^ (window.crypto || window.msCrypto).getRandomValues(new Uint8Array(1))[0] & 15 >> e / 4).toString(16)
                  })
              };
              e.config = i || {}, e.config.apiKey = o, e.config.workspaceId = n, e.config.environment = e.config.environment || "production", (window.crypto || window.msCrypto) && (e.config.viewId = t());
              for (var g = ["addon", "identify", "track", "trigger", "query", "segment", "segments", "ready", "on", "once", "user", "consent"], r = 0; r < g.length; r++) {
                  var w = g[r];
                  e[w] = function (o) {
                      return function () {
                          var n = Array.prototype.slice.call(arguments, 0);
                          e.q.push({
                              functionName: o,
                              arguments: n
                          })
                      }
                  }(w)
              }
          }
      }(window.permutive, "bca90777-e088-4f2a-96c2-13ad18deeccc", "18ad0c5b-460c-4d19-a729-dc537805538f", {});
      window.googletag = window.googletag || {}, window.googletag.cmd = window.googletag.cmd || [], window.googletag.cmd.push(function () {
          if (0 === window.googletag.pubads().getTargeting("permutive").length) {
              var e = window.localStorage.getItem("_pdfps");
              window.googletag.pubads().setTargeting("permutive", e ? JSON.parse(e) : []);
              var o = window.localStorage.getItem("permutive-id");
              o && (window.googletag.pubads().setTargeting("puid", o), window.googletag.pubads().setTargeting("ptime", Date.now().toString())), window.permutive.config.viewId && window.googletag.pubads().setTargeting("prmtvvid", window.permutive.config.viewId), window.permutive.config.workspaceId && window.googletag.pubads().setTargeting("prmtvwid", window.permutive.config.workspaceId)
          }
      });


      permutive.addon('web', {
          'page': {
              'category': 'Java',
              'node': {
                  'authorCompany': 'Contract',
                  'authors': [3694239, ],
                  'publishDate': new Date(1564099200000),
                  'sponsorAuthor': false,
                  'tags': ['JSON', 'java', 'unit test', 'object', 'parser', 'element', ],
                  'title': 'jsonTuples: JSON Parser and Comparator in Java',
                  'type': 'article',
              },
              'section': 'article',
          }
      });
  </script>
  <script async src="https://18ad0c5b-460c-4d19-a729-dc537805538f.edge.permutive.app/18ad0c5b-460c-4d19-a729-dc537805538f-web.js"></script>

  <script>
      const csrf = '-8940263678410219163'
      const articleId = 2815633
      const likes = 4
      const assetDomain = 'https://dz2cdn1.dzone.com'
      const codemirrorVars = {
          modeURI: 'https://dz2cdn1.dzone.com/themes/dz20/lib/codemirror/mode/',
          requiredScripts: [
              'https://dz2cdn1.dzone.com/themes/dz20/lib/codemirror/lib/codemirror.js',
              'https://dz2cdn1.dzone.com/themes/dz20/lib/codemirror/mode/meta.js'
          ]
      }

      const gptTags = {
          'zone': 'java',
          'topicTag': 'JSON,java,unit test,object,parser,element',
          'company': '',
          'siteSection': 'Zones',
          'articleCategory': 'tutorial',
          'nodeID': '2815633',
          'authorID': '3694239',
          'publishYear': '2019',
          'publishMonth': '07',
          'jobRole': '',
          'companySize': ''
      }

      const minCommentChar = 10;
      const peer39Enabled = true;
  </script>

  <script src="https://dz2cdn1.dzone.com/themes/dz20/lib/static/jquery/jquery.min.js"></script>
  <script async src="https://dz2cdn1.dzone.com/themes/dz20/lib/static/bootstrap/bootstrap.min.js"></script>
  <script async src="https://dz2cdn1.dzone.com/themes/dz20/ftl/article/ads.js"></script>



  <script>
      function loadScript(src) {
          return new Promise(function (resolve, reject) {
              const s = document.createElement('script')
              s.src = src
              s.onload = resolve
              s.onerror = reject
              document.head.appendChild(s)
          })
      }

      function loadStyle(href) {
          const link = document.createElement('link')
          link.rel = 'stylesheet'
          link.href = href
          document.head.appendChild(link)
      }

      function loadScriptsSync(deferred) {
          var p = Promise.resolve()
          for (var i = 0; i < deferred.length; i++) {
              let script = deferred[i]
              p = p.then(function() {
                  return loadScript(script)
              })
          }
          return p
      }

      function loadStyles() {
          const deferred = [
              'https://dz2cdn1.dzone.com/themes/dz20/lib/codemirror/lib/codemirror.css',
              'https://dz2cdn1.dzone.com/themes/dz20/ftl/comments/styles.css',
              'https://dz2cdn1.dzone.com/themes/dz20/lib/froala3/css/froala_editor.pkgd.min.css',
              'https://dz2cdn1.dzone.com/themes/dz20/lib/froala3/css/themes/gray.min.css',
              'https://dz2cdn1.dzone.com/themes/dz20/ftl/article/mini-profile.css'
          ]

          for (var i = 0; i < deferred.length; i++) {
              loadStyle(deferred[i])
          }
      }

      window.addEventListener('load', function(event) {
          loadStyles()
          loadScriptsSync([
              'https://dz2cdn1.dzone.com/themes/dz20/ftl/header/auth-status.js',
              'https://dz2cdn1.dzone.com/themes/dz20/lib/lazysizes.min.js',
              'https://dz2cdn1.dzone.com/themes/dz20/ftl/article/codeblocks.js',
              'https://dz2cdn1.dzone.com/themes/dz20/ftl/article/activity-bar.js',
              'https://dz2cdn1.dzone.com/themes/dz20/lib/froala3/js/froala_editor.pkgd.min.js',
              'https://dz2cdn1.dzone.com/themes/dz20/ftl/froala/content.js',
              'https://dz2cdn1.dzone.com/themes/dz20/ftl/comments/content.js',
              'https://dz2cdn1.dzone.com/themes/dz20/ftl/article/content.js'
          ])
      })
  </script>
</body>
</html>