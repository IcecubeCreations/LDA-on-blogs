<!DOCTYPE html><html class="has-navbar-fixed-top" lang="de" xmlns:og="http://ogp.me/ns#" xmlns:fb="http://www.facebook.com/2008/fbml" xmlns:exslt="http://exslt.org/common"><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-5735649-9', 'auto');
ga('set', 'anonymizeIp', true);
ga('send', 'pageview');</script><title>ActiveMQ, Qpid, HornetQ und RabbitMQ im Vergleich</title><meta http-equiv="content-type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="keywords" content=""><meta name="description" content="Gro&szlig;er Vergleich der Enterprise Message Broker. Betrachtet werden Protokolle, Performanz und Architektur."><meta name="language" content="de"><meta name="geo.region" content="DE-NRW"><meta name="geo.placename" content="Bonn"><link href="/sh2/styles/shCore.css" rel="stylesheet" type="text/css"><link href="/sh2/styles/shThemePredic8.css" rel="stylesheet" type="text/css"><script src="/sh2/scripts/shCore.js" type="text/javascript"></script><script src="/sh2/scripts/shBrushJScript.js" type="text/javascript"></script><script src="/sh2/scripts/shBrushCSharp.js" type="text/javascript"></script><script src="/sh2/scripts/shBrushSql.js" type="text/javascript"></script><script src="/sh2/scripts/shBrushXml.js" type="text/javascript"></script><script src="/sh2/scripts/shBrushJava.js" type="text/javascript"></script><script type="text/javascript">SyntaxHighlighter.all();</script><link rel="stylesheet" href="/b.css"><script type="application/ld+json">
            {
            "@context": "http://schema.org",
            "@type": "Article",
            "url" : "https://www.predic8.de/activemq-hornetq-rabbitmq-apollo-qpid-vergleich.htm",
            "mainEntityOfPage": {
                "@type": "WebPage",
                "@id": "https://www.predic8.de/activemq-hornetq-rabbitmq-apollo-qpid-vergleich.htm"
            },
            "headline": "ActiveMQ, Qpid, HornetQ und RabbitMQ im Vergleich" ,
            "image": [
            
                    "https://www.predic8.de/images/enterprise-message-broker.jpg"
                    
            ],
            "datePublished": "2013-01-17" ,
            "dateModified": "2018-07-06",
            
                    "author": {
                    "@type": "Person",
                    "name": "Thomas Bayer",
                    "url": "https://www.predic8.de/thomas-bayer.htm"
                    },
                
            "publisher": {
                "@type": "Organization",
                "name": "predic8 GmbH",
                "logo": {
                    "@type": "ImageObject",
                    "url": "https://www.predic8.de/bootstrap-theme1.6/img/colors/blue/logo_big.png"
                }
            },
            "description": "GroÃer Vergleich der Enterprise Message Broker. Betrachtet werden Protokolle, Performanz und Architektur."}
        </script><script language="JavaScript">document.addEventListener('DOMContentLoaded', function () { var $nb = Array.prototype.slice.call(document.querySelectorAll('.navbar-burger'), 0); if ($nb.length) { $nb.forEach(function ($el) { $el.addEventListener('click', function () { $el.classList.toggle('is-active'); document.getElementById($el.dataset.target).classList.toggle('is-active'); }); }); }});</script></head><body><nav id="navbar" class="navbar is-fixed-top"><div class="container"><div class="navbar-brand"><a class="navbar-item" href="/"><img src="/logo6.png" alt="predic8 GmbH" height="28"></a><div id="navbarBurger" class="navbar-burger burger" data-target="menu2"><span></span><span></span><span></span></div></div><div id="menu2" class="navbar-menu"><div class="navbar-start"><div class="navbar-item has-dropdown is-hoverable"><a href="/entwicklung/" class="navbar-link">Entwicklung</a><div class="navbar-dropdown"><a class="navbar-item" href="/branchen/">Branchen</a><a class="navbar-item" href="/entwicklung/sso-projekte.htm">SSO</a><a class="navbar-item" href="/entwicklung/web-services-enablement.htm">Schnittstellen</a><a class="navbar-item" href="/entwicklung/esb-einfuehrung.htm">ESB Einf&uuml;hrung</a><a class="navbar-item" href="/entwicklung/beispiel-web-services-clients.htm">Beispiel Clients</a></div></div><div class="navbar-item has-dropdown is-hoverable"><a href="/beratung/" class="navbar-link">Beratung</a><div class="navbar-dropdown"><a class="navbar-item" href="/anwendungsintegration-beratung-microservices.htm">Anwendungsintegration</a><a class="navbar-item" href="/api-review.htm">API Review</a></div></div><div class="navbar-item has-dropdown is-hoverable"><a href="/schulung/" class="navbar-link">Schulung</a><div class="navbar-dropdown"><a class="navbar-item" href="/webinar/">Webinare</a><a class="navbar-item" href="/schulung-microservices/">Microservices</a><a class="navbar-item" href="/schulung-integration/">Integration</a><a class="navbar-item" href="/schulung-rest-api/">REST APIs</a><a class="navbar-item" href="/schulung-big-data/">Big Data</a><a class="navbar-item" href="/schulung-soa-esb/">SOA</a><a class="navbar-item" href="/onsite-web-service-schulung.htm">Onsite</a><a class="navbar-item" href="/kursmaterial.htm">Kursmaterial</a><a class="navbar-item" href="/schulung/agbs.htm">AGBs</a><a class="navbar-item" href="/schulung/faq.html">Teilnahme FAQ</a><a class="navbar-item" href="/schulung-bewertung.htm">Bewertungen</a><a class="navbar-item" href="/schulung-termine.htm">Termine</a><a class="navbar-item" href="/schulung-termine-datum.htm">Termine nach Datum</a><a class="navbar-item" href="/schulung/raumanforderungen-fs-praxis.htm">Raumanforderungen</a></div></div><div class="navbar-item has-dropdown is-hoverable"><a href="/referenzen/" class="navbar-link">Referenzen</a><div class="navbar-dropdown"><a class="navbar-item" href="/fallstudien/">Fallstudien</a><a class="navbar-item" href="/referenzen/apps/">Apps</a><a class="navbar-item" href="/referenzen/soa/">SOA</a><a class="navbar-item" href="/mobile-app-entwicklung/apps/">Apps</a><a class="navbar-item" href="/referenzen/web20/">Web 2.0</a><a class="navbar-item" href="/referenzen/sonstiges/">Sonstiges</a></div></div><div class="navbar-item has-dropdown is-hoverable"><a href="/public/" class="navbar-link">Ver&ouml;ffentlichungen</a><div class="navbar-dropdown"><a class="navbar-item" href="/microservices/">Microservices</a><a class="navbar-item" href="/kubernetes-docker/">Kubernetes &amp; Docker</a><a class="navbar-item" href="/rest/">REST</a><a class="navbar-item" href="/security/">Security</a><a class="navbar-item" href="/integration/">Open Source Integration</a><a class="navbar-item" href="/mobile/">Mobile</a><a class="navbar-item" href="/enterprise/">Enterprise</a><a class="navbar-item" href="/iot/">IoT</a><a class="navbar-item" href="/javascript/">JavaScript</a><a class="navbar-item" href="/soa/">SOA &amp; Web Services</a><a class="navbar-item" href="/public/vortrag/">Vortr&auml;ge</a><a class="navbar-item" href="/public/authors/">Autoren</a><a class="navbar-item" href="/video/">Video</a></div></div><div class="navbar-item has-dropdown is-hoverable"><a href="/open-source/" class="navbar-link">Open Source</a><div class="navbar-dropdown"><a class="navbar-item" href="/open-source-api-gateway.htm">API Gateway</a><a class="navbar-item" href="/soa-monitoring.htm">SOA Monitor</a><a class="navbar-item" href="/open-source/virtualisierung/">Service Virtualisierung</a><a class="navbar-item" href="/was-ist-ein-virtueller-service.htm">Virtuelle Services</a></div></div></div><div class="navbar-end"><div class="navbar-item has-dropdown is-hoverable"><a href="/kontakt/" class="navbar-link">Kontakt</a><div class="navbar-dropdown"><a class="navbar-item" href="/kontakt/hotelliste.htm">Hotels</a><a class="navbar-item" href="/kontakt/anreise.htm">Anreise</a><a class="navbar-item" href="/freizeit/">Freizeittipps</a></div></div><div class="navbar-item has-dropdown is-hoverable"><a href="/jobs/" class="navbar-link">Jobs</a><div class="navbar-dropdown"><a class="navbar-item" href="/senior-java-entwickler-job-bonn.htm">Senior Java Entwickler w/m/d</a><a class="navbar-item" href="/java-entwickler-job-bonn.htm">Java Entwickler m/w/d</a><a class="navbar-item" href="/studentenjob-java-bonn.htm">Java Student m/w/d</a><a class="navbar-item" href="/studentenjob-kubernetes-bonn.htm">Kubernetes-Administrator m/w/d</a><a class="navbar-item" href="/jobs/freiberufler-java-bonn.htm">Freiberufler m/w/d</a><a class="navbar-item" href="/jobs/bachelorarbeit.htm">Bachelorarbeiten</a><a class="navbar-item" href="/jobs/wie-bewerbe-ich-mich-als-programmierer.htm">Bewerbung als Coder</a><a class="navbar-item" href="/jobs/was-muss-bewerbung-enthalten.htm">Inhalt der Bewerbung</a><a class="navbar-item" href="/azubi-fachinformatiker-bonn.htm">Azubi Fachinformatiker w/m/d</a></div></div></div></div></div></nav><section><div class="container"><div class="columns"><div class="column content is-three-quarters"><h1>ActiveMQ, Qpid, HornetQ und RabbitMQ im Vergleich</h1><p><a href="https://www.predic8.de/thomas-bayer.htm"><img src="/people/thomas-bayer.jpg" align="left" style="padding: 0px 10px 10px 0px"></a><b>Von: </b><a href="https://www.predic8.de/thomas-bayer.htm">Thomas Bayer</a><br><b>Datum: </b>17. Januar 2013<br><b>Aktualisiert: </b>6. Juli 2018</p><em>Neuere Architekturen und das standardisierte AMQP Protokoll haben zu einer wahren Flut an Message Brokern gef&uuml;hrt. Alle Broker nehmen f&uuml;r sich in Anspruch schnell, robust und zuverl&auml;ssig zu sein. Aber worin unterscheiden sich die Broker wirklich? Wie w&auml;hle ich einen geeigneten Broker aus? Sollte man weiterhin etablierte Broker wie zum Beispiel den ActiveMQ verwenden? Dieser Artikel versucht diese Fragen zu beantworten und den Leser bei der Auswahl eines geeigneten Brokers zu unterst&uuml;tzen.</em><p>
      
    </p><p>Die in diesem  Artikel beschriebenen Broker mussten:
    <ul><li>unter einer Open Source Lizenz verf&uuml;gbar sein</li><li>Zugriff von Java aus erm&ouml;glichen</li><li><i>Quality of Service</i> Eigenschaften wie garantierte Zustellung und Persistenz bieten</li></ul>
    In den n&auml;chsten Abschnitten werden die Broker mit ihren Besonderheiten vorgestellt. Danach werden Kriterien wie Persistenz, unterst&uuml;tzte Plattformen, Performanz und Verbreitung behandelt. Die Beschreibung der einzelnen Broker beginnt mit dem Verteidiger dem etablierten ActiveMQ Broker.
  </p><h2>Apache ActiveMQ</h2><p>Apache ActiveMQ ist mit der gr&ouml;&szlig;ten Anzahl von Installationen der Open Source Message Broker mit der gr&ouml;&szlig;ten Verbreitung. ActiveMQ implementiert die <i>Java Message Service</i> Spezifikation und bietet zahlreiche Features wie z.B. Unterst&uuml;tzung f&uuml;r die <i>Enterprise Integration Patterns</i>, f&uuml;r das Spring Framework und f&uuml;r Transaktionen.</p><p>F&uuml;r die Persistierung von Nachrichten k&ouml;nnen verschiedene Speicher verwendet werden. Die Datei-basierte <i>Kaha</i> Datenbank bietet eine sehr gute Performanz, da Sie in der Java VM des Brokers ausgef&uuml;hrt wird, wenige Ressourcen ben&ouml;tigt und f&uuml;r Nachrichten optimiert ist. Beliebt ist im Enterprise-Umfeld aber die Verwendung einer relationalen Datenbank wie z.B. IBMs DB/2 oder die Datenbank von Oracle. Die Verwendung eines JDBC Speicher zusammen mit einer relationalen Datenbank ist mit einer Geschwindigkeitseinbu&szlig;e verbunden, bringt jedoch Vorteile f&uuml;r den Betrieb: die Datenbank f&uuml;r die Persistenz von Nachrichten kann in das Operating eines Rechenzentrums eingebunden werden und f&uuml;r das Backup kann der bestehende Mechanismus verwendet werden. Es macht jedoch nicht immer Sinn ein Backup f&uuml;r einen Nachrichten Speicher zu erstellen.</p><p>Ein Highlight beim ActiveMQ sind die zahlreichen M&ouml;glichkeiten f&uuml;r Clustering und Verteilung. Um beim Ausfall eines Brokers den Betrieb aufrecht zu erhalten kann ActiveMQ in einer <i>Master/Slave</i> Konfiguration betrieben werden. Ferner k&ouml;nnen mehrere Broker zu einem Network of Brokers verbunden werden. In einem <i>Network of Brokers</i> sind Queues und Topics (Publish/Subscribe) virtuell, d.h. eine Queue ist auf allen Knoten verf&uuml;gbar und das Routing findet automatisch statt.</p><p>Abbildung 1 skizziert einen virtuellen Broker den man mit verteilten ActiveMQ Installation realisieren k&ouml;nnte.</p><img src="/public/enterprise/network-of-brokers.png" alt="network-of-brokers" title="Network Of Brokers" name="network-of-brokers"><br><p class="imgcap"><b>Abbildung 1: </b><caption>Virtueller Broker mit weltweit verteilten Knoten</caption></p><p>ActiveMQ wird in einigen <i>Enterprise Service Bus</i> Produkten wie z.B. beim ServiceMix und Mule ESB als Bus Infrastruktur verwendet. Daneben gibt es noch zahlreiche andere Projekte, die ActiveMQ f&uuml;r den Transport von Nachrichten verwenden. Apache Geronimo und TomEE, die Java Enterprise Edition des Tomcat Web Containers, verwenden ActiveMQ als JMS Implementierung.</p><p>Der Fuse MQ Enterprise Broker von Progress Software basiert auf dem Apache ActiveMQ Broker. Bugfix-Versionen der Fuse Variante werden &ouml;fter released als die ActiveMQ Versionen von Apache.</p><p>Seit seinen Anf&auml;ngen in 2004 ist der ActiveMQ Broker gereift und hat eine gro&szlig;e Verbreitung erlangt. Kinderkrankheiten wie Speicherl&ouml;cher sind l&auml;ngst beseitigt. F&uuml;r die meisten Messaging Aufgaben arbeitet ActiveMQ zuverl&auml;ssig, hoch performant und Ressourcen schonend.</p><p>F&uuml;r das <i>Enterprise Messaging</i> ist ActiveMQ immer noch eine sehr gute Wahl. ActiveMQ hat jedoch Konkurrenz bekommen, die mit neueren Architekturen, besserer Performanz und mit der Unterst&uuml;tzung von standardisierten Protokollen im Revier des Platzhirsches wildert.
  </p><h2>Apache Apollo</h2><p><b>Update: 2015 wurde Apache Apollo nichtoffiziell f&uuml;r tot erkl&auml;rt. Eine weitere Entwicklung findet nicht statt. M&ouml;glicherweise ist <a href="/apache-artemis-vergleich-kafka-activemq.htm">Apache Artemis</a> die n&auml;chste Version des ActiveMQ Brokers.</b></p><p>ActiveMQ bekommt von Apache Apollo Konkurrenz aus dem eigenen Hause. Apollo ist eine Neuentwicklung basierend auf den Erfahrungen des ActiveMQ Projektes.</p><p>Um schneller, robuster und besser wartbar zu sein als ActiveMQ wurde eine komplett neue Architektur eingef&uuml;hrt. Die Architektur basiert auf der Programmiersprache Scala, die gut die Entwicklung von nebenl&auml;ufigen Systemen unterst&uuml;tzt. Das Threading des Apollo Brokers unterscheidet sich grundlegend von dem des ActiveMQ. Alle Aufgaben werden asynchron und nicht-blockierend ausgef&uuml;hrt, was zu erh&ouml;hter Performanz und Stabilit&auml;t beitr&auml;gt. Dadurch k&ouml;nnen die F&auml;higkeiten von Mehrkernprozessoren besser genutzt werden.</p><p>F&uuml;r Apollo gibt es derzeit zwei Speicher f&uuml;r persistente Nachrichten. Zum einen &uuml;ber die NoSQL Datenbank LevelDB von Google und zum anderen &uuml;ber die Java Edition der Berkeley DB.</p><p>&Uuml;ber den HTML5 WebSocket Connector kann ein Messaging Client direkt in eine Webseite eingebunden werden. Das folgende Listing zeigt, wie man mit JavaScript und der <i>stomp.js</i> Bibliothek auf einen Apollo Broker von einer Webseite aus zugreifen kann. Beim Verbindungsaufbau wird eine Callback-Funktion angemeldet, die beim Eintreffen einer Nachricht den Inhalt in einem Dialog anzeigt.
  <div class="listing">
        <pre class="brush: java; wrap-lines: false; width: 2000px; toolbar:false; ">
var client = Stomp.client("ws://apollo.predic8.com:61623");

client.connect("admin", "pwd", function(frame) {
   client.subscribe("/topic/like", function(msg) {
 	  alert(msg.body);
   });
});
        </pre>
        <div class="cap"><b>Listing 1: </b>Zugriff auf den Apollo Broker mit STOMP und JavaScript </div>
      </div>
  Das Senden von Nachrichten aus dem Browser heraus kann mit dem folgenden JavaScript Ein-Zeiler erfolgen:
  <div class="listing">
        <pre class="brush: java; wrap-lines: false; width: 2000px; toolbar:false; ">
client.send("/topic/like", {}, inhalt);
        </pre>
      </div>
  Apollo ist zwar in Scala geschrieben, der Broker kann aber ohne Bedenken in einer Java Umgebung betrieben werden. Dass Apollo mit Scala realisiert ist erkennt man nur daran, dass die Distribution neben vielen Java Bibliotheken auch einige Scala Bibliotheken enth&auml;lt.</p><p>F&uuml;r die Verwaltung bietet Apollo eine einfache Web Konsole wie der folgende Screenshot zeigt.</p><img src="/images/apollo-console-html.png" alt="Apollo Admin Konsole" title="Apollo Admin Konsole" name="apollo-console-html"><br><p class="imgcap"><b>Abbildung 2: </b><caption>Admin Konsole des Apollo Brokers</caption></p><p>&Auml;ndert man in der URL das Anh&auml;ngsel von <i>.html</i>nach <i>.json</i> bekommt man eine JSON Repr&auml;sentation anstatt einer Web Seite.</p><img src="/images/apollo-console-json.png" alt="Apollo Konsole als JSON" title="Apollo Konsole als JSON" name="apollo-console-json"><br><p class="imgcap"><b>Abbildung 3: </b><caption>Apollo Konsole als JSON Repr&auml;sentation</caption></p><p>&Uuml;ber REST und JSON kann auch schreibend auf die Apollo Web Anwendung zugegriffen werden um beispielsweise eine neue Queue anzulegen. Abbildung 4 zeigt einen Screenshot mit einer Visualisierung des Apollo REST APIs. Die Visualisierung ist in Apollo integriert und &uuml;ber das Swagger Tool realisiert. <a href="http://swagger.wordnik.com/">Beschreibung mit Swagger</a> ist eine Spezifikation und ein Framework zur Beschreibung von REST APIs.</p><img src="/images/swagger-rest-api.png" alt="REST API Beschreibung mit Swagger" title="REST API Beschreibung mit Swagger" name="swagger-rest-api"><br><p class="imgcap"><b>Abbildung 4: </b><caption>REST API Beschreibung mit Swagger</caption></p><p>F&uuml;r Apollo selbst gibt es keine Client Bibliothek. Daf&uuml;r k&ouml;nnen andere Clients f&uuml;r die von Apollo unterst&uuml;tzten Protokolle MQTT, OpenWire und STOMP verwendet werden.</p><h2>FFMQ</h2><p>Der <i>Full-Java, native JMS, message Queuer</i> ist eine leichtgewichtige JMS Implementierung. Der gesamt Server ist kleiner als 600 KByte daf&uuml;r gibt es eine Reihe von Einschr&auml;nkungen bez&uuml;glich JMS Konformit&auml;t oder Transaktionen. Wer auf fortgeschrittene JMS Funktionalit&auml;t wie z.B. <i>Message Groups</i> verzichten kann bekommt mit FFMQ einen einfachen, schnellen und unkomplizierten Message Broker.</p><h2>HornetQ</h2><p><b>Update: Der Quellcode von HornetQ wurde 2015 von JBoss an Apache gestiftet. Bei Apache wird der Code unter dem Namen Apache <a href="/apache-artemis-vergleich-kafka-activemq.htm">Apache Artemis</a> weiter entwickelt. Bestehende HornetQ Clients k&ouml;nnen leicht auf Artemis portiert werden, da Artemis das HornetQ Protokoll beherrscht. M&ouml;glicherweise wird Artemis der Nachfolger des beliebten ActiveMQ Brokers. Vielleicht als ActiveMQ Version 6? Wer HornetQ nicht einsetzt, f&uuml;r den lohnt sich eine Besch&auml;ftigung mit dem Broker nicht mehr. Statt dessen k&ouml;nnte man Artemis betrachten.</b></p><p>Die Code Basis von HornetQ war lange unter dem Namen <i>JBoss Messaging 2.0</i> bekannt bis sie als eigenes Projekt unter dem Namen HornetQ weiterentwickelt wurde. HornetQ kann unabh&auml;ngig vom JBoss Application Server eingesetzt werden. Ab der Version 6 ist HornetQ der vorkonfigurierte Message Broker f&uuml;r JMS beim JBoss Server.</p><p>HornetQ ist als Enterprise Message Broker ausgelegt. Er bietet zahlreiche Features sowie viele Einstellungen und ist eine vollwertige Umsetzung der <i>Java Message Service</i> Spezifikation.</p><p>Das User Manual ist mit 334 Seiten das umfangreichste der hier aufgef&uuml;hrten Message Broker. Die Dokumentation ist sehr ausf&uuml;hrlich von den Konzepten &uuml;ber die Architektur bis hin zu XA Transaktionen und Clustering.</p><p>F&uuml;r HornetQ gibt es keine eigenst&auml;ndige Konsole f&uuml;r die Administration. &Uuml;ber die Konsole des JBoss Application Servers kann HornetQ administriert werden. &Uuml;ber JMX und MBeans k&ouml;nnen beispielsweise Queues angelegt oder Statistiken ausgelesen werden. Da ich den HornetQ gerne in der Standalone-Version einsetzen m&ouml;chte steht eine spezielle Konsole auf meiner Wunschliste.</p><p>HornetQ hat seine St&auml;rken im Einsatz als Enterprise Broker und als JMS Implementierung. Die Integration im JBoss wird sicher auch zu seiner Verbreitung beitragen. Damit verbunden ist eine gewisse Komplexit&auml;t, so dass es f&uuml;r einfachere Konfigurationen geeignetere Broker gibt. F&uuml;r den Enterprise Einsatz hat HornetQ auf jeden Fall einen spitzen Stachel.</p><h2>JBoss Messaging</h2><p>Die Weiterentwicklung von JBoss Messaging wurde eingestellt. Neue Funktionen werden ausschlie&szlig;lich im Nachfolgeprojekt HornetQ umgesetzt. F&uuml;r JBoss Messaging wird es noch eine Zeitlang Support und Bugfixes geben.
  </p><h2>OpenJMS</h2><p>OpenJMS war die Open Source JMS Implementierung von SUN Microsystems. In den letzten Jahren konnte ich nicht mehr viel Aktivit&auml;t rund um OpenJMS beobachten. Es hat den Anschein, dass dieses Projekt nicht mehr besonders lebendig ist.
  </p><h2>Apache Qpid&#8482;</h2><p>Neben ActiveMQ und Apollo gibt es bei Apache einen weiteren Message Broker, Apache Qpid. Ziel des Qpid Projektes ist die 100 prozentige Kompatibilit&auml;t zum <i>Advanced Message Queuing Protocol Standard</i>.</p><p>Der Qpid Broker ist in einer Version f&uuml;r C++ und in einer f&uuml;r Java verf&uuml;gbar. Dieser Artikel beschreibt die Eigenschaften der Java Version. F&uuml;r Java Clients gibt es ein JMS API f&uuml;r Qpid. F&uuml;r C++, Python und Microsofts .Net gibt es das <i>Qpid Messaging API</i>.</p><p>F&uuml;r die Persistenz von Nachrichten wird die relationale Apache Derby Datenbank und die Oracle Berkeley DB unterst&uuml;tzt.</p><p>Auf der Basis von Apache Qpid bietet Red Hat das Enterprise Messaging Produkt MRG an. F&uuml;r MRG gibt es langj&auml;hrigen Support sowie Versionen mit zus&auml;tzlichen Bug Fixes.</p><p>Proton&#8482;, ein Subprojekt von Qpid, ist eine leichtgewichtige Implementierung des AMQP Protokolls. Mit Proton soll es gleicherma&szlig;en m&ouml;glich sein Clients und Server zu entwickeln. Proton ist f&uuml;r C und Java verf&uuml;gbar. Die C Implementierung enth&auml;lt auch Bindings f&uuml;r PHP, Python und Ruby.
  </p><h2>RabbitMQ</h2><p>Der RabbitMQ Broker ist mit der funktionalen Sprache Erlang erstellt. Erlang eignet sich besonders f&uuml;r verteilte Anwendungen, da Nebenl&auml;ufigkeit und Verf&uuml;gbarkeit gut unterst&uuml;tzt wird.</p><p>Lassen Sie sich nicht davon abschrecken, dass RabbitMQ in Erlang implementiert ist. Die Installation erfolgt unter Windows und Mac OS schnell und unkompliziert. F&uuml;r das Programmieren in Java oder anderen Sprachen stehen Client Bibliotheken zur Verf&uuml;gung.</p><p>&Uuml;ber Plugins kann RabbitMQ Protokolle wie z.B. STOMP verstehen.  Der Kern von RabbitMQ ist vollkommen auf das AMQP Protokoll ausgerichtet. Leider wird Stand heute noch kein AMQP in der Version 1.0 unterst&uuml;tzt. Unterst&uuml;tzung f&uuml;r AMQP 1.0 ist aber bereits in der Planung.</p><p>Das Management Plugin bietet eine ansprechende Web Konsole die eine einfache Administration erm&ouml;glicht. Dort werden auch Statistiken wie z.B. die Anzahl der Nachrichten pro Sekunde und der Verbrauch an Ressourcen wie z.B. Speicher, Sockets und die entscheidenden File Descriptoren angezeit.</p><img src="/images/rabbitmq-console.png" alt="RabbitMQ Konsole" title="RabbitMQ Konsole" name="rabbitmq-console"><br><p class="imgcap"><b>Abbildung 5: </b><caption>RabbitMQ Konsole</caption></p><h2>ZeroMQ</h2><p>ZeroMQ ist kein klassischer Broker, der Message Queues seinen Clients zur Verf&uuml;gung stellt, sondern eine Bibliothek mit der verteilte, nebenl&auml;ufige Anwendungen erstellt werden k&ouml;nnen. Das API f&uuml;r ZeroMQ gleicht der low Level Socket API f&uuml;r die Kommunikation &uuml;ber Netzwerke.</p><p>Im Gegensatz zu einer Message orientierten Middleware wird beim ZeroMQ kein zentraler Server ben&ouml;tigt. Der Sender einer Nachricht ist f&uuml;r das Routing zum richtigen Ziel und der Empf&auml;nger einer Nachricht ist f&uuml;r das Queueing verantwortlich.</p><p>F&uuml;r ZeroMQ gibt es noch die folgenden Schreibweisen: MQ, OMQ und ZMQ. ZeroMQ wird von iMatix entwickelt, die mit an der Entwicklung von AMQP beteiligt waren. Mittlerweile hat sich iMatix von der Mitarbeit an AMQP zur&uuml;ckgezogen und konzentriert sich ganz auf ZeroMQ. Der Ansatz von ZeroMQ ist recht elegant und erm&ouml;glicht Topologien mit 0 bis n Knoten bzw. Brokern zwischen Sender und Empf&auml;nger.</p><p>Der Verzicht eines zentralen Brokers erm&ouml;glicht sehr geringe Verz&ouml;gerungszeiten und gro&szlig;e Bandbreiten. ZeroMQ ist damit ideal f&uuml;r gr&ouml;&szlig;te Nachrichtenmengen z.B. f&uuml;r Messwerte, f&uuml;r Echtzeit Kurse in der Finanzbranche oder f&uuml;r Onlinespiele.</p><h2>Skalierbarkeit und Zuverl&auml;ssigkeit</h2><p>Gut skalierbar, robust und zuverl&auml;ssig sind grunds&auml;tzlich alle Broker. Bei fast jedem Projekt wird dies als herausragende Eigenschaft gepriesen. Daher wurden in den Beschreibungen der Broker diese Eigenschaften nicht extra erw&auml;hnt, es sei den ein Broker unterscheidet sich wesentlich von den anderen. Als Auswahlkriterium dient dieser Punkt daher nur eingeschr&auml;nkt.</p><p>Der ActiveMQ Broker hat bedingt durch seine Architektur Grenzen was die Skalierbarkeit, Robustheit und Zuverl&auml;ssigkeit angeht. Aber nur bei extrem hoher Last  oder bei Tausenden von Queues sollte ActiveMQ an seine Grenzen sto&szlig;en. In der Praxis ist der  ActiveMQ durch seine Reife oft noch stabiler als seine moderneren Herausforderer.</p><h2>Performanz</h2><p>Wichtig bei der Beurteilung der Geschwindigkeit eines Brokers ist sein Anwendungsgebiet. Nur einen schnellen Broker zu suchen ist meist zu simpel. Um die Performanz eines Brokers richtig beurteilen zu k&ouml;nnen sollte man sich folgende Fragen stellen:
    <ul><li>Ben&ouml;tige ich einen Broker f&uuml;r Finanztransaktionen oder Onlinespiele?</li><li>Was ist f&uuml;r den Einsatz wichtiger, eine garantierte transaktionale Zustellung oder die Geschwindigkeit und Bandbreite?</li><li>Wie gro&szlig; darf die Verz&ouml;gerung bei der Zustellung von Nachrichten sein?</li><li>Wie gro&szlig; sind die zu &uuml;bertragenden Nachrichten?</li><li>Wieviele Queues werden ben&ouml;tigt?</li><li>Wieviele Clients greifen gleichzeitig auf den/die Broker zu?</li></ul>
  Eigenschaften wie Persistenz oder Transaktionalit&auml;t kosten Performanz und f&uuml;hren dazu, dass Messaging L&ouml;sungen ohne QoS, die Nachrichten nur im Hauptspeicher halten, meist schneller sind als die, die QoS Merkmale anbieten.</p><p>Falls mehr Durchsatz gew&uuml;nscht wird, lassen sich Persistenz und eine garantierte Zustellung auch deaktivieren. Meist ist die Performanz trotz Persistenz mehr als ausreichend f&uuml;r die meisten Anwendungen.</p><p>Selbst der mittlerweile in die Jahre gekommene ActiveMQ kann mehrere tausend Nachrichten pro Sekunde verarbeiten. Das reicht in der Regel f&uuml;r die meisten Business Anwendungen in den Bereichen Finanz, Versicherung und Handel. H&ouml;here Anforderungen an die Performance stellt die Echtzeitverarbeitung von Messwerten oder Onlinespiele.</p><p>Wird ein Durchsatz von 10.000 oder mehr Nachrichten pro Sekunde ben&ouml;tigt, sollte man zu einem der neueren Broker greifen. Der Durchsatz von Apollo, Qpid, RabbitMQ und den anderen Brokern liegt zwischen mehreren Hunderttausend bis zu mehreren Millionen Nachrichten pro Sekunde. Beispielsweise hat HornetQ beim <a href="Link: http://planet.jboss.org/post/8_2_million_messages_second_with_specjms">SpecJMS Benchmark</a> mehr als 8 Millionen Nachrichten pro Sekunde zustellen k&ouml;nnen. Getestet wurde auf einem 2 Chip Rechner mit 4 Kernen und 24 GB Hauptspeicher. F&uuml;r die anderen Broker gibt es &auml;hnliche Testergebnisse.</p><p>Ein objektiver Vergleich selbst bei standardisierten Benchmarks ist nur schwer m&ouml;glich, da sich meist die Konfigurationen, die Features oder die Protokolle unterscheiden. Von mehreren Brokern wurde behauptet, dass sie der schnellste seien. Diese Aussagen sind meist nur ein kurze Zeit und nur f&uuml;r ein bestimmtes Szenario g&uuml;ltig.</p><p>Die oben genannten Richtwerte lassen den Schluss zu, dass die Performanz eines Brokers in den wenigsten F&auml;llen ein Projektrisiko darstellt. Damit dient die Geschwindigkeit kaum als Auswahlkriterium zu Gunsten eines speziellen Brokers.</p><p style="border:1.5px solid #000000">
      <b>Praxiserfahrung:</b>
      <br>Meist ist nicht der Broker der Flaschenhals, sondern Message Consumer, die durch langsame Backend Systeme oder Datenbankabfragen ausgebremst werden.
  </p><h2>Message Persistenz</h2><p>Damit Nachrichten den Ausfall eines Brokers &uuml;berleben k&ouml;nnen m&uuml;ssen diese auf einem Datentr&auml;ger dauerhaft gesichert werden. Bei den meisten Brokern gibt es daf&uuml;r austauschbare Message Stores.</p><p>Werden Nachrichten dauerhaft zwischengespeichert tr&auml;gt die verwendete Datenbank ma&szlig;geblich zur Geschwindigkeit des Brokers bei. Daher werden f&uuml;r die Speicherung von Nachrichten spezielle Datenbanken verwendet. Nachrichten m&uuml;ssen gespeichert, &uuml;ber den Namen einer Queue gesucht und gel&ouml;scht werden k&ouml;nnen. Das Ver&auml;ndern von Nachrichten ist nicht notwendig. Die f&uuml;r diese Aufgaben optimierten Datenbanken, die meist direkt auf die Festplatte zugreifen erzielen daher bei der Persistierung von Nachrichten eine wesentlich bessere Performanz als die universell verwendbaren relationalen Datenbanken. Die Gr&ouml;&szlig;enordnung des Geschwindigkeitsunterschiedes zwischen einer relationalen Datenbank und einer speziellen Nachrichten Datenbank liegt ungef&auml;hr bei dem Zehnfachen.</p><p>Trotz der Geschwindigkeitseinbu&szlig;e durch einen relationalen Datenspeicher m&ouml;chten viele Anwender Nachrichten in ihrer vertrauten Datenbank zwischenspeichern. Der JDBC Store des ActiveMQ Brokers erlaubt die Verwendung jeder beliebigen relationalen Datenbank f&uuml;r die es einen JDBC-Treiber gibt. Selbstverst&auml;ndlich kann mit ActiveMQ die Oracle Datenbank zur Speicherung verwendet werden.
  </p><h2>JMS Unterst&uuml;tzung</h2><p>Ein wichtiges Kriterium f&uuml;r die Entscheidung f&uuml;r einen Broker ist die Unterst&uuml;tzung des <i>Java Message Service Standards</i>. Viele bestehende Java Anwendungen verwenden das JMS API um mit einem Message Broker kommunizieren zu k&ouml;nnen. Die Migration auf einen neuen Broker kann dann ohne &Auml;nderungen des Anwendungscodes erfolgen.</p><p>Bei ActiveMQ und HornetQ steht JMS Konformit&auml;t ganz oben auf der Liste der Features.</p><p>Apache Qpid kommt mit einem JMS Client API, welche es Clients erm&ouml;glicht sich &uuml;ber AMQP mit dem Broker zu verbinden. &Uuml;ber dieses API kann mit JMS auch auf andere Broker wie z.B. den RabbitMQ zugegriffen werden.</p><h2>Messaging Protokolle</h2><p>Lange gab es keinen Standard f&uuml;r ein Messaging Protokoll. Der Java Standard JMS beschreibt nur die Schnittstelle, &uuml;ber die Anwendungen mit einem Broker kommunizieren k&ouml;nnen. Das Protokoll zwischen der JMS Bibliothek und dem Server ist abh&auml;ngig vom Hersteller.</p><p>Abbildung 6 zeigt, wie mit Hilfe von JMS die selbe Anwendung mit unterschiedlichen Message Brokern betrieben werden kann. Die Anwendung verwendet das standardisierte JMS API &uuml;ber das sie auf eine JMS Implentierung eines bestimmten Brokers zugreift. Um die Anwendung mit einem anderen Broker betreiben zu k&ouml;nnen muss nur die JMS Client Bibliothek ausgetauscht werden.</p><img src="/images/jms-interoperability.png" alt="Austauschbarkeit des Brokers &uuml;ber JMS" title="Austauschbarkeit des Brokers &uuml;ber JMS" name="jms-interoperability"><br><p class="imgcap"><b>Abbildung 6: </b><caption>Austauschbarkeit des Brokers &uuml;ber JMS</caption></p><p>Die Broker untereinander verstehen sich aufgrund der verschiedene Protokolle nicht. JMS adressiert auch nicht die Interoperabilit&auml;t mit anderen Programmiersprachen.</p><p>Das <i>Advanced Message Queuing Protocol</i> ist ein Standard, der diese L&uuml;cke schlie&szlig;en m&ouml;chte. AMQP erm&ouml;glicht die Zusammenarbeit von Brokern sowie Clients verschiedener Hersteller und Plattformen. AMQP beschreibt dazu ein Bin&auml;rformat sowie die notwendige Anwendungslogik. Viele gro&szlig;e Hersteller setzten auf AMQP. Allerdings gibt es aufgrund der Komplexit&auml;t von AMQP und der Art und Weise wie die Standardisierung erfolgt ist einige Kritik.</p><p>Die im Oktober 2012 als OASIS Standard verabschiedete AMQP 1.0 Version unterscheidet sich erheblich von den vorherigen Versionen, so dass man von einem komplett eigenst&auml;ndigen Protokoll sprechen k&ouml;nnte. Auch die Vorg&auml;nger Versionen 0-8, 0-9, 0-9-1 und 0-10-0 sind nicht alle untereinander kompatibel. Ob AMQP wirklich zu mehr Interoperabilit&auml;t f&uuml;hrt, h&auml;ngt davon ab, wie gut die AMQP 1.0 Version akzeptiert und umgesetzt wird. Die Unterst&uuml;tzung von AMQP 1.0 im ActiveMQ, Apollo und Qpid Broker sowie die Ank&uuml;ndigungen f&uuml;r HornetQ und RabbitMQ lassen hoffen, dass AMQP zu einem Erfolg wird. Entscheidend d&uuml;rfte auch die Abkehr von der viel zu &uuml;berladenen Vorg&auml;ngerversion 0-10-0 sein. Die AMQP 1.0 Version ist im Vergleich mit der 0-10-0 Version etwas einfacher.</p><p>Ein f&uuml;r die Anbindung von Skriptsprachen beliebtes Protokoll ist das textbasierte STOMP. Es ist einfach, performant und es gibt eine Vielzahl von Servern und Klienten. F&uuml;r STOMP gibt es die meisten Client Bibliotheken beispielsweise f&uuml;r C, Objective-C, PHP, Go, Python und Ruby. STOMP ist so einfach, dass man mit wenig Aufwand selbst eine Client Bibliothek erstellen kann f&uuml;r den unwahrscheinlichen Fall, dass es keine Bibliothek gibt. Die <i>stomp.js</i> Bibliothek f&uuml;r JavaScript ist zum Beispiel nur 7 KByte gro&szlig;. Um Web Seiten mit JavaScript als Messaging Client nutzen zu k&ouml;nnen kann man STOMP mit dem WebSockets Protokoll kombinieren. Auf diese Weise lassen sich schlanke Web 2.0 Anwendungen erstellen.</p><p>Die folgende Tabelle f&uuml;hrt die unterst&uuml;tzten Protokolle der einzelnen Broker auf.
      
      <table class="table1">
        <thead>
          <tr>
            	<th>Protokoll/Broker</th>
            	<th>ActiveMQ</th>
            	<th>Apollo</th>
            	<th>HornetQ</th>
            	<th>Qpid</th>
            	<th>RabbitMQ</th>
            	<th>ZeroMQ</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            	<th>AMQP</th>
            <td>1.0</td>
            <td>1.0</td>
            <td>ist angek&uuml;ndigt</td>
            <td>1.0</td>
            <td>0-8, 0-9, 0-9-1</td>
            	<td>&#10060;</td>
          </tr>
          <tr>
            	<th>MQTT</th>
            <td>&#10004;</td>
            <td>&#10004;</td>
            	<td>&#10060;</td>
            	<td>&#10060;</td>
            <td>&#10004;</td>
            	<td>&#10060;</td>
          </tr>
          <tr>
            	<th>OpenWire</th>
            <td>&#10004;</td>
            <td>&#10004;</td>
            	<td>&#10060;</td>
            	<td>&#10060;</td>
            	<td>&#10060;</td>
            	<td>&#10060;</td>
          </tr>
          <tr>
            	<th>REST</th>
            <td>&#10004;</td>
            <td>&#10004;</td>
            <td>&#10004;</td>
            	<td>&#10060;</td>
            <td>&#10004;</td>
            	<td>&#10060;</td>
          </tr>
          <tr>
            	<th>STOMP</th>
            <td>&#10004;</td>
            <td>&#10004;</td>
            <td>&#10004;</td>
            	<td>&#10060;</td>
            <td>&#10004;</td>
            	<td>&#10060;</td>
          </tr>
          <tr>
            	<th>STOMP over Websockets</th>
            <td>&#10004;</td>
            <td>&#10004;</td>
            <td>&#10004;</td>
            	<td>&#10060;</td>
            <td>&#10004;</td>
            	<td>&#10060;</td>
          </tr>
          <tr>
            	<th>XMPP</th>
            <td>&#10004;</td>
            	<td>&#10060;</td>
            	<td>&#10060;</td>
            	<td>&#10060;</td>
            <td>&Uuml;ber Gateway</td>
            	<td>&#10060;</td>
          </tr>
        </tbody>
      </table>
  Tabelle 1: Unterst&uuml;tzung f&uuml;r Messaging Protokolle
  </p><h2>Client Schnittstellen</h2><p>Der Zugriff auf einen Message Broker ist nicht allein Java Anwendungen vorbehalten. F&uuml;r viele Broker gibt es Client APIs in den verschiedensten Programmiersprachen. Es ist sogar &uuml;blich f&uuml;r Client und Broker andere Plattformen einzusetzen, z.B. beim Zugriff von einer mit Java realisierten Anwendung auf den in Erlang geschriebenen RabbitMQ Broker.</p><p>Da AMQP das Protokoll auf der &#8222;Kabelebene&#8220; standardisiert hat, ist es sogar m&ouml;glich die AMQP Client Bibliothek eines Brokers mit einem anderen Broker zu verbinden. Damit dies funktioniert muss die AMQP Version &uuml;bereinstimmen, da die einzelnen Versionen des Protokolls nicht alle miteinander kompatibel sind.</p><p>&Uuml;ber das STOMP Protokoll k&ouml;nnen verschiedene Client Plattformen mit einem Broker verbunden werden. Beliebt ist STOMP um von Skriptsprachen wie Perl, PHP und Ruby auf einen Broker zuzugreifen.</p><table class="table1">
      <thead>
        <tr>
          	<th></th>
          	<th>ActiveMQ</th>
          	<th>Apollo</th>
          	<th>HornetQ</th>
          	<th>Qpid</th>
          	<th>RabbitMQ</th>
          	<th>ZeroQ</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          	<th>C</th>
          <td>&#10004;</td>
          	<td>&#10060;</td>
          	<td>&#10060;</td>
          <td>&#10004;</td>
          <td>&#10004;</td>
          <td>&#10004;</td>
        </tr>
        <tr>
          	<th>C++</th>
          	<td>&#10060;</td>
          	<td>&#10060;</td>
          	<td>&#10060;</td>
          <td>&#10004;</td>
          <td>&#10004;</td>
          <td>&#10004;</td>
        </tr>
        <tr>
          	<th>Erlang</th>
          	<td>&#10060;</td>
          	<td>&#10060;</td>
          	<td>&#10060;</td>
          	<td>&#10060;</td>
          <td>&#10004;</td>
          <td>&#10004;</td>
        </tr>
        <tr>
          	<th>Haskell</th>
          	<td>&#10060;</td>
          	<td>&#10060;</td>
          	<td>&#10060;</td>
          	<td>&#10060;</td>
          <td>&#10004;</td>
          <td>&#10004;</td>
        </tr>
        <tr>
          	<th>Java JMS</th>
          <td>&#10004;</td>
          	<td>&#10060;</td>
          <td>&#10004;</td>
          <td>&#10004;</td>
          	<td>&#10060;</td>
          	<td>&#10060;</td>
        </tr>
        <tr>
          	<th>Java propriet&auml;r</th>
          <td>&#10004;</td>
          	<td>&#10060;</td>
          <td>&#10004;</td>
          	<td>&#10060;</td>
          <td>&#10004;</td>
          <td>&#10004;</td>
        </tr>
        <tr>
          	<th>.NET</th>
          	<td>&#10060;</td>
          	<td>&#10060;</td>
          	<td>&#10060;</td>
          <td>&#10004;</td>
          <td>&#10004;</td>
          <td>&#10004;</td>
        </tr>
        <tr>
          	<th>Objective-C</th>
          	<td>&#10060;</td>
          	<td>&#10060;</td>
          	<td>&#10060;</td>
          	<td>&#10060;</td>
          	<td>&#10060;</td>
          <td>&#10004;</td>
        </tr>
        <tr>
          	<th>Perl</th>
          	<td>&#10060;</td>
          	<td>&#10060;</td>
          	<td>&#10060;</td>
          	<td>&#10060;</td>
          <td>&#10004;</td>
          <td>&#10004;</td>
        </tr>
        <tr>
          	<th>PHP</th>
          	<td>&#10060;</td>
          	<td>&#10060;</td>
          	<td>&#10060;</td>
          	<td>&#10060;</td>
          <td>&#10004;</td>
          <td>&#10004;</td>
        </tr>
        <tr>
          	<th>Python</th>
          	<td>&#10060;</td>
          	<td>&#10060;</td>
          	<td>&#10060;</td>
          <td>&#10004;</td>
          <td>&#10004;</td>
          <td>&#10004;</td>
        </tr>
        <tr>
          	<th>Ruby</th>
          	<td>&#10060;</td>
          	<td>&#10060;</td>
          	<td>&#10060;</td>
          <td>&#10004;</td>
          <td>&#10004;</td>
          <td>&#10004;</td>
        </tr>
      </tbody>
    </table><h2>Verbreitung</h2><p>Die mit Abstand gr&ouml;&szlig;te Verbreitung hat der ActiveMQ Broker. Viel Aufmerksamkeit hat der RabbitMQ in letzter Zeit erfahren.</p><p>Das im Folgenden eingebettete Google Trends Diagramm zeigt wie h&auml;ufig nach den Brokern gesucht wurde.</p><script type="text/javascript" src="http://www.google.de/trends/embed.js?hl=en-US&amp;q=activemq,+hornetq,+rabbitmq,+qpid&amp;cmpt=q&amp;content=1&amp;cid=TIMESERIES_GRAPH_0&amp;export=5&amp;w=500&amp;h=330"></script><p>Hinter dem AMQP Standard stehen viele Schwergewichte aus IT und Wirtschaft. Unter anderen waren an der Standardisierung die Deutsche Boerse, JPMorgan Chase, Microsoft, Progress Software, Red Hat, Software AG, US Dept of Homeland Security und VMware beteiligt. Seit Oktober 2012 ist AMQP ein offizieller OASIS Standard. Dies alles l&auml;&szlig;t den Schlu&szlig; zu, dass AMQP eine gro&szlig;e Verbreitung erfahren wird.</p><h1>Fazit</h1><p>Wie so oft in der IT gibt es auch bei der Auswahl eines Brokers keinen K&ouml;nigsweg. Mit ActiveMQ gibt es einen bew&auml;hrten, schnellen und weit verbreiteten Broker, dessen Architektur jedoch an ihre Grenzen st&ouml;&szlig;t. Der JDBC Message Store ist ein Alleinstellungsmerkmal des ActiveMQ f&uuml;r einen Betrieb im Rechenzentrum.</p><p>Als Alternative gibt es eine Reihe von vielversprechenden und coolen Projekten, denen es aber noch etwas an Reife und Verbreitung mangelt. In den Projekten ist viel Bewegung, so dass ich davon ausgehe, dass 2013 viele Broker eine ausreichende Stabilit&auml;t, Dokumentation und Kompatibilit&auml;t erreichen werden.</p><p>HornetQ bietet sich an, wenn es um Enterprise Messaging mit JMS Unterst&uuml;tzung geht. Die umfangreiche Dokumentation beschreibt selbst fortgeschrittene Konfigurationen mit Transaktionen und Clustering.</p><p>Wer einen einfachen Broker f&uuml;r Web 2.0 Anwendungen sucht, direkt &uuml;ber JavaScript Nachrichten versenden und empfangen m&ouml;chte oder wer au&szlig;er Java noch Skriptsprachen einsetzt, sollte sich den Apache Apollo ansehen.</p><p>Wenn Erlang als Plattform kein Ausschlusskriterium darstellt, k&ouml;nnte auch RabbitMQ interessant sein. Momentan wird beim RabbitMQ noch die AMQP 1.0 Kompatibilit&auml;t vermisst.</p><p>
      <br>Thomas Bayer<br>
      <a href="mailto:bayer@predic8.com">bayer@predic8.com</a>
      <br>
    </p><h2>Betrachtete Versionen</h2><p>Die in der folgenden Liste aufgef&uuml;hrten Versionen wurden f&uuml;r die Erstellung dieses Artikels betrachtet.</p><ul><li>Apache ActiveMQ 5.7.0</li><li>Apache Apollo 1.5</li><li>FFMQ 3.0.1</li><li>HornetQ 2.3.0.Beta 3</li><li>JBoss Messaging 2.0.0</li><li>OpenJMS 0.7.7</li><li>Qpid 0.18</li><li>RabbitMQ 3.0.1</li><li>ZeroMQ 3.2</li></ul><h1>Quellen</h1><p>
      <i>AMQP Homepage</i>
      <br>
      <a href="http://www.amqp.org/node/">http://www.amqp.org/node/</a>
    </p><p>
      <i>ActiveMQ Homepage</i>
      <br>
      <a href="http://activemq.apache.org/">http://activemq.apache.org/</a>
    </p><p>
      <i>STOMP Protocol Specification</i>
      <br>
      <a href="http://stomp.github.com/stomp-specification-1.2.html">http://stomp.github.com/stomp-specification-1.2.html</a>
    </p><p>
      <i>HornetQ Homepage</i>
      <br>
      <a href="http://www.jboss.org/hornetq">http://www.jboss.org/hornetq</a>
    </p><p>
      <i>RabbitMQ support JMS in the future?</i>
      <br>
      <a href="http://rabbitmq.1065348.n5.nabble.com/RabbitMQ-support-JMS-in-the-future-td24361.html">http://rabbitmq.1065348.n5.nabble.com/RabbitMQ-support-JMS-in-the-future-td24361.html</a>
    </p><p>
      <i>Message Queue Evaluation Notes</i>
      <br>
      <a href="http://wiki.secondlife.com/wiki/Message_Queue_Evaluation_Notes">http://wiki.secondlife.com/wiki/Message_Queue_Evaluation_Notes</a>
    </p><p>
      <i>Enabling the ActiveMQ Broker for AMQP</i>
      <br>
      <a href="http://activemq.apache.org/amqp.html">http://activemq.apache.org/amqp.html</a>
    </p><p>
      <i>Open JMS Homepage</i>
      <br>
      <a href="http://openjms.sourceforge.net/">http://openjms.sourceforge.net/</a>
    </p><p>
      <i>Apache Qpid Homepage</i>
      <br>
      <a href="http://qpid.apache.org/">http://qpid.apache.org/</a>
    </p><p>
      <i>RabbitMQ Homepage</i>
      <br>
      <a href="http://www.rabbitmq.com/">http://www.rabbitmq.com/</a>
    </p><p>
      <i>ZeroMQ Homepage</i>
      <br>
      <a href="http://www.zeromq.org/">http://www.zeromq.org/</a>
    </p></div><div class="column"><div><div class="tags" style="margin-top: 1rem"><span class="tag"><a href="/tag/open-source.html">Open Source</a></span><span class="tag"><a href="/tag/messaging.html">Messaging</a></span><span class="tag"><a href="/tag/jms.html">JMS</a></span><span class="tag"><a href="/tag/activemq.html">ActiveMQ</a></span><span class="tag"><a href="/tag/artikel.html">Artikel</a></span><span class="tag"><a href="/tag/enterprise.html">Enterprise</a></span><span class="tag"><a href="/tag/qpid.html">Qpid</a></span><span class="tag"><a href="/tag/hornetq.html">HornetQ</a></span><span class="tag"><a href="/tag/rabbitmq.html">RabbitMQ</a></span><span class="tag"><a href="/tag/amqp.html">AMQP</a></span><span class="tag"><a href="/tag/stomp.html">STOMP</a></span><span class="tag"><a href="/tag/websockets.html">WebSockets</a></span></div><div class="box" style="margin-top: 1rem"><b class="is-5">English <img src="/images/english.jpg" alt="View this article in English language" title="View this article in English language" border="0">
      </b><div class="content"><content>
        <a href="http://predic8.com/activemq-hornetq-rabbitmq-apollo-qpid-comparison.htm">ActiveMQ, Qpid, HornetQ und RabbitMQ im Vergleich</a> is available in English, too.</content></div></div><div class="box" style="margin-top: 1rem"><b class="is-5">
        <a href="/activemq-schulung.htm">ActiveMQ Schulung</a>
      </b><div class="content"><content>Lerne Entwicklung, Installation, Konfiguration und Betrieb in unserem Seminar zum ActiveMQ.</content></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="columns"><div class="column"><b>Webinare</b><ul><li><a href="/api-rest-swagger-graphql-webinar.htm">REST APIs</a></li><li><a href="/microservices-webinar-online-training.htm">Microservices</a></li><li><a href="/api-rest-security-webinar-online-schulung.htm">API Sicherheit</a></li><li><a href="/camel-webinar-online-training.htm">Integration mit Apache Camel</a></li><li><a href="/kubernetes-fuer-manager-webinar-online-schulung.htm">Kubernetes f&uuml;r Manager</a></li><li><a href="/kubernetes-webinar-online-schulung.htm">Kubernetes Workshop</a></li><li><a href="/artemis-jms-2-online-training.htm">Apache Artemis</a></li></ul></div><div class="column"><b>Artikel</b><ul><li><a href="/rest-graphql-grpc-api-vergleich-artikel.htm">REST, GraphQL &amp; gRPC im Vergleich</a></li><li><a href="/service-mesh-microservices.htm">Service Mesh: Einf&uuml;hrung &amp; Vergleich von Istio und Linkerd</a></li><li><a href="/microservices-spring-boot-spring-cloud.htm">Microservices mit Spring Boot &amp; Cloud</a></li><li><a href="/api-management.htm">API Management</a></li><li><a href="/camel-fuse-mule-servicemix-talend-esb/">Camel, Nifi, JBoss Fuse, Mule
                &amp; Talend ESB im Vergleich</a></li></ul><br><b>Blog</b><ul><li><a href="/blog/api-gateway-servicemesh.htm">Unterschied zwischen API Gateway und Service Mesh</a></li><li><a href="/blog/minimale-groesse-microservice.htm">Minimale Gr&ouml;&szlig;e eines Microservice</a></li></ul></div><div class="column"><b>Sitemap</b><ul><li><a href="/jobs/">Jobs</a></li><li><a href="/impressum/">Impressum</a></li><li><a href="/unternehmen/datenschutz.htm" rel="nofollow">Datenschutzerkl&auml;rung</a></li></ul></div></div><p>&copy; 2021 predic8 GmbH Bonn (0228) 5552576-0</p><link rel="stylesheet" type="text/css" href="/cookies.css"></div></footer></body></html>