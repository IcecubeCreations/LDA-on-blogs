<!DOCTYPE HTML>


<html xmlns:ng="http://angularjs.org" id="ng-app" lang="en" ng-app="TH">

<head ng-controller="DZHeadController">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <meta name="description" ng-attr-content="{{ service.description }}" content="Enterprise Integration Patterns (EIP) have become the standard way to describe, document and implement complex integration problems. Apache Camel is an open-source project for implementing the EIP simply in a few lines of Java code or XML configuration. This DZone Refcard will guide you through the most common Enterprise Integration Patterns and give you examples of how to implement them either in Java code or using Spring XML. While it is targeted toward software developers and enterprise architects, anyone in the integration space can benefit from this Refcard.">
    <meta name="keywords" ng-attr-content="{{ service.keywords }}" content="apache,integration,refcard">

    <meta property="og:description" ng-attr-content="{{ service.description }}" content="Enterprise Integration Patterns (EIP) have become the standard way to describe, document and implement complex integration problems. Apache Camel is an open-source project for implementing the EIP simply in a few lines of Java code or XML configuration. This DZone Refcard will guide you through the most common Enterprise Integration Patterns and give you examples of how to implement them either in Java code or using Spring XML. While it is targeted toward software developers and enterprise architects, anyone in the integration space can benefit from this Refcard.">

    <meta ng-attr-content="{{ service.noIndex ? 'noindex' : '' }}" ng-attr-name="{{ service.noIndex ? 'robots' : '' }}"
          name="" content="">

    <meta property="og:site_name" ng-attr-content="{{ service.siteName }}" content="dzone.com">
    <meta property="og:title" ng-attr-content="{{ service.metaTitle ? service.metaTitle : service.title }}" content="The Top Twelve Integration Patterns for Apache Camel - DZone Refcardz">
    <meta property="og:url" ng-attr-content="{{ service.canonical }}" content="https://dzone.com/refcardz/enterprise-integration">
    <meta ng-if="service.img" ng-attr-content="{{ service.img }}" property="og:image" content="">
    <meta ng-if="service.type" ng-attr-content="{{ service.type }}" property="og:type" content="article">

    <meta name="twitter:site" content="@DZoneInc">
    <meta ng-if="service.twitterImage" ng-attr-content="{{ service.twitterImage }}" name="twitter:image" content="">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:description" ng-attr-content="{{ service.description }}" content="Enterprise Integration Patterns (EIP) have become the standard way to describe, document and implement complex integration problems. Apache Camel is an open-source project for implementing the EIP simply in a few lines of Java code or XML configuration. This DZone Refcard will guide you through the most common Enterprise Integration Patterns and give you examples of how to implement them either in Java code or using Spring XML. While it is targeted toward software developers and enterprise architects, anyone in the integration space can benefit from this Refcard.">
    <meta name="twitter:title" ng-attr-content="{{ service.metaTitle ? service.metaTitle : service.title }}" content="The Top Twelve Integration Patterns for Apache Camel - DZone Refcardz">

    <meta ng-if="service.wordCount" property="article:wordcount" ng-attr-content="{{service.wordCount}}" content="88">
    <meta name="referrer" content="origin">
    <meta name="google-site-verification" content="kndbhxcupfEqWmZclhCpB6vlgOs7QSmx2UHAGGnP2mA">

    

    <link rel="dns-prefetch" href="//www.googletagservices.com">
    <link rel="dns-prefetch" href="//www.google-analytics.com">
    <link rel="dns-prefetch" href="//a.optnmstr.com">
    <link rel="dns-prefetch" href="//ajax.googleapis.com">
    <link rel="dns-prefetch" href="//csi.gstatic.com">

    <link rel="image_src" ng-href="{{ service.img }}" href="">

    <link ng-if="service.prevPage" rel="prev" ng-href="{{ service.prevPage }}" href="">
    <link ng-if="service.nextPage" rel="next" ng-href="{{ service.nextPage }}" href="">
    <link rel="icon" type="image/x-icon" href="/themes/dz20/images/favicon.png">

        <link rel="canonical" href="https://dzone.com/refcardz/enterprise-integration" ng-href="{{service.canonical}}">

    <title ng-bind="service.metaTitle ? service.metaTitle : service.title">
        The Top Twelve Integration Patterns for Apache Camel - DZone Refcardz
    </title>

    <meta name="df-verify" content="df0d76632b4543">

<link rel="stylesheet" type="text/css" href="//dz2cdn3.dzone.com/storage/pub/15894838-combined.css" charset="utf-8"/><link rel="stylesheet" type="text/css" href="//dz2cdn3.dzone.com/storage/pub/15895081-combined.css" charset="utf-8"/></head>
<body>

    <noscript>
        <iframe src="https://www.googletagmanager.com/ns.html?id=GTM-K25QL22"
                height="0" width="0" style="display:none;visibility:hidden">
        </iframe>
    </noscript>

    <script type="application/ld+json">
        {
            "@context": "https://schema.org",
            "@type": "Organization",
            "url": "https://dzone.com",
            "logo": "https://dzone.com/themes/dz20/images/dz_logo_2021_cropped.png",
            "contactPoint": [{
                "@type": "ContactPoint",
                "telephone": "+1-919-678-0300",
                "contactType": "customer service"
            }]
        }
    </script>

    <toast></toast>

    <div class="container-fluid header" th-element="header" th-element-groups="[]" ng-hide="$root.isHidden('header')" data-th-element-name="header"><div class="row mainHeaderRow" th-element="mainHeaderRow" th-element-groups="['header']" ng-hide="$root.isHidden('mainHeaderRow')" data-th-element-name="mainHeaderRow"><div class="col-md-12 mainHeader headerHeaderV2 oUhbWOfRPSwBoUhM" th-element="mainHeader" th-element-groups="['header','mainHeaderRow']" ng-hide="$root.isHidden('mainHeader')" data-th-element-name="mainHeader" data-th-widget="header.headerV2" data-widget-header-header-v2="" ng-controller="mainHeader">
<script type="text/ng-template" id="like-article.html">
        <div class="dz-like"
             ng-class='{liked: status.liked}'
             ng-click='like()'

<a href="#">
    <i ng-class="{'icon-thumbs-up-alt': status.liked, 'icon-thumbs-up liked': !status.liked}"></i>
    <span>Like ({{ status.score }})</span>
</a>
</div>
</script>

<script type="text/ng-template" id="refcard-save.html">
    <button type="button" ng-class="{'icon-star gold': status.saved, 'icon-star-empty': !status.saved}"
            ng-click="save()" class="btn btn-save btn-lg"><span class="save-title">Save</span><span ng-if="status.saved"
                                                                                                    class="d-letter">D</span>
    </button>
</script>

<div class="header-top">
    <div class="header-container">
        <div class="pull-left logo-container">
            <div class="logo" >
                <a class="inner" href="/">
                    <img src="/themes/dz20/images/dz_logo_2021_cropped.png" width="160" height="52" alt="DZone">
                </a>
            </div>

        
        </div>

        <div class="pull-right login-and-search">

                <div class="dz-intro">Over 2 million developers have joined DZone.</div>
                <div class="mobile-invisible sign-in-join" ng-if="!$root.user.authenticated"><a href="#" ng-click="login()">Log In</a> <span class="dz-intro-span">/</span> <a href="#" ng-click="signIn()">Join</a></div>
                <button class="join-icon"><i class="icon-user" ng-if="!$root.user.authenticated" ng-click="login()"></i></button>
                <div class="headerSearch">
                    <button class="icon-search dropdown-toggle" ng-click="focusSearch()" id="dropdownMenu2" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"></button>
                    <ul class="dropdown-menu" aria-labelledby="dropdownMenu2">
                        <li>
                            <form class="form-wrapper">
                                <label for="search" class="sr-only">Search</label>
                                <input id="search" role="search" ng-model="searchT" type="text" placeholder="Search" ng-model-options="{debounce: 500}" required>
                                <input type="button" value="Search" class="btn btn-action search-button" ng-click="allResults()" ng-disabled="searchT.length < 3">
                            </form>
                        </li>

                      <div class="results-area" ng-cloak>
                          <div class="col-md-12"><th-loader flag="loading"></th-loader></div>
                          <li ng-repeat="node in nodes">
                              <div class="results-container">
                                  <img dz-image-fid-width="80" dz-image-fid="{{ node.thumb }}">
                                  <div class="results-content">
                                    <a class="title" target="{{ node.type=='link'? '_blank' : '_self'}}" ng-href="{{node.urlOrigin}}">{{node.title}}</a>
                                    <p class="source">
                                        <span class="type">{{node.type}}</span>
                                        <span class="source-bullet"> &middot;</span>
                                        <span ng-if="node.type=='link'" class="link-source">{{ node.urlSource.name }}</span>
                                        <span ng-if="node.type=='link'" aria-hidden="true" class="source-bullet"> &middot;</span>
                                        <span class="source-date" am-time-ago="node.articleDate"></span>
                                        <span ng-if="node.type != 'guide'">
                                            by <a ng-bind-html="node.authors[0].realName" href="{{ node.authors[0].url }}" target="_blank" class="author-name" th-popup="users.profile.mini" popup-data="{user: node.authors[0].id}"></a>
                                        </span>
                                    </p>
                                    <div class="hover-buttons" ng-if="node.type=='refcard'">
                                        <a type="button" class="btn download" href="{{node.pdf}}"><i class="icon-download"></i> Download</a>
                                        <dz-save template="refcard-save.html" node="node" class="save-btn"></dz-save>
                                        <span class="download-count"><i class="icon-download"></i> {{node.downloads}}</span>
                                    </div>
                                  </div>
                                  <div class="clear"></div>
                              </div>
                          </li>
                      </div>

                      <div class="results-additional-actions" ng-if="totalResults || haveResults">
                        <div class="totalResults" ng-if="totalResults"><span>{{totalResults}} search results</span></div>
                        <li class="btn-vall" ng-if="haveResults">
                            <input type="button" value="View All Results" ng-click="allResults()" class="btn btn-action" ng-disabled="searchT.length < 3">
                        </li>
                      </div>
                    </ul>
                </div>

        </div>
    </div>
</div>

<div class="header-bottom">



    <ul class="portals header-container scrollable-ul">
            <li >
                <a href="/refcardz" id="header-refcardz"
                   
                >
                    <em>
                      Refcardz
                    </em>
                </a>
            </li>
            <li >
                <a href="/trendreports" id="header-research"
                   
                >
                    <em>
                      Trend Reports
                    </em>
                </a>
            </li>
            <li >
                <a href="/webinars" id="header-webinars"
                   
                >
                    <em>
                      Webinars
                    </em>
                </a>
            </li>
            <li class="last-portal-link">
                <a href="/portals" id="header-portals"
                   
                      ng-click="toggleZones('/portals', $event)"
                >
                    <em>
                      Zones
                      <span class="collapsible-toggle {{zonesOpen ? 'open': ''}}">
                        <i class="icon-angle-down"></i>
                        <i class="icon-angle-up"></i>
                      </span>
                    </em>
                </a>
            </li>

        <li class="separator" aria-hidden="true" style="color: #d9dcdd">|</li>
        <li class="portal-topics {{zonesOpen ? 'open': ''}}">
          <ul>
                <li>
                    <a href="/agile-methodology-training-tools-news" id="header-2"
                       ng-class="{'active-state': isActivePortal(2)}"
                    >
                        Agile
                    </a>
                </li>
                <li>
                    <a href="/artificial-intelligence-tutorials-tools-news" id="header-4001"
                       ng-class="{'active-state': isActivePortal(4001)}"
                    >
                        AI
                    </a>
                </li>
                <li>
                    <a href="/big-data-analytics-tutorials-tools-news" id="header-3"
                       ng-class="{'active-state': isActivePortal(3)}"
                    >
                        Big Data
                    </a>
                </li>
                <li>
                    <a href="/cloud-computing-tutorials-tools-news" id="header-4"
                       ng-class="{'active-state': isActivePortal(4)}"
                    >
                        Cloud
                    </a>
                </li>
                <li>
                    <a href="/database-sql-nosql-tutorials-tools-news" id="header-5"
                       ng-class="{'active-state': isActivePortal(5)}"
                    >
                        Database
                    </a>
                </li>
                <li>
                    <a href="/devops-tutorials-tools-news" id="header-6"
                       ng-class="{'active-state': isActivePortal(6)}"
                    >
                        DevOps
                    </a>
                </li>
                <li>
                    <a href="/enterprise-integration-training-tools-news" id="header-7"
                       ng-class="{'active-state': isActivePortal(7)}"
                    >
                        Integration
                    </a>
                </li>
                <li>
                    <a href="/iot-developer-tutorials-tools-news-reviews" id="header-8"
                       ng-class="{'active-state': isActivePortal(8)}"
                    >
                        IoT
                    </a>
                </li>
                <li>
                    <a href="/java-jdk-development-tutorials-tools-news" id="header-1"
                       ng-class="{'active-state': isActivePortal(1)}"
                    >
                        Java
                    </a>
                </li>
                <li>
                    <a href="/microservices-news-tutorials-tools" id="header-6001"
                       ng-class="{'active-state': isActivePortal(6001)}"
                    >
                        Microservices
                    </a>
                </li>
                <li>
                    <a href="/open-source-news-tutorials-tools" id="header-7001"
                       ng-class="{'active-state': isActivePortal(7001)}"
                    >
                        Open Source
                    </a>
                </li>
                <li>
                    <a href="/apm-tools-performance-monitoring-optimization" id="header-10"
                       ng-class="{'active-state': isActivePortal(10)}"
                    >
                        Performance
                    </a>
                </li>
                <li>
                    <a href="/application-web-network-security" id="header-2001"
                       ng-class="{'active-state': isActivePortal(2001)}"
                    >
                        Security
                    </a>
                </li>
                <li>
                    <a href="/web-development-programming-tutorials-tools-news" id="header-11"
                       ng-class="{'active-state': isActivePortal(11)}"
                    >
                        Web Dev
                    </a>
                </li>
          </ul>
        </li>
    </ul>
</div></div></div></div><div class="container-fluid body" th-element="body" th-element-groups="[]" ng-hide="$root.isHidden('body')" data-th-element-name="body"><div class="row mainContentRow" th-element="mainContentRow" th-element-groups="['body']" ng-hide="$root.isHidden('mainContentRow')" data-th-element-name="mainContentRow"><div class="col-md-12 announcementBar1 announcementBar oUhbYlrRaqMaoUhM" th-element="announcementBar1" th-element-groups="['body','mainContentRow']" ng-hide="$root.isHidden('announcementBar1')" data-th-element-name="announcementBar1" data-th-widget="announcementBar" data-widget-announcement-bar="" ng-controller="announcementBar1"><div ng-if="announcement && toShow" back-img hasImage="{{announcement.hasImage}}" img="{{announcement.img}}" imgBackup="{{announcement.img2}}" id="acontainer" class="ann-container" ng-cloak>
    <div class="ann-body">{{announcement.body}}</div><a ng-if="announcement.link" class="ann-link" ng-click="track(announcement.id)" ng-ref="{{announcement.link}}">{{announcement.title}}<span class="icon-right-dir"></span></a>
</div>
</div><div class="col-md-12 refcardzTopHeaderV34 layout-card refcardzTopHeaderV3 oUhbfSbmcnWOfYfWVcC" th-element="refcardzTopHeaderV34" th-element-groups="['body','mainContentRow']" ng-hide="$root.isHidden('refcardzTopHeaderV34')" data-th-element-name="refcardzTopHeaderV34" data-th-widget="refcardz.topHeaderV3" data-widget-refcardz-top-header-v3="" ng-controller="refcardzTopHeaderV34"><div class="refcardz-header">
    <script type="text/ng-template" id="asset-save.html">
<button type="button"
        class="btn btn-save btn-lg "
        ng-class="{'icon-star gold': status.saved, 'icon-star-empty': !status.saved}"
        ng-click="save()">
    <span class="save-title">{{ status.saved ? 'saved' : 'save' }}</span>
</button>
    </script>

        <script type="application/ld+json">
            {
                "@context": "https://schema.org",
                "@type": "BreadcrumbList",
                "itemListElement": [{
                    "@type": "ListItem",
                    "position": 1,
                    "name": "DZone",
                    "item": "https://dzone.com"
                }, {
                    "@type": "ListItem",
                    "position": 2,
                    "name": "Refcardz",
                    "item": "https://dzone.com/refcardz"
                }, {
                    "@type": "ListItem",
                    "position": 3,
                    "name": "The Top Twelve Integration Patterns for Apache Camel",
                    "item": "https://dzone.com/refcardz/enterprise-integration"
                }]
            }
        </script>

    <div class="row asset-details no-mobile">

        <div class="header-background col-xs-12" style="background: url('//dz2cdn4.dzone.com/storage/rc-covers/8782979-apachecamel.png') no-repeat center center; background-size: cover;">
            <div class="breadcrumb-container row">
                <div class="col-xs-12 breadcrumb-padding">
                    <a href="/">DZone</a>
                    >
                    <a href="/refcardz">Refcardz</a>
                    >
                    <a href="#">The Top Twelve Integration Patterns for Apache Camel</a>
                </div>
            </div>

            <div class="row">
                <div class="cog-area">
                </div>

                <div class="mobile-image col-xs-12">
                    <img class="cover" src="//dz2cdn3.dzone.com/storage/rc-covers/4378-dzone_refcard_47.png" alt="refcard cover">
                </div>
            </div>

            <div class="row info-zone">
                <div class="col-xs-12 col-sm-8">
                    <span class="asset-number">Refcard #047</span>
                    <h1 class="asset-title">The Top Twelve Integration Patterns for Apache Camel</h1>
                </div>
            </div>
        </div>
        <div class="header-info-container col-xs-12">
            <div class="row info-zone">
                <div class="asset-sub-details col-xs-12 col-sm-8">
                      <h2 class="subtitle">Implement in Java or Spring XML</h2>
                    <p class="asset-description">Check out the 12 most common integration patterns and implementation methods for Apache Camel.</p>
                    <div class="button-container">
                        <div class="download-save">
                                <div class="asset-buttons no-campaign">
                                    <dz-download asset="'/asset/download/232'" user="false" cta="'Refcard'"></dz-download>
                                    <div class="download-label">Free PDF for Easy Reference</div>
                                </div>
                        </div>
                    </div>
                </div>
                <div class="col-xs-12 col-sm-4 asset-authors-zone">
                    <a type="button" class="cover-download" ng-click="$root.user.authenticated ? showDownload() : showRegistration()">
                        <img class="cover" src="//dz2cdn3.dzone.com/storage/rc-covers/4378-dzone_refcard_47.png" alt="refcard cover">
                    </a>
                    <div class="row">
                        <div class="col-xs-12 asset-authors">
                            <div class="col-xs-12 writing-by">
                                <p>Written By</p>
                            </div>
                            <div class="col-xs-12 asset-authors">
                                    <div class="asset-author">
                                        <a class="asset-author-avatar" href="/users/354055/davsclaus.html">
                                            <img src="https://secure.gravatar.com/avatar/62d4ca92192b41f45829db7b7020ee0e?d=identicon&r=PG" alt="author avatar" class="avatar" width="40">
                                        </a>
                                        <span class="asset-author-info">
                                            <a href="/users/354055/davsclaus.html" class="asset-author-name" th-popup="users.profile.mini" popup-data="{user: 354055}">
                                                Claus Ibsen
                                            </a>
                                            <div>Senior Principal Software Engineer, Red Hat</div>
                                        </span>
                                    </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="col-xs-12 separator"></div>
        </div>
    </div>
</div></div><div class="col-md-12 assetsContentChapters5 layout-card assetsContentChapters oUhbcgvMlhqMSsfboUhM" th-element="assetsContentChapters5" th-element-groups="['body','mainContentRow']" ng-hide="$root.isHidden('assetsContentChapters5')" data-th-element-name="assetsContentChapters5" data-th-widget="assets.content.chapters" data-widget-assets-content-chapters="" ng-controller="assetsContentChapters5"><div class="refcard-details row">
    <div class="obsolete-warning" ng-if="refcard.isOld" ng-cloak>
        <old-warning-message time="refcard.creationDate" body="daysOldBody" type="refcard.rawType" title="daysOldTitle"></old-warning-message>
    </div>

    <div class="refcard-content row">
        <div class="col-xs-12">
            <div id="table-contents">
                <div class="tc-title">
                    <span class="tc-blue">Table of Contents</span>
                    <span class="tc-separator"></span>
                </div>

                <div class="chapter-index">
                                            <a class="tc-chapter-title" ng-click="scrollTo($event, '#section-1')" href="#section-1">
                            <span aria-hidden="true">&#9658;</span>
                            About Enterprise Integration Patterns
                        </a>
                        <a class="tc-chapter-title" ng-click="scrollTo($event, '#section-2')" href="#section-2">
                            <span aria-hidden="true">&#9658;</span>
                            About Apache Camel
                        </a>
                        <a class="tc-chapter-title" ng-click="scrollTo($event, '#section-3')" href="#section-3">
                            <span aria-hidden="true">&#9658;</span>
                            Essential Patterns
                        </a>
                        <a class="tc-chapter-title" ng-click="scrollTo($event, '#section-4')" href="#section-4">
                            <span aria-hidden="true">&#9658;</span>
                            Conclusion
                        </a>
                </div>
            </div>

                <div class="content">
                    <div id="section-1" class="chapter-box tc-blue">Section 1</div>
                    <h2 class="chapter-title">About Enterprise Integration Patterns</h2>
                    <div class="content-html" dz-code-container ng-non-bindable>
                        <p pid="2">Integration is a hard problem. To help deal with the complexity of integration problems the Enterprise Integration Patterns (EIP) have become the standard way to describe, document and implement complex integration problems. Hohpe &amp; Woolf's book the Enterprise Integration Patterns has become the bible in the integration space - essential reading for any integration professional.</p><p pid="3">Apache Camel is an open source project for implementing the EIP easily in a few lines of Java code or Spring XML configuration. This reference card, the first in a two card series, guides you through the most common Enterprise Integration Patterns and gives you examples of how to implement them either in Java code or using Spring XML. This Refcard is targeted for software developers and enterprise architects, but anyone in the integration space can benefit as well.</p>
                    </div>
                </div>
                <div class="content">
                    <div id="section-2" class="chapter-box tc-blue">Section 2</div>
                    <h2 class="chapter-title">About Apache Camel</h2>
                    <div class="content-html" dz-code-container ng-non-bindable>
                        <p pid="4">Apache Camel is a powerful open source integration platform based on Enterprise Integration Patterns (EIP) with powerful Bean Integration. Camel lets you implementing EIP routing using Camels intuitive Domain Specific Language (DSL) based on Java (aka fluent builder) or XML. Camel uses URI for endpoint resolution so its very easy to work with any kind of transport such as HTTP, REST, JMS, web service, File, FTP, TCP, Mail, JBI, Bean (POJO) and many others. Camel also provides Data Formats for various popular formats such as: CSV, EDI, FIX, HL7, JAXB, Json, Xstream. Camel is an integration API that can be embedded in any server of choice such as: J2EE Server, ActiveMQ, Tomcat, OSGi, or as standalone. Camels Bean Integration let you define loose coupling allowing you to fully separate your business logic from the integration logic. Camel is based on a modular architecture allowing you to plugin your own component or data format, so they seamlessly blend in with existing modules. Camel provides a test kit for unit and integration testing with strong mock and assertion capabilities.</p>
                    </div>
                </div>
                <div class="content">
                    <div id="section-3" class="chapter-box tc-blue">Section 3</div>
                    <h2 class="chapter-title">Essential Patterns</h2>
                    <div class="content-html" dz-code-container ng-non-bindable>
                        <p pid="5">This group consists of the most essential patterns that anyone working with integration must know.</p><h3>Pipes and Filters</h3><table cellpadding="0" cellspacing="0">
 <tbody>
  <tr>
   <td><img alt="Diagram" class="fr-dii fr-fil" src="images/rc047-010d-enterprise_integration_patterns-1.jpg" /></td>
   <td class="light_cream">How can we perform complex processing on a message while maintaining independence and flexibility?</td>
  </tr>
  <tr>
   <td colspan="2"><img alt="Pipes and Filters" class="fr-dii fr-fil" src="images/rc047-010d-enterprise_integration_patterns-2.jpg" /></td>
  </tr>
 </tbody>
</table><table cellpadding="0" cellspacing="0">
 <tbody>
  <tr>
   <td class="light_blue">Problem</td>
   <td class="light_cream">A single event often triggers a sequence of processing steps</td>
  </tr>
  <tr>
   <td class="light_blue">Solution</td>
   <td class="light_cream">Use Pipes and Filters to divide a larger processing steps (filters) that are connected by channels (pipes)</td>
  </tr>
  <tr>
   <td class="light_blue">Camel</td>
   <td class="light_cream">Camel supports Pipes and Filters using the <strong>pipeline</strong> node.</td>
  </tr>
  <tr>
   <td class="light_blue">Java DSL</td>
   <td class="light_cream"><pre><code lang="text/x-java">
from(&quot;jms:queue:order:in&quot;).pipeline(&quot;direct:transformOrder&quot;, &quot;direct:validateOrder&quot;, &quot;jms:queue:order:process&quot;);
</code></pre><p>Where jms represents the JMS component used for consuming JMS messages on the JMS broker. Direct is used for combining endpoints in a synchronous fashion, allow you to divide routes into sub routes and/or reuse common routes.</p><p><strong>Tip:</strong> Pipeline is the default mode of operation when you specify multiple outputs, so it can be omitted and replaced with the more common node:</p><pre><code lang="text/x-java">
from(&quot;jms:queue:order:in&quot;).to(&quot;direct:transformOrder&quot;,
&quot;direct:validateOrder&quot;, &quot;jms:queue:order:process&quot;);
</code></pre><p><strong>TIP:</strong> You can also separate each step as individual <strong>to</strong> nodes:</p><pre><code lang="text/x-java">
from(&quot;jms:queue:order:in&quot;)
        .to(&quot;direct:transformOrder&quot;)
        .to(&quot;direct:validateOrder&quot;)
        .to(&quot;jms:queue:order:process&quot;);
</code></pre></td>
  </tr>
  <tr>
   <td class="light_blue">Spring DSL</td>
   <td class="light_cream"><pre><code lang="text/x-java">
&lt;route&gt;
        &lt;from uri=&quot;jms:queue:order:in&quot;/&gt;
        &lt;pipeline&gt;
                &lt;to uri=&quot;direct:transformOrder&quot;/&gt;
                &lt;to uri=&quot;direct:validateOrder&quot;/&gt;
                &lt;to uri=&quot;jms:queue:order:process&quot;/&gt;
        &lt;/pipeline&gt;
&lt;/route&gt;
&lt;route&gt;
        &lt;from uri=&quot;jms:queue:order:in&quot;/&gt;
        &lt;to uri=&quot;direct:transformOrder&quot;/&gt;
        &lt;to uri=&quot;direct:validateOrder&quot;/&gt;
        &lt;to uri=&quot;jms:queue:order:process&quot;/&gt;
&lt;/route&gt;</code></pre><br /><br /></td>
  </tr>
 </tbody>
</table><h3>Message Router</h3><table cellpadding="0" cellspacing="0">
 <tbody>
  <tr>
   <td><img alt="Diagram" class="fr-dii fr-fil" height="23" src="images/rc047-010d-enterprise_integration_patterns-3.jpg" width="42" /></td>
   <td class="light_cream">How can you deouple indevidual processing steps so that messages can be passed to different filters depending on a set of conditions?</td>
  </tr>
  <tr>
   <td colspan="2"><img alt="Message Router" class="fr-dii fr-fil" src="images/rc047-010d-enterprise_integration_patterns-4.jpg" /></td>
  </tr>
  <tr>
   <td class="light_blue">Problem</td>
   <td class="light_cream">Pipes and Filters route each message in the same processing steps. How can we route messages differently?</td>
  </tr>
  <tr>
   <td class="light_blue">Solution</td>
   <td class="light_cream">Filter using predicates to choose the right output destination.</td>
  </tr>
  <tr>
   <td class="light_blue">Camel</td>
   <td class="light_cream">Camel supports Message Router using the <strong>choice</strong> node. For more details see the Content Based router pattern.</td>
  </tr>
 </tbody>
</table><h3>Content-Based Router</h3><table cellpadding="0" cellspacing="0">
 <tbody>
  <tr>
   <td><img alt="Diagram" class="fr-dii fr-fil" src="images/rc047-010d-enterprise_integration_patterns-5.jpg" /></td>
   <td class="light_cream">How do we handle a situation where the implementation of a single logical function (e.g., inventory check) is spread across multiple physical systems?</td>
  </tr>
  <tr>
   <td colspan="2"><img alt="Content-Based Router" class="fr-dii fr-fil" src="images/rc047-010d-enterprise_integration_patterns-6.jpg" /></td>
  </tr>
  <tr>
   <td class="light_blue">Problem</td>
   <td class="light_cream">How do we ensure a Message is sent to the correct recipient based on information from its content?</td>
  </tr>
  <tr>
   <td class="light_blue">Solution</td>
   <td class="light_cream">Use a Content-Based Router to route each message to the correct recipient based on the message content.</td>
  </tr>
  <tr>
   <td class="light_blue">Camel</td>
   <td class="light_cream">Camel has extensive support for Content-Based Routing. Camel supports content based routing based on <strong>choice, filter,</strong> or any other expression.</td>
  </tr>
  <tr>
   <td class="light_blue">Java DSL</td>
   <td class="light_cream"><h4>Choice</h4><pre><code lang="text/x-java">
from(&quot;jms:queue:order&quot;)
.choice()
.when(header(&quot;type&quot;).in(&quot;widget&quot;,&quot;wiggy&quot;))
.to(&quot;jms:queue:order:widget&quot;)
.when(header(&quot;type&quot;).isEqualTo(&quot;gadget&quot;))
.to(&quot;jms:queue:order:gadget&quot;)
.otherwise().to(&quot;jms:queue:order:misc&quot;)
.end();
</code></pre><p><strong>TIP:</strong> In the route above end() can be omitted as its the last node and we do not route the message to a new destination after the choice.</p><p><strong>TIP:</strong> You can continue routing after the choice ends.</p></td>
  </tr>
  <tr>
   <td class="light_blue">Spring DSL</td>
   <td class="light_cream"><h4>Choice</h4><pre><code lang="text/x-java">
&lt;route&gt;
        &lt;from uri=&quot;jms:queue:order&quot;/&gt;
        &lt;choice&gt;
                &lt;when&gt;
                        &lt;simple&gt;${header.type} in 'widget,wiggy'&lt;/simple&gt;
                        &lt;to uri=&quot;jms:queue:order:widget&quot;/&gt;
                &lt;/when&gt;
                &lt;when&gt;
                        &lt;simple&gt;${header.type} == 'gadget'&lt;/simple&gt;
                        &lt;to uri=&quot;jms:queue:order:gadget&quot;/&gt;
                &lt;/when&gt;
                &lt;otherwise&gt;
                        &lt;to uri=&quot;jms:queue:order:misc&quot;/&gt;
                &lt;/otherwise&gt;
        &lt;/choice&gt;
&lt;/route&gt;
</code></pre><p><strong>TIP:</strong> In Spring DSL you cannot invoke code, as opposed to the Java DSL that is 100% Java. To express the predicates for the choices we need to use a language. We will use simple language that uses a simple expression parser that supports a limited set of operators. You can use any of the more powerful languages supported in Camel such as: JavaScript, Groovy, Unified EL and many others.</p><p><strong>TIP:</strong> You can also use a method call to invoke a method on a bean to evaluate the predicate. Lets try that:</p><pre><code lang="text/x-java">
&lt;when&gt;
        &lt;method bean=&quot;myBean&quot; method=&quot;isGadget&quot;/&gt;
        ...
&lt;/when&gt;

&lt;bean id=&quot;myBean&quot; class=&quot;com.mycomapany.MyBean&quot;/&gt;

public boolean isGadget(@Header(name = &quot;type&quot;) String type) {
        return type.equals(&quot;Gadget&quot;);
}
</code></pre><p>Notice how we use Bean Parameter Binding to instruct Camel to invoke this method and pass in the type header as the String parameter. This allows your code to be fully decoupled from any Camel API so its easy to read, write and unit test.</p></td>
  </tr>
 </tbody>
</table><h3>Message Translator</h3><table cellpadding="0" cellspacing="0">
 <tbody>
  <tr>
   <td><img alt="Diagram" class="fr-dii fr-fil" src="images/rc047-010d-enterprise_integration_patterns-7.jpg" /></td>
   <td class="light_cream">How can systems using different data formats communicate with each other using messaging?</td>
  </tr>
  <tr>
   <td colspan="2"><img alt="Message Translator" class="fr-dii fr-fil" src="images/rc047-010d-enterprise_integration_patterns-8.jpg" /></td>
  </tr>
  <tr>
   <td class="light_blue">Problem</td>
   <td class="light_cream">Each application uses its own data format, so we need to translate the message into the data format the application supports.</td>
  </tr>
  <tr>
   <td class="light_blue">Solution</td>
   <td class="light_cream">Use a special filter, a messae translator, between filters or applications to translate one data format into another.</td>
  </tr>
  <tr>
   <td class="light_blue">Camel</td>
   <td class="light_cream">Camel supports the message translator using the <strong>processor, bean</strong> or <strong>transform</strong> nodes. TIP: Camel routes the message as a chain of <strong>processor</strong> nodes.</td>
  </tr>
  <tr>
   <td class="light_blue">Java DSL</td>
   <td class="light_cream"><h4>Processor</h4><pre><code lang="text/x-java">
public class OrderTransformProcessor
                implements Processor {
        public void process(Exchange exchange)
                        throws Exception {
                // do message translation here
        }
}
from(&quot;direct:transformOrder&quot;)
        .process(new OrderTransformProcessor());
</code></pre><h4>Bean</h4><p>Instead of the processor we can use Bean (POJO). An advantage of using a Bean over Processor is the fact that we do not have to implement or use any Camel specific interfaces or types. This allows you to fully decouple your beans from Camel.</p><pre><code lang="text/x-java">
public class OrderTransformerBean {
        public StringtransformOrder(String body) {
                // do message translation here
        }
}
Object transformer = new OrderTransformerBean();
from(&quot;direct:transformOrder&quot;).bean(transformer);
</code></pre><p><strong>TIP:</strong> Camel can create an instance of the bean automatically; you can just refer to the class type.</p><pre><code lang="text/x-java">
from(&quot;direct:transformOrder&quot;)
        .bean(OrderTransformerBean.class);
</code></pre><p><strong>TIP:</strong> Camel will try to figure out which method to invoke on the bean in case there are multiple methods. In case of ambiguity you can specify which methods to invoke by the method parameter:</p><pre><code lang="text/x-java">
from(&quot;direct:transformOrder&quot;)
        .bean(OrderTransformerBean.class, &quot;transformOrder&quot;);
</code></pre><h4>Transform</h4><p>Transform is a particular processor allowing you to set a response to be returned to the original caller. We use transform to return a constant ACK response to the TCP listener after we have copied the message to the JMS queue. Notice we use a constant to build an &quot;ACK&quot; string as response.</p><pre><code lang="text/x-java">
from(&quot;mina:tcp://localhost:8888?textline=true&quot;)
        .to(&quot;jms:queue:order:in&quot;)
        .transform(constant(&quot;ACK&quot;));
</code></pre></td>
  </tr>
  <tr>
   <td class="light_blue">Spring DSL</td>
   <td class="light_cream"><h4>Processor</h4><pre><code lang="text/x-java">
&lt;route&gt;
        &lt;from uri=&quot;direct:transformOrder&quot;/&gt;
        &lt;process ref=&quot;transformer&quot;/&gt;
&lt;/route&gt;

&lt;bean id=&quot;transformer&quot; class=&quot;com.mycompany.
OrderTransformProcessor&quot;/&gt;
</code></pre><p>In Spring DSL Camel will look up the processor or POJO/Bean in the registry based on the id of the bean.</p><h4>Bean</h4><pre><code lang="text/x-java">
&lt;route&gt;
&lt;from uri=&quot;direct:transformOrder&quot;/&gt;
&lt;bean ref=&quot;transformer&quot;/&gt;
&lt;/route&gt;
&lt;bean id=&quot;tramsformer&quot;
class=&quot;com.mycompany.OrderTransformBean&quot;/&gt;
</code></pre><h4>Transform</h4><pre><code lang="text/x-java">
&lt;route&gt;
&lt;from uri=&quot;mina:tcp://localhost:8888?textline=true&quot;/&gt;
&lt;to uri=&quot;jms:queue:order:in&quot;/&gt;
&lt;transform&gt;
&lt;constant&gt;ACK&lt;/constant&gt;
&lt;/transform&gt;
&lt;/route&gt;
</code></pre></td>
  </tr>
  <tr>
   <td class="light_blue">Annotation DSL</td>
   <td class="light_cream"><p>You can also use the <strong>@Consume</strong> annotation for transformations. For example in the method below we consume from a JMS queue and do the transformation in regular Java code. Notice that the input and output parameters of the method is String. Camel will automatically coerce the payload to the expected type defined by the method. Since this is a JMS example the response will be sent back to the JMS reply-to destination.</p><pre><code lang="text/x-java">
@Consume(uri=&quot;jms:queue:order:transform&quot;)
public String transformOrder(String body) {
        // do message translation
}
</code></pre><p><strong>TIP:</strong> You can use Bean Parameter Binding to help Camel coerce the Message into the method parameters. For instance you can use <strong>@Body, @Headers</strong> parameter annotations to bind parameters to the body and headers.</p></td>
  </tr>
 </tbody>
</table><h3>Message Filter</h3><table cellpadding="0" cellspacing="0">
 <tbody>
  <tr>
   <td><img alt="Diagram" class="fr-dii fr-fil" src="images/rc047-010d-enterprise_integration_patterns-9.jpg" /></td>
   <td class="light_cream">How can a component avoid receiving unwanted messages?</td>
  </tr>
  <tr>
   <td colspan="2"><img alt="Message Filter" class="fr-dii fr-fil" src="images/rc047-010d-enterprise_integration_patterns-10.jpg" /></td>
  </tr>
  <tr>
   <td class="light_blue">Problem</td>
   <td class="light_cream">How do you discard unwanted messages?</td>
  </tr>
  <tr>
   <td class="light_blue">Solution</td>
   <td class="light_cream">Use a special kind of Message Router, a Message Filter, to eliminate undesired messages from a channel based on a set of criteria.</td>
  </tr>
  <tr>
   <td class="light_blue">Camel</td>
   <td class="light_cream">Camel has support for Message Filter using the filter node. The filter evaluates a predicate whether its true or false; only allowing the true condition to pass the filter, where as the false condition will silently be ignored.</td>
  </tr>
  <tr>
   <td class="light_blue">Java DSL</td>
   <td class="light_cream">We want to discard any test messages so we only route non-test messages to the order queue. <pre><code lang="text/x-java">
from(&quot;jms:queue:inbox&quot;)
        .filter(header(&quot;test&quot;).isNotEqualTo(&quot;true&quot;))
        .to(&quot;jms:queue:order&quot;);</code></pre><br /><br /></td>
  </tr>
  <tr>
   <td class="light_blue">Spring DSL</td>
   <td class="light_cream">For the Spring DSL we use XPath to evaluate the predicate. The $test is a special shorthand in Camel to refer to the header with the given name. So even if the payload is not XML based we can still use XPath to evaluate predicates. <pre><code lang="text/x-java">
&lt;route&gt;
        &lt;from uri=&quot;jms:queue:inbox&quot;/&gt;
        &lt;filter&gt;
                &lt;xpath&gt;$test = 'false'&lt;/xpath&gt;
                &lt;to uri=&quot;jms:queue:inbox&quot;/&gt;
        &lt;/filter&gt;
&lt;/route&gt;</code></pre><br /><br /></td>
  </tr>
 </tbody>
</table><h3>Dynamic Router</h3><table cellpadding="0" cellspacing="0">
 <tbody>
  <tr>
   <td><img alt="Diagram" class="fr-dii fr-fil" src="images/rc047-010d-enterprise_integration_patterns-11.jpg" /></td>
   <td class="light_cream"></td>
  </tr>
  <tr>
   <td colspan="2"><img alt="Dynamic Router" class="fr-dii fr-fil" src="images/rc047-010d-enterprise_integration_patterns-12.jpg" /></td>
  </tr>
  <tr>
   <td class="light_blue">Problem</td>
   <td class="light_cream">How can we route messages based on a dynamic list of destinations?</td>
  </tr>
  <tr>
   <td class="light_blue">Solution</td>
   <td class="light_cream">Use a Dynamic Router, a router that can self-configure based on special configuration messages from participating destinations.</td>
  </tr>
  <tr>
   <td class="light_blue">Camel</td>
   <td class="light_cream">Camel has support for Dynamic Router using the Dynamic <strong>Recipient List</strong> combined with a data store holding the list of destinations.</td>
  </tr>
  <tr>
   <td class="light_blue">Java DSL</td>
   <td class="light_cream">We use a Processor as the dynamic router to determine the destinations. We could also have used a Bean instead. <pre><code lang="text/x-java">
from(&quot;jms:queue:order&quot;)
        .processRef(myDynamicRouter)
        .recipientList(&quot;destinations&quot;);

public class MyDynamicRouter implements Processor {
        public void process(Exchange exchange) {
                // query a data store to find the best match of the
                // endpoint and return the destination(s) in the
                // header exchange.getIn()
                // .setHeader(&quot;destinations&quot;, list);
        }
}</code></pre><br /><br /></td>
  </tr>
  <tr>
   <td class="light_blue">Spring DSL</td>
   <td class="light_cream"><pre><code lang="text/x-java">
&lt;route&gt;
        &lt;from uri=&quot;jms:queue:order&quot;/&gt;
        &lt;process ref=&quot;myDynamicRouter&quot;/&gt;
        &lt;recipientList&gt;
                &lt;header&gt;destinations&lt;/destinations&gt;
        &lt;/recipientList&gt;
&lt;/route&gt;</code></pre><br /><br /></td>
  </tr>
  <tr>
   <td class="light_blue">Annotation DSL</td>
   <td class="light_cream"><pre><code lang="text/x-java">
public class MyDynamicRouter {
        @Consume(uri = &quot;jms:queue:order&quot;)
        @RecipientList
        public List&lt;String&gt; route(@XPath(&quot;/customer/id&quot;)
String customerId, @Header(&quot;location&quot;) String location,
Document body) {
                // query data store, find best match for the
                //endpoint and return destination (s)
        }
}
</code></pre><p><strong>TIP:</strong> Notice how we used Bean Parameter Binding to bind the parameters to the route method based on an <strong>@XPath</strong> expression on the XML payload of the JMS message. This allows us to extract the customer id as a string parameter. <strong>@Header</strong> wil bind a JMS property with the key location. <strong>Document</strong> is the XML payload of the JMS message.</p><p><strong>TIP:</strong> Camel uses its strong type converter feature to convert the payload to the type of the method parameter. We could use String and Camel will convert the body to a String instead. You can register your own type converters as well using the <strong>@Converter</strong> annotation at the class and method level.</p></td>
  </tr>
 </tbody>
</table><h3>Recipient List</h3><table cellpadding="0" cellspacing="0">
 <tbody>
  <tr>
   <td><img alt="Diagram" class="fr-dii fr-fil" src="images/rc047-010d-enterprise_integration_patterns-13.jpg" /></td>
   <td class="light_cream">How do we route a message to a list of statically or dynamically specified recipients?</td>
  </tr>
  <tr>
   <td colspan="2"><img alt="Recipient List" class="fr-dii fr-fil" src="images/rc047-010d-enterprise_integration_patterns-14.jpg" /></td>
  </tr>
  <tr>
   <td class="light_blue">Problem</td>
   <td class="light_cream">How can we route messages based on a static or dynamic list of destinations?</td>
  </tr>
  <tr>
   <td class="light_blue">Solution</td>
   <td class="light_cream">Define a channel for each recipient. Then use a Recipient List to inspect an incoming message, determine the list of desired recipients and forward the message to all channels associated with the recipients in the list.</td>
  </tr>
  <tr>
   <td class="light_blue">Camel</td>
   <td class="light_cream">Camel supports the static Recipient List using the <strong>multicast</strong> node, and the dynamic Recipient List using the <strong>recipientList</strong> node.</td>
  </tr>
  <tr>
   <td class="light_blue">Java DSL</td>
   <td class="light_cream"><h4>Static</h4><p>In this route we route to a static list of two recipients, that will receive a copy of the same message simultaneously.</p><pre><code lang="text/x-java">
from(&quot;jms:queue:inbox&quot;)
        .multicast().to(&quot;file://backup&quot;, &quot;seda:inbox&quot;);
</code></pre><h4>Dynamic</h4><p>In this route we route to a dynamic list of recipients defined in the message header [mails] containing a list of recipients as endpoint URLs. The bean processMails is used to add the header[mails] to the message.</p><pre><code lang="text/x-java">
from(&quot;seda:confirmMails&quot;).beanRef(processMails)
        .recipientList(&quot;destinations&quot;);
</code></pre><p>And in the process mails bean we use <strong>@Headers</strong> Bean Parameter Binding to provide a <strong>java.util.Map</strong> to store the recipients.</p><pre><code lang="text/x-java">
public void confirm(@Headers Map headers, @Body String body} {
        String[] recipients = ...
        headers.put(&quot;&quot;destinations&quot;, recipients);
}
</code></pre></td>
  </tr>
  <tr>
   <td class="light_blue">Spring DSL</td>
   <td class="light_cream"><h4>Static</h4><pre><code lang="text/x-java">
&lt;route&gt;
        &lt;from uri=&quot;jms:queue:inbox&quot; /&gt;
        &lt;multicast&gt;
                &lt;to uri=&quot;file://backup&quot;/&gt;
                &lt;to uri=&quot;seda:inbox&quot;/&gt;
        &lt;/multicast&gt;
&lt;/route&gt;
</code></pre><h4>Dynamic</h4><p>In this example we invoke a method call on a Bean to provide the dynamic list of recipients.</p><pre><code lang="text/x-java">
&lt;route&gt;
        &lt;from uri=&quot;jms:queue:inbox&quot; /&gt;
        &lt;recipientList&gt;
                &lt;method bean=&quot;myDynamicRouter&quot; method=&quot;route&quot;/&gt;
        &lt;/recipientList&gt;
&lt;/route&gt;

&lt;bean id=&quot;myDynamicRouter&quot;
        class=&quot;com.mycompany.MyDynamicRouter&quot;/&gt;

public class myDynamicRouter {
        public String[] route(String body) {
                return new String[] { &quot;file://backup&quot;, .... }
        }
}
</code></pre></td>
  </tr>
  <tr>
   <td class="light_blue">Annotation DSL</td>
   <td class="light_cream"><p>In the CustomerService class we annoate the <strong>whereTo</strong> method with <strong>@RecipientList</strong>, and return a single destination based on the customer id. Notice the flexibility of Camel as it can adapt accordingly to how you define what your methods are returning: a single element, a list, an iterator, etc.</p><pre><code lang="text/x-java">
public class CustomerService {
        @RecipientList
        public String whereTo(@Header(&quot;customerId&quot;) id) {
                return &quot;jms:queue:customer:&quot; + id;
        }
}
</code></pre><p>And then we can route to the bean and it will act as a dynamic recipient list.</p><pre><code lang="text/x-java">
from(&quot;jms:queue:inbox&quot;)
        .bean(CustomerService.class, &quot;whereTo&quot;);
</code></pre></td>
  </tr>
 </tbody>
</table><h3>Splitter</h3><table cellpadding="0" cellspacing="0">
 <tbody>
  <tr>
   <td><img alt="Diagram" class="fr-dii fr-fil" src="images/rc047-010d-enterprise_integration_patterns-15.jpg" /></td>
   <td class="light_cream">How can we process a message if it contains multiple elements, each of which may have to be processed in a different way?</td>
  </tr>
  <tr>
   <td colspan="2"><img alt="Splitter" class="fr-dii fr-fil" src="images/rc047-010d-enterprise_integration_patterns-16.jpg" /></td>
  </tr>
  <tr>
   <td class="light_blue">Problem</td>
   <td class="light_cream">How can we split a single message into pieces to be routed individually?</td>
  </tr>
  <tr>
   <td class="light_blue">Solution</td>
   <td class="light_cream">Use a Splitter to break out the composite message into a series of individual messages, each containing data related to one item.</td>
  </tr>
  <tr>
   <td class="light_blue">Camel</td>
   <td class="light_cream">Camel has support for Splitter using the <strong>split</strong> node.</td>
  </tr>
  <tr>
   <td class="light_blue">Java DSL</td>
   <td class="light_cream"><p>In this route we consume files from the inbox folder. Each file is then split into a new message. We use a tokenizer to split the file content line by line based on line breaks.</p><pre><code lang="text/x-java">
from(&quot;file://inbox&quot;)
        .split(body().tokenize(&quot;\n&quot;))
        .to(&quot;seda:orderLines&quot;);
</code></pre><p><strong>TIP:</strong> Camel also supports splitting streams using the streaming node. We can split the stream by using a comma:</p><pre><code lang="text/x-java">
.split(body().tokenize(&quot;,&quot;)).streaming().to(&quot;seda:parts&quot;);
</code></pre><p><strong>TIP:</strong> In the routes above each individual split message will be executed in sequence. Camel also supports parallel execution using the parallelProcessing node.</p><pre><code lang="text/x-java">
.split(body().tokenize(&quot;,&quot;)).streaming()
        .parallelProcessing().to(&quot;seda:parts&quot;);
</code></pre></td>
  </tr>
  <tr>
   <td class="light_blue">Spring DSL</td>
   <td class="light_cream">In this route we use XPath to split XML payloads received on the JMS order queue. <pre><code lang="text/x-java">
&lt;route&gt;
        &lt;from uri=&quot;jms:queue:order&quot;/&gt;
        &lt;split&gt;
                &lt;xpath&gt;/invoice/lineItems&lt;/xpath&gt;
                &lt;to uri=&quot;seda:processOrderLine&quot;/&gt;
        &lt;/split&gt;
&lt;/route&gt;
</code></pre><p>And in this route we split the messages using a regular expression</p><pre><code lang="text/x-java">
&lt;route&gt;
        &lt;from uri=&quot;jms:queue:order&quot;/&gt;
        &lt;split&gt;
                &lt;tokenizer token=&quot;([A-Z|0-9]*);&quot; regex=&quot;true&quot;/&gt;
                &lt;to uri=&quot;seda:processOrderLine&quot;/&gt;
        &lt;/split&gt;
&lt;/route&gt;
</code></pre><p><strong>TIP:</strong> Split evaluates an org.apahce.camel.Expression to provide something that is iterable to produce each individual new message. This allows you to provide any kind of expression such as a Bean invoked as a method call.</p><pre><code lang="text/x-java">
&lt;split&gt;
        &lt;method bean=&quot;mySplitter&quot; method=&quot;splitMe&quot;/&gt;
        &lt;to uri=&quot;seda:processOrderLine&quot;/&gt;
&lt;/split&gt;

&lt;bean id=&quot;mySplitter&quot; class=&quot;com.mycompany.MySplitter&quot;/&gt;

public List splitMe(String body) {
        // split using java code and return a List
        List parts = ...
        return parts;
}
</code></pre></td>
  </tr>
 </tbody>
</table><h3>Aggregator</h3><table cellpadding="0" cellspacing="0">
 <tbody>
  <tr>
   <td><img alt="Diagram" class="fr-dii fr-fil" src="images/rc047-010d-enterprise_integration_patterns-17.jpg" /></td>
   <td class="light_cream">How do we combine the results of individual, but related messages so that they can be processed as a whole?</td>
  </tr>
  <tr>
   <td colspan="2"><img alt="Message Router" class="fr-dii fr-fil" src="images/rc047-010d-enterprise_integration_patterns-18.jpg" /></td>
  </tr>
  <tr>
   <td class="light_blue">Problem</td>
   <td class="light_cream">How do we combine multiple messages into a single combined message?</td>
  </tr>
  <tr>
   <td class="light_blue">Solution</td>
   <td class="light_cream">Use a stateful filter, an Aggregator, to collect and store individual messages until it receives a complete set of related messages to be published.</td>
  </tr>
  <tr>
   <td class="light_blue">Camel</td>
   <td class="light_cream">Camel has support for the Aggregator using the aggregate node. Camel uses a stateful batch processor that is capable of aggregating related messaged into a single combined message. A correlation expression is used to determine which messages should be aggregated. An aggregation strategy is used to combine aggregated messages into the result message. Camel’s aggregator also supports a completion predicate allowing you to signal when the aggregation is complete. Camel also supports other completion signals based on timeout and/or a number of messages already aggregated.</td>
  </tr>
  <tr>
   <td class="light_blue">Java DSL</td>
   <td class="light_cream"><h4>Stock quote example</h4><p>We want to update a website every five minutes with the latest stock quotes. The quotes are received on a JMS topic. As we can receive multiple quotes for the same stock within this time period we only want to keep the last one as its the most up to date. We can do this with the aggregator:</p><pre><code lang="text/x-java">
from(&quot;jms:topic:stock:quote&quot;)
        .aggregate().xpath(&quot;/quote/@symbol&quot;)
        .batchTimeout(5 * 60 * 1000).to(&quot;seda:quotes&quot;);
</code></pre><p>As the correlation expression we use XPath to fetch the stock symbol from the message body. As the aggregation strategy we use the default provided by Camel that picks the latest message, and thus also the most up to date. The time period is set as a timeout value in milliseconds.</p><h4>Loan broker example</h4><p>We aggregate responses from various banks for their quote for a given loan request. We want to pick the bank with the best quote (the cheapest loan), therefore we need to base our aggregation strategy to pick the best quote.</p><pre><code lang="text/x-java">
from(&quot;jms:topic:loan:quote&quot;)
        .aggregate().header(&quot;loanId&quot;)
        .aggregationStrategy(bestQuote)
        .completionPredicate(header(Exchange.AGGREGATED_SIZE)
        .isGreaterThan(2))
        .to(&quot;seda:bestLoanQuote&quot;);
</code></pre><p>We use a completion predicate that signals when we have received more than 2 quotes for a given loan, giving us at least 3 quotes to pick among. The following shows the code snippet for the aggregation strategy we must implement to pick the best quote:</p><pre><code lang="text/x-java">
public class BestQuoteStrategy implements AggregationStrategy {
        public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {
                double oldQuote = oldExchange.getIn().getBody(Double.class);
                double newQuote = newExchange.getIn().getBody(Double.class);
                // return the &quot;winner&quot; that has the lowest quote
                return newQuote &lt; oldQuote ? newExchange : oldExchange;
        }
}
</code></pre></td>
  </tr>
  <tr>
   <td class="light_blue">Spring DSL</td>
   <td class="light_cream"><h4>Loan Broker Example</h4><pre><code lang="text/x-java">
&lt;route&gt;
        &lt;from uri=&quot;jms:topic:loan:qoute&quot;/&gt;
        &lt;aggregate strategyRef=&quot;bestQuote&quot;&gt;
                &lt;correlationExpression&gt;
                        &lt;header&gt;loanId&lt;/header&gt;
                &lt;/correlationExpression&gt;
                &lt;completionPredicate&gt;
                        &lt;simple&gt;${header.CamelAggregatedSize} &gt; 2&lt;/simple&gt;
                &lt;/completionPredicate&gt;
        &lt;/aggregate&gt;
        &lt;to uri=&quot;seda:bestLoanQuote&quot;/&gt;
&lt;/route&gt;

&lt;bean id=&quot;bestQuote&quot;
        class=&quot;com.mycompany.BestQuoteStrategy&quot;/&gt;
</code></pre><p><strong>TIP:</strong> We use the simple language to declare the completion predicate. Simple is a basic language that supports a primitive set of operators. ${header. CamelAggregatedSize} will fetch a header holding the number of messages aggregated.</p><p><strong>TIP:</strong> If the completed predicate is more complex we can use a method call to invoke a Bean so we can do the evaluation in pure Java code:</p><pre><code lang="text/x-java">
&lt;completionPredicate&gt;
        &lt;method bean=&quot;quoteService&quot; method=&quot;isComplete&quot;/&gt;
&lt;/compledtionPrediacate&gt;
public boolean isComplete(@Header(Exchange.AGGREGATED_SIZE)
        int count, String body) {
        return body.equals(&quot;STOP&quot;);
}
</code></pre><p>Notice how we can use Bean Binding Parameter to get hold of the aggregation size as a parameter, instead of looking it up in the message.</p></td>
  </tr>
 </tbody>
</table><h3>Resequencer</h3><table cellpadding="0" cellspacing="0">
 <tbody>
  <tr>
   <td><img alt="Diagram" class="fr-dii fr-fil" src="images/rc047-010d-enterprise_integration_patterns-19.jpg" /></td>
   <td class="light_cream">How can we get a stream of related but out-of-sequence messages back into the correct order?</td>
  </tr>
  <tr>
   <td colspan="2"><img alt="Resequencer" class="fr-dii fr-fil" src="images/rc047-010d-enterprise_integration_patterns-20.jpg" /></td>
  </tr>
  <tr>
   <td class="light_blue">Problem</td>
   <td class="light_cream">How do we ensure ordering of messages?</td>
  </tr>
  <tr>
   <td class="light_blue">Solution</td>
   <td class="light_cream">Use a stateful filter, a Resequencer, to collect and reorder messages so that they can be published in a specified order.</td>
  </tr>
  <tr>
   <td class="light_blue">Camel</td>
   <td class="light_cream"><p>Camel has support for the Resequencer using the resequence node. Camel uses a stateful batch processor that is capable of reordering related messages. Camel supports two resequencing algorithms:</p><p><strong>-batch</strong> = collects messages into a batch, sorts the messages and publish the messages</p><p><strong>-stream</strong> = re-orders, continuously, message streams based on detection of gaps between messages.</p><p>Batch is similar to the aggregator but with sorting. Stream is the traditional Resequencer pattern with gap detection. Stream requires usage of number (longs) as sequencer numbers, enforced by the gap detection, as it must be able to compute if gaps exist. A gap is detected if a number in a series is missing, e.g. 3, 4, 6 with number 5 missing. Camel will back off the messages until number 5 arrives.</p></td>
  </tr>
  <tr>
   <td class="light_blue">Java DSL</td>
   <td class="light_cream"><h4>Batch:</h4><p>We want to process received stock quotes, once a minute, ordered by their stock symbol. We use XPath as the expression to select the stock symbol, as the value used for sorting.</p><pre><code lang="text/x-java">
from(&quot;jms:topic:stock:quote&quot;)
        .resequence().xpath(&quot;/quote/@symbol&quot;)
        .timeout(60 * 1000)
        .to(&quot;seda:quotes&quot;);
</code></pre><p>Camel will default the order to ascending. You can provide your own comparison for sorting if needed.</p><h4>Stream:</h4><p>Suppose we continuously poll a file directory for inventory updates, and its important they are processed in sequence by their inventory id. To do this we enable streaming and use one hour as the timeout.</p><pre><code lang="text/x-java">
from(&quot;file://inventory&quot;)
        .resequence().xpath(&quot;/inventory/@id&quot;)
        .stream().timeout(60 * 60 * 1000)
        .to(&quot;seda:inventoryUpdates&quot;);
</code></pre></td>
  </tr>
  <tr>
   <td class="light_blue">Spring DSL</td>
   <td class="light_cream"><h4>Batch:</h4><pre><code lang="text/x-java">
&lt;route&gt;
        &lt;from uri=&quot;jms:topic:stock:quote&quot;/&gt;
        &lt;resequence&gt;
                &lt;xpath&gt;/quote/@symbol&lt;/xpath&gt;
                &lt;batch-config batchTimeout=&quot;60000&quot;/&gt;
        &lt;/resequence&gt;
        &lt;to uri=&quot;seda:quotes&quot;/&gt;
&lt;/route&gt;
</code></pre><h4>Stream:</h4><pre><code lang="text/x-java">
&lt;route&gt;
        &lt;from uri=&quot;file://inventory&quot;/&gt;
        &lt;resequence&gt;
                &lt;xpath&gt;/inventory/@id&lt;xpath&gt;
                &lt;stream-config timeout=&quot;3600000&quot;/&gt;
        &lt;/resequence&gt;
        &lt;to uri=&quot;seda:quotes&quot;/&gt;
&lt;/route&gt;
</code></pre><p>Notice that you can enable streaming by specifying &lt;stream-config&gt; instead of &lt;batch-config&gt;.</p></td>
  </tr>
 </tbody>
</table><h3>Dead Letter Channel</h3><table cellpadding="0" cellspacing="0">
 <tbody>
  <tr>
   <td><img alt="Diagram" class="fr-dii fr-fil" src="images/rc047-010d-enterprise_integration_patterns-21.jpg" /></td>
   <td class="light_cream">What will the messaging system do with a message it cannot deliver?</td>
  </tr>
  <tr>
   <td colspan="2"><img alt="Message Router" class="fr-dii fr-fil" src="images/rc047-010d-enterprise_integration_patterns-22.jpg" /></td>
  </tr>
  <tr>
   <td class="light_blue">Problem</td>
   <td class="light_cream">The messaging system cannot deliver a message</td>
  </tr>
  <tr>
   <td class="light_blue">Solution</td>
   <td class="light_cream">When a message cannot be delivered it should be moved to a Dead Letter Channel</td>
  </tr>
  <tr>
   <td class="light_blue">Camel</td>
   <td class="light_cream"><p>Camel has extensive support for Dead Letter Channel by its error handler and exception clauses. Error handler supports redelivery policies to decide how many times to try redelivering a message, before moving it to a Dead Letter Channel.</p><p>The default Dead Letter Channel will log the message at ERROR level and perform up to 6 redeliveries using a one second delay before each retry.</p><p>Error handler has two scopes: global and per route</p><p><strong>TIP:</strong> See Exception Clause in the Camel documentation for selective interception of thrown exception. This allows you to route certain exceptions differently or even reset the failure by marking it as handled.</p><p><strong>TIP:</strong> DeadLetterChannel supports processing the message before it gets redelivered using onRedelivery. This allows you to alter the message beforehand (i.e. to set any custom headers).</p></td>
  </tr>
  <tr>
   <td class="light_blue">Java DSL</td>
   <td class="light_cream"><h4>Global scope</h4><pre><code lang="text/x-java">
errorHandler(deadLetterChannel(&quot;jms:queue:error&quot;)
        .maximumRedeliveries(3));

from(...)

Route scope
from(&quot;jms:queue:event&quot;)
        .errorHandler(deadLetterChannel()
        .maximumRedeliveries(5))
        .multicast().to(&quot;log:event&quot;, &quot;seda:handleEvent&quot;);
</code></pre><p>In this route we override the global scope to use up to five redeliveries, where as the global only has three. You can of course also set a different error queue destination:</p><pre><code lang="text/x-java">
deadLetterChannel(&quot;log:badEvent&quot;).maximumRedeliveries(5)
</code></pre></td>
  </tr>
  <tr>
   <td class="light_blue">Spring DSL</td>
   <td class="light_cream"><p>The error handler is configured very differently in the Java DSL vs. the Spring DSL. The Spring DSL relies more on standard Spring bean configuration whereas the Java DSL uses fluent builders.</p><h4>Global scope</h4><p>The Global scope error handler is configured using the errorHandlerRef attribute on the camelContext tag.</p><pre><code lang="text/x-java">
&lt;camelContext errorHandlerRef=&quot;myDeadLetterChannel&quot;&gt;
...
&lt;/camelContext&gt;
</code></pre><h4>Route scope</h4><p>Route scoped is configured using the errorHandlerRef attribute on the route tag.</p><pre><code lang="text/x-java">
&lt;route errorHandlerRef=&quot;myDeadLetterChannel&quot;&gt;
...
&lt;/route&gt;
</code></pre><p>For both the error handler itself is configured using a regular Spring bean</p><pre><code lang="text/x-java">
&lt;bean id=&quot;myDeadLetterChannel&quot; class=&quot;org.apache.camel.
builder.DeadLetterChannelBuilder&quot;&gt;
        &lt;property name=&quot;deadLetterUri&quot; value=&quot;jms:queue:error&quot;/&gt;
        &lt;property name=&quot;redeliveryPolicy&quot;
                ref=&quot;myRedeliveryPolicy&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;myRedeliverPolicy&quot;
                class=&quot;org.apache.camel.processor.RedeliverPolicy&quot;&gt;
        &lt;property name=&quot;maximumRedeliveries&quot; value=&quot;5&quot;/&gt;
        &lt;property name=&quot;delay&quot; value=&quot;5000&quot;/&gt;
&lt;/bean&gt;
</code></pre></td>
  </tr>
 </tbody>
</table><h3>Wire Tap</h3><table cellpadding="0" cellspacing="0">
 <tbody>
  <tr>
   <td><img alt="Diagram" class="fr-dii fr-fil" height="20" src="images/rc047-010d-enterprise_integration_patterns-23.jpg" width="34" /></td>
   <td class="light_cream">How do you inspect messages that travel on a point-to-point channel?</td>
  </tr>
  <tr>
   <td colspan="2"><img alt="Wire Tap" class="fr-dii fr-fil" src="images/rc047-010d-enterprise_integration_patterns-24.jpg" /></td>
  </tr>
  <tr>
   <td class="light_blue">Problem</td>
   <td class="light_cream">How do you tap messages while they are routed?</td>
  </tr>
  <tr>
   <td class="light_blue">Solution</td>
   <td class="light_cream">Insert a Wire Tap into the channel, that publishes each incoming message to the main channel as well as to a secondary channel.</td>
  </tr>
  <tr>
   <td class="light_blue">Camel</td>
   <td class="light_cream">Camel has support for Wire Tap using the wireTap node, that supports two modes: traditional and new message. The traditional mode sends a copy of the original message, as opposed to sending a new message. All messages are sent as Event Message and runs in parallel with the original message.</td>
  </tr>
  <tr>
   <td class="light_blue">Java DSL</td>
   <td class="light_cream"><h4>Traditional</h4><p>The route uses the traditional mode to send a copy of the original message to the seda tapped queue, while the original message is routed to its destination, the process order bean.</p><pre><code lang="text/x-java">
from(&quot;jms:queue:order&quot;)
        .wireTap(&quot;seda:tappedOrder&quot;)
        .to(&quot;bean:processOrder&quot;);
</code></pre><h4>New message</h4><p>In this route we tap the high priority orders and send a new message containing a body with the from part of the order. Tip: As Camel uses an Expression for evaluation you can use other functions than xpath, for instance to send a fixed String you can use constant.</p><pre><code lang="text/x-java">
from(&quot;jms:queue:order&quot;)
        .choice()
                .when(&quot;/order/priority = ‘high’&quot;)
                        .wireTap(&quot;seda:from&quot;, xpath(&quot;/order/from&quot;))
                        .to(&quot;bean:processHighOrder&quot;);
                .otherwise()
                        .to(&quot;bean:processOrder&quot;);
</code></pre></td>
  </tr>
  <tr>
   <td class="light_blue">Spring DSL</td>
   <td class="light_cream"><h4>Traditional</h4><pre><code lang="text/x-java">
&lt;route&gt;
        &lt;from uri=&quot;jms:queue:order&quot;/&gt;
        &lt;wireTap uri=&quot;seda:tappedOrder&quot;/&gt;
        &lt;to uri=&quot;bean:processOrder&quot;/&gt;
&lt;/route&gt;
</code></pre><h4>New Message</h4><pre><code lang="text/x-java">
&lt;route&gt;
        &lt;choice&gt;
                &lt;when&gt;
                        &lt;xpath&gt;/order/priority = 'high'&lt;/xpath&gt;
                        &lt;wireTap uri=&quot;seda:from&quot;&gt;
                                &lt;body&gt;&lt;xpath&gt;/order/from&lt;/xpath&gt;&lt;/body&gt;
                        &lt;/wireTap&gt;
                        &lt;to uri=&quot;bean:processHighOrder&quot;/&gt;
                &lt;/when&gt;
                &lt;otherwise&gt;
                        &lt;to uri=&quot;bean:processOrder&quot;/&gt;
                &lt;/otherwise&gt;
        &lt;/choice&gt;
&lt;/route&gt;
</code></pre></td>
  </tr>
 </tbody>
</table>
                    </div>
                </div>
                <div class="content">
                    <div id="section-4" class="chapter-box tc-blue">Section 4</div>
                    <h2 class="chapter-title">Conclusion</h2>
                    <div class="content-html" dz-code-container ng-non-bindable>
                        <p pid="6">The twelve patterns in this Refcard cover the most used patterns in the integration space, together with two of the most complex such as the Aggregator and the Dead Letter Channel. In the second part of this series we will take a further look at common patterns and transations.</p><h3>Get More Information</h3><table cellpadding="0" cellspacing="0">
 <tbody>
  <tr>
   <td class="light_blue">Camel Website <a href="http://camel.apache.org">http://camel.apache.org</a></td>
   <td class="light_cream">The home of the Apache Camel project. Find downloads, tutorials, examples, getting started guides, issue tracker, roadmap, mailing lists, irc chat rooms, and how to get help.</td>
  </tr>
  <tr>
   <td class="light_blue">FuseSource Website <a href="http://fusesource.com">http://fusesource.com</a></td>
   <td class="light_cream">The home of the FuseSource company, the professional company behind Apache Camel with enterprise offerings, support, consulting and training.</td>
  </tr>
  <tr>
   <td class="light_blue">About Author <a href="http://davsclaus.blogspot.com">http://davsclaus.blogspot.com</a></td>
   <td class="light_cream">The personal blog of the author of this reference card.</td>
  </tr>
 </tbody>
</table>
                    </div>
                </div>

            <div class="row">
                <div class="related col-xs-12">
                    <h3>Like This Refcard? Read More From DZone</h3>
                    <div class="relateddiv">
                        <div ng-repeat="related in refcard.relatedArticles" class="related-container">
                            <a ng-href="{{::related.url}}?fromrel=true">
                                <img class="relatedimg lazyload"
                                     dz-image-fid-width="120"
                                     dz-image-fid="{{related.img}}"
                                     data-lazy="true"
                                     alt="related article thumbnail"
                                     width="60">
                            </a>
                            <a ng-href="{{::related.url}}?fromrel=true" class="relatedres-text">
                                <p class="relatedres">DZone Article</p>
                                <div ng-bind="related.title"></div>
                            </a>
                        </div>

                        <div ng-repeat="related in refcard.relatedRefcards" class="related-container">
                            <a href="{{::related.url}}?fromrel=true">
                                <img class="relatedimg lazyload"
                                     dz-image-fid-width="120"
                                     dz-image-fid="{{related.img}}"
                                     data-lazy="true"
                                     alt="related refcard thumbnail"
                                     width="60">
                            </a>
                            <a href="{{::related.url}}?fromrel=true" class="relatedres-text">
                                <p class="relatedres">Free DZone Refcard</p>
                                <div ng-bind="related.title"></div>
                            </a>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

</div></div></div></div><div class="container-fluid footerOuter" th-element="footerOuter" th-element-groups="[]" ng-hide="$root.isHidden('footerOuter')" data-th-element-name="footerOuter"><div class="row row2" th-element="row2" th-element-groups="['footerOuter']" ng-hide="$root.isHidden('row2')" data-th-element-name="row2"><div class="col-md-12 container3" th-element="container3" th-element-groups="['footerOuter','row2']" ng-hide="$root.isHidden('container3')" data-th-element-name="container3"><div class="container container3" th-element="container3" th-element-groups="['footerOuter','row2','container3']" ng-hide="$root.isHidden('container3')" data-th-element-name="container3"><div class="row footer" th-element="footer" th-element-groups="['footerOuter','row2','container3','container3']" ng-hide="$root.isHidden('footer')" data-th-element-name="footer"><div class="col-md-12 footerFooterV28 footerFooterV2 oUhbdrfPmhwBdrfXM" th-element="footerFooterV28" th-element-groups="['footerOuter','row2','container3','container3','footer']" ng-hide="$root.isHidden('footerFooterV28')" data-th-element-name="footerFooterV28" data-th-widget="footer.footerV2" data-widget-footer-footer-v2="" ng-controller="footerFooterV28"><div class="row footerContainer">
    <div class="left col-xs-12 col-sm-7">
        <div class="col-xs-12 social-media-icons footer-mobile">
            <ul class="icons-only">
                <li class="rss-icon" id="rss-footer-1">
                    <a href="/pages/feeds" target="_blank" rel="noreferrer noopener">
                        <i class="icon-rss-1"></i>
                    </a>
                </li>
                <li class="twitter-icon">
                    <a href="https://twitter.com/DZoneInc" target="_blank" rel="noreferrer noopener">
                        <i class="icon-twitter"></i>
                    </a>
                </li>
                <li class="facebook-icon">
                    <a href="https://www.facebook.com/DZoneInc" target="_blank" rel="noreferrer noopener">
                        <i class="icon-facebook-1"></i>
                    </a>
                </li>
                <li class="linkedin-icon">
                    <a href="https://www.linkedin.com/company/dzone/" target="_blank" rel="noreferrer noopener">
                        <i class="icon-linkedin-1"></i>
                    </a>
                </li>
            </ul>
        </div>

        <div class="top-section col-xs-12">
            <div class="col-xs-12 col-sm-6">
                <p class="section-header">ABOUT US</p>
                <ul class="link-group">
                    <li><a href="/pages/about" rel="noreferrer noopener">About DZone</a></li>
                    <li><a href="mailto:support@dzone.com" rel="noreferrer noopener">Send feedback</a></li>
                    <li><a href="https://careers.dzone.com/" target="_blank" rel="noreferrer noopener">Careers</a></li>
                                            <li><a href="/sitemap" rel="noreferrer noopener">Sitemap</a></li>
                </ul>
            </div>
            <div class="col-xs-12 col-sm-6">
                <p class="section-header">ADVERTISE</p>
                <ul class="link-group">
                    <li><a href="https://advertise.dzone.com" target="_blank" rel="noreferrer noopener">Advertise with DZone</a></li>
                </ul>
            </div>
        </div>

        <div class="bottom-section col-xs-12">
            <div class="col-xs-12 col-sm-6">
                <p class="section-header">CONTRIBUTE ON DZONE</p>
                <ul class="bottom-top-list link-group">
                    <li><a href="/articles/dzones-article-submission-guidelines">Article Submission Guidelines</a></li>
                    <li><a href="/pages/mvb" rel="noreferrer noopener">MVB Program</a></li>
                    <li><a href="/pages/contribute" rel="noreferrer noopener">Become a Contributor</a></li>
                    <li><a href="/writers-zone" rel="noreferrer noopener">Visit the Writers' Zone</a></li>
                </ul>

                <p class="section-header">LEGAL</p>
                <ul class="link-group">
                    <li><a href="/pages/tos" rel="noreferrer noopener">Terms of Service</a></li>
                    <li><a href="/pages/privacy" rel="noreferrer noopener">Privacy Policy</a></li>
                </ul>
            </div>
            <div class="col-xs-12 col-sm-6">
                <p class="section-header">CONTACT US</p>
                <ul class="link-group">
                    <li>600 Park Offices Drive</li>
                    <li>Suite 300</li>
                    <li>Durham, NC 27709</li>
                    <li><a href="mailto:support@dzone.com" rel="noreferrer noopener">support@dzone.com</a></li>
                    <li><a href="tel:+19196780300" rel="noreferrer noopener">+1 (919) 678-0300</a></li>
                </ul>
            </div>
        </div>
    </div>

    <div class="right col-xs-12 col-sm-5">

        <p class="connect-text">Let's be friends:</p>
        <div class="col-xs-12 social-media-icons footer-wide">
            <ul class="icons-only">
                <li class="rss-icon" id="rss-footer-1">
                    <a href="/pages/feeds" target="_blank" rel="noreferrer noopener">
                        <i class="icon-rss-1"></i>
                    </a>
                </li>
                <li class="twitter-icon">
                    <a href="https://twitter.com/DZoneInc" target="_blank" rel="noreferrer noopener">
                        <i class="icon-twitter"></i>
                    </a>
                </li>
                <li class="facebook-icon">
                    <a href="https://www.facebook.com/DZoneInc" target="_blank" rel="noreferrer noopener">
                        <i class="icon-facebook-1"></i>
                    </a>
                </li>
                <li class="linkedin-icon">
                    <a href="https://www.linkedin.com/company/dzone/" target="_blank" rel="noreferrer noopener">
                        <i class="icon-linkedin-1"></i>
                    </a>
                </li>
            </ul>
        </div>

        <div class="col-xs-12 powered-by">
            <p>DZone.com is powered by&nbsp;</p>
            <a href="https://devada.com/answerhub/" rel="noreferrer noopener">
                <img src="" data-src="/themes/dz20/images/answerhub_logo_white_footer.png" class="lazyload"
                     width="150" height="56" alt="AnswerHub logo">
            </a>
        </div>
    </div>
</div>
</div></div></div></div></div></div><div class=" componentsSlider6 componentsSlider oUhballbvbdSaoUhM" th-element="componentsSlider6" th-element-groups="[]" ng-hide="$root.isHidden('componentsSlider6')" data-th-element-name="componentsSlider6" data-th-widget="components.slider" data-widget-components-slider="" ng-controller="componentsSlider6"><div class="background" ng-class="{open: _sliderOpen}" ng-if="_ready" ng-click="close()">
</div>

<div class="slider-outer-wrapper" ng-class="{open: _sliderOpen}">

    <div class="row slider-inner-wrapper" ng-if="_ready">
        <div class=" componentsSlider6.widgets" th-element="componentsSlider6.widgets" th-element-groups="['componentsSlider6']" ng-hide="$root.isHidden('componentsSlider6.widgets')" data-th-element-name="componentsSlider6.widgets"><div class="col-md-12 contentCommentsSlider7 contentCommentsSlider oUhbaqbcaibvnWffWVcC" th-element="contentCommentsSlider7" th-element-groups="['componentsSlider6','componentsSlider6.widgets']" ng-hide="$root.isHidden('contentCommentsSlider7')" data-th-element-name="contentCommentsSlider7" data-th-widget="content.commentsSlider" data-widget-content-comments-slider="" ng-controller="contentCommentsSlider7"><script type="text/ng-template" id="link-article-save.html">
    <div ng-class="{'icon-star gold': status.saved, 'icon-star-empty': !status.saved}" ng-click="save()" class="save"><span class="save-title">Save</span><span ng-if="status.saved" class="d-letter">d</span></div>
</script>

<div class="comment-slider-content">

    <div class="node-info">
        <div class="comment-title">
            <h1 class="parent-title">{{ parent.title || parent.header.title}}</h1>
            <p ng-if="parent.tldr"  class="tldr">{{ parent.tldr }}</p>
            <h3 ng-if="parent.title" class="link-description" >{{ parent.linkDescription }}</h3>
            <a ng-if="parent.title" ng-href="{{parent.url}}" class="link-source">{{ parent.urlSource.name }}</a>
        </div>
    </div>
    <div class="author-n-article-info">
        <div class="author-avatar">
            <a ng-href="{{ parent.authors[0].url || parent.authorUrl }}">
                <img dz-image-fid-width="80" dz-image-fid="{{ parent.authors[0].avatar || parent.authorAvatar }}" class="avatar" width="40" />
            </a>
        </div>
        <div class="author-name">
            by
            <a ng-bind-html="parent.authors[0].realName ? parent.authors[0].realName : parent.author" th-popup="users.profile.mini" popup-data="{user: parent.authors[0].id || parent.authorId }" ng-href="{{ parent.authors[0].url || parent.authorUrl }}"></a>

            <div ng-if="parent.authors[0].isStaff || parent.isStaff" class="mbv-award staff-area">
                <i tooltip="Staff of DZone" class="icon-staff"></i>
            </div>

            <div ng-if="parent.authors[0].isMVB || parent.isMVB" class="mbv-award">
                <i tooltip="Most Valuable Blogger" class="icon-mvb-1"></i>
            </div>

            <div class="mvb-partner">
                <user-is-partner user="parent.authors[0].id"></user-is-partner>
            </div>

            <div class="badge-container badge-text-md" ng-if="parent.authors[0].isCore || parent.isCore">
                <i tooltip="DZone Core" class="icon-core-1"></i>CORE
            </div>

            <div class="zone-leader">
                <user-is-zone-leader user="parent.authors[0].id"></user-is-zone-leader>
            </div>

        </div>
        <div class="publish-date">
            &middot; <span class="author-date">{{ parent.articleDate | date:'MMM. dd, yyyy' }} {{ parent.linkDate | date:'MMM. dd, yyyy' }}</span>
        </div>
        <div class="portal-link">
            &middot; <a href="{{ parent.portal.url }}" id="portal-name" ng-cloak><span class="portal-name">{{ parent.portal.name }} Zone</span></a>
        </div>
    </div>
    <div class="user-actions">
        <div class="like action" ng-if="parent.title">
            <dz-like template="like-article.html" callback="addVoter()" node="parent" ng-if="parent.articleDate"></dz-like>
            <dz-like callback="addVoter()" callback="addVoter()" node="parent" ng-if="parent.linkDate"></dz-like>
        </div>

        <div class="like action" ng-if="!parent.title">
            <dz-like template="like-article.html" callback="addVoter()" node="parent"></dz-like>
        </div>

        <div class="save-article action"><dz-save template="link-article-save.html" node="parent" class="save"></dz-save></div>

        <div class="tweet action">
            <a ng-href="#" ng-click='shareTwitter($event, parent.title || parent.header.title,parent.linkSource || parent.url)' class="title" target="_blank"><i class="icon-twitter"></i>Tweet</a>
        </div>

        <div class="pull-right">
            <div class="view-count action">
                <i class="icon-eye"></i> {{ parent.views }} <span ng-if="!parent.title">Views</span><span ng-if="parent.title" class="action-label">Clicks</span>
            </div>

            <div class="user-n-admin-action action" ng-if="canEdit(parent) || canDelete(parent)">
                <div class="mod-tools" dropdown is-open="dropdown.open">
                    <span dropdown-toggle><i class="icon-cog"></i></span>
                    <ul class="dropdown-menu">
                        <li><a ng-href="/content/{{ parent.id }}/edit.html">Edit</a></li>
                        <li><a href="#" ng-if="canDelete(parent)" ng-click="deleteLink(parent)">Delete</a></li>
                        <li><a href="#" ng-if="canPublish && !parent.title" ng-click="toggleComments(parent)">{{ parent.isLocked ? 'Enable' : 'Disable' }} comments</a></li>
                        <li><a href="#" ng-if="canPublish && !parent.isLocked && !parent.title" ng-click="toggleLimitComments(parent)">
                            {{ parent.isLimited ? 'Remove comment limits' : 'Enable moderated comments' }}
                        </a></li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
    <div th-defer-until="_sliderOpen">
        <!--<div content-comment-box parent="parent.id" count="parent.nComments" limited="parent.isLimited" class="comment-box"></div>-->
    </div>
</div></div></div>    </div>
</div>

</div>

    <div class="row">
        <a href="#" class="back-to-top"><i class="icon-up-big"></i></a>
    </div>


    <script type="text/ng-template" id="/themes/dz20/widgets/header/sections/widget.html">
<span dropdown is-open="dropdown.open" ng-class="{small: width < 768}">
    <span dropdown-toggle class="sections"><i class="icon-menu"></i>
        <span class="menuLabel" ng-if="width < 768"></span></span>
    <ul class="dropdown-menu ul-first" ng-style="width < 768 ? {'top': headerSize + 0 + 'px', 'padding-top': '15px'} : {}">
        <li><a href="/links">Links</a></li>
        <li><a href="/refcardz">Refcardz</a></li>
        <li><a href="/guides">Guides</a></li>
        <li><a href="/about">About Us</a></li>
        <li class="divider"></li>

        <li class="post-title"><span>Zones</span></li>
        <li ng-repeat="topic in portals" class="dropdown">
            <a ng-href="{{ topic.url }}">{{ topic.name }}</a>
        </li>
        <li class="divider"></li>
        <li class="post-title"><span>Post</span></li>
        <li><a href="/links">Link</a></li>
        <li><a href="/article/post.html">Article</a></li>
    </ul>
</span>


    </script>

<script type="text/ng-template" id="followus.html">
<div class="top-social">
    <p>Let's be friends:</p>
    <ul class="icons-only" ng-class="{open: isOpen}" click-outside="outside()">
        <li class="rss-icon" id="rss-spotlight-1">
            <a href="/pages/feeds"><i class="icon-rss-1"></i></a>
        </li>
        <li class="twitter-icon">
            <a href="https://twitter.com/DZoneInc" target="_blank"><i class="icon-twitter"></i></a>
        </li>
        <li class="facebook-icon">
            <a href="https://www.facebook.com/DZoneInc" target="_blank"><i class="icon-facebook-1"></i></a>
        </li>
        <li class="linkedin-icon">
            <a href="https://www.linkedin.com/company/devada-team" target="_blank"><i class="icon-linkedin-1"></i></a>
        </li>

            <ul class="social-dropdown dropdown-menu">
                <li class="rss" id="rss-spotlight"><a href="/pages/feeds"><i class="icon-rss-squared"></i> <span>RSS Feed</span></a></li>
                <li class="twitter" id="twitter-spotlight">
                    <a href="https://twitter.com/DZoneInc" class="twitter-follow-button" data-show-count="true"
                       data-show-screen-name="false">Follow @DZoneInc</a>
                </li>
                <li class="fb-like" id="fb-spotlight" data-href="https://www.facebook.com/DZoneInc"
                    data-layout="button_count" data-action="like" data-show-faces="true" data-share="false"></li>
                <li class="linkedin" id="linkedin-spotlight">
                    <script type="IN/FollowCompany" data-id="114427" data-counter="right"></script>
                </li>
            </ul>
    </ul>
</div>
</script><script type="text/ng-template" id="recaptcha.html"><script async defer src="https://www.google.com/recaptcha/api.js?render=6LevLMUUAAAAAIHR_NiM-0FV6xtDGFZSQ0IHuKK8"></script></script><script type="text/ng-template" id="dzlike.html">
<div class="dz-like " ng-class="{liked: status.liked}" ng-click="like()">
    <a href="#">
        <i class="icon-up-dir"></i>
        <span>{{ status.score }}</span>
    </a>
</div>
</script><script type="text/ng-template" id="dztopicselect.html"><ui-select  ng-if="canAddTopics" ng-model="editing.topics" theme="bootstrap" multiple tagging tagging-label="(add topic)"
           tagging-tokens=",">
    <ui-select-match class="input-tags"><div class="topics-tag">{{ $item }}</div></ui-select-match>
    <ui-select-choices
            refresh="topicsRefresh($select.search)"
            refresh-delay="250"
            repeat="topic in foundTopics | filter: $select.search">
        <div ng-bind-html="topic | highlight: $select.search"></div>
    </ui-select-choices>
</ui-select>
<ui-select ng-if="!canAddTopics" ng-model="editing.topics" theme="bootstrap" multiple>
    <ui-select-match><div class="topics-tag">{{ $item }}</div></ui-select-match>
    <ui-select-choices
            refresh="topicsRefresh($select.search)"
            refresh-delay="250"
            repeat="topic in foundTopics | filter: $select.search">
        <div ng-bind-html="topic | highlight: $select.search"></div>
    </ui-select-choices>
</ui-select></script><script type="text/ng-template" id="dzsave.html"><i class="icon-star-empty" ng-class="{'icon-star gold': status.saved, 'icon-star-empty': !status.saved}" tooltip-html-unsafe="{{status.saved ? 'Saved' : 'Save'}}" ng-click="save()"></i>
<!--<span ng-class="{'gold count': status.saved}">{{ status.count }}</span>--></script><script type="text/ng-template" id="overlay.html"><div class="ngdialog th-overlay">
    <div class="ngdialog-overlay">
        <div class="overlay-box">
            <i class="icon-spin5 animate-spin"></i>

            <p>{{ message }}</p>
        </div>
    </div>
</div></script><script type="text/ng-template" id="inline-editable.html"><div class="inline-editable" ng-if="!status.editing" ng-click="edit()" ng-transclude></div>
<div class="inline-editor-wrapper" ng-if="status.editing">
    <textarea class="inline-editor" ng-model="status.editValue" ng-if="type == 'textarea'"></textarea>
    <input class="inline-editor" ng-model="status.editValue" ng-if="type == 'input'"></textarea>
    <div class="inline-editor-tools">
        <button class="btn select-ok" ng-disabled="!status.editValue" ng-click="save()"><i class="icon-check-1"></i></button>
        <button class="btn select-cancel" ng-disabled="!editable" ng-click="cancel()"><i class="icon-cancel-1"></i></button>
    </div>
</div></script><script type="text/ng-template" id="dzupload.html"><span class="btn btn-upload" >
    <div ng-bind-html="label"></div>
    <div class="progress-container" ng-style="{visibility: uploading ? 'visible' : 'hidden'}">
        <progressbar max="100" value="progress"><span>{{ progress }}</span></progressbar>
    </div>
    <input type="file" ng-file-drop ng-file-select ng-file-change="upload($files)" />
</span></script><script type="text/ng-template" id="dzfollow.html"><button class="btn btn-follow" ng-class="{'btn-success': !status.followed, 'btn-warning': status.followed, 'hidden': followed.id == $root.user.id}" ng-click="follow()"><span ng-if="!status.followed"><i class="icon-plus"></i> Follow</span><span ng-if="status.followed" class="following">Following</span><span ng-if="status.followed" class="hover">Unfollow</span></button></script><script type="text/ng-template" id="dzphoto.html"><i class="icon-camera-alt photo" type="file" ng-file-drop ng-file-select ng-file-change="upload($files)"></i></script><script type="text/ng-template" id="dialog.confirm.html"><p>{{ message }}</p></script><script type="text/ng-template" id="dialog.confirm-custom.html"><p ng-bind-html="trustAsHtml(message)"></p></script><script type="text/ng-template" id="dialog.skeleton.html"><div class="dialog-title">
    <h1 ng-if="$dialog.title">{{ $dialog.title }}</h1>
</div>
<div class="dialog-body {{ $dialog.extraClass }}" ng-include="$dialog.template"></div>
<div class="dialog-footer">
    <div class="dialog-buttons" ng-if="$dialog.buttons">
        <button ng-repeat="button in $dialog.buttons" ng-hide="button.hidden" ng-disabled="button.disabled || $dialog.executing"
                class="btn btn-{{ button.type || 'info' }}" ng-click="$dialog.runAction(button)">
            <span class="icon-spin6 animate-spin" ng-if="button.executing"></span>{{ button.label || button.name }}</button>
    </div>
</div></script><script type="text/ng-template" id="dialog.message.html"><div class="message-icon">
    <i class="icon-{{ icon }}"></i>
</div>
<div class="message-text">
    <p class="message-title" ng-bind-html="trustAsHtml(title)"></p>
    <p ng-bind-html="trustAsHtml(message)"></p>
</div>
</script><script type="text/ng-template" id="dialog.delete-article.html"><p>{{ message }}</p>
<label for="modal-textarea" style="font-weight: 200; margin-top: 1em;">Editor's feedback:</label>
<textarea id="modal-textarea" class="form-control" placeholder="Optional" rows="3" maxlength="8000" style="height: auto; font-weight: 200;"></textarea></script>
<script type="text/javascript">

    var TH_CORE_VARS = {};

    try {
        TH_CORE_VARS.additional = {};

        TH_CORE_VARS.additional.matchedUrl = {"name":"refcard:view","mapping":"/refcardz/**","mappingPatterns":{}};
        TH_CORE_VARS.additional.request = [{"site":{"keywords":"programming, software development, devops, java, agile, web, iot, database, mobile, big data, cloud","name":"DZone.com","description":"Programming, Web Development, and DevOps news, tutorials and tools for beginners to experts. Hundreds of free publications, over 1M members, totally free.","id":7,"title":"DZone: Programming & DevOps news, tutorials & tools"},"dev":false,"context":"","theme":"dz20","cdn":["dz2cdn1.dzone.com","dz2cdn2.dzone.com","dz2cdn3.dzone.com","dz2cdn4.dzone.com"],"user":{"realName":null,"authenticated":false,"profile":"/users/2500002/anon-user.html","name":"Anonymous","jobRole":"","GDPRStatus":null,"id":2500002,"avatar":"https://secure.gravatar.com/avatar/?d=identicon&r=PG","companySize":""}}];
        TH_CORE_VARS.additional.loadedScripts = [["/lib/jquery/jquery.js","/lib/lodash/lodash.js","/lib/moment/moment.js","/scripts/utils.js","/lib/angular/angular.js","/lib/angular/angular-sanitize.js","/lib/local-storage/angular-local-storage.js","/lib/bootstrap/dropdown.js","/lib/angular-ui/bootstrap.js","/lib/angular-ui/select.js","/lib/bootstrap-switch/bootstrap-switch.js","/lib/ngDialog/js/ngDialog.js","/lib/angular-moment/angular-moment.js","/scripts/app.js","/scripts/socket.js","/scripts/services.js","/scripts/ui-services.js","/scripts/directives.js","/scripts/filters.js","/lib/angular/angular-cookies.js","/lib/angulartics/angulartics.js","/lib/angulartics/angulartics-ga.js","/lib/angular-touch/angular-touch.min.js","/lib/elastic/elastic.js","/lib/ng-file-upload/angular-file-upload-all.js","/scripts/ads.js","/scripts/social-media.js","/scripts/head.js","/scripts/links.js","/scripts/utilities/ad-manager.js","/scripts/utilities/directives.js","/scripts/utilities/editor.js","/scripts/utilities/recaptcha.js","/scripts/utilities/services.js","/lib/bootstrap-slider/bootstrap-slider.js","/lib/bootstrap-slider/directive.js","/lib/angular-animate.min.js","/lib/ngToast.min.js","/lib/lazysizes.min.js","/widgets/components/slider/service.js","/widgets/header/headerV2/resize.js"]];
        TH_CORE_VARS.additional.botInfo = [{"isRenderBot":false}];
        TH_CORE_VARS.additional.portals = [[{"hideFromHomepageWidgets":false,"hideFromNav":false,"code":"agile","color":"red","name":"Agile","topic":8,"id":2,"shortTitle":"agile-methodology-training-tools-news","url":"/agile-methodology-training-tools-news"},{"hideFromHomepageWidgets":false,"hideFromNav":false,"code":"ai","color":"purple","name":"AI","topic":2551,"id":4001,"shortTitle":"artificial-intelligence-tutorials-tools-news","url":"/artificial-intelligence-tutorials-tools-news"},{"hideFromHomepageWidgets":false,"hideFromNav":false,"code":"big-data","color":"green","name":"Big Data","topic":6129,"id":3,"shortTitle":"big-data-analytics-tutorials-tools-news","url":"/big-data-analytics-tutorials-tools-news"},{"hideFromHomepageWidgets":false,"hideFromNav":false,"code":"cloud","color":"orange","name":"Cloud","topic":30,"id":4,"shortTitle":"cloud-computing-tutorials-tools-news","url":"/cloud-computing-tutorials-tools-news"},{"hideFromHomepageWidgets":false,"hideFromNav":false,"code":"database","color":"purple","name":"Database","topic":59,"id":5,"shortTitle":"database-sql-nosql-tutorials-tools-news","url":"/database-sql-nosql-tutorials-tools-news"},{"hideFromHomepageWidgets":false,"hideFromNav":false,"code":"devops","color":"yellow","name":"DevOps","topic":31,"id":6,"shortTitle":"devops-tutorials-tools-news","url":"/devops-tutorials-tools-news"},{"hideFromHomepageWidgets":false,"hideFromNav":false,"code":"integration","color":"green","name":"Integration","topic":1138,"id":7,"shortTitle":"enterprise-integration-training-tools-news","url":"/enterprise-integration-training-tools-news"},{"hideFromHomepageWidgets":false,"hideFromNav":false,"code":"iot","color":"orange","name":"IoT","topic":48,"id":8,"shortTitle":"iot-developer-tutorials-tools-news-reviews","url":"/iot-developer-tutorials-tools-news-reviews"},{"hideFromHomepageWidgets":false,"hideFromNav":false,"code":"java","color":"purple","name":"Java","topic":1,"id":1,"shortTitle":"java-jdk-development-tutorials-tools-news","url":"/java-jdk-development-tutorials-tools-news"},{"hideFromHomepageWidgets":false,"hideFromNav":false,"code":"microservices","color":"green","name":"Microservices","topic":13268,"id":6001,"shortTitle":"microservices-news-tutorials-tools","url":"/microservices-news-tutorials-tools"},{"hideFromHomepageWidgets":true,"hideFromNav":true,"code":"mobile","color":"yellow","name":"Mobile","topic":29,"id":9,"shortTitle":"mobile-app-developer-tutorials-tools-news","url":"/mobile-app-developer-tutorials-tools-news"},{"hideFromHomepageWidgets":false,"hideFromNav":false,"code":"open-source","color":"purple","name":"Open Source","topic":75,"id":7001,"shortTitle":"open-source-news-tutorials-tools","url":"/open-source-news-tutorials-tools"},{"hideFromHomepageWidgets":false,"hideFromNav":false,"code":"performance","color":"red","name":"Performance","topic":653,"id":10,"shortTitle":"apm-tools-performance-monitoring-optimization","url":"/apm-tools-performance-monitoring-optimization"},{"hideFromHomepageWidgets":false,"hideFromNav":false,"code":"security","color":"green","name":"Security","topic":85,"id":2001,"shortTitle":"application-web-network-security","url":"/application-web-network-security"},{"hideFromHomepageWidgets":false,"hideFromNav":false,"code":"webdev","color":"orange","name":"Web Dev","topic":35,"id":11,"shortTitle":"web-development-programming-tutorials-tools-news","url":"/web-development-programming-tutorials-tools-news"},{"hideFromHomepageWidgets":true,"hideFromNav":true,"code":"inspiration-station ","color":"purple","name":"Writers","topic":16873,"id":3001,"shortTitle":"writers-zone","url":"/writers-zone"}]];
        TH_CORE_VARS.additional.loadedStyles = [["/lib/bootstrap/bootstrap.less","/lib/fontello/css/fontello.css","/lib/fontello/css/animation.css","/lib/angular-ui/select.css","/lib/ngDialog/css/ngDialog.css","/less/ngDialog-theme.less","/less/container.less","/lib/bootstrap-switch/bootstrap-switch.css","/less/dzone20.less","/lib/bootstrap-slider/bootstrap-slider.css","/lib/codemirror/lib/codemirror.css","/less/layout.less","/widgets/announcementBar/widget.less","/widgets/assets/content/chapters/widget.less","/widgets/components/slider/widget.less","/widgets/content/commentsSlider/widget.less","/widgets/footer/footerV2/footerV2.less","/widgets/header/headerV2/widget.less","/widgets/refcardz/topHeaderV3/widget.less"]];
        TH_CORE_VARS.additional.model = [{"metaData":{"title":"The Top Twelve Integration Patterns for Apache Camel - DZone Refcardz","description":"Enterprise Integration Patterns (EIP) have become the standard way to describe, document and implement complex integration problems. Apache Camel is an open-source project for implementing the EIP simply in a few lines of Java code or XML configuration. This DZone Refcard will guide you through the most common Enterprise Integration Patterns and give you examples of how to implement them either in Java code or using Spring XML. While it is targeted toward software developers and enterprise architects, anyone in the integration space can benefit from this Refcard.","keywords":"apache,integration,refcard","siteName":"dzone.com","url":"/refcardz/enterprise-integration","img":"","imgprop":"og:image","twitterImage":"","type":"article","wordCount":88,"canonical":"https://dzone.com/refcardz/enterprise-integration","noIndex":false,"noFollow":false,"showCanonical":true,"prevPage":null,"nextPage":null,"pubDate":"2009-03-29 21:54:22.0","id":520156,"author":"Claus Ibsen","section":"Integration","useEscapedFragment":false,"useNoSiteLinkSearchBox":false,"isProd":true,"robots":false,"robotsTag":""},"enableThreadedComments":true,"contentType":"refcard","content":{"id":"520156","type":"refcard","creationDate":1238363662000,"creationDateFormatted":"03/29/2009 09:54 PM","title":"The Top Twelve Integration Patterns for Apache Camel","body":"<p pid=\"1\" class=\"author_name\">By Claus Ibsen</p><h2>About Enterprise Integration Patterns</h2><p pid=\"2\">Integration is a hard problem. To help deal with the complexity of integration problems the Enterprise Integration Patterns (EIP) have become the standard way to describe, document and implement complex integration problems. Hohpe &amp; Woolf's book the Enterprise Integration Patterns has become the bible in the integration space - essential reading for any integration professional.</p><p pid=\"3\">Apache Camel is an open source project for implementing the EIP easily in a few lines of Java code or Spring XML configuration. This reference card, the first in a two card series, guides you through the most common Enterprise Integration Patterns and gives you examples of how to implement them either in Java code or using Spring XML. This Refcard is targeted for software developers and enterprise architects, but anyone in the integration space can benefit as well.</p><h2>About Apache Camel</h2><p pid=\"4\">Apache Camel is a powerful open source integration platform based on Enterprise Integration Patterns (EIP) with powerful Bean Integration. Camel lets you implementing EIP routing using Camels intuitive Domain Specific Language (DSL) based on Java (aka fluent builder) or XML. Camel uses URI for endpoint resolution so its very easy to work with any kind of transport such as HTTP, REST, JMS, web service, File, FTP, TCP, Mail, JBI, Bean (POJO) and many others. Camel also provides Data Formats for various popular formats such as: CSV, EDI, FIX, HL7, JAXB, Json, Xstream. Camel is an integration API that can be embedded in any server of choice such as: J2EE Server, ActiveMQ, Tomcat, OSGi, or as standalone. Camels Bean Integration let you define loose coupling allowing you to fully separate your business logic from the integration logic. Camel is based on a modular architecture allowing you to plugin your own component or data format, so they seamlessly blend in with existing modules. Camel provides a test kit for unit and integration testing with strong mock and assertion capabilities.</p><h2>Essential Patterns</h2><p pid=\"5\">This group consists of the most essential patterns that anyone working with integration must know.</p><h3>Pipes and Filters</h3><table cellpadding=\"0\" cellspacing=\"0\"><tbody><tr><td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-1.jpg\"></td><td class=\"light_cream\">How can we perform complex processing on a message while maintaining independence and flexibility?</td></tr><tr><td colspan=\"2\"><img alt=\"Pipes and Filters\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-2.jpg\"></td></tr></tbody></table><table cellpadding=\"0\" cellspacing=\"0\"><tbody><tr><td class=\"light_blue\">Problem</td><td class=\"light_cream\">A single event often triggers a sequence of processing steps</td></tr><tr><td class=\"light_blue\">Solution</td><td class=\"light_cream\">Use Pipes and Filters to divide a larger processing steps (filters) that are connected by channels (pipes)</td></tr><tr><td class=\"light_blue\">Camel</td><td class=\"light_cream\">Camel supports Pipes and Filters using the <strong>pipeline</strong> node.</td></tr><tr><td class=\"light_blue\">Java DSL</td><td class=\"light_cream\"><pre><code lang=\"text/x-java\">\nfrom(\"jms:queue:order:in\").pipeline(\"direct:transformOrder\", \"direct:validateOrder\", \"jms:queue:order:process\");\n</code></pre><p>Where jms represents the JMS component used for consuming JMS messages on the JMS broker. Direct is used for combining endpoints in a synchronous fashion, allow you to divide routes into sub routes and/or reuse common routes.</p><p><strong>Tip:</strong> Pipeline is the default mode of operation when you specify multiple outputs, so it can be omitted and replaced with the more common node:</p><pre><code lang=\"text/x-java\">\nfrom(\"jms:queue:order:in\").to(\"direct:transformOrder\",\n\"direct:validateOrder\", \"jms:queue:order:process\");\n</code></pre><p><strong>TIP:</strong> You can also separate each step as individual <strong>to</strong> nodes:</p><pre><code lang=\"text/x-java\">\nfrom(\"jms:queue:order:in\")\n        .to(\"direct:transformOrder\")\n        .to(\"direct:validateOrder\")\n        .to(\"jms:queue:order:process\");\n</code></pre></td></tr><tr><td class=\"light_blue\">Spring DSL</td><td class=\"light_cream\"><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=\"jms:queue:order:in\"/&gt;\n        &lt;pipeline&gt;\n                &lt;to uri=\"direct:transformOrder\"/&gt;\n                &lt;to uri=\"direct:validateOrder\"/&gt;\n                &lt;to uri=\"jms:queue:order:process\"/&gt;\n        &lt;/pipeline&gt;\n&lt;/route&gt;\n&lt;route&gt;\n        &lt;from uri=\"jms:queue:order:in\"/&gt;\n        &lt;to uri=\"direct:transformOrder\"/&gt;\n        &lt;to uri=\"direct:validateOrder\"/&gt;\n        &lt;to uri=\"jms:queue:order:process\"/&gt;\n&lt;/route&gt;</code></pre><br><br></td></tr></tbody></table><h3>Message Router</h3><table cellpadding=\"0\" cellspacing=\"0\"><tbody><tr><td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" height=\"23\" src=\"images/rc047-010d-enterprise_integration_patterns-3.jpg\" width=\"42\"></td><td class=\"light_cream\">How can you deouple indevidual processing steps so that messages can be passed to different filters depending on a set of conditions?</td></tr><tr><td colspan=\"2\"><img alt=\"Message Router\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-4.jpg\"></td></tr><tr><td class=\"light_blue\">Problem</td><td class=\"light_cream\">Pipes and Filters route each message in the same processing steps. How can we route messages differently?</td></tr><tr><td class=\"light_blue\">Solution</td><td class=\"light_cream\">Filter using predicates to choose the right output destination.</td></tr><tr><td class=\"light_blue\">Camel</td><td class=\"light_cream\">Camel supports Message Router using the <strong>choice</strong> node. For more details see the Content Based router pattern.</td></tr></tbody></table><h3>Content-Based Router</h3><table cellpadding=\"0\" cellspacing=\"0\"><tbody><tr><td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-5.jpg\"></td><td class=\"light_cream\">How do we handle a situation where the implementation of a single logical function (e.g., inventory check) is spread across multiple physical systems?</td></tr><tr><td colspan=\"2\"><img alt=\"Content-Based Router\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-6.jpg\"></td></tr><tr><td class=\"light_blue\">Problem</td><td class=\"light_cream\">How do we ensure a Message is sent to the correct recipient based on information from its content?</td></tr><tr><td class=\"light_blue\">Solution</td><td class=\"light_cream\">Use a Content-Based Router to route each message to the correct recipient based on the message content.</td></tr><tr><td class=\"light_blue\">Camel</td><td class=\"light_cream\">Camel has extensive support for Content-Based Routing. Camel supports content based routing based on <strong>choice, filter,</strong> or any other expression.</td></tr><tr><td class=\"light_blue\">Java DSL</td><td class=\"light_cream\"><h4>Choice</h4><pre><code lang=\"text/x-java\">\nfrom(\"jms:queue:order\")\n.choice()\n.when(header(\"type\").in(\"widget\",\"wiggy\"))\n.to(\"jms:queue:order:widget\")\n.when(header(\"type\").isEqualTo(\"gadget\"))\n.to(\"jms:queue:order:gadget\")\n.otherwise().to(\"jms:queue:order:misc\")\n.end();\n</code></pre><p><strong>TIP:</strong> In the route above end() can be omitted as its the last node and we do not route the message to a new destination after the choice.</p><p><strong>TIP:</strong> You can continue routing after the choice ends.</p></td></tr><tr><td class=\"light_blue\">Spring DSL</td><td class=\"light_cream\"><h4>Choice</h4><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=\"jms:queue:order\"/&gt;\n        &lt;choice&gt;\n                &lt;when&gt;\n                        &lt;simple&gt;${header.type} in 'widget,wiggy'&lt;/simple&gt;\n                        &lt;to uri=\"jms:queue:order:widget\"/&gt;\n                &lt;/when&gt;\n                &lt;when&gt;\n                        &lt;simple&gt;${header.type} == 'gadget'&lt;/simple&gt;\n                        &lt;to uri=\"jms:queue:order:gadget\"/&gt;\n                &lt;/when&gt;\n                &lt;otherwise&gt;\n                        &lt;to uri=\"jms:queue:order:misc\"/&gt;\n                &lt;/otherwise&gt;\n        &lt;/choice&gt;\n&lt;/route&gt;\n</code></pre><p><strong>TIP:</strong> In Spring DSL you cannot invoke code, as opposed to the Java DSL that is 100% Java. To express the predicates for the choices we need to use a language. We will use simple language that uses a simple expression parser that supports a limited set of operators. You can use any of the more powerful languages supported in Camel such as: JavaScript, Groovy, Unified EL and many others.</p><p><strong>TIP:</strong> You can also use a method call to invoke a method on a bean to evaluate the predicate. Lets try that:</p><pre><code lang=\"text/x-java\">\n&lt;when&gt;\n        &lt;method bean=\"myBean\" method=\"isGadget\"/&gt;\n        ...\n&lt;/when&gt;\n\n&lt;bean id=\"myBean\" class=\"com.mycomapany.MyBean\"/&gt;\n\npublic boolean isGadget(@Header(name = \"type\") String type) {\n        return type.equals(\"Gadget\");\n}\n</code></pre><p>Notice how we use Bean Parameter Binding to instruct Camel to invoke this method and pass in the type header as the String parameter. This allows your code to be fully decoupled from any Camel API so its easy to read, write and unit test.</p></td></tr></tbody></table><h3>Message Translator</h3><table cellpadding=\"0\" cellspacing=\"0\"><tbody><tr><td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-7.jpg\"></td><td class=\"light_cream\">How can systems using different data formats communicate with each other using messaging?</td></tr><tr><td colspan=\"2\"><img alt=\"Message Translator\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-8.jpg\"></td></tr><tr><td class=\"light_blue\">Problem</td><td class=\"light_cream\">Each application uses its own data format, so we need to translate the message into the data format the application supports.</td></tr><tr><td class=\"light_blue\">Solution</td><td class=\"light_cream\">Use a special filter, a messae translator, between filters or applications to translate one data format into another.</td></tr><tr><td class=\"light_blue\">Camel</td><td class=\"light_cream\">Camel supports the message translator using the <strong>processor, bean</strong> or <strong>transform</strong> nodes. TIP: Camel routes the message as a chain of <strong>processor</strong> nodes.</td></tr><tr><td class=\"light_blue\">Java DSL</td><td class=\"light_cream\"><h4>Processor</h4><pre><code lang=\"text/x-java\">\npublic class OrderTransformProcessor\n                implements Processor {\n        public void process(Exchange exchange)\n                        throws Exception {\n                // do message translation here\n        }\n}\nfrom(\"direct:transformOrder\")\n        .process(new OrderTransformProcessor());\n</code></pre><h4>Bean</h4><p>Instead of the processor we can use Bean (POJO). An advantage of using a Bean over Processor is the fact that we do not have to implement or use any Camel specific interfaces or types. This allows you to fully decouple your beans from Camel.</p><pre><code lang=\"text/x-java\">\npublic class OrderTransformerBean {\n        public StringtransformOrder(String body) {\n                // do message translation here\n        }\n}\nObject transformer = new OrderTransformerBean();\nfrom(\"direct:transformOrder\").bean(transformer);\n</code></pre><p><strong>TIP:</strong> Camel can create an instance of the bean automatically; you can just refer to the class type.</p><pre><code lang=\"text/x-java\">\nfrom(\"direct:transformOrder\")\n        .bean(OrderTransformerBean.class);\n</code></pre><p><strong>TIP:</strong> Camel will try to figure out which method to invoke on the bean in case there are multiple methods. In case of ambiguity you can specify which methods to invoke by the method parameter:</p><pre><code lang=\"text/x-java\">\nfrom(\"direct:transformOrder\")\n        .bean(OrderTransformerBean.class, \"transformOrder\");\n</code></pre><h4>Transform</h4><p>Transform is a particular processor allowing you to set a response to be returned to the original caller. We use transform to return a constant ACK response to the TCP listener after we have copied the message to the JMS queue. Notice we use a constant to build an \"ACK\" string as response.</p><pre><code lang=\"text/x-java\">\nfrom(\"mina:tcp://localhost:8888?textline=true\")\n        .to(\"jms:queue:order:in\")\n        .transform(constant(\"ACK\"));\n</code></pre></td></tr><tr><td class=\"light_blue\">Spring DSL</td><td class=\"light_cream\"><h4>Processor</h4><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=\"direct:transformOrder\"/&gt;\n        &lt;process ref=\"transformer\"/&gt;\n&lt;/route&gt;\n\n&lt;bean id=\"transformer\" class=\"com.mycompany.\nOrderTransformProcessor\"/&gt;\n</code></pre><p>In Spring DSL Camel will look up the processor or POJO/Bean in the registry based on the id of the bean.</p><h4>Bean</h4><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n&lt;from uri=\"direct:transformOrder\"/&gt;\n&lt;bean ref=\"transformer\"/&gt;\n&lt;/route&gt;\n&lt;bean id=\"tramsformer\"\nclass=\"com.mycompany.OrderTransformBean\"/&gt;\n</code></pre><h4>Transform</h4><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n&lt;from uri=\"mina:tcp://localhost:8888?textline=true\"/&gt;\n&lt;to uri=\"jms:queue:order:in\"/&gt;\n&lt;transform&gt;\n&lt;constant&gt;ACK&lt;/constant&gt;\n&lt;/transform&gt;\n&lt;/route&gt;\n</code></pre></td></tr><tr><td class=\"light_blue\">Annotation DSL</td><td class=\"light_cream\"><p>You can also use the <strong>@Consume</strong> annotation for transformations. For example in the method below we consume from a JMS queue and do the transformation in regular Java code. Notice that the input and output parameters of the method is String. Camel will automatically coerce the payload to the expected type defined by the method. Since this is a JMS example the response will be sent back to the JMS reply-to destination.</p><pre><code lang=\"text/x-java\">\n@Consume(uri=\"jms:queue:order:transform\")\npublic String transformOrder(String body) {\n        // do message translation\n}\n</code></pre><p><strong>TIP:</strong> You can use Bean Parameter Binding to help Camel coerce the Message into the method parameters. For instance you can use <strong>@Body, @Headers</strong> parameter annotations to bind parameters to the body and headers.</p></td></tr></tbody></table><h3>Message Filter</h3><table cellpadding=\"0\" cellspacing=\"0\"><tbody><tr><td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-9.jpg\"></td><td class=\"light_cream\">How can a component avoid receiving unwanted messages?</td></tr><tr><td colspan=\"2\"><img alt=\"Message Filter\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-10.jpg\"></td></tr><tr><td class=\"light_blue\">Problem</td><td class=\"light_cream\">How do you discard unwanted messages?</td></tr><tr><td class=\"light_blue\">Solution</td><td class=\"light_cream\">Use a special kind of Message Router, a Message Filter, to eliminate undesired messages from a channel based on a set of criteria.</td></tr><tr><td class=\"light_blue\">Camel</td><td class=\"light_cream\">Camel has support for Message Filter using the filter node. The filter evaluates a predicate whether its true or false; only allowing the true condition to pass the filter, where as the false condition will silently be ignored.</td></tr><tr><td class=\"light_blue\">Java DSL</td><td class=\"light_cream\">We want to discard any test messages so we only route non-test messages to the order queue.                <pre><code lang=\"text/x-java\">\nfrom(\"jms:queue:inbox\")\n        .filter(header(\"test\").isNotEqualTo(\"true\"))\n        .to(\"jms:queue:order\");</code></pre><br><br></td></tr><tr><td class=\"light_blue\">Spring DSL</td><td class=\"light_cream\">For the Spring DSL we use XPath to evaluate the predicate. The $test is a special shorthand in Camel to refer to the header with the given name. So even if the payload is not XML based we can still use XPath to evaluate predicates.                <pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=\"jms:queue:inbox\"/&gt;\n        &lt;filter&gt;\n                &lt;xpath&gt;$test = 'false'&lt;/xpath&gt;\n                &lt;to uri=\"jms:queue:inbox\"/&gt;\n        &lt;/filter&gt;\n&lt;/route&gt;</code></pre><br><br></td></tr></tbody></table><h3>Dynamic Router</h3><table cellpadding=\"0\" cellspacing=\"0\"><tbody><tr><td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-11.jpg\"></td><td class=\"light_cream\"></td></tr><tr><td colspan=\"2\"><img alt=\"Dynamic Router\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-12.jpg\"></td></tr><tr><td class=\"light_blue\">Problem</td><td class=\"light_cream\">How can we route messages based on a dynamic list of destinations?</td></tr><tr><td class=\"light_blue\">Solution</td><td class=\"light_cream\">Use a Dynamic Router, a router that can self-configure based on special configuration messages from participating destinations.</td></tr><tr><td class=\"light_blue\">Camel</td><td class=\"light_cream\">Camel has support for Dynamic Router using the Dynamic <strong>Recipient List</strong> combined with a data store holding the list of destinations.</td></tr><tr><td class=\"light_blue\">Java DSL</td><td class=\"light_cream\">We use a Processor as the dynamic router to determine the destinations. We could also have used a Bean instead.                <pre><code lang=\"text/x-java\">\nfrom(\"jms:queue:order\")\n        .processRef(myDynamicRouter)\n        .recipientList(\"destinations\");\n\npublic class MyDynamicRouter implements Processor {\n        public void process(Exchange exchange) {\n                // query a data store to find the best match of the\n                // endpoint and return the destination(s) in the\n                // header exchange.getIn()\n                // .setHeader(\"destinations\", list);\n        }\n}</code></pre><br><br></td></tr><tr><td class=\"light_blue\">Spring DSL</td><td class=\"light_cream\"><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=\"jms:queue:order\"/&gt;\n        &lt;process ref=\"myDynamicRouter\"/&gt;\n        &lt;recipientList&gt;\n                &lt;header&gt;destinations&lt;/destinations&gt;\n        &lt;/recipientList&gt;\n&lt;/route&gt;</code></pre><br><br></td></tr><tr><td class=\"light_blue\">Annotation DSL</td><td class=\"light_cream\"><pre><code lang=\"text/x-java\">\npublic class MyDynamicRouter {\n        @Consume(uri = \"jms:queue:order\")\n        @RecipientList\n        public List&lt;String&gt; route(@XPath(\"/customer/id\")\nString customerId, @Header(\"location\") String location,\nDocument body) {\n                // query data store, find best match for the\n                //endpoint and return destination (s)\n        }\n}\n</code></pre><p><strong>TIP:</strong> Notice how we used Bean Parameter Binding to bind the parameters to the route method based on an <strong>@XPath</strong> expression on the XML payload of the JMS message. This allows us to extract the customer id as a string parameter. <strong>@Header</strong> wil bind a JMS property with the key location. <strong>Document</strong> is the XML payload of the JMS message.</p><p><strong>TIP:</strong> Camel uses its strong type converter feature to convert the payload to the type of the method parameter. We could use String and Camel will convert the body to a String instead. You can register your own type converters as well using the <strong>@Converter</strong> annotation at the class and method level.</p></td></tr></tbody></table><h3>Recipient List</h3><table cellpadding=\"0\" cellspacing=\"0\"><tbody><tr><td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-13.jpg\"></td><td class=\"light_cream\">How do we route a message to a list of statically or dynamically specified recipients?</td></tr><tr><td colspan=\"2\"><img alt=\"Recipient List\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-14.jpg\"></td></tr><tr><td class=\"light_blue\">Problem</td><td class=\"light_cream\">How can we route messages based on a static or dynamic list of destinations?</td></tr><tr><td class=\"light_blue\">Solution</td><td class=\"light_cream\">Define a channel for each recipient. Then use a Recipient List to inspect an incoming message, determine the list of desired recipients and forward the message to all channels associated with the recipients in the list.</td></tr><tr><td class=\"light_blue\">Camel</td><td class=\"light_cream\">Camel supports the static Recipient List using the <strong>multicast</strong> node, and the dynamic Recipient List using the <strong>recipientList</strong> node.</td></tr><tr><td class=\"light_blue\">Java DSL</td><td class=\"light_cream\"><h4>Static</h4><p>In this route we route to a static list of two recipients, that will receive a copy of the same message simultaneously.</p><pre><code lang=\"text/x-java\">\nfrom(\"jms:queue:inbox\")\n        .multicast().to(\"file://backup\", \"seda:inbox\");\n</code></pre><h4>Dynamic</h4><p>In this route we route to a dynamic list of recipients defined in the message header [mails] containing a list of recipients as endpoint URLs. The bean processMails is used to add the header[mails] to the message.</p><pre><code lang=\"text/x-java\">\nfrom(\"seda:confirmMails\").beanRef(processMails)\n        .recipientList(\"destinations\");\n</code></pre><p>And in the process mails bean we use <strong>@Headers</strong> Bean Parameter Binding to provide a <strong>java.util.Map</strong> to store the recipients.</p><pre><code lang=\"text/x-java\">\npublic void confirm(@Headers Map headers, @Body String body} {\n        String[] recipients = ...\n        headers.put(\"\"destinations\", recipients);\n}\n</code></pre></td></tr><tr><td class=\"light_blue\">Spring DSL</td><td class=\"light_cream\"><h4>Static</h4><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=\"jms:queue:inbox\" /&gt;\n        &lt;multicast&gt;\n                &lt;to uri=\"file://backup\"/&gt;\n                &lt;to uri=\"seda:inbox\"/&gt;\n        &lt;/multicast&gt;\n&lt;/route&gt;\n</code></pre><h4>Dynamic</h4><p>In this example we invoke a method call on a Bean to provide the dynamic list of recipients.</p><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=\"jms:queue:inbox\" /&gt;\n        &lt;recipientList&gt;\n                &lt;method bean=\"myDynamicRouter\" method=\"route\"/&gt;\n        &lt;/recipientList&gt;\n&lt;/route&gt;\n\n&lt;bean id=\"myDynamicRouter\"\n        class=\"com.mycompany.MyDynamicRouter\"/&gt;\n\npublic class myDynamicRouter {\n        public String[] route(String body) {\n                return new String[] { \"file://backup\", .... }\n        }\n}\n</code></pre></td></tr><tr><td class=\"light_blue\">Annotation DSL</td><td class=\"light_cream\"><p>In the CustomerService class we annoate the <strong>whereTo</strong> method with <strong>@RecipientList</strong>, and return a single destination based on the customer id. Notice the flexibility of Camel as it can adapt accordingly to how you define what your methods are returning: a single element, a list, an iterator, etc.</p><pre><code lang=\"text/x-java\">\npublic class CustomerService {\n        @RecipientList\n        public String whereTo(@Header(\"customerId\") id) {\n                return \"jms:queue:customer:\" + id;\n        }\n}\n</code></pre><p>And then we can route to the bean and it will act as a dynamic recipient list.</p><pre><code lang=\"text/x-java\">\nfrom(\"jms:queue:inbox\")\n        .bean(CustomerService.class, \"whereTo\");\n</code></pre></td></tr></tbody></table><h3>Splitter</h3><table cellpadding=\"0\" cellspacing=\"0\"><tbody><tr><td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-15.jpg\"></td><td class=\"light_cream\">How can we process a message if it contains multiple elements, each of which may have to be processed in a different way?</td></tr><tr><td colspan=\"2\"><img alt=\"Splitter\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-16.jpg\"></td></tr><tr><td class=\"light_blue\">Problem</td><td class=\"light_cream\">How can we split a single message into pieces to be routed individually?</td></tr><tr><td class=\"light_blue\">Solution</td><td class=\"light_cream\">Use a Splitter to break out the composite message into a series of individual messages, each containing data related to one item.</td></tr><tr><td class=\"light_blue\">Camel</td><td class=\"light_cream\">Camel has support for Splitter using the <strong>split</strong> node.</td></tr><tr><td class=\"light_blue\">Java DSL</td><td class=\"light_cream\"><p>In this route we consume files from the inbox folder. Each file is then split into a new message. We use a tokenizer to split the file content line by line based on line breaks.</p><pre><code lang=\"text/x-java\">\nfrom(\"file://inbox\")\n        .split(body().tokenize(\"\\n\"))\n        .to(\"seda:orderLines\");\n</code></pre><p><strong>TIP:</strong> Camel also supports splitting streams using the streaming node. We can split the stream by using a comma:</p><pre><code lang=\"text/x-java\">\n.split(body().tokenize(\",\")).streaming().to(\"seda:parts\");\n</code></pre><p><strong>TIP:</strong> In the routes above each individual split message will be executed in sequence. Camel also supports parallel execution using the parallelProcessing node.</p><pre><code lang=\"text/x-java\">\n.split(body().tokenize(\",\")).streaming()\n        .parallelProcessing().to(\"seda:parts\");\n</code></pre></td></tr><tr><td class=\"light_blue\">Spring DSL</td><td class=\"light_cream\">In this route we use XPath to split XML payloads received on the JMS order queue.                <pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=\"jms:queue:order\"/&gt;\n        &lt;split&gt;\n                &lt;xpath&gt;/invoice/lineItems&lt;/xpath&gt;\n                &lt;to uri=\"seda:processOrderLine\"/&gt;\n        &lt;/split&gt;\n&lt;/route&gt;\n</code></pre><p>And in this route we split the messages using a regular expression</p><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=\"jms:queue:order\"/&gt;\n        &lt;split&gt;\n                &lt;tokenizer token=\"([A-Z|0-9]*);\" regex=\"true\"/&gt;\n                &lt;to uri=\"seda:processOrderLine\"/&gt;\n        &lt;/split&gt;\n&lt;/route&gt;\n</code></pre><p><strong>TIP:</strong> Split evaluates an org.apahce.camel.Expression to provide something that is iterable to produce each individual new message. This allows you to provide any kind of expression such as a Bean invoked as a method call.</p><pre><code lang=\"text/x-java\">\n&lt;split&gt;\n        &lt;method bean=\"mySplitter\" method=\"splitMe\"/&gt;\n        &lt;to uri=\"seda:processOrderLine\"/&gt;\n&lt;/split&gt;\n\n&lt;bean id=\"mySplitter\" class=\"com.mycompany.MySplitter\"/&gt;\n\npublic List splitMe(String body) {\n        // split using java code and return a List\n        List parts = ...\n        return parts;\n}\n</code></pre></td></tr></tbody></table><h3>Aggregator</h3><table cellpadding=\"0\" cellspacing=\"0\"><tbody><tr><td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-17.jpg\"></td><td class=\"light_cream\">How do we combine the results of individual, but related messages so that they can be processed as a whole?</td></tr><tr><td colspan=\"2\"><img alt=\"Message Router\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-18.jpg\"></td></tr><tr><td class=\"light_blue\">Problem</td><td class=\"light_cream\">How do we combine multiple messages into a single combined message?</td></tr><tr><td class=\"light_blue\">Solution</td><td class=\"light_cream\">Use a stateful filter, an Aggregator, to collect and store individual messages until it receives a complete set of related messages to be published.</td></tr><tr><td class=\"light_blue\">Camel</td><td class=\"light_cream\">Camel has support for the Aggregator using the aggregate node. Camel uses a stateful batch processor that is capable of aggregating related messaged into a single combined message. A correlation expression is used to determine which messages should be aggregated. An aggregation strategy is used to combine aggregated messages into the result message. Camel’s aggregator also supports a completion predicate allowing you to signal when the aggregation is complete. Camel also supports other completion signals based on timeout and/or a number of messages already aggregated.</td></tr><tr><td class=\"light_blue\">Java DSL</td><td class=\"light_cream\"><h4>Stock quote example</h4><p>We want to update a website every five minutes with the latest stock quotes. The quotes are received on a JMS topic. As we can receive multiple quotes for the same stock within this time period we only want to keep the last one as its the most up to date. We can do this with the aggregator:</p><pre><code lang=\"text/x-java\">\nfrom(\"jms:topic:stock:quote\")\n        .aggregate().xpath(\"/quote/@symbol\")\n        .batchTimeout(5 * 60 * 1000).to(\"seda:quotes\");\n</code></pre><p>As the correlation expression we use XPath to fetch the stock symbol from the message body. As the aggregation strategy we use the default provided by Camel that picks the latest message, and thus also the most up to date. The time period is set as a timeout value in milliseconds.</p><h4>Loan broker example</h4><p>We aggregate responses from various banks for their quote for a given loan request. We want to pick the bank with the best quote (the cheapest loan), therefore we need to base our aggregation strategy to pick the best quote.</p><pre><code lang=\"text/x-java\">\nfrom(\"jms:topic:loan:quote\")\n        .aggregate().header(\"loanId\")\n        .aggregationStrategy(bestQuote)\n        .completionPredicate(header(Exchange.AGGREGATED_SIZE)\n        .isGreaterThan(2))\n        .to(\"seda:bestLoanQuote\");\n</code></pre><p>We use a completion predicate that signals when we have received more than 2 quotes for a given loan, giving us at least 3 quotes to pick among. The following shows the code snippet for the aggregation strategy we must implement to pick the best quote:</p><pre><code lang=\"text/x-java\">\npublic class BestQuoteStrategy implements AggregationStrategy {\n        public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {\n                double oldQuote = oldExchange.getIn().getBody(Double.class);\n                double newQuote = newExchange.getIn().getBody(Double.class);\n                // return the \"winner\" that has the lowest quote\n                return newQuote &lt; oldQuote ? newExchange : oldExchange;\n        }\n}\n</code></pre></td></tr><tr><td class=\"light_blue\">Spring DSL</td><td class=\"light_cream\"><h4>Loan Broker Example</h4><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=\"jms:topic:loan:qoute\"/&gt;\n        &lt;aggregate strategyRef=\"bestQuote\"&gt;\n                &lt;correlationExpression&gt;\n                        &lt;header&gt;loanId&lt;/header&gt;\n                &lt;/correlationExpression&gt;\n                &lt;completionPredicate&gt;\n                        &lt;simple&gt;${header.CamelAggregatedSize} &gt; 2&lt;/simple&gt;\n                &lt;/completionPredicate&gt;\n        &lt;/aggregate&gt;\n        &lt;to uri=\"seda:bestLoanQuote\"/&gt;\n&lt;/route&gt;\n\n&lt;bean id=\"bestQuote\"\n        class=\"com.mycompany.BestQuoteStrategy\"/&gt;\n</code></pre><p><strong>TIP:</strong> We use the simple language to declare the completion predicate. Simple is a basic language that supports a primitive set of operators. ${header. CamelAggregatedSize} will fetch a header holding the number of messages aggregated.</p><p><strong>TIP:</strong> If the completed predicate is more complex we can use a method call to invoke a Bean so we can do the evaluation in pure Java code:</p><pre><code lang=\"text/x-java\">\n&lt;completionPredicate&gt;\n        &lt;method bean=\"quoteService\" method=\"isComplete\"/&gt;\n&lt;/compledtionPrediacate&gt;\npublic boolean isComplete(@Header(Exchange.AGGREGATED_SIZE)\n        int count, String body) {\n        return body.equals(\"STOP\");\n}\n</code></pre><p>Notice how we can use Bean Binding Parameter to get hold of the aggregation size as a parameter, instead of looking it up in the message.</p></td></tr></tbody></table><h3>Resequencer</h3><table cellpadding=\"0\" cellspacing=\"0\"><tbody><tr><td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-19.jpg\"></td><td class=\"light_cream\">How can we get a stream of related but out-of-sequence messages back into the correct order?</td></tr><tr><td colspan=\"2\"><img alt=\"Resequencer\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-20.jpg\"></td></tr><tr><td class=\"light_blue\">Problem</td><td class=\"light_cream\">How do we ensure ordering of messages?</td></tr><tr><td class=\"light_blue\">Solution</td><td class=\"light_cream\">Use a stateful filter, a Resequencer, to collect and reorder messages so that they can be published in a specified order.</td></tr><tr><td class=\"light_blue\">Camel</td><td class=\"light_cream\"><p>Camel has support for the Resequencer using the resequence node. Camel uses a stateful batch processor that is capable of reordering related messages. Camel supports two resequencing algorithms:</p><p><strong>-batch</strong> = collects messages into a batch, sorts the messages and publish the messages</p><p><strong>-stream</strong> = re-orders, continuously, message streams based on detection of gaps between messages.</p><p>Batch is similar to the aggregator but with sorting. Stream is the traditional Resequencer pattern with gap detection. Stream requires usage of number (longs) as sequencer numbers, enforced by the gap detection, as it must be able to compute if gaps exist. A gap is detected if a number in a series is missing, e.g. 3, 4, 6 with number 5 missing. Camel will back off the messages until number 5 arrives.</p></td></tr><tr><td class=\"light_blue\">Java DSL</td><td class=\"light_cream\"><h4>Batch:</h4><p>We want to process received stock quotes, once a minute, ordered by their stock symbol. We use XPath as the expression to select the stock symbol, as the value used for sorting.</p><pre><code lang=\"text/x-java\">\nfrom(\"jms:topic:stock:quote\")\n        .resequence().xpath(\"/quote/@symbol\")\n        .timeout(60 * 1000)\n        .to(\"seda:quotes\");\n</code></pre><p>Camel will default the order to ascending. You can provide your own comparison for sorting if needed.</p><h4>Stream:</h4><p>Suppose we continuously poll a file directory for inventory updates, and its important they are processed in sequence by their inventory id. To do this we enable streaming and use one hour as the timeout.</p><pre><code lang=\"text/x-java\">\nfrom(\"file://inventory\")\n        .resequence().xpath(\"/inventory/@id\")\n        .stream().timeout(60 * 60 * 1000)\n        .to(\"seda:inventoryUpdates\");\n</code></pre></td></tr><tr><td class=\"light_blue\">Spring DSL</td><td class=\"light_cream\"><h4>Batch:</h4><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=\"jms:topic:stock:quote\"/&gt;\n        &lt;resequence&gt;\n                &lt;xpath&gt;/quote/@symbol&lt;/xpath&gt;\n                &lt;batch-config batchTimeout=\"60000\"/&gt;\n        &lt;/resequence&gt;\n        &lt;to uri=\"seda:quotes\"/&gt;\n&lt;/route&gt;\n</code></pre><h4>Stream:</h4><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=\"file://inventory\"/&gt;\n        &lt;resequence&gt;\n                &lt;xpath&gt;/inventory/@id&lt;xpath&gt;\n                &lt;stream-config timeout=\"3600000\"/&gt;\n        &lt;/resequence&gt;\n        &lt;to uri=\"seda:quotes\"/&gt;\n&lt;/route&gt;\n</code></pre><p>Notice that you can enable streaming by specifying &lt;stream-config&gt; instead of &lt;batch-config&gt;.</p></td></tr></tbody></table><h3>Dead Letter Channel</h3><table cellpadding=\"0\" cellspacing=\"0\"><tbody><tr><td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-21.jpg\"></td><td class=\"light_cream\">What will the messaging system do with a message it cannot deliver?</td></tr><tr><td colspan=\"2\"><img alt=\"Message Router\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-22.jpg\"></td></tr><tr><td class=\"light_blue\">Problem</td><td class=\"light_cream\">The messaging system cannot deliver a message</td></tr><tr><td class=\"light_blue\">Solution</td><td class=\"light_cream\">When a message cannot be delivered it should be moved to a Dead Letter Channel</td></tr><tr><td class=\"light_blue\">Camel</td><td class=\"light_cream\"><p>Camel has extensive support for Dead Letter Channel by its error handler and exception clauses. Error handler supports redelivery policies to decide how many times to try redelivering a message, before moving it to a Dead Letter Channel.</p><p>The default Dead Letter Channel will log the message at ERROR level and perform up to 6 redeliveries using a one second delay before each retry.</p><p>Error handler has two scopes: global and per route</p><p><strong>TIP:</strong> See Exception Clause in the Camel documentation for selective interception of thrown exception. This allows you to route certain exceptions differently or even reset the failure by marking it as handled.</p><p><strong>TIP:</strong> DeadLetterChannel supports processing the message before it gets redelivered using onRedelivery. This allows you to alter the message beforehand (i.e. to set any custom headers).</p></td></tr><tr><td class=\"light_blue\">Java DSL</td><td class=\"light_cream\"><h4>Global scope</h4><pre><code lang=\"text/x-java\">\nerrorHandler(deadLetterChannel(\"jms:queue:error\")\n        .maximumRedeliveries(3));\n\nfrom(...)\n\nRoute scope\nfrom(\"jms:queue:event\")\n        .errorHandler(deadLetterChannel()\n        .maximumRedeliveries(5))\n        .multicast().to(\"log:event\", \"seda:handleEvent\");\n</code></pre><p>In this route we override the global scope to use up to five redeliveries, where as the global only has three. You can of course also set a different error queue destination:</p><pre><code lang=\"text/x-java\">\ndeadLetterChannel(\"log:badEvent\").maximumRedeliveries(5)\n</code></pre></td></tr><tr><td class=\"light_blue\">Spring DSL</td><td class=\"light_cream\"><p>The error handler is configured very differently in the Java DSL vs. the Spring DSL. The Spring DSL relies more on standard Spring bean configuration whereas the Java DSL uses fluent builders.</p><h4>Global scope</h4><p>The Global scope error handler is configured using the errorHandlerRef attribute on the camelContext tag.</p><pre><code lang=\"text/x-java\">\n&lt;camelContext errorHandlerRef=\"myDeadLetterChannel\"&gt;\n...\n&lt;/camelContext&gt;\n</code></pre><h4>Route scope</h4><p>Route scoped is configured using the errorHandlerRef attribute on the route tag.</p><pre><code lang=\"text/x-java\">\n&lt;route errorHandlerRef=\"myDeadLetterChannel\"&gt;\n...\n&lt;/route&gt;\n</code></pre><p>For both the error handler itself is configured using a regular Spring bean</p><pre><code lang=\"text/x-java\">\n&lt;bean id=\"myDeadLetterChannel\" class=\"org.apache.camel.\nbuilder.DeadLetterChannelBuilder\"&gt;\n        &lt;property name=\"deadLetterUri\" value=\"jms:queue:error\"/&gt;\n        &lt;property name=\"redeliveryPolicy\"\n                ref=\"myRedeliveryPolicy\"/&gt;\n&lt;/bean&gt;\n\n&lt;bean id=\"myRedeliverPolicy\"\n                class=\"org.apache.camel.processor.RedeliverPolicy\"&gt;\n        &lt;property name=\"maximumRedeliveries\" value=\"5\"/&gt;\n        &lt;property name=\"delay\" value=\"5000\"/&gt;\n&lt;/bean&gt;\n</code></pre></td></tr></tbody></table><h3>Wire Tap</h3><table cellpadding=\"0\" cellspacing=\"0\"><tbody><tr><td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" height=\"20\" src=\"images/rc047-010d-enterprise_integration_patterns-23.jpg\" width=\"34\"></td><td class=\"light_cream\">How do you inspect messages that travel on a point-to-point channel?</td></tr><tr><td colspan=\"2\"><img alt=\"Wire Tap\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-24.jpg\"></td></tr><tr><td class=\"light_blue\">Problem</td><td class=\"light_cream\">How do you tap messages while they are routed?</td></tr><tr><td class=\"light_blue\">Solution</td><td class=\"light_cream\">Insert a Wire Tap into the channel, that publishes each incoming message to the main channel as well as to a secondary channel.</td></tr><tr><td class=\"light_blue\">Camel</td><td class=\"light_cream\">Camel has support for Wire Tap using the wireTap node, that supports two modes: traditional and new message. The traditional mode sends a copy of the original message, as opposed to sending a new message. All messages are sent as Event Message and runs in parallel with the original message.</td></tr><tr><td class=\"light_blue\">Java DSL</td><td class=\"light_cream\"><h4>Traditional</h4><p>The route uses the traditional mode to send a copy of the original message to the seda tapped queue, while the original message is routed to its destination, the process order bean.</p><pre><code lang=\"text/x-java\">\nfrom(\"jms:queue:order\")\n        .wireTap(\"seda:tappedOrder\")\n        .to(\"bean:processOrder\");\n</code></pre><h4>New message</h4><p>In this route we tap the high priority orders and send a new message containing a body with the from part of the order. Tip: As Camel uses an Expression for evaluation you can use other functions than xpath, for instance to send a fixed String you can use constant.</p><pre><code lang=\"text/x-java\">\nfrom(\"jms:queue:order\")\n        .choice()\n                .when(\"/order/priority = ‘high’\")\n                        .wireTap(\"seda:from\", xpath(\"/order/from\"))\n                        .to(\"bean:processHighOrder\");\n                .otherwise()\n                        .to(\"bean:processOrder\");\n</code></pre></td></tr><tr><td class=\"light_blue\">Spring DSL</td><td class=\"light_cream\"><h4>Traditional</h4><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=\"jms:queue:order\"/&gt;\n        &lt;wireTap uri=\"seda:tappedOrder\"/&gt;\n        &lt;to uri=\"bean:processOrder\"/&gt;\n&lt;/route&gt;\n</code></pre><h4>New Message</h4><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;choice&gt;\n                &lt;when&gt;\n                        &lt;xpath&gt;/order/priority = 'high'&lt;/xpath&gt;\n                        &lt;wireTap uri=\"seda:from\"&gt;\n                                &lt;body&gt;&lt;xpath&gt;/order/from&lt;/xpath&gt;&lt;/body&gt;\n                        &lt;/wireTap&gt;\n                        &lt;to uri=\"bean:processHighOrder\"/&gt;\n                &lt;/when&gt;\n                &lt;otherwise&gt;\n                        &lt;to uri=\"bean:processOrder\"/&gt;\n                &lt;/otherwise&gt;\n        &lt;/choice&gt;\n&lt;/route&gt;\n</code></pre></td></tr></tbody></table><h2>Conclusion</h2><p pid=\"6\">The twelve patterns in this Refcard cover the most used patterns in the integration space, together with two of the most complex such as the Aggregator and the Dead Letter Channel. In the second part of this series we will take a further look at common patterns and transations.</p><h3>Get More Information</h3><table cellpadding=\"0\" cellspacing=\"0\"><tbody><tr><td class=\"light_blue\">Camel Website <a href=\"http://camel.apache.org\">http://camel.apache.org</a></td><td class=\"light_cream\">The home of the Apache Camel project. Find downloads, tutorials, examples, getting started guides, issue tracker, roadmap, mailing lists, irc chat rooms, and how to get help.</td></tr><tr><td class=\"light_blue\">FuseSource Website <a href=\"http://fusesource.com\">http://fusesource.com</a></td><td class=\"light_cream\">The home of the FuseSource company, the professional company behind Apache Camel with enterprise offerings, support, consulting and training.</td></tr><tr><td class=\"light_blue\">About Author <a href=\"http://davsclaus.blogspot.com\">http://davsclaus.blogspot.com</a></td><td class=\"light_cream\">The personal blog of the author of this reference card.</td></tr></tbody></table>","bodyAsHTML":"<p pid=\"1\" class=\"author_name\">By Claus Ibsen</p>\n<h2>About Enterprise Integration Patterns</h2>\n<p pid=\"2\">Integration is a hard problem. To help deal with the complexity of integration problems the Enterprise Integration Patterns (EIP) have become the standard way to describe, document and implement complex integration problems. Hohpe &amp; Woolf's book the Enterprise Integration Patterns has become the bible in the integration space - essential reading for any integration professional.</p>\n<p pid=\"3\">Apache Camel is an open source project for implementing the EIP easily in a few lines of Java code or Spring XML configuration. This reference card, the first in a two card series, guides you through the most common Enterprise Integration Patterns and gives you examples of how to implement them either in Java code or using Spring XML. This Refcard is targeted for software developers and enterprise architects, but anyone in the integration space can benefit as well.</p>\n<h2>About Apache Camel</h2>\n<p pid=\"4\">Apache Camel is a powerful open source integration platform based on Enterprise Integration Patterns (EIP) with powerful Bean Integration. Camel lets you implementing EIP routing using Camels intuitive Domain Specific Language (DSL) based on Java (aka fluent builder) or XML. Camel uses URI for endpoint resolution so its very easy to work with any kind of transport such as HTTP, REST, JMS, web service, File, FTP, TCP, Mail, JBI, Bean (POJO) and many others. Camel also provides Data Formats for various popular formats such as: CSV, EDI, FIX, HL7, JAXB, Json, Xstream. Camel is an integration API that can be embedded in any server of choice such as: J2EE Server, ActiveMQ, Tomcat, OSGi, or as standalone. Camels Bean Integration let you define loose coupling allowing you to fully separate your business logic from the integration logic. Camel is based on a modular architecture allowing you to plugin your own component or data format, so they seamlessly blend in with existing modules. Camel provides a test kit for unit and integration testing with strong mock and assertion capabilities.</p>\n<h2>Essential Patterns</h2>\n<p pid=\"5\">This group consists of the most essential patterns that anyone working with integration must know.</p>\n<h3>Pipes and Filters</h3>\n<table cellpadding=\"0\" cellspacing=\"0\">\n <tbody>\n  <tr>\n   <td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-1.jpg\"></td>\n   <td class=\"light_cream\">How can we perform complex processing on a message while maintaining independence and flexibility?</td>\n  </tr>\n  <tr>\n   <td colspan=\"2\"><img alt=\"Pipes and Filters\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-2.jpg\"></td>\n  </tr>\n </tbody>\n</table>\n<table cellpadding=\"0\" cellspacing=\"0\">\n <tbody>\n  <tr>\n   <td class=\"light_blue\">Problem</td>\n   <td class=\"light_cream\">A single event often triggers a sequence of processing steps</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Solution</td>\n   <td class=\"light_cream\">Use Pipes and Filters to divide a larger processing steps (filters) that are connected by channels (pipes)</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Camel</td>\n   <td class=\"light_cream\">Camel supports Pipes and Filters using the <strong>pipeline</strong> node.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Java DSL</td>\n   <td class=\"light_cream\"><pre><code lang=\"text/x-java\">\nfrom(\"jms:queue:order:in\").pipeline(\"direct:transformOrder\", \"direct:validateOrder\", \"jms:queue:order:process\");\n</code></pre><p>Where jms represents the JMS component used for consuming JMS messages on the JMS broker. Direct is used for combining endpoints in a synchronous fashion, allow you to divide routes into sub routes and/or reuse common routes.</p><p><strong>Tip:</strong> Pipeline is the default mode of operation when you specify multiple outputs, so it can be omitted and replaced with the more common node:</p><pre><code lang=\"text/x-java\">\nfrom(\"jms:queue:order:in\").to(\"direct:transformOrder\",\n\"direct:validateOrder\", \"jms:queue:order:process\");\n</code></pre><p><strong>TIP:</strong> You can also separate each step as individual <strong>to</strong> nodes:</p><pre><code lang=\"text/x-java\">\nfrom(\"jms:queue:order:in\")\n        .to(\"direct:transformOrder\")\n        .to(\"direct:validateOrder\")\n        .to(\"jms:queue:order:process\");\n</code></pre></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Spring DSL</td>\n   <td class=\"light_cream\"><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=\"jms:queue:order:in\"/&gt;\n        &lt;pipeline&gt;\n                &lt;to uri=\"direct:transformOrder\"/&gt;\n                &lt;to uri=\"direct:validateOrder\"/&gt;\n                &lt;to uri=\"jms:queue:order:process\"/&gt;\n        &lt;/pipeline&gt;\n&lt;/route&gt;\n&lt;route&gt;\n        &lt;from uri=\"jms:queue:order:in\"/&gt;\n        &lt;to uri=\"direct:transformOrder\"/&gt;\n        &lt;to uri=\"direct:validateOrder\"/&gt;\n        &lt;to uri=\"jms:queue:order:process\"/&gt;\n&lt;/route&gt;</code></pre><br><br></td>\n  </tr>\n </tbody>\n</table>\n<h3>Message Router</h3>\n<table cellpadding=\"0\" cellspacing=\"0\">\n <tbody>\n  <tr>\n   <td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" height=\"23\" src=\"images/rc047-010d-enterprise_integration_patterns-3.jpg\" width=\"42\"></td>\n   <td class=\"light_cream\">How can you deouple indevidual processing steps so that messages can be passed to different filters depending on a set of conditions?</td>\n  </tr>\n  <tr>\n   <td colspan=\"2\"><img alt=\"Message Router\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-4.jpg\"></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Problem</td>\n   <td class=\"light_cream\">Pipes and Filters route each message in the same processing steps. How can we route messages differently?</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Solution</td>\n   <td class=\"light_cream\">Filter using predicates to choose the right output destination.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Camel</td>\n   <td class=\"light_cream\">Camel supports Message Router using the <strong>choice</strong> node. For more details see the Content Based router pattern.</td>\n  </tr>\n </tbody>\n</table>\n<h3>Content-Based Router</h3>\n<table cellpadding=\"0\" cellspacing=\"0\">\n <tbody>\n  <tr>\n   <td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-5.jpg\"></td>\n   <td class=\"light_cream\">How do we handle a situation where the implementation of a single logical function (e.g., inventory check) is spread across multiple physical systems?</td>\n  </tr>\n  <tr>\n   <td colspan=\"2\"><img alt=\"Content-Based Router\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-6.jpg\"></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Problem</td>\n   <td class=\"light_cream\">How do we ensure a Message is sent to the correct recipient based on information from its content?</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Solution</td>\n   <td class=\"light_cream\">Use a Content-Based Router to route each message to the correct recipient based on the message content.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Camel</td>\n   <td class=\"light_cream\">Camel has extensive support for Content-Based Routing. Camel supports content based routing based on <strong>choice, filter,</strong> or any other expression.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Java DSL</td>\n   <td class=\"light_cream\"><h4>Choice</h4><pre><code lang=\"text/x-java\">\nfrom(\"jms:queue:order\")\n.choice()\n.when(header(\"type\").in(\"widget\",\"wiggy\"))\n.to(\"jms:queue:order:widget\")\n.when(header(\"type\").isEqualTo(\"gadget\"))\n.to(\"jms:queue:order:gadget\")\n.otherwise().to(\"jms:queue:order:misc\")\n.end();\n</code></pre><p><strong>TIP:</strong> In the route above end() can be omitted as its the last node and we do not route the message to a new destination after the choice.</p><p><strong>TIP:</strong> You can continue routing after the choice ends.</p></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Spring DSL</td>\n   <td class=\"light_cream\"><h4>Choice</h4><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=\"jms:queue:order\"/&gt;\n        &lt;choice&gt;\n                &lt;when&gt;\n                        &lt;simple&gt;${header.type} in 'widget,wiggy'&lt;/simple&gt;\n                        &lt;to uri=\"jms:queue:order:widget\"/&gt;\n                &lt;/when&gt;\n                &lt;when&gt;\n                        &lt;simple&gt;${header.type} == 'gadget'&lt;/simple&gt;\n                        &lt;to uri=\"jms:queue:order:gadget\"/&gt;\n                &lt;/when&gt;\n                &lt;otherwise&gt;\n                        &lt;to uri=\"jms:queue:order:misc\"/&gt;\n                &lt;/otherwise&gt;\n        &lt;/choice&gt;\n&lt;/route&gt;\n</code></pre><p><strong>TIP:</strong> In Spring DSL you cannot invoke code, as opposed to the Java DSL that is 100% Java. To express the predicates for the choices we need to use a language. We will use simple language that uses a simple expression parser that supports a limited set of operators. You can use any of the more powerful languages supported in Camel such as: JavaScript, Groovy, Unified EL and many others.</p><p><strong>TIP:</strong> You can also use a method call to invoke a method on a bean to evaluate the predicate. Lets try that:</p><pre><code lang=\"text/x-java\">\n&lt;when&gt;\n        &lt;method bean=\"myBean\" method=\"isGadget\"/&gt;\n        ...\n&lt;/when&gt;\n\n&lt;bean id=\"myBean\" class=\"com.mycomapany.MyBean\"/&gt;\n\npublic boolean isGadget(@Header(name = \"type\") String type) {\n        return type.equals(\"Gadget\");\n}\n</code></pre><p>Notice how we use Bean Parameter Binding to instruct Camel to invoke this method and pass in the type header as the String parameter. This allows your code to be fully decoupled from any Camel API so its easy to read, write and unit test.</p></td>\n  </tr>\n </tbody>\n</table>\n<h3>Message Translator</h3>\n<table cellpadding=\"0\" cellspacing=\"0\">\n <tbody>\n  <tr>\n   <td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-7.jpg\"></td>\n   <td class=\"light_cream\">How can systems using different data formats communicate with each other using messaging?</td>\n  </tr>\n  <tr>\n   <td colspan=\"2\"><img alt=\"Message Translator\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-8.jpg\"></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Problem</td>\n   <td class=\"light_cream\">Each application uses its own data format, so we need to translate the message into the data format the application supports.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Solution</td>\n   <td class=\"light_cream\">Use a special filter, a messae translator, between filters or applications to translate one data format into another.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Camel</td>\n   <td class=\"light_cream\">Camel supports the message translator using the <strong>processor, bean</strong> or <strong>transform</strong> nodes. TIP: Camel routes the message as a chain of <strong>processor</strong> nodes.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Java DSL</td>\n   <td class=\"light_cream\"><h4>Processor</h4><pre><code lang=\"text/x-java\">\npublic class OrderTransformProcessor\n                implements Processor {\n        public void process(Exchange exchange)\n                        throws Exception {\n                // do message translation here\n        }\n}\nfrom(\"direct:transformOrder\")\n        .process(new OrderTransformProcessor());\n</code></pre><h4>Bean</h4><p>Instead of the processor we can use Bean (POJO). An advantage of using a Bean over Processor is the fact that we do not have to implement or use any Camel specific interfaces or types. This allows you to fully decouple your beans from Camel.</p><pre><code lang=\"text/x-java\">\npublic class OrderTransformerBean {\n        public StringtransformOrder(String body) {\n                // do message translation here\n        }\n}\nObject transformer = new OrderTransformerBean();\nfrom(\"direct:transformOrder\").bean(transformer);\n</code></pre><p><strong>TIP:</strong> Camel can create an instance of the bean automatically; you can just refer to the class type.</p><pre><code lang=\"text/x-java\">\nfrom(\"direct:transformOrder\")\n        .bean(OrderTransformerBean.class);\n</code></pre><p><strong>TIP:</strong> Camel will try to figure out which method to invoke on the bean in case there are multiple methods. In case of ambiguity you can specify which methods to invoke by the method parameter:</p><pre><code lang=\"text/x-java\">\nfrom(\"direct:transformOrder\")\n        .bean(OrderTransformerBean.class, \"transformOrder\");\n</code></pre><h4>Transform</h4><p>Transform is a particular processor allowing you to set a response to be returned to the original caller. We use transform to return a constant ACK response to the TCP listener after we have copied the message to the JMS queue. Notice we use a constant to build an \"ACK\" string as response.</p><pre><code lang=\"text/x-java\">\nfrom(\"mina:tcp://localhost:8888?textline=true\")\n        .to(\"jms:queue:order:in\")\n        .transform(constant(\"ACK\"));\n</code></pre></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Spring DSL</td>\n   <td class=\"light_cream\"><h4>Processor</h4><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=\"direct:transformOrder\"/&gt;\n        &lt;process ref=\"transformer\"/&gt;\n&lt;/route&gt;\n\n&lt;bean id=\"transformer\" class=\"com.mycompany.\nOrderTransformProcessor\"/&gt;\n</code></pre><p>In Spring DSL Camel will look up the processor or POJO/Bean in the registry based on the id of the bean.</p><h4>Bean</h4><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n&lt;from uri=\"direct:transformOrder\"/&gt;\n&lt;bean ref=\"transformer\"/&gt;\n&lt;/route&gt;\n&lt;bean id=\"tramsformer\"\nclass=\"com.mycompany.OrderTransformBean\"/&gt;\n</code></pre><h4>Transform</h4><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n&lt;from uri=\"mina:tcp://localhost:8888?textline=true\"/&gt;\n&lt;to uri=\"jms:queue:order:in\"/&gt;\n&lt;transform&gt;\n&lt;constant&gt;ACK&lt;/constant&gt;\n&lt;/transform&gt;\n&lt;/route&gt;\n</code></pre></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Annotation DSL</td>\n   <td class=\"light_cream\"><p>You can also use the <strong>@Consume</strong> annotation for transformations. For example in the method below we consume from a JMS queue and do the transformation in regular Java code. Notice that the input and output parameters of the method is String. Camel will automatically coerce the payload to the expected type defined by the method. Since this is a JMS example the response will be sent back to the JMS reply-to destination.</p><pre><code lang=\"text/x-java\">\n@Consume(uri=\"jms:queue:order:transform\")\npublic String transformOrder(String body) {\n        // do message translation\n}\n</code></pre><p><strong>TIP:</strong> You can use Bean Parameter Binding to help Camel coerce the Message into the method parameters. For instance you can use <strong>@Body, @Headers</strong> parameter annotations to bind parameters to the body and headers.</p></td>\n  </tr>\n </tbody>\n</table>\n<h3>Message Filter</h3>\n<table cellpadding=\"0\" cellspacing=\"0\">\n <tbody>\n  <tr>\n   <td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-9.jpg\"></td>\n   <td class=\"light_cream\">How can a component avoid receiving unwanted messages?</td>\n  </tr>\n  <tr>\n   <td colspan=\"2\"><img alt=\"Message Filter\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-10.jpg\"></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Problem</td>\n   <td class=\"light_cream\">How do you discard unwanted messages?</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Solution</td>\n   <td class=\"light_cream\">Use a special kind of Message Router, a Message Filter, to eliminate undesired messages from a channel based on a set of criteria.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Camel</td>\n   <td class=\"light_cream\">Camel has support for Message Filter using the filter node. The filter evaluates a predicate whether its true or false; only allowing the true condition to pass the filter, where as the false condition will silently be ignored.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Java DSL</td>\n   <td class=\"light_cream\">We want to discard any test messages so we only route non-test messages to the order queue. <pre><code lang=\"text/x-java\">\nfrom(\"jms:queue:inbox\")\n        .filter(header(\"test\").isNotEqualTo(\"true\"))\n        .to(\"jms:queue:order\");</code></pre><br><br></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Spring DSL</td>\n   <td class=\"light_cream\">For the Spring DSL we use XPath to evaluate the predicate. The $test is a special shorthand in Camel to refer to the header with the given name. So even if the payload is not XML based we can still use XPath to evaluate predicates. <pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=\"jms:queue:inbox\"/&gt;\n        &lt;filter&gt;\n                &lt;xpath&gt;$test = 'false'&lt;/xpath&gt;\n                &lt;to uri=\"jms:queue:inbox\"/&gt;\n        &lt;/filter&gt;\n&lt;/route&gt;</code></pre><br><br></td>\n  </tr>\n </tbody>\n</table>\n<h3>Dynamic Router</h3>\n<table cellpadding=\"0\" cellspacing=\"0\">\n <tbody>\n  <tr>\n   <td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-11.jpg\"></td>\n   <td class=\"light_cream\"></td>\n  </tr>\n  <tr>\n   <td colspan=\"2\"><img alt=\"Dynamic Router\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-12.jpg\"></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Problem</td>\n   <td class=\"light_cream\">How can we route messages based on a dynamic list of destinations?</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Solution</td>\n   <td class=\"light_cream\">Use a Dynamic Router, a router that can self-configure based on special configuration messages from participating destinations.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Camel</td>\n   <td class=\"light_cream\">Camel has support for Dynamic Router using the Dynamic <strong>Recipient List</strong> combined with a data store holding the list of destinations.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Java DSL</td>\n   <td class=\"light_cream\">We use a Processor as the dynamic router to determine the destinations. We could also have used a Bean instead. <pre><code lang=\"text/x-java\">\nfrom(\"jms:queue:order\")\n        .processRef(myDynamicRouter)\n        .recipientList(\"destinations\");\n\npublic class MyDynamicRouter implements Processor {\n        public void process(Exchange exchange) {\n                // query a data store to find the best match of the\n                // endpoint and return the destination(s) in the\n                // header exchange.getIn()\n                // .setHeader(\"destinations\", list);\n        }\n}</code></pre><br><br></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Spring DSL</td>\n   <td class=\"light_cream\"><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=\"jms:queue:order\"/&gt;\n        &lt;process ref=\"myDynamicRouter\"/&gt;\n        &lt;recipientList&gt;\n                &lt;header&gt;destinations&lt;/destinations&gt;\n        &lt;/recipientList&gt;\n&lt;/route&gt;</code></pre><br><br></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Annotation DSL</td>\n   <td class=\"light_cream\"><pre><code lang=\"text/x-java\">\npublic class MyDynamicRouter {\n        @Consume(uri = \"jms:queue:order\")\n        @RecipientList\n        public List&lt;String&gt; route(@XPath(\"/customer/id\")\nString customerId, @Header(\"location\") String location,\nDocument body) {\n                // query data store, find best match for the\n                //endpoint and return destination (s)\n        }\n}\n</code></pre><p><strong>TIP:</strong> Notice how we used Bean Parameter Binding to bind the parameters to the route method based on an <strong>@XPath</strong> expression on the XML payload of the JMS message. This allows us to extract the customer id as a string parameter. <strong>@Header</strong> wil bind a JMS property with the key location. <strong>Document</strong> is the XML payload of the JMS message.</p><p><strong>TIP:</strong> Camel uses its strong type converter feature to convert the payload to the type of the method parameter. We could use String and Camel will convert the body to a String instead. You can register your own type converters as well using the <strong>@Converter</strong> annotation at the class and method level.</p></td>\n  </tr>\n </tbody>\n</table>\n<h3>Recipient List</h3>\n<table cellpadding=\"0\" cellspacing=\"0\">\n <tbody>\n  <tr>\n   <td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-13.jpg\"></td>\n   <td class=\"light_cream\">How do we route a message to a list of statically or dynamically specified recipients?</td>\n  </tr>\n  <tr>\n   <td colspan=\"2\"><img alt=\"Recipient List\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-14.jpg\"></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Problem</td>\n   <td class=\"light_cream\">How can we route messages based on a static or dynamic list of destinations?</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Solution</td>\n   <td class=\"light_cream\">Define a channel for each recipient. Then use a Recipient List to inspect an incoming message, determine the list of desired recipients and forward the message to all channels associated with the recipients in the list.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Camel</td>\n   <td class=\"light_cream\">Camel supports the static Recipient List using the <strong>multicast</strong> node, and the dynamic Recipient List using the <strong>recipientList</strong> node.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Java DSL</td>\n   <td class=\"light_cream\"><h4>Static</h4><p>In this route we route to a static list of two recipients, that will receive a copy of the same message simultaneously.</p><pre><code lang=\"text/x-java\">\nfrom(\"jms:queue:inbox\")\n        .multicast().to(\"file://backup\", \"seda:inbox\");\n</code></pre><h4>Dynamic</h4><p>In this route we route to a dynamic list of recipients defined in the message header [mails] containing a list of recipients as endpoint URLs. The bean processMails is used to add the header[mails] to the message.</p><pre><code lang=\"text/x-java\">\nfrom(\"seda:confirmMails\").beanRef(processMails)\n        .recipientList(\"destinations\");\n</code></pre><p>And in the process mails bean we use <strong>@Headers</strong> Bean Parameter Binding to provide a <strong>java.util.Map</strong> to store the recipients.</p><pre><code lang=\"text/x-java\">\npublic void confirm(@Headers Map headers, @Body String body} {\n        String[] recipients = ...\n        headers.put(\"\"destinations\", recipients);\n}\n</code></pre></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Spring DSL</td>\n   <td class=\"light_cream\"><h4>Static</h4><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=\"jms:queue:inbox\" /&gt;\n        &lt;multicast&gt;\n                &lt;to uri=\"file://backup\"/&gt;\n                &lt;to uri=\"seda:inbox\"/&gt;\n        &lt;/multicast&gt;\n&lt;/route&gt;\n</code></pre><h4>Dynamic</h4><p>In this example we invoke a method call on a Bean to provide the dynamic list of recipients.</p><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=\"jms:queue:inbox\" /&gt;\n        &lt;recipientList&gt;\n                &lt;method bean=\"myDynamicRouter\" method=\"route\"/&gt;\n        &lt;/recipientList&gt;\n&lt;/route&gt;\n\n&lt;bean id=\"myDynamicRouter\"\n        class=\"com.mycompany.MyDynamicRouter\"/&gt;\n\npublic class myDynamicRouter {\n        public String[] route(String body) {\n                return new String[] { \"file://backup\", .... }\n        }\n}\n</code></pre></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Annotation DSL</td>\n   <td class=\"light_cream\"><p>In the CustomerService class we annoate the <strong>whereTo</strong> method with <strong>@RecipientList</strong>, and return a single destination based on the customer id. Notice the flexibility of Camel as it can adapt accordingly to how you define what your methods are returning: a single element, a list, an iterator, etc.</p><pre><code lang=\"text/x-java\">\npublic class CustomerService {\n        @RecipientList\n        public String whereTo(@Header(\"customerId\") id) {\n                return \"jms:queue:customer:\" + id;\n        }\n}\n</code></pre><p>And then we can route to the bean and it will act as a dynamic recipient list.</p><pre><code lang=\"text/x-java\">\nfrom(\"jms:queue:inbox\")\n        .bean(CustomerService.class, \"whereTo\");\n</code></pre></td>\n  </tr>\n </tbody>\n</table>\n<h3>Splitter</h3>\n<table cellpadding=\"0\" cellspacing=\"0\">\n <tbody>\n  <tr>\n   <td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-15.jpg\"></td>\n   <td class=\"light_cream\">How can we process a message if it contains multiple elements, each of which may have to be processed in a different way?</td>\n  </tr>\n  <tr>\n   <td colspan=\"2\"><img alt=\"Splitter\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-16.jpg\"></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Problem</td>\n   <td class=\"light_cream\">How can we split a single message into pieces to be routed individually?</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Solution</td>\n   <td class=\"light_cream\">Use a Splitter to break out the composite message into a series of individual messages, each containing data related to one item.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Camel</td>\n   <td class=\"light_cream\">Camel has support for Splitter using the <strong>split</strong> node.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Java DSL</td>\n   <td class=\"light_cream\"><p>In this route we consume files from the inbox folder. Each file is then split into a new message. We use a tokenizer to split the file content line by line based on line breaks.</p><pre><code lang=\"text/x-java\">\nfrom(\"file://inbox\")\n        .split(body().tokenize(\"\\n\"))\n        .to(\"seda:orderLines\");\n</code></pre><p><strong>TIP:</strong> Camel also supports splitting streams using the streaming node. We can split the stream by using a comma:</p><pre><code lang=\"text/x-java\">\n.split(body().tokenize(\",\")).streaming().to(\"seda:parts\");\n</code></pre><p><strong>TIP:</strong> In the routes above each individual split message will be executed in sequence. Camel also supports parallel execution using the parallelProcessing node.</p><pre><code lang=\"text/x-java\">\n.split(body().tokenize(\",\")).streaming()\n        .parallelProcessing().to(\"seda:parts\");\n</code></pre></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Spring DSL</td>\n   <td class=\"light_cream\">In this route we use XPath to split XML payloads received on the JMS order queue. <pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=\"jms:queue:order\"/&gt;\n        &lt;split&gt;\n                &lt;xpath&gt;/invoice/lineItems&lt;/xpath&gt;\n                &lt;to uri=\"seda:processOrderLine\"/&gt;\n        &lt;/split&gt;\n&lt;/route&gt;\n</code></pre><p>And in this route we split the messages using a regular expression</p><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=\"jms:queue:order\"/&gt;\n        &lt;split&gt;\n                &lt;tokenizer token=\"([A-Z|0-9]*);\" regex=\"true\"/&gt;\n                &lt;to uri=\"seda:processOrderLine\"/&gt;\n        &lt;/split&gt;\n&lt;/route&gt;\n</code></pre><p><strong>TIP:</strong> Split evaluates an org.apahce.camel.Expression to provide something that is iterable to produce each individual new message. This allows you to provide any kind of expression such as a Bean invoked as a method call.</p><pre><code lang=\"text/x-java\">\n&lt;split&gt;\n        &lt;method bean=\"mySplitter\" method=\"splitMe\"/&gt;\n        &lt;to uri=\"seda:processOrderLine\"/&gt;\n&lt;/split&gt;\n\n&lt;bean id=\"mySplitter\" class=\"com.mycompany.MySplitter\"/&gt;\n\npublic List splitMe(String body) {\n        // split using java code and return a List\n        List parts = ...\n        return parts;\n}\n</code></pre></td>\n  </tr>\n </tbody>\n</table>\n<h3>Aggregator</h3>\n<table cellpadding=\"0\" cellspacing=\"0\">\n <tbody>\n  <tr>\n   <td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-17.jpg\"></td>\n   <td class=\"light_cream\">How do we combine the results of individual, but related messages so that they can be processed as a whole?</td>\n  </tr>\n  <tr>\n   <td colspan=\"2\"><img alt=\"Message Router\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-18.jpg\"></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Problem</td>\n   <td class=\"light_cream\">How do we combine multiple messages into a single combined message?</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Solution</td>\n   <td class=\"light_cream\">Use a stateful filter, an Aggregator, to collect and store individual messages until it receives a complete set of related messages to be published.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Camel</td>\n   <td class=\"light_cream\">Camel has support for the Aggregator using the aggregate node. Camel uses a stateful batch processor that is capable of aggregating related messaged into a single combined message. A correlation expression is used to determine which messages should be aggregated. An aggregation strategy is used to combine aggregated messages into the result message. Camel’s aggregator also supports a completion predicate allowing you to signal when the aggregation is complete. Camel also supports other completion signals based on timeout and/or a number of messages already aggregated.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Java DSL</td>\n   <td class=\"light_cream\"><h4>Stock quote example</h4><p>We want to update a website every five minutes with the latest stock quotes. The quotes are received on a JMS topic. As we can receive multiple quotes for the same stock within this time period we only want to keep the last one as its the most up to date. We can do this with the aggregator:</p><pre><code lang=\"text/x-java\">\nfrom(\"jms:topic:stock:quote\")\n        .aggregate().xpath(\"/quote/@symbol\")\n        .batchTimeout(5 * 60 * 1000).to(\"seda:quotes\");\n</code></pre><p>As the correlation expression we use XPath to fetch the stock symbol from the message body. As the aggregation strategy we use the default provided by Camel that picks the latest message, and thus also the most up to date. The time period is set as a timeout value in milliseconds.</p><h4>Loan broker example</h4><p>We aggregate responses from various banks for their quote for a given loan request. We want to pick the bank with the best quote (the cheapest loan), therefore we need to base our aggregation strategy to pick the best quote.</p><pre><code lang=\"text/x-java\">\nfrom(\"jms:topic:loan:quote\")\n        .aggregate().header(\"loanId\")\n        .aggregationStrategy(bestQuote)\n        .completionPredicate(header(Exchange.AGGREGATED_SIZE)\n        .isGreaterThan(2))\n        .to(\"seda:bestLoanQuote\");\n</code></pre><p>We use a completion predicate that signals when we have received more than 2 quotes for a given loan, giving us at least 3 quotes to pick among. The following shows the code snippet for the aggregation strategy we must implement to pick the best quote:</p><pre><code lang=\"text/x-java\">\npublic class BestQuoteStrategy implements AggregationStrategy {\n        public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {\n                double oldQuote = oldExchange.getIn().getBody(Double.class);\n                double newQuote = newExchange.getIn().getBody(Double.class);\n                // return the \"winner\" that has the lowest quote\n                return newQuote &lt; oldQuote ? newExchange : oldExchange;\n        }\n}\n</code></pre></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Spring DSL</td>\n   <td class=\"light_cream\"><h4>Loan Broker Example</h4><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=\"jms:topic:loan:qoute\"/&gt;\n        &lt;aggregate strategyRef=\"bestQuote\"&gt;\n                &lt;correlationExpression&gt;\n                        &lt;header&gt;loanId&lt;/header&gt;\n                &lt;/correlationExpression&gt;\n                &lt;completionPredicate&gt;\n                        &lt;simple&gt;${header.CamelAggregatedSize} &gt; 2&lt;/simple&gt;\n                &lt;/completionPredicate&gt;\n        &lt;/aggregate&gt;\n        &lt;to uri=\"seda:bestLoanQuote\"/&gt;\n&lt;/route&gt;\n\n&lt;bean id=\"bestQuote\"\n        class=\"com.mycompany.BestQuoteStrategy\"/&gt;\n</code></pre><p><strong>TIP:</strong> We use the simple language to declare the completion predicate. Simple is a basic language that supports a primitive set of operators. ${header. CamelAggregatedSize} will fetch a header holding the number of messages aggregated.</p><p><strong>TIP:</strong> If the completed predicate is more complex we can use a method call to invoke a Bean so we can do the evaluation in pure Java code:</p><pre><code lang=\"text/x-java\">\n&lt;completionPredicate&gt;\n        &lt;method bean=\"quoteService\" method=\"isComplete\"/&gt;\n&lt;/compledtionPrediacate&gt;\npublic boolean isComplete(@Header(Exchange.AGGREGATED_SIZE)\n        int count, String body) {\n        return body.equals(\"STOP\");\n}\n</code></pre><p>Notice how we can use Bean Binding Parameter to get hold of the aggregation size as a parameter, instead of looking it up in the message.</p></td>\n  </tr>\n </tbody>\n</table>\n<h3>Resequencer</h3>\n<table cellpadding=\"0\" cellspacing=\"0\">\n <tbody>\n  <tr>\n   <td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-19.jpg\"></td>\n   <td class=\"light_cream\">How can we get a stream of related but out-of-sequence messages back into the correct order?</td>\n  </tr>\n  <tr>\n   <td colspan=\"2\"><img alt=\"Resequencer\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-20.jpg\"></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Problem</td>\n   <td class=\"light_cream\">How do we ensure ordering of messages?</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Solution</td>\n   <td class=\"light_cream\">Use a stateful filter, a Resequencer, to collect and reorder messages so that they can be published in a specified order.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Camel</td>\n   <td class=\"light_cream\"><p>Camel has support for the Resequencer using the resequence node. Camel uses a stateful batch processor that is capable of reordering related messages. Camel supports two resequencing algorithms:</p><p><strong>-batch</strong> = collects messages into a batch, sorts the messages and publish the messages</p><p><strong>-stream</strong> = re-orders, continuously, message streams based on detection of gaps between messages.</p><p>Batch is similar to the aggregator but with sorting. Stream is the traditional Resequencer pattern with gap detection. Stream requires usage of number (longs) as sequencer numbers, enforced by the gap detection, as it must be able to compute if gaps exist. A gap is detected if a number in a series is missing, e.g. 3, 4, 6 with number 5 missing. Camel will back off the messages until number 5 arrives.</p></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Java DSL</td>\n   <td class=\"light_cream\"><h4>Batch:</h4><p>We want to process received stock quotes, once a minute, ordered by their stock symbol. We use XPath as the expression to select the stock symbol, as the value used for sorting.</p><pre><code lang=\"text/x-java\">\nfrom(\"jms:topic:stock:quote\")\n        .resequence().xpath(\"/quote/@symbol\")\n        .timeout(60 * 1000)\n        .to(\"seda:quotes\");\n</code></pre><p>Camel will default the order to ascending. You can provide your own comparison for sorting if needed.</p><h4>Stream:</h4><p>Suppose we continuously poll a file directory for inventory updates, and its important they are processed in sequence by their inventory id. To do this we enable streaming and use one hour as the timeout.</p><pre><code lang=\"text/x-java\">\nfrom(\"file://inventory\")\n        .resequence().xpath(\"/inventory/@id\")\n        .stream().timeout(60 * 60 * 1000)\n        .to(\"seda:inventoryUpdates\");\n</code></pre></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Spring DSL</td>\n   <td class=\"light_cream\"><h4>Batch:</h4><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=\"jms:topic:stock:quote\"/&gt;\n        &lt;resequence&gt;\n                &lt;xpath&gt;/quote/@symbol&lt;/xpath&gt;\n                &lt;batch-config batchTimeout=\"60000\"/&gt;\n        &lt;/resequence&gt;\n        &lt;to uri=\"seda:quotes\"/&gt;\n&lt;/route&gt;\n</code></pre><h4>Stream:</h4><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=\"file://inventory\"/&gt;\n        &lt;resequence&gt;\n                &lt;xpath&gt;/inventory/@id&lt;xpath&gt;\n                &lt;stream-config timeout=\"3600000\"/&gt;\n        &lt;/resequence&gt;\n        &lt;to uri=\"seda:quotes\"/&gt;\n&lt;/route&gt;\n</code></pre><p>Notice that you can enable streaming by specifying &lt;stream-config&gt; instead of &lt;batch-config&gt;.</p></td>\n  </tr>\n </tbody>\n</table>\n<h3>Dead Letter Channel</h3>\n<table cellpadding=\"0\" cellspacing=\"0\">\n <tbody>\n  <tr>\n   <td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-21.jpg\"></td>\n   <td class=\"light_cream\">What will the messaging system do with a message it cannot deliver?</td>\n  </tr>\n  <tr>\n   <td colspan=\"2\"><img alt=\"Message Router\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-22.jpg\"></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Problem</td>\n   <td class=\"light_cream\">The messaging system cannot deliver a message</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Solution</td>\n   <td class=\"light_cream\">When a message cannot be delivered it should be moved to a Dead Letter Channel</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Camel</td>\n   <td class=\"light_cream\"><p>Camel has extensive support for Dead Letter Channel by its error handler and exception clauses. Error handler supports redelivery policies to decide how many times to try redelivering a message, before moving it to a Dead Letter Channel.</p><p>The default Dead Letter Channel will log the message at ERROR level and perform up to 6 redeliveries using a one second delay before each retry.</p><p>Error handler has two scopes: global and per route</p><p><strong>TIP:</strong> See Exception Clause in the Camel documentation for selective interception of thrown exception. This allows you to route certain exceptions differently or even reset the failure by marking it as handled.</p><p><strong>TIP:</strong> DeadLetterChannel supports processing the message before it gets redelivered using onRedelivery. This allows you to alter the message beforehand (i.e. to set any custom headers).</p></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Java DSL</td>\n   <td class=\"light_cream\"><h4>Global scope</h4><pre><code lang=\"text/x-java\">\nerrorHandler(deadLetterChannel(\"jms:queue:error\")\n        .maximumRedeliveries(3));\n\nfrom(...)\n\nRoute scope\nfrom(\"jms:queue:event\")\n        .errorHandler(deadLetterChannel()\n        .maximumRedeliveries(5))\n        .multicast().to(\"log:event\", \"seda:handleEvent\");\n</code></pre><p>In this route we override the global scope to use up to five redeliveries, where as the global only has three. You can of course also set a different error queue destination:</p><pre><code lang=\"text/x-java\">\ndeadLetterChannel(\"log:badEvent\").maximumRedeliveries(5)\n</code></pre></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Spring DSL</td>\n   <td class=\"light_cream\"><p>The error handler is configured very differently in the Java DSL vs. the Spring DSL. The Spring DSL relies more on standard Spring bean configuration whereas the Java DSL uses fluent builders.</p><h4>Global scope</h4><p>The Global scope error handler is configured using the errorHandlerRef attribute on the camelContext tag.</p><pre><code lang=\"text/x-java\">\n&lt;camelContext errorHandlerRef=\"myDeadLetterChannel\"&gt;\n...\n&lt;/camelContext&gt;\n</code></pre><h4>Route scope</h4><p>Route scoped is configured using the errorHandlerRef attribute on the route tag.</p><pre><code lang=\"text/x-java\">\n&lt;route errorHandlerRef=\"myDeadLetterChannel\"&gt;\n...\n&lt;/route&gt;\n</code></pre><p>For both the error handler itself is configured using a regular Spring bean</p><pre><code lang=\"text/x-java\">\n&lt;bean id=\"myDeadLetterChannel\" class=\"org.apache.camel.\nbuilder.DeadLetterChannelBuilder\"&gt;\n        &lt;property name=\"deadLetterUri\" value=\"jms:queue:error\"/&gt;\n        &lt;property name=\"redeliveryPolicy\"\n                ref=\"myRedeliveryPolicy\"/&gt;\n&lt;/bean&gt;\n\n&lt;bean id=\"myRedeliverPolicy\"\n                class=\"org.apache.camel.processor.RedeliverPolicy\"&gt;\n        &lt;property name=\"maximumRedeliveries\" value=\"5\"/&gt;\n        &lt;property name=\"delay\" value=\"5000\"/&gt;\n&lt;/bean&gt;\n</code></pre></td>\n  </tr>\n </tbody>\n</table>\n<h3>Wire Tap</h3>\n<table cellpadding=\"0\" cellspacing=\"0\">\n <tbody>\n  <tr>\n   <td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" height=\"20\" src=\"images/rc047-010d-enterprise_integration_patterns-23.jpg\" width=\"34\"></td>\n   <td class=\"light_cream\">How do you inspect messages that travel on a point-to-point channel?</td>\n  </tr>\n  <tr>\n   <td colspan=\"2\"><img alt=\"Wire Tap\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-24.jpg\"></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Problem</td>\n   <td class=\"light_cream\">How do you tap messages while they are routed?</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Solution</td>\n   <td class=\"light_cream\">Insert a Wire Tap into the channel, that publishes each incoming message to the main channel as well as to a secondary channel.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Camel</td>\n   <td class=\"light_cream\">Camel has support for Wire Tap using the wireTap node, that supports two modes: traditional and new message. The traditional mode sends a copy of the original message, as opposed to sending a new message. All messages are sent as Event Message and runs in parallel with the original message.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Java DSL</td>\n   <td class=\"light_cream\"><h4>Traditional</h4><p>The route uses the traditional mode to send a copy of the original message to the seda tapped queue, while the original message is routed to its destination, the process order bean.</p><pre><code lang=\"text/x-java\">\nfrom(\"jms:queue:order\")\n        .wireTap(\"seda:tappedOrder\")\n        .to(\"bean:processOrder\");\n</code></pre><h4>New message</h4><p>In this route we tap the high priority orders and send a new message containing a body with the from part of the order. Tip: As Camel uses an Expression for evaluation you can use other functions than xpath, for instance to send a fixed String you can use constant.</p><pre><code lang=\"text/x-java\">\nfrom(\"jms:queue:order\")\n        .choice()\n                .when(\"/order/priority = ‘high’\")\n                        .wireTap(\"seda:from\", xpath(\"/order/from\"))\n                        .to(\"bean:processHighOrder\");\n                .otherwise()\n                        .to(\"bean:processOrder\");\n</code></pre></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Spring DSL</td>\n   <td class=\"light_cream\"><h4>Traditional</h4><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=\"jms:queue:order\"/&gt;\n        &lt;wireTap uri=\"seda:tappedOrder\"/&gt;\n        &lt;to uri=\"bean:processOrder\"/&gt;\n&lt;/route&gt;\n</code></pre><h4>New Message</h4><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;choice&gt;\n                &lt;when&gt;\n                        &lt;xpath&gt;/order/priority = 'high'&lt;/xpath&gt;\n                        &lt;wireTap uri=\"seda:from\"&gt;\n                                &lt;body&gt;&lt;xpath&gt;/order/from&lt;/xpath&gt;&lt;/body&gt;\n                        &lt;/wireTap&gt;\n                        &lt;to uri=\"bean:processHighOrder\"/&gt;\n                &lt;/when&gt;\n                &lt;otherwise&gt;\n                        &lt;to uri=\"bean:processOrder\"/&gt;\n                &lt;/otherwise&gt;\n        &lt;/choice&gt;\n&lt;/route&gt;\n</code></pre></td>\n  </tr>\n </tbody>\n</table>\n<h2>Conclusion</h2>\n<p pid=\"6\">The twelve patterns in this Refcard cover the most used patterns in the integration space, together with two of the most complex such as the Aggregator and the Dead Letter Channel. In the second part of this series we will take a further look at common patterns and transations.</p>\n<h3>Get More Information</h3>\n<table cellpadding=\"0\" cellspacing=\"0\">\n <tbody>\n  <tr>\n   <td class=\"light_blue\">Camel Website <a href=\"http://camel.apache.org\" rel=\"nofollow\">http://camel.apache.org</a></td>\n   <td class=\"light_cream\">The home of the Apache Camel project. Find downloads, tutorials, examples, getting started guides, issue tracker, roadmap, mailing lists, irc chat rooms, and how to get help.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">FuseSource Website <a href=\"http://fusesource.com\" rel=\"nofollow\">http://fusesource.com</a></td>\n   <td class=\"light_cream\">The home of the FuseSource company, the professional company behind Apache Camel with enterprise offerings, support, consulting and training.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">About Author <a href=\"http://davsclaus.blogspot.com\" rel=\"nofollow\">http://davsclaus.blogspot.com</a></td>\n   <td class=\"light_cream\">The personal blog of the author of this reference card.</td>\n  </tr>\n </tbody>\n</table>","author":{"id":360761,"username":"RyanLittle","avatar":"https://secure.gravatar.com/avatar/b7ea965bf9b8d654d840826463499ecc?d=identicon&r=PG","reputation":0},"lastEditedAction":27185807,"activeRevisionId":3025453,"revisionIds":[3025453,3025450,2732430,2732429,1368109,952468,952465,952464,927472,635467,635466,635465,635464,635463,635462,635461,635460,635459,635458],"lastActiveUserId":3048562,"lastActiveDate":1523454525000,"parentId":null,"parentAuthor":null,"originalParentId":null,"childrenIds":[535340],"commentIds":[535340],"marked":true,"topics":["integration","apache"],"primaryContainerId":8,"containerIds":[7,8],"plug":"enterprise-integration","wiki":false,"score":0,"depth":0}}];
        TH_CORE_VARS.additional.requiresModule = ["generalDirectives","monospaced.elastic","angularFileUpload","ui.bootstrap-slider","angulartics","angulartics.google.analytics","ngCookies","ngSanitize","ui.select","ui.bootstrap","angularMoment","ngTouch","ngDialog","LocalStorageModule"];
        TH_CORE_VARS.additional.TH_CSRF = "-658015970810654626";
            } catch (e) {
        console.error(e);
    }
</script>
<script async src="https://securepubads.g.doubleclick.net/tag/js/gpt.js"></script>

<script>
    const peer39Enabled = true;
</script>

<script type="text/javascript" src="//dz2cdn2.dzone.com/storage/pub/15894840-combined.js" charset="utf-8"></script><script type="text/javascript" src="//dz2cdn2.dzone.com/storage/pub/15895071-combined.js" charset="utf-8"></script>    <script>
        window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
        ga('create', 'UA-410289-1', 'auto');
        ga('require', 'linkid', 'linkid.js');
        ga('require', 'GTM-TSD9TZP');
        ga('set', 'siteSpeedSampleRate', 25);
    </script>
    <script async src="https://www.google-analytics.com/analytics.js"></script>

    <script>
        (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
            j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
            'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
        })(window,document,'script','dataLayer','GTM-K25QL22');
    </script>

<script>
    !function (e, o, n, i) {
        if (!e) {
            e = e || {}, window.permutive = e, e.q = [];
            var t = function () {
                return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, function (e) {
                    return (e ^ (window.crypto || window.msCrypto).getRandomValues(new Uint8Array(1))[0] & 15 >> e / 4).toString(16)
                })
            };
            e.config = i || {}, e.config.apiKey = o, e.config.workspaceId = n, e.config.environment = e.config.environment || "production", (window.crypto || window.msCrypto) && (e.config.viewId = t());
            for (var g = ["addon", "identify", "track", "trigger", "query", "segment", "segments", "ready", "on", "once", "user", "consent"], r = 0; r < g.length; r++) {
                var w = g[r];
                e[w] = function (o) {
                    return function () {
                        var n = Array.prototype.slice.call(arguments, 0);
                        e.q.push({
                            functionName: o,
                            arguments: n
                        })
                    }
                }(w)
            }
        }
    }(window.permutive, "bca90777-e088-4f2a-96c2-13ad18deeccc", "18ad0c5b-460c-4d19-a729-dc537805538f", {});
    window.googletag = window.googletag || {}, window.googletag.cmd = window.googletag.cmd || [], window.googletag.cmd.push(function () {
        if (0 === window.googletag.pubads().getTargeting("permutive").length) {
            var e = window.localStorage.getItem("_pdfps");
            window.googletag.pubads().setTargeting("permutive", e ? JSON.parse(e) : []);
            var o = window.localStorage.getItem("permutive-id");
            o && (window.googletag.pubads().setTargeting("puid", o), window.googletag.pubads().setTargeting("ptime", Date.now().toString())), window.permutive.config.viewId && window.googletag.pubads().setTargeting("prmtvvid", window.permutive.config.viewId), window.permutive.config.workspaceId && window.googletag.pubads().setTargeting("prmtvwid", window.permutive.config.workspaceId)
        }
    });


        permutive.addon('web', {
            'page': {
                'category': 'Integration',
                'node': {
                    'authorCompany': 'Red Hat',
                    'authors': [354055, ],
                    'publishDate': new Date(1523454525000),
                    'sponsorAuthor': true,
                    'tags': ['apache', 'integration', ],
                    'title': 'The Top Twelve Integration Patterns for Apache Camel',
                    'type': 'refcard',
                },
                'section': 'refcard',
            }
        });
</script>
<script async src="https://18ad0c5b-460c-4d19-a729-dc537805538f.edge.permutive.app/18ad0c5b-460c-4d19-a729-dc537805538f-web.js"></script>



<script type="text/javascript">
    (function() {
            function controller($scope, TH$Dialog, $location, $rootScope, $timeout, TH$SharedVars, $service, TH$LocalStorage) {

    $scope.searchT ='';
    $scope.zonesOpen = false;

    $scope.login = function() {
        TH$Dialog.open({
            loadWidget: 'users.loginForm',
            size: 'modalForm',
            showClose: true
        });
    };

    $scope.signIn = function() {
        TH$Dialog.open({
            loadWidget: 'users.registration',
            size: 'modalFormExtended',
            showClose: true
        });
    };

    $scope.allResults = function() {
        window.location='/search';
    };

    $("#search").keyup(function(e) {
        var length = ($scope.searchT ? $scope.searchT.length : 0);
        $scope.searchT = ($scope.searchT ? $scope.searchT : '');

        if (e.keyCode === 13 && length > 2) {
            $scope.allResults();
        }
    });

    $scope.focusSearch = function() {
        $timeout(function() {
            $("#search").focus();
        }, 100)
    };

    $scope.search = function() {
        var length = ($scope.searchT ? $scope.searchT.length : 0);
        $scope.loading = (length > 2);
        if (length < 3) {
            if ($scope.nodes || $scope.nodes == []) {
                $timeout(function() {
                    $scope.nodes = [];
                    $scope.cType = [];
                    $scope.related = [];
                    $scope.pager = [];
                    $scope.searchParam = [];
                    $scope.totalResults = null;

                }, 100)
            }
            return false;
        }

        var term = $scope.searchT;
        if ($scope.prevTerm == term) {
            return;
        }

        $scope.prevTerm = term;

        TH$LocalStorage.value('searchValue', term);
        term = (term ? term : '');
        $service.nextPage({term: term, pageSize: 7}, null, true).then(function(data) {
            $scope.loading = false;
            var curPage = 1;
            $scope.nodes = data.pages.newest[curPage];
            $scope.haveResults = ($scope.nodes) ? true : false;
            $scope.totalResults = data.totalItems;
        });
    }

    $scope.toggleZones = function(url, $event) {
        $event.preventDefault();
        $scope.zonesOpen = !$scope.zonesOpen;
    }

    $scope.$watch('searchT', function(t) {
        $scope.search();

        if (t && t.length) {
            permutive.track('Search', {
                searchQuery: t
            });
        }
    });
}

            var WMODEL_DATA = {};
            WMODEL_DATA.isAdmin = false;
        WMODEL_DATA.getPortals = null;
        WMODEL_DATA.OPTIONS = {};
        WMODEL_DATA.user = {"karma":40,"country":null,"website":null,"city":null,"about":null,"avatar":"https://secure.gravatar.com/avatar/?d=identicon&r=PG","realName":"$$ANON_USER$$","websiteUrl":"","jobRole":null,"tagline":null,"company":null,"id":2500002,"job":null};
        TH.installWidgetController('header.headerV2', 'mainHeader', WMODEL_DATA, typeof controller == 'function' ? controller : null, [{name: 'nextPage', data: true}], ' oUhbWOfRPSwBoUhM', null);
        })();
        (function() {
            function controller($scope, TH$Dialog, TH$Service, $window, $rootScope) {

    var body = $(".body"),
        announcement = $(".announcementBar"),
        marginRight = body.css("marginRight"),
        marginLeft = body.css("marginLeft");

    $scope.goToRegistration = function() {
        TH$Dialog.open({
            loadWidget: 'users.registration',
            size: 'modalFormExtended',
            showClose: true,
            data: {
                fromDownload: true,
                redirectUrl: $scope.announcement.link
            }
        });
    };

    $scope.track = function(id) {
        var data = {
            siteNotification: id
        };
        if ($rootScope.user.authenticated) {
            TH$Service.exec('dzoneUsers.trackAnnouncementBar', data).then(function() {
            });
            $window.location.href = $scope.announcement.link;
        } else {
            $scope.goToRegistration();
        }
    };

    $(window).resize(function() {
        marginRight = body.css("marginRight");
        marginLeft = body.css("marginLeft");
        $scope.setBarWidth()
    });

    if (!(announcement.next().is(".layout-card"))) {
        announcement.css("margin-bottom", "10px");
    }

    $scope.toShow = ($scope.announcement && $scope.announcement.anononly) ? !($rootScope.user.authenticated) : true;

    $scope.setBarWidth = function() {
        var container = $("#acontainer");
        container.css("margin-right", "-" + marginRight);
        container.css("margin-left", "-" + marginLeft);
    }
}

TH.directive('backImg', function() {
    return function(scope, element, attrs) {
        if (attrs.hasimage == "true") {
            var img = new Image();
            img.onload = a(attrs.img, element, scope);
            img.onerror = a(attrs.imgbackup, element, scope);
            img.src = attrs.img;
        }
        scope.setBarWidth();
    };
});

var a = function(url, element) {
    element.css({
        'background-image': 'url(' + url + ')',
        'background-size': 'cover'
    });
};
            var WMODEL_DATA = {};
            WMODEL_DATA.OPTIONS = {};
        WMODEL_DATA.announcement = {"id":4911195,"body":"[New Research] Check out DZone's 2022 Trend Report on \"Data Pipelines: Ingestion, Warehousing, and Processing\"","link":"https://dzone.tradepub.com/c/pubRD.mpl?secure=1&sr=pp&_t=pp:&qf=w_defa2593&ch=sitenote","title":"Read the report","img2":"/notificationImage.html?id=4911195","img":"https://dz2cdn1.dzone.com/notificationImage.html?id=4911195","hasImage":false,"anononly":false};
        TH.installWidgetController('announcementBar', 'announcementBar1', WMODEL_DATA, typeof controller == 'function' ? controller : null, null, ' oUhbYlrRaqMaoUhM', null);
        })();
        (function() {
            function controller($scope, $location, DZHeadService, TH$SharedVars, TH$Dialog, TH$Service) {

    TH$SharedVars.bind($scope, 'campaign', 'refcardCampaign', true);

    $scope.editUrl = function() {
        return '/dzone/staff/refcardz/' + $scope.asset.id + '/edit.html';
    };

    $scope.showRegistration = function() {
        TH$Dialog.open({
            loadWidget: 'users.registration',
            size: 'modalFormExtended',
            showClose: true,
            data: {
                asset: $scope.asset.pdf,
                fromDownload: true
            }
        });
    };

    $scope.showDownload = function() {
        TH$Service.data('dzoneUsers.getNextQuestion', { asset: $scope.asset.pdf }).then(function(result) {
            if (result) {
                TH$Dialog.open({
                    loadWidget: 'users.questionForm',
                    size: 'modalForm',
                    showClose: true,
                    closeByDocument: true,
                    closeByEscape: true,
                    data: {
                        asset: $scope.asset.pdf,
                        question: result,
                        fromDownload: true,
                        portalId: result.portalId,
                        portalName: result.portalName,
                        portalAlreadySubscribed: result.portalSubscribed,
                    }
                });
            } else {
                $location.url($scope.asset.pdf);
            }
        });
    };

    DZHeadService.title = TH_CORE_VARS.additional.model[0].metaData.title;
    DZHeadService.description = TH_CORE_VARS.additional.model[0].metaData.description;
    DZHeadService.url = $location.absUrl();
}
            var WMODEL_DATA = {};
            WMODEL_DATA.reprint = false;
        WMODEL_DATA.directPdf = false;
        WMODEL_DATA.perms = {"canEdit":false};
        WMODEL_DATA.type = "refcard";
        WMODEL_DATA.asset = {"assetDate":1238363662000,"description":"Enterprise Integration Patterns (EIP) have become the standard way to describe, document and implement complex integration problems. Apache Camel is an open-source project for implementing the EIP simply in a few lines of Java code or XML configuration. This DZone Refcard will guide you through the most common Enterprise Integration Patterns and give you examples of how to implement them either in Java code or using Spring XML. While it is targeted toward software developers and enterprise architects, anyone in the integration space can benefit from this Refcard.","title":"The Top Twelve Integration Patterns for Apache Camel","url":"/refcardz/enterprise-integration","tags":["apache","integration"],"cover":"//dz2cdn3.dzone.com/storage/rc-covers/4378-dzone_refcard_47.png","saveStatus":{"saved":false,"count":216,"canSave":false},"editUrl":"/dzone/staff/refcardz/520156/edit.html","pages":null,"pdf":"/asset/download/232","featuredImage":"","headerImage":"//dz2cdn4.dzone.com/storage/rc-covers/8782979-apachecamel.png","subtitle":"Implement in Java or Spring XML","cardId":"#047","shortDesc":"Check out the 12 most common integration patterns and implementation methods for Apache Camel.","id":520156,"portal":"Integration","views":175828,"authors":[{"firstName":"Claus","lastName":"Ibsen","realName":"Claus Ibsen","aboutAuthor":"Claus Ibsen works for Red Hat on open source integration projects such as Apache Camel, fabric8 and hawtio.\n\nClaus is author of the Camel in Action 1st and 2nd edition books.","jobTitle":"Senior Principal Software Engineer","companyName":"Red Hat","name":"davsclaus","id":354055,"avatar":"https://secure.gravatar.com/avatar/62d4ca92192b41f45829db7b7020ee0e?d=identicon&r=PG","url":"/users/354055/davsclaus.html"}]};
        WMODEL_DATA.OPTIONS = {"type":"refcard"};
        TH.installWidgetController('refcardz.topHeaderV3', 'refcardzTopHeaderV34', WMODEL_DATA, typeof controller == 'function' ? controller : null, null, ' oUhbfSbmcnWOfYfWVcC', null);
        })();
        (function() {
            function controller($scope, $rootScope, TH$Dialog, TH$SharedVars, $timeout, TH$Location, TH$Service, $location,
                    $analytics) {

    if ($scope.refcard && $scope.refcard.topicNames) {
        var portal = ($scope.refcard.portal && $scope.refcard.portal.id ? $scope.refcard.portal.id : null);
        // Find related articles and refcards for the refcard template
        TH$Service.data('articles.getRelatedArticlesAndRefcards', {
            article: $scope.refcard.id,
            topicNames: $scope.refcard.topicNames,
            articleLimit: 4,
            refcardPortal: portal,
            refcardLimit: 4
        }).then(function(result) {
            $scope.refcard.relatedArticles = result.articles;
            $scope.refcard.relatedRefcards = result.refcards;
        });
    }

     // Build comma separated list of author ids
    $scope.refcardAuthorIds = $scope.refcard.authors.map(function(elem) {
        return elem.id.toString();
    });

     $scope.loginForm = function() {
        TH$Dialog.open({
            loadWidget: 'users.loginForm',
            size: 'modalForm',
            showClose: true
        });
    };

     $scope.scrollTo = function($event, anchor) {
         $event.preventDefault();

         $('html,body').animate({
             scrollTop: $(anchor).offset().top - 100}, 'slow', function () {
             window.location.hash = anchor;
         });
     }

    TH$SharedVars.bind($scope, 'chapter', 'currentChapter');
    TH$SharedVars.bind($scope, 'campaign', 'refcardCampaign');

    $analytics.pageTrack($location.absUrl());
}

            var WMODEL_DATA = {};
            WMODEL_DATA.preview = "";
        WMODEL_DATA.daysOldBody = "Technology moves quickly and this #type was published #time.  Some or all of its contents may be outdated.";
        WMODEL_DATA.chapterList = {"ordered":[{"chapter":1,"new":false,"active":true,"body":"<p pid=\"2\">Integration is a hard problem. To help deal with the complexity of integration problems the Enterprise Integration Patterns (EIP) have become the standard way to describe, document and implement complex integration problems. Hohpe &amp; Woolf's book the Enterprise Integration Patterns has become the bible in the integration space - essential reading for any integration professional.</p><p pid=\"3\">Apache Camel is an open source project for implementing the EIP easily in a few lines of Java code or Spring XML configuration. This reference card, the first in a two card series, guides you through the most common Enterprise Integration Patterns and gives you examples of how to implement them either in Java code or using Spring XML. This Refcard is targeted for software developers and enterprise architects, but anyone in the integration space can benefit as well.</p>","creationDate":1449599891000,"creationDateFormatted":"12/08/2015 06:38 PM","title":"About Enterprise Integration Patterns","revision":2,"modificationDate":null,"id":2004635},{"chapter":2,"new":false,"active":true,"body":"<p pid=\"4\">Apache Camel is a powerful open source integration platform based on Enterprise Integration Patterns (EIP) with powerful Bean Integration. Camel lets you implementing EIP routing using Camels intuitive Domain Specific Language (DSL) based on Java (aka fluent builder) or XML. Camel uses URI for endpoint resolution so its very easy to work with any kind of transport such as HTTP, REST, JMS, web service, File, FTP, TCP, Mail, JBI, Bean (POJO) and many others. Camel also provides Data Formats for various popular formats such as: CSV, EDI, FIX, HL7, JAXB, Json, Xstream. Camel is an integration API that can be embedded in any server of choice such as: J2EE Server, ActiveMQ, Tomcat, OSGi, or as standalone. Camels Bean Integration let you define loose coupling allowing you to fully separate your business logic from the integration logic. Camel is based on a modular architecture allowing you to plugin your own component or data format, so they seamlessly blend in with existing modules. Camel provides a test kit for unit and integration testing with strong mock and assertion capabilities.</p>","creationDate":1449599891000,"creationDateFormatted":"12/08/2015 06:38 PM","title":"About Apache Camel","revision":2,"modificationDate":null,"id":2004636},{"chapter":3,"new":false,"active":true,"body":"<p pid=\"5\">This group consists of the most essential patterns that anyone working with integration must know.</p><h3>Pipes and Filters</h3><table cellpadding=\"0\" cellspacing=\"0\">\n <tbody>\n  <tr>\n   <td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-1.jpg\" /></td>\n   <td class=\"light_cream\">How can we perform complex processing on a message while maintaining independence and flexibility?</td>\n  </tr>\n  <tr>\n   <td colspan=\"2\"><img alt=\"Pipes and Filters\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-2.jpg\" /></td>\n  </tr>\n </tbody>\n</table><table cellpadding=\"0\" cellspacing=\"0\">\n <tbody>\n  <tr>\n   <td class=\"light_blue\">Problem</td>\n   <td class=\"light_cream\">A single event often triggers a sequence of processing steps</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Solution</td>\n   <td class=\"light_cream\">Use Pipes and Filters to divide a larger processing steps (filters) that are connected by channels (pipes)</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Camel</td>\n   <td class=\"light_cream\">Camel supports Pipes and Filters using the <strong>pipeline</strong> node.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Java DSL</td>\n   <td class=\"light_cream\"><pre><code lang=\"text/x-java\">\nfrom(&quot;jms:queue:order:in&quot;).pipeline(&quot;direct:transformOrder&quot;, &quot;direct:validateOrder&quot;, &quot;jms:queue:order:process&quot;);\n</code></pre><p>Where jms represents the JMS component used for consuming JMS messages on the JMS broker. Direct is used for combining endpoints in a synchronous fashion, allow you to divide routes into sub routes and/or reuse common routes.</p><p><strong>Tip:</strong> Pipeline is the default mode of operation when you specify multiple outputs, so it can be omitted and replaced with the more common node:</p><pre><code lang=\"text/x-java\">\nfrom(&quot;jms:queue:order:in&quot;).to(&quot;direct:transformOrder&quot;,\n&quot;direct:validateOrder&quot;, &quot;jms:queue:order:process&quot;);\n</code></pre><p><strong>TIP:</strong> You can also separate each step as individual <strong>to</strong> nodes:</p><pre><code lang=\"text/x-java\">\nfrom(&quot;jms:queue:order:in&quot;)\n        .to(&quot;direct:transformOrder&quot;)\n        .to(&quot;direct:validateOrder&quot;)\n        .to(&quot;jms:queue:order:process&quot;);\n</code></pre></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Spring DSL</td>\n   <td class=\"light_cream\"><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=&quot;jms:queue:order:in&quot;/&gt;\n        &lt;pipeline&gt;\n                &lt;to uri=&quot;direct:transformOrder&quot;/&gt;\n                &lt;to uri=&quot;direct:validateOrder&quot;/&gt;\n                &lt;to uri=&quot;jms:queue:order:process&quot;/&gt;\n        &lt;/pipeline&gt;\n&lt;/route&gt;\n&lt;route&gt;\n        &lt;from uri=&quot;jms:queue:order:in&quot;/&gt;\n        &lt;to uri=&quot;direct:transformOrder&quot;/&gt;\n        &lt;to uri=&quot;direct:validateOrder&quot;/&gt;\n        &lt;to uri=&quot;jms:queue:order:process&quot;/&gt;\n&lt;/route&gt;</code></pre><br /><br /></td>\n  </tr>\n </tbody>\n</table><h3>Message Router</h3><table cellpadding=\"0\" cellspacing=\"0\">\n <tbody>\n  <tr>\n   <td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" height=\"23\" src=\"images/rc047-010d-enterprise_integration_patterns-3.jpg\" width=\"42\" /></td>\n   <td class=\"light_cream\">How can you deouple indevidual processing steps so that messages can be passed to different filters depending on a set of conditions?</td>\n  </tr>\n  <tr>\n   <td colspan=\"2\"><img alt=\"Message Router\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-4.jpg\" /></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Problem</td>\n   <td class=\"light_cream\">Pipes and Filters route each message in the same processing steps. How can we route messages differently?</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Solution</td>\n   <td class=\"light_cream\">Filter using predicates to choose the right output destination.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Camel</td>\n   <td class=\"light_cream\">Camel supports Message Router using the <strong>choice</strong> node. For more details see the Content Based router pattern.</td>\n  </tr>\n </tbody>\n</table><h3>Content-Based Router</h3><table cellpadding=\"0\" cellspacing=\"0\">\n <tbody>\n  <tr>\n   <td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-5.jpg\" /></td>\n   <td class=\"light_cream\">How do we handle a situation where the implementation of a single logical function (e.g., inventory check) is spread across multiple physical systems?</td>\n  </tr>\n  <tr>\n   <td colspan=\"2\"><img alt=\"Content-Based Router\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-6.jpg\" /></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Problem</td>\n   <td class=\"light_cream\">How do we ensure a Message is sent to the correct recipient based on information from its content?</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Solution</td>\n   <td class=\"light_cream\">Use a Content-Based Router to route each message to the correct recipient based on the message content.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Camel</td>\n   <td class=\"light_cream\">Camel has extensive support for Content-Based Routing. Camel supports content based routing based on <strong>choice, filter,</strong> or any other expression.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Java DSL</td>\n   <td class=\"light_cream\"><h4>Choice</h4><pre><code lang=\"text/x-java\">\nfrom(&quot;jms:queue:order&quot;)\n.choice()\n.when(header(&quot;type&quot;).in(&quot;widget&quot;,&quot;wiggy&quot;))\n.to(&quot;jms:queue:order:widget&quot;)\n.when(header(&quot;type&quot;).isEqualTo(&quot;gadget&quot;))\n.to(&quot;jms:queue:order:gadget&quot;)\n.otherwise().to(&quot;jms:queue:order:misc&quot;)\n.end();\n</code></pre><p><strong>TIP:</strong> In the route above end() can be omitted as its the last node and we do not route the message to a new destination after the choice.</p><p><strong>TIP:</strong> You can continue routing after the choice ends.</p></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Spring DSL</td>\n   <td class=\"light_cream\"><h4>Choice</h4><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=&quot;jms:queue:order&quot;/&gt;\n        &lt;choice&gt;\n                &lt;when&gt;\n                        &lt;simple&gt;${header.type} in 'widget,wiggy'&lt;/simple&gt;\n                        &lt;to uri=&quot;jms:queue:order:widget&quot;/&gt;\n                &lt;/when&gt;\n                &lt;when&gt;\n                        &lt;simple&gt;${header.type} == 'gadget'&lt;/simple&gt;\n                        &lt;to uri=&quot;jms:queue:order:gadget&quot;/&gt;\n                &lt;/when&gt;\n                &lt;otherwise&gt;\n                        &lt;to uri=&quot;jms:queue:order:misc&quot;/&gt;\n                &lt;/otherwise&gt;\n        &lt;/choice&gt;\n&lt;/route&gt;\n</code></pre><p><strong>TIP:</strong> In Spring DSL you cannot invoke code, as opposed to the Java DSL that is 100% Java. To express the predicates for the choices we need to use a language. We will use simple language that uses a simple expression parser that supports a limited set of operators. You can use any of the more powerful languages supported in Camel such as: JavaScript, Groovy, Unified EL and many others.</p><p><strong>TIP:</strong> You can also use a method call to invoke a method on a bean to evaluate the predicate. Lets try that:</p><pre><code lang=\"text/x-java\">\n&lt;when&gt;\n        &lt;method bean=&quot;myBean&quot; method=&quot;isGadget&quot;/&gt;\n        ...\n&lt;/when&gt;\n\n&lt;bean id=&quot;myBean&quot; class=&quot;com.mycomapany.MyBean&quot;/&gt;\n\npublic boolean isGadget(@Header(name = &quot;type&quot;) String type) {\n        return type.equals(&quot;Gadget&quot;);\n}\n</code></pre><p>Notice how we use Bean Parameter Binding to instruct Camel to invoke this method and pass in the type header as the String parameter. This allows your code to be fully decoupled from any Camel API so its easy to read, write and unit test.</p></td>\n  </tr>\n </tbody>\n</table><h3>Message Translator</h3><table cellpadding=\"0\" cellspacing=\"0\">\n <tbody>\n  <tr>\n   <td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-7.jpg\" /></td>\n   <td class=\"light_cream\">How can systems using different data formats communicate with each other using messaging?</td>\n  </tr>\n  <tr>\n   <td colspan=\"2\"><img alt=\"Message Translator\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-8.jpg\" /></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Problem</td>\n   <td class=\"light_cream\">Each application uses its own data format, so we need to translate the message into the data format the application supports.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Solution</td>\n   <td class=\"light_cream\">Use a special filter, a messae translator, between filters or applications to translate one data format into another.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Camel</td>\n   <td class=\"light_cream\">Camel supports the message translator using the <strong>processor, bean</strong> or <strong>transform</strong> nodes. TIP: Camel routes the message as a chain of <strong>processor</strong> nodes.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Java DSL</td>\n   <td class=\"light_cream\"><h4>Processor</h4><pre><code lang=\"text/x-java\">\npublic class OrderTransformProcessor\n                implements Processor {\n        public void process(Exchange exchange)\n                        throws Exception {\n                // do message translation here\n        }\n}\nfrom(&quot;direct:transformOrder&quot;)\n        .process(new OrderTransformProcessor());\n</code></pre><h4>Bean</h4><p>Instead of the processor we can use Bean (POJO). An advantage of using a Bean over Processor is the fact that we do not have to implement or use any Camel specific interfaces or types. This allows you to fully decouple your beans from Camel.</p><pre><code lang=\"text/x-java\">\npublic class OrderTransformerBean {\n        public StringtransformOrder(String body) {\n                // do message translation here\n        }\n}\nObject transformer = new OrderTransformerBean();\nfrom(&quot;direct:transformOrder&quot;).bean(transformer);\n</code></pre><p><strong>TIP:</strong> Camel can create an instance of the bean automatically; you can just refer to the class type.</p><pre><code lang=\"text/x-java\">\nfrom(&quot;direct:transformOrder&quot;)\n        .bean(OrderTransformerBean.class);\n</code></pre><p><strong>TIP:</strong> Camel will try to figure out which method to invoke on the bean in case there are multiple methods. In case of ambiguity you can specify which methods to invoke by the method parameter:</p><pre><code lang=\"text/x-java\">\nfrom(&quot;direct:transformOrder&quot;)\n        .bean(OrderTransformerBean.class, &quot;transformOrder&quot;);\n</code></pre><h4>Transform</h4><p>Transform is a particular processor allowing you to set a response to be returned to the original caller. We use transform to return a constant ACK response to the TCP listener after we have copied the message to the JMS queue. Notice we use a constant to build an &quot;ACK&quot; string as response.</p><pre><code lang=\"text/x-java\">\nfrom(&quot;mina:tcp://localhost:8888?textline=true&quot;)\n        .to(&quot;jms:queue:order:in&quot;)\n        .transform(constant(&quot;ACK&quot;));\n</code></pre></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Spring DSL</td>\n   <td class=\"light_cream\"><h4>Processor</h4><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=&quot;direct:transformOrder&quot;/&gt;\n        &lt;process ref=&quot;transformer&quot;/&gt;\n&lt;/route&gt;\n\n&lt;bean id=&quot;transformer&quot; class=&quot;com.mycompany.\nOrderTransformProcessor&quot;/&gt;\n</code></pre><p>In Spring DSL Camel will look up the processor or POJO/Bean in the registry based on the id of the bean.</p><h4>Bean</h4><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n&lt;from uri=&quot;direct:transformOrder&quot;/&gt;\n&lt;bean ref=&quot;transformer&quot;/&gt;\n&lt;/route&gt;\n&lt;bean id=&quot;tramsformer&quot;\nclass=&quot;com.mycompany.OrderTransformBean&quot;/&gt;\n</code></pre><h4>Transform</h4><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n&lt;from uri=&quot;mina:tcp://localhost:8888?textline=true&quot;/&gt;\n&lt;to uri=&quot;jms:queue:order:in&quot;/&gt;\n&lt;transform&gt;\n&lt;constant&gt;ACK&lt;/constant&gt;\n&lt;/transform&gt;\n&lt;/route&gt;\n</code></pre></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Annotation DSL</td>\n   <td class=\"light_cream\"><p>You can also use the <strong>@Consume</strong> annotation for transformations. For example in the method below we consume from a JMS queue and do the transformation in regular Java code. Notice that the input and output parameters of the method is String. Camel will automatically coerce the payload to the expected type defined by the method. Since this is a JMS example the response will be sent back to the JMS reply-to destination.</p><pre><code lang=\"text/x-java\">\n@Consume(uri=&quot;jms:queue:order:transform&quot;)\npublic String transformOrder(String body) {\n        // do message translation\n}\n</code></pre><p><strong>TIP:</strong> You can use Bean Parameter Binding to help Camel coerce the Message into the method parameters. For instance you can use <strong>@Body, @Headers</strong> parameter annotations to bind parameters to the body and headers.</p></td>\n  </tr>\n </tbody>\n</table><h3>Message Filter</h3><table cellpadding=\"0\" cellspacing=\"0\">\n <tbody>\n  <tr>\n   <td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-9.jpg\" /></td>\n   <td class=\"light_cream\">How can a component avoid receiving unwanted messages?</td>\n  </tr>\n  <tr>\n   <td colspan=\"2\"><img alt=\"Message Filter\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-10.jpg\" /></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Problem</td>\n   <td class=\"light_cream\">How do you discard unwanted messages?</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Solution</td>\n   <td class=\"light_cream\">Use a special kind of Message Router, a Message Filter, to eliminate undesired messages from a channel based on a set of criteria.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Camel</td>\n   <td class=\"light_cream\">Camel has support for Message Filter using the filter node. The filter evaluates a predicate whether its true or false; only allowing the true condition to pass the filter, where as the false condition will silently be ignored.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Java DSL</td>\n   <td class=\"light_cream\">We want to discard any test messages so we only route non-test messages to the order queue. <pre><code lang=\"text/x-java\">\nfrom(&quot;jms:queue:inbox&quot;)\n        .filter(header(&quot;test&quot;).isNotEqualTo(&quot;true&quot;))\n        .to(&quot;jms:queue:order&quot;);</code></pre><br /><br /></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Spring DSL</td>\n   <td class=\"light_cream\">For the Spring DSL we use XPath to evaluate the predicate. The $test is a special shorthand in Camel to refer to the header with the given name. So even if the payload is not XML based we can still use XPath to evaluate predicates. <pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=&quot;jms:queue:inbox&quot;/&gt;\n        &lt;filter&gt;\n                &lt;xpath&gt;$test = 'false'&lt;/xpath&gt;\n                &lt;to uri=&quot;jms:queue:inbox&quot;/&gt;\n        &lt;/filter&gt;\n&lt;/route&gt;</code></pre><br /><br /></td>\n  </tr>\n </tbody>\n</table><h3>Dynamic Router</h3><table cellpadding=\"0\" cellspacing=\"0\">\n <tbody>\n  <tr>\n   <td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-11.jpg\" /></td>\n   <td class=\"light_cream\"></td>\n  </tr>\n  <tr>\n   <td colspan=\"2\"><img alt=\"Dynamic Router\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-12.jpg\" /></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Problem</td>\n   <td class=\"light_cream\">How can we route messages based on a dynamic list of destinations?</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Solution</td>\n   <td class=\"light_cream\">Use a Dynamic Router, a router that can self-configure based on special configuration messages from participating destinations.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Camel</td>\n   <td class=\"light_cream\">Camel has support for Dynamic Router using the Dynamic <strong>Recipient List</strong> combined with a data store holding the list of destinations.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Java DSL</td>\n   <td class=\"light_cream\">We use a Processor as the dynamic router to determine the destinations. We could also have used a Bean instead. <pre><code lang=\"text/x-java\">\nfrom(&quot;jms:queue:order&quot;)\n        .processRef(myDynamicRouter)\n        .recipientList(&quot;destinations&quot;);\n\npublic class MyDynamicRouter implements Processor {\n        public void process(Exchange exchange) {\n                // query a data store to find the best match of the\n                // endpoint and return the destination(s) in the\n                // header exchange.getIn()\n                // .setHeader(&quot;destinations&quot;, list);\n        }\n}</code></pre><br /><br /></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Spring DSL</td>\n   <td class=\"light_cream\"><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=&quot;jms:queue:order&quot;/&gt;\n        &lt;process ref=&quot;myDynamicRouter&quot;/&gt;\n        &lt;recipientList&gt;\n                &lt;header&gt;destinations&lt;/destinations&gt;\n        &lt;/recipientList&gt;\n&lt;/route&gt;</code></pre><br /><br /></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Annotation DSL</td>\n   <td class=\"light_cream\"><pre><code lang=\"text/x-java\">\npublic class MyDynamicRouter {\n        @Consume(uri = &quot;jms:queue:order&quot;)\n        @RecipientList\n        public List&lt;String&gt; route(@XPath(&quot;/customer/id&quot;)\nString customerId, @Header(&quot;location&quot;) String location,\nDocument body) {\n                // query data store, find best match for the\n                //endpoint and return destination (s)\n        }\n}\n</code></pre><p><strong>TIP:</strong> Notice how we used Bean Parameter Binding to bind the parameters to the route method based on an <strong>@XPath</strong> expression on the XML payload of the JMS message. This allows us to extract the customer id as a string parameter. <strong>@Header</strong> wil bind a JMS property with the key location. <strong>Document</strong> is the XML payload of the JMS message.</p><p><strong>TIP:</strong> Camel uses its strong type converter feature to convert the payload to the type of the method parameter. We could use String and Camel will convert the body to a String instead. You can register your own type converters as well using the <strong>@Converter</strong> annotation at the class and method level.</p></td>\n  </tr>\n </tbody>\n</table><h3>Recipient List</h3><table cellpadding=\"0\" cellspacing=\"0\">\n <tbody>\n  <tr>\n   <td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-13.jpg\" /></td>\n   <td class=\"light_cream\">How do we route a message to a list of statically or dynamically specified recipients?</td>\n  </tr>\n  <tr>\n   <td colspan=\"2\"><img alt=\"Recipient List\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-14.jpg\" /></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Problem</td>\n   <td class=\"light_cream\">How can we route messages based on a static or dynamic list of destinations?</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Solution</td>\n   <td class=\"light_cream\">Define a channel for each recipient. Then use a Recipient List to inspect an incoming message, determine the list of desired recipients and forward the message to all channels associated with the recipients in the list.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Camel</td>\n   <td class=\"light_cream\">Camel supports the static Recipient List using the <strong>multicast</strong> node, and the dynamic Recipient List using the <strong>recipientList</strong> node.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Java DSL</td>\n   <td class=\"light_cream\"><h4>Static</h4><p>In this route we route to a static list of two recipients, that will receive a copy of the same message simultaneously.</p><pre><code lang=\"text/x-java\">\nfrom(&quot;jms:queue:inbox&quot;)\n        .multicast().to(&quot;file://backup&quot;, &quot;seda:inbox&quot;);\n</code></pre><h4>Dynamic</h4><p>In this route we route to a dynamic list of recipients defined in the message header [mails] containing a list of recipients as endpoint URLs. The bean processMails is used to add the header[mails] to the message.</p><pre><code lang=\"text/x-java\">\nfrom(&quot;seda:confirmMails&quot;).beanRef(processMails)\n        .recipientList(&quot;destinations&quot;);\n</code></pre><p>And in the process mails bean we use <strong>@Headers</strong> Bean Parameter Binding to provide a <strong>java.util.Map</strong> to store the recipients.</p><pre><code lang=\"text/x-java\">\npublic void confirm(@Headers Map headers, @Body String body} {\n        String[] recipients = ...\n        headers.put(&quot;&quot;destinations&quot;, recipients);\n}\n</code></pre></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Spring DSL</td>\n   <td class=\"light_cream\"><h4>Static</h4><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=&quot;jms:queue:inbox&quot; /&gt;\n        &lt;multicast&gt;\n                &lt;to uri=&quot;file://backup&quot;/&gt;\n                &lt;to uri=&quot;seda:inbox&quot;/&gt;\n        &lt;/multicast&gt;\n&lt;/route&gt;\n</code></pre><h4>Dynamic</h4><p>In this example we invoke a method call on a Bean to provide the dynamic list of recipients.</p><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=&quot;jms:queue:inbox&quot; /&gt;\n        &lt;recipientList&gt;\n                &lt;method bean=&quot;myDynamicRouter&quot; method=&quot;route&quot;/&gt;\n        &lt;/recipientList&gt;\n&lt;/route&gt;\n\n&lt;bean id=&quot;myDynamicRouter&quot;\n        class=&quot;com.mycompany.MyDynamicRouter&quot;/&gt;\n\npublic class myDynamicRouter {\n        public String[] route(String body) {\n                return new String[] { &quot;file://backup&quot;, .... }\n        }\n}\n</code></pre></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Annotation DSL</td>\n   <td class=\"light_cream\"><p>In the CustomerService class we annoate the <strong>whereTo</strong> method with <strong>@RecipientList</strong>, and return a single destination based on the customer id. Notice the flexibility of Camel as it can adapt accordingly to how you define what your methods are returning: a single element, a list, an iterator, etc.</p><pre><code lang=\"text/x-java\">\npublic class CustomerService {\n        @RecipientList\n        public String whereTo(@Header(&quot;customerId&quot;) id) {\n                return &quot;jms:queue:customer:&quot; + id;\n        }\n}\n</code></pre><p>And then we can route to the bean and it will act as a dynamic recipient list.</p><pre><code lang=\"text/x-java\">\nfrom(&quot;jms:queue:inbox&quot;)\n        .bean(CustomerService.class, &quot;whereTo&quot;);\n</code></pre></td>\n  </tr>\n </tbody>\n</table><h3>Splitter</h3><table cellpadding=\"0\" cellspacing=\"0\">\n <tbody>\n  <tr>\n   <td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-15.jpg\" /></td>\n   <td class=\"light_cream\">How can we process a message if it contains multiple elements, each of which may have to be processed in a different way?</td>\n  </tr>\n  <tr>\n   <td colspan=\"2\"><img alt=\"Splitter\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-16.jpg\" /></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Problem</td>\n   <td class=\"light_cream\">How can we split a single message into pieces to be routed individually?</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Solution</td>\n   <td class=\"light_cream\">Use a Splitter to break out the composite message into a series of individual messages, each containing data related to one item.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Camel</td>\n   <td class=\"light_cream\">Camel has support for Splitter using the <strong>split</strong> node.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Java DSL</td>\n   <td class=\"light_cream\"><p>In this route we consume files from the inbox folder. Each file is then split into a new message. We use a tokenizer to split the file content line by line based on line breaks.</p><pre><code lang=\"text/x-java\">\nfrom(&quot;file://inbox&quot;)\n        .split(body().tokenize(&quot;\\n&quot;))\n        .to(&quot;seda:orderLines&quot;);\n</code></pre><p><strong>TIP:</strong> Camel also supports splitting streams using the streaming node. We can split the stream by using a comma:</p><pre><code lang=\"text/x-java\">\n.split(body().tokenize(&quot;,&quot;)).streaming().to(&quot;seda:parts&quot;);\n</code></pre><p><strong>TIP:</strong> In the routes above each individual split message will be executed in sequence. Camel also supports parallel execution using the parallelProcessing node.</p><pre><code lang=\"text/x-java\">\n.split(body().tokenize(&quot;,&quot;)).streaming()\n        .parallelProcessing().to(&quot;seda:parts&quot;);\n</code></pre></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Spring DSL</td>\n   <td class=\"light_cream\">In this route we use XPath to split XML payloads received on the JMS order queue. <pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=&quot;jms:queue:order&quot;/&gt;\n        &lt;split&gt;\n                &lt;xpath&gt;/invoice/lineItems&lt;/xpath&gt;\n                &lt;to uri=&quot;seda:processOrderLine&quot;/&gt;\n        &lt;/split&gt;\n&lt;/route&gt;\n</code></pre><p>And in this route we split the messages using a regular expression</p><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=&quot;jms:queue:order&quot;/&gt;\n        &lt;split&gt;\n                &lt;tokenizer token=&quot;([A-Z|0-9]*);&quot; regex=&quot;true&quot;/&gt;\n                &lt;to uri=&quot;seda:processOrderLine&quot;/&gt;\n        &lt;/split&gt;\n&lt;/route&gt;\n</code></pre><p><strong>TIP:</strong> Split evaluates an org.apahce.camel.Expression to provide something that is iterable to produce each individual new message. This allows you to provide any kind of expression such as a Bean invoked as a method call.</p><pre><code lang=\"text/x-java\">\n&lt;split&gt;\n        &lt;method bean=&quot;mySplitter&quot; method=&quot;splitMe&quot;/&gt;\n        &lt;to uri=&quot;seda:processOrderLine&quot;/&gt;\n&lt;/split&gt;\n\n&lt;bean id=&quot;mySplitter&quot; class=&quot;com.mycompany.MySplitter&quot;/&gt;\n\npublic List splitMe(String body) {\n        // split using java code and return a List\n        List parts = ...\n        return parts;\n}\n</code></pre></td>\n  </tr>\n </tbody>\n</table><h3>Aggregator</h3><table cellpadding=\"0\" cellspacing=\"0\">\n <tbody>\n  <tr>\n   <td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-17.jpg\" /></td>\n   <td class=\"light_cream\">How do we combine the results of individual, but related messages so that they can be processed as a whole?</td>\n  </tr>\n  <tr>\n   <td colspan=\"2\"><img alt=\"Message Router\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-18.jpg\" /></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Problem</td>\n   <td class=\"light_cream\">How do we combine multiple messages into a single combined message?</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Solution</td>\n   <td class=\"light_cream\">Use a stateful filter, an Aggregator, to collect and store individual messages until it receives a complete set of related messages to be published.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Camel</td>\n   <td class=\"light_cream\">Camel has support for the Aggregator using the aggregate node. Camel uses a stateful batch processor that is capable of aggregating related messaged into a single combined message. A correlation expression is used to determine which messages should be aggregated. An aggregation strategy is used to combine aggregated messages into the result message. Camel’s aggregator also supports a completion predicate allowing you to signal when the aggregation is complete. Camel also supports other completion signals based on timeout and/or a number of messages already aggregated.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Java DSL</td>\n   <td class=\"light_cream\"><h4>Stock quote example</h4><p>We want to update a website every five minutes with the latest stock quotes. The quotes are received on a JMS topic. As we can receive multiple quotes for the same stock within this time period we only want to keep the last one as its the most up to date. We can do this with the aggregator:</p><pre><code lang=\"text/x-java\">\nfrom(&quot;jms:topic:stock:quote&quot;)\n        .aggregate().xpath(&quot;/quote/@symbol&quot;)\n        .batchTimeout(5 * 60 * 1000).to(&quot;seda:quotes&quot;);\n</code></pre><p>As the correlation expression we use XPath to fetch the stock symbol from the message body. As the aggregation strategy we use the default provided by Camel that picks the latest message, and thus also the most up to date. The time period is set as a timeout value in milliseconds.</p><h4>Loan broker example</h4><p>We aggregate responses from various banks for their quote for a given loan request. We want to pick the bank with the best quote (the cheapest loan), therefore we need to base our aggregation strategy to pick the best quote.</p><pre><code lang=\"text/x-java\">\nfrom(&quot;jms:topic:loan:quote&quot;)\n        .aggregate().header(&quot;loanId&quot;)\n        .aggregationStrategy(bestQuote)\n        .completionPredicate(header(Exchange.AGGREGATED_SIZE)\n        .isGreaterThan(2))\n        .to(&quot;seda:bestLoanQuote&quot;);\n</code></pre><p>We use a completion predicate that signals when we have received more than 2 quotes for a given loan, giving us at least 3 quotes to pick among. The following shows the code snippet for the aggregation strategy we must implement to pick the best quote:</p><pre><code lang=\"text/x-java\">\npublic class BestQuoteStrategy implements AggregationStrategy {\n        public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {\n                double oldQuote = oldExchange.getIn().getBody(Double.class);\n                double newQuote = newExchange.getIn().getBody(Double.class);\n                // return the &quot;winner&quot; that has the lowest quote\n                return newQuote &lt; oldQuote ? newExchange : oldExchange;\n        }\n}\n</code></pre></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Spring DSL</td>\n   <td class=\"light_cream\"><h4>Loan Broker Example</h4><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=&quot;jms:topic:loan:qoute&quot;/&gt;\n        &lt;aggregate strategyRef=&quot;bestQuote&quot;&gt;\n                &lt;correlationExpression&gt;\n                        &lt;header&gt;loanId&lt;/header&gt;\n                &lt;/correlationExpression&gt;\n                &lt;completionPredicate&gt;\n                        &lt;simple&gt;${header.CamelAggregatedSize} &gt; 2&lt;/simple&gt;\n                &lt;/completionPredicate&gt;\n        &lt;/aggregate&gt;\n        &lt;to uri=&quot;seda:bestLoanQuote&quot;/&gt;\n&lt;/route&gt;\n\n&lt;bean id=&quot;bestQuote&quot;\n        class=&quot;com.mycompany.BestQuoteStrategy&quot;/&gt;\n</code></pre><p><strong>TIP:</strong> We use the simple language to declare the completion predicate. Simple is a basic language that supports a primitive set of operators. ${header. CamelAggregatedSize} will fetch a header holding the number of messages aggregated.</p><p><strong>TIP:</strong> If the completed predicate is more complex we can use a method call to invoke a Bean so we can do the evaluation in pure Java code:</p><pre><code lang=\"text/x-java\">\n&lt;completionPredicate&gt;\n        &lt;method bean=&quot;quoteService&quot; method=&quot;isComplete&quot;/&gt;\n&lt;/compledtionPrediacate&gt;\npublic boolean isComplete(@Header(Exchange.AGGREGATED_SIZE)\n        int count, String body) {\n        return body.equals(&quot;STOP&quot;);\n}\n</code></pre><p>Notice how we can use Bean Binding Parameter to get hold of the aggregation size as a parameter, instead of looking it up in the message.</p></td>\n  </tr>\n </tbody>\n</table><h3>Resequencer</h3><table cellpadding=\"0\" cellspacing=\"0\">\n <tbody>\n  <tr>\n   <td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-19.jpg\" /></td>\n   <td class=\"light_cream\">How can we get a stream of related but out-of-sequence messages back into the correct order?</td>\n  </tr>\n  <tr>\n   <td colspan=\"2\"><img alt=\"Resequencer\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-20.jpg\" /></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Problem</td>\n   <td class=\"light_cream\">How do we ensure ordering of messages?</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Solution</td>\n   <td class=\"light_cream\">Use a stateful filter, a Resequencer, to collect and reorder messages so that they can be published in a specified order.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Camel</td>\n   <td class=\"light_cream\"><p>Camel has support for the Resequencer using the resequence node. Camel uses a stateful batch processor that is capable of reordering related messages. Camel supports two resequencing algorithms:</p><p><strong>-batch</strong> = collects messages into a batch, sorts the messages and publish the messages</p><p><strong>-stream</strong> = re-orders, continuously, message streams based on detection of gaps between messages.</p><p>Batch is similar to the aggregator but with sorting. Stream is the traditional Resequencer pattern with gap detection. Stream requires usage of number (longs) as sequencer numbers, enforced by the gap detection, as it must be able to compute if gaps exist. A gap is detected if a number in a series is missing, e.g. 3, 4, 6 with number 5 missing. Camel will back off the messages until number 5 arrives.</p></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Java DSL</td>\n   <td class=\"light_cream\"><h4>Batch:</h4><p>We want to process received stock quotes, once a minute, ordered by their stock symbol. We use XPath as the expression to select the stock symbol, as the value used for sorting.</p><pre><code lang=\"text/x-java\">\nfrom(&quot;jms:topic:stock:quote&quot;)\n        .resequence().xpath(&quot;/quote/@symbol&quot;)\n        .timeout(60 * 1000)\n        .to(&quot;seda:quotes&quot;);\n</code></pre><p>Camel will default the order to ascending. You can provide your own comparison for sorting if needed.</p><h4>Stream:</h4><p>Suppose we continuously poll a file directory for inventory updates, and its important they are processed in sequence by their inventory id. To do this we enable streaming and use one hour as the timeout.</p><pre><code lang=\"text/x-java\">\nfrom(&quot;file://inventory&quot;)\n        .resequence().xpath(&quot;/inventory/@id&quot;)\n        .stream().timeout(60 * 60 * 1000)\n        .to(&quot;seda:inventoryUpdates&quot;);\n</code></pre></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Spring DSL</td>\n   <td class=\"light_cream\"><h4>Batch:</h4><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=&quot;jms:topic:stock:quote&quot;/&gt;\n        &lt;resequence&gt;\n                &lt;xpath&gt;/quote/@symbol&lt;/xpath&gt;\n                &lt;batch-config batchTimeout=&quot;60000&quot;/&gt;\n        &lt;/resequence&gt;\n        &lt;to uri=&quot;seda:quotes&quot;/&gt;\n&lt;/route&gt;\n</code></pre><h4>Stream:</h4><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=&quot;file://inventory&quot;/&gt;\n        &lt;resequence&gt;\n                &lt;xpath&gt;/inventory/@id&lt;xpath&gt;\n                &lt;stream-config timeout=&quot;3600000&quot;/&gt;\n        &lt;/resequence&gt;\n        &lt;to uri=&quot;seda:quotes&quot;/&gt;\n&lt;/route&gt;\n</code></pre><p>Notice that you can enable streaming by specifying &lt;stream-config&gt; instead of &lt;batch-config&gt;.</p></td>\n  </tr>\n </tbody>\n</table><h3>Dead Letter Channel</h3><table cellpadding=\"0\" cellspacing=\"0\">\n <tbody>\n  <tr>\n   <td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-21.jpg\" /></td>\n   <td class=\"light_cream\">What will the messaging system do with a message it cannot deliver?</td>\n  </tr>\n  <tr>\n   <td colspan=\"2\"><img alt=\"Message Router\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-22.jpg\" /></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Problem</td>\n   <td class=\"light_cream\">The messaging system cannot deliver a message</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Solution</td>\n   <td class=\"light_cream\">When a message cannot be delivered it should be moved to a Dead Letter Channel</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Camel</td>\n   <td class=\"light_cream\"><p>Camel has extensive support for Dead Letter Channel by its error handler and exception clauses. Error handler supports redelivery policies to decide how many times to try redelivering a message, before moving it to a Dead Letter Channel.</p><p>The default Dead Letter Channel will log the message at ERROR level and perform up to 6 redeliveries using a one second delay before each retry.</p><p>Error handler has two scopes: global and per route</p><p><strong>TIP:</strong> See Exception Clause in the Camel documentation for selective interception of thrown exception. This allows you to route certain exceptions differently or even reset the failure by marking it as handled.</p><p><strong>TIP:</strong> DeadLetterChannel supports processing the message before it gets redelivered using onRedelivery. This allows you to alter the message beforehand (i.e. to set any custom headers).</p></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Java DSL</td>\n   <td class=\"light_cream\"><h4>Global scope</h4><pre><code lang=\"text/x-java\">\nerrorHandler(deadLetterChannel(&quot;jms:queue:error&quot;)\n        .maximumRedeliveries(3));\n\nfrom(...)\n\nRoute scope\nfrom(&quot;jms:queue:event&quot;)\n        .errorHandler(deadLetterChannel()\n        .maximumRedeliveries(5))\n        .multicast().to(&quot;log:event&quot;, &quot;seda:handleEvent&quot;);\n</code></pre><p>In this route we override the global scope to use up to five redeliveries, where as the global only has three. You can of course also set a different error queue destination:</p><pre><code lang=\"text/x-java\">\ndeadLetterChannel(&quot;log:badEvent&quot;).maximumRedeliveries(5)\n</code></pre></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Spring DSL</td>\n   <td class=\"light_cream\"><p>The error handler is configured very differently in the Java DSL vs. the Spring DSL. The Spring DSL relies more on standard Spring bean configuration whereas the Java DSL uses fluent builders.</p><h4>Global scope</h4><p>The Global scope error handler is configured using the errorHandlerRef attribute on the camelContext tag.</p><pre><code lang=\"text/x-java\">\n&lt;camelContext errorHandlerRef=&quot;myDeadLetterChannel&quot;&gt;\n...\n&lt;/camelContext&gt;\n</code></pre><h4>Route scope</h4><p>Route scoped is configured using the errorHandlerRef attribute on the route tag.</p><pre><code lang=\"text/x-java\">\n&lt;route errorHandlerRef=&quot;myDeadLetterChannel&quot;&gt;\n...\n&lt;/route&gt;\n</code></pre><p>For both the error handler itself is configured using a regular Spring bean</p><pre><code lang=\"text/x-java\">\n&lt;bean id=&quot;myDeadLetterChannel&quot; class=&quot;org.apache.camel.\nbuilder.DeadLetterChannelBuilder&quot;&gt;\n        &lt;property name=&quot;deadLetterUri&quot; value=&quot;jms:queue:error&quot;/&gt;\n        &lt;property name=&quot;redeliveryPolicy&quot;\n                ref=&quot;myRedeliveryPolicy&quot;/&gt;\n&lt;/bean&gt;\n\n&lt;bean id=&quot;myRedeliverPolicy&quot;\n                class=&quot;org.apache.camel.processor.RedeliverPolicy&quot;&gt;\n        &lt;property name=&quot;maximumRedeliveries&quot; value=&quot;5&quot;/&gt;\n        &lt;property name=&quot;delay&quot; value=&quot;5000&quot;/&gt;\n&lt;/bean&gt;\n</code></pre></td>\n  </tr>\n </tbody>\n</table><h3>Wire Tap</h3><table cellpadding=\"0\" cellspacing=\"0\">\n <tbody>\n  <tr>\n   <td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" height=\"20\" src=\"images/rc047-010d-enterprise_integration_patterns-23.jpg\" width=\"34\" /></td>\n   <td class=\"light_cream\">How do you inspect messages that travel on a point-to-point channel?</td>\n  </tr>\n  <tr>\n   <td colspan=\"2\"><img alt=\"Wire Tap\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-24.jpg\" /></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Problem</td>\n   <td class=\"light_cream\">How do you tap messages while they are routed?</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Solution</td>\n   <td class=\"light_cream\">Insert a Wire Tap into the channel, that publishes each incoming message to the main channel as well as to a secondary channel.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Camel</td>\n   <td class=\"light_cream\">Camel has support for Wire Tap using the wireTap node, that supports two modes: traditional and new message. The traditional mode sends a copy of the original message, as opposed to sending a new message. All messages are sent as Event Message and runs in parallel with the original message.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Java DSL</td>\n   <td class=\"light_cream\"><h4>Traditional</h4><p>The route uses the traditional mode to send a copy of the original message to the seda tapped queue, while the original message is routed to its destination, the process order bean.</p><pre><code lang=\"text/x-java\">\nfrom(&quot;jms:queue:order&quot;)\n        .wireTap(&quot;seda:tappedOrder&quot;)\n        .to(&quot;bean:processOrder&quot;);\n</code></pre><h4>New message</h4><p>In this route we tap the high priority orders and send a new message containing a body with the from part of the order. Tip: As Camel uses an Expression for evaluation you can use other functions than xpath, for instance to send a fixed String you can use constant.</p><pre><code lang=\"text/x-java\">\nfrom(&quot;jms:queue:order&quot;)\n        .choice()\n                .when(&quot;/order/priority = ‘high’&quot;)\n                        .wireTap(&quot;seda:from&quot;, xpath(&quot;/order/from&quot;))\n                        .to(&quot;bean:processHighOrder&quot;);\n                .otherwise()\n                        .to(&quot;bean:processOrder&quot;);\n</code></pre></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Spring DSL</td>\n   <td class=\"light_cream\"><h4>Traditional</h4><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=&quot;jms:queue:order&quot;/&gt;\n        &lt;wireTap uri=&quot;seda:tappedOrder&quot;/&gt;\n        &lt;to uri=&quot;bean:processOrder&quot;/&gt;\n&lt;/route&gt;\n</code></pre><h4>New Message</h4><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;choice&gt;\n                &lt;when&gt;\n                        &lt;xpath&gt;/order/priority = 'high'&lt;/xpath&gt;\n                        &lt;wireTap uri=&quot;seda:from&quot;&gt;\n                                &lt;body&gt;&lt;xpath&gt;/order/from&lt;/xpath&gt;&lt;/body&gt;\n                        &lt;/wireTap&gt;\n                        &lt;to uri=&quot;bean:processHighOrder&quot;/&gt;\n                &lt;/when&gt;\n                &lt;otherwise&gt;\n                        &lt;to uri=&quot;bean:processOrder&quot;/&gt;\n                &lt;/otherwise&gt;\n        &lt;/choice&gt;\n&lt;/route&gt;\n</code></pre></td>\n  </tr>\n </tbody>\n</table>","creationDate":1523454468000,"creationDateFormatted":"04/11/2018 01:47 PM","title":"Essential Patterns","revision":4,"modificationDate":null,"id":2772526},{"chapter":4,"new":false,"active":true,"body":"<p pid=\"6\">The twelve patterns in this Refcard cover the most used patterns in the integration space, together with two of the most complex such as the Aggregator and the Dead Letter Channel. In the second part of this series we will take a further look at common patterns and transations.</p><h3>Get More Information</h3><table cellpadding=\"0\" cellspacing=\"0\">\n <tbody>\n  <tr>\n   <td class=\"light_blue\">Camel Website <a href=\"http://camel.apache.org\">http://camel.apache.org</a></td>\n   <td class=\"light_cream\">The home of the Apache Camel project. Find downloads, tutorials, examples, getting started guides, issue tracker, roadmap, mailing lists, irc chat rooms, and how to get help.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">FuseSource Website <a href=\"http://fusesource.com\">http://fusesource.com</a></td>\n   <td class=\"light_cream\">The home of the FuseSource company, the professional company behind Apache Camel with enterprise offerings, support, consulting and training.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">About Author <a href=\"http://davsclaus.blogspot.com\">http://davsclaus.blogspot.com</a></td>\n   <td class=\"light_cream\">The personal blog of the author of this reference card.</td>\n  </tr>\n </tbody>\n</table>","creationDate":1449599891000,"creationDateFormatted":"12/08/2015 06:38 PM","title":"Conclusion","revision":2,"modificationDate":null,"id":2004638}],"map":{"1":{"chapter":1,"new":false,"active":true,"body":"<p pid=\"2\">Integration is a hard problem. To help deal with the complexity of integration problems the Enterprise Integration Patterns (EIP) have become the standard way to describe, document and implement complex integration problems. Hohpe &amp; Woolf's book the Enterprise Integration Patterns has become the bible in the integration space - essential reading for any integration professional.</p><p pid=\"3\">Apache Camel is an open source project for implementing the EIP easily in a few lines of Java code or Spring XML configuration. This reference card, the first in a two card series, guides you through the most common Enterprise Integration Patterns and gives you examples of how to implement them either in Java code or using Spring XML. This Refcard is targeted for software developers and enterprise architects, but anyone in the integration space can benefit as well.</p>","creationDate":1449599891000,"creationDateFormatted":"12/08/2015 06:38 PM","title":"About Enterprise Integration Patterns","revision":2,"modificationDate":null,"id":2004635},"2":{"chapter":2,"new":false,"active":true,"body":"<p pid=\"4\">Apache Camel is a powerful open source integration platform based on Enterprise Integration Patterns (EIP) with powerful Bean Integration. Camel lets you implementing EIP routing using Camels intuitive Domain Specific Language (DSL) based on Java (aka fluent builder) or XML. Camel uses URI for endpoint resolution so its very easy to work with any kind of transport such as HTTP, REST, JMS, web service, File, FTP, TCP, Mail, JBI, Bean (POJO) and many others. Camel also provides Data Formats for various popular formats such as: CSV, EDI, FIX, HL7, JAXB, Json, Xstream. Camel is an integration API that can be embedded in any server of choice such as: J2EE Server, ActiveMQ, Tomcat, OSGi, or as standalone. Camels Bean Integration let you define loose coupling allowing you to fully separate your business logic from the integration logic. Camel is based on a modular architecture allowing you to plugin your own component or data format, so they seamlessly blend in with existing modules. Camel provides a test kit for unit and integration testing with strong mock and assertion capabilities.</p>","creationDate":1449599891000,"creationDateFormatted":"12/08/2015 06:38 PM","title":"About Apache Camel","revision":2,"modificationDate":null,"id":2004636},"4":{"chapter":4,"new":false,"active":true,"body":"<p pid=\"6\">The twelve patterns in this Refcard cover the most used patterns in the integration space, together with two of the most complex such as the Aggregator and the Dead Letter Channel. In the second part of this series we will take a further look at common patterns and transations.</p><h3>Get More Information</h3><table cellpadding=\"0\" cellspacing=\"0\">\n <tbody>\n  <tr>\n   <td class=\"light_blue\">Camel Website <a href=\"http://camel.apache.org\">http://camel.apache.org</a></td>\n   <td class=\"light_cream\">The home of the Apache Camel project. Find downloads, tutorials, examples, getting started guides, issue tracker, roadmap, mailing lists, irc chat rooms, and how to get help.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">FuseSource Website <a href=\"http://fusesource.com\">http://fusesource.com</a></td>\n   <td class=\"light_cream\">The home of the FuseSource company, the professional company behind Apache Camel with enterprise offerings, support, consulting and training.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">About Author <a href=\"http://davsclaus.blogspot.com\">http://davsclaus.blogspot.com</a></td>\n   <td class=\"light_cream\">The personal blog of the author of this reference card.</td>\n  </tr>\n </tbody>\n</table>","creationDate":1449599891000,"creationDateFormatted":"12/08/2015 06:38 PM","title":"Conclusion","revision":2,"modificationDate":null,"id":2004638},"3":{"chapter":3,"new":false,"active":true,"body":"<p pid=\"5\">This group consists of the most essential patterns that anyone working with integration must know.</p><h3>Pipes and Filters</h3><table cellpadding=\"0\" cellspacing=\"0\">\n <tbody>\n  <tr>\n   <td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-1.jpg\" /></td>\n   <td class=\"light_cream\">How can we perform complex processing on a message while maintaining independence and flexibility?</td>\n  </tr>\n  <tr>\n   <td colspan=\"2\"><img alt=\"Pipes and Filters\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-2.jpg\" /></td>\n  </tr>\n </tbody>\n</table><table cellpadding=\"0\" cellspacing=\"0\">\n <tbody>\n  <tr>\n   <td class=\"light_blue\">Problem</td>\n   <td class=\"light_cream\">A single event often triggers a sequence of processing steps</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Solution</td>\n   <td class=\"light_cream\">Use Pipes and Filters to divide a larger processing steps (filters) that are connected by channels (pipes)</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Camel</td>\n   <td class=\"light_cream\">Camel supports Pipes and Filters using the <strong>pipeline</strong> node.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Java DSL</td>\n   <td class=\"light_cream\"><pre><code lang=\"text/x-java\">\nfrom(&quot;jms:queue:order:in&quot;).pipeline(&quot;direct:transformOrder&quot;, &quot;direct:validateOrder&quot;, &quot;jms:queue:order:process&quot;);\n</code></pre><p>Where jms represents the JMS component used for consuming JMS messages on the JMS broker. Direct is used for combining endpoints in a synchronous fashion, allow you to divide routes into sub routes and/or reuse common routes.</p><p><strong>Tip:</strong> Pipeline is the default mode of operation when you specify multiple outputs, so it can be omitted and replaced with the more common node:</p><pre><code lang=\"text/x-java\">\nfrom(&quot;jms:queue:order:in&quot;).to(&quot;direct:transformOrder&quot;,\n&quot;direct:validateOrder&quot;, &quot;jms:queue:order:process&quot;);\n</code></pre><p><strong>TIP:</strong> You can also separate each step as individual <strong>to</strong> nodes:</p><pre><code lang=\"text/x-java\">\nfrom(&quot;jms:queue:order:in&quot;)\n        .to(&quot;direct:transformOrder&quot;)\n        .to(&quot;direct:validateOrder&quot;)\n        .to(&quot;jms:queue:order:process&quot;);\n</code></pre></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Spring DSL</td>\n   <td class=\"light_cream\"><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=&quot;jms:queue:order:in&quot;/&gt;\n        &lt;pipeline&gt;\n                &lt;to uri=&quot;direct:transformOrder&quot;/&gt;\n                &lt;to uri=&quot;direct:validateOrder&quot;/&gt;\n                &lt;to uri=&quot;jms:queue:order:process&quot;/&gt;\n        &lt;/pipeline&gt;\n&lt;/route&gt;\n&lt;route&gt;\n        &lt;from uri=&quot;jms:queue:order:in&quot;/&gt;\n        &lt;to uri=&quot;direct:transformOrder&quot;/&gt;\n        &lt;to uri=&quot;direct:validateOrder&quot;/&gt;\n        &lt;to uri=&quot;jms:queue:order:process&quot;/&gt;\n&lt;/route&gt;</code></pre><br /><br /></td>\n  </tr>\n </tbody>\n</table><h3>Message Router</h3><table cellpadding=\"0\" cellspacing=\"0\">\n <tbody>\n  <tr>\n   <td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" height=\"23\" src=\"images/rc047-010d-enterprise_integration_patterns-3.jpg\" width=\"42\" /></td>\n   <td class=\"light_cream\">How can you deouple indevidual processing steps so that messages can be passed to different filters depending on a set of conditions?</td>\n  </tr>\n  <tr>\n   <td colspan=\"2\"><img alt=\"Message Router\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-4.jpg\" /></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Problem</td>\n   <td class=\"light_cream\">Pipes and Filters route each message in the same processing steps. How can we route messages differently?</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Solution</td>\n   <td class=\"light_cream\">Filter using predicates to choose the right output destination.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Camel</td>\n   <td class=\"light_cream\">Camel supports Message Router using the <strong>choice</strong> node. For more details see the Content Based router pattern.</td>\n  </tr>\n </tbody>\n</table><h3>Content-Based Router</h3><table cellpadding=\"0\" cellspacing=\"0\">\n <tbody>\n  <tr>\n   <td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-5.jpg\" /></td>\n   <td class=\"light_cream\">How do we handle a situation where the implementation of a single logical function (e.g., inventory check) is spread across multiple physical systems?</td>\n  </tr>\n  <tr>\n   <td colspan=\"2\"><img alt=\"Content-Based Router\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-6.jpg\" /></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Problem</td>\n   <td class=\"light_cream\">How do we ensure a Message is sent to the correct recipient based on information from its content?</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Solution</td>\n   <td class=\"light_cream\">Use a Content-Based Router to route each message to the correct recipient based on the message content.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Camel</td>\n   <td class=\"light_cream\">Camel has extensive support for Content-Based Routing. Camel supports content based routing based on <strong>choice, filter,</strong> or any other expression.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Java DSL</td>\n   <td class=\"light_cream\"><h4>Choice</h4><pre><code lang=\"text/x-java\">\nfrom(&quot;jms:queue:order&quot;)\n.choice()\n.when(header(&quot;type&quot;).in(&quot;widget&quot;,&quot;wiggy&quot;))\n.to(&quot;jms:queue:order:widget&quot;)\n.when(header(&quot;type&quot;).isEqualTo(&quot;gadget&quot;))\n.to(&quot;jms:queue:order:gadget&quot;)\n.otherwise().to(&quot;jms:queue:order:misc&quot;)\n.end();\n</code></pre><p><strong>TIP:</strong> In the route above end() can be omitted as its the last node and we do not route the message to a new destination after the choice.</p><p><strong>TIP:</strong> You can continue routing after the choice ends.</p></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Spring DSL</td>\n   <td class=\"light_cream\"><h4>Choice</h4><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=&quot;jms:queue:order&quot;/&gt;\n        &lt;choice&gt;\n                &lt;when&gt;\n                        &lt;simple&gt;${header.type} in 'widget,wiggy'&lt;/simple&gt;\n                        &lt;to uri=&quot;jms:queue:order:widget&quot;/&gt;\n                &lt;/when&gt;\n                &lt;when&gt;\n                        &lt;simple&gt;${header.type} == 'gadget'&lt;/simple&gt;\n                        &lt;to uri=&quot;jms:queue:order:gadget&quot;/&gt;\n                &lt;/when&gt;\n                &lt;otherwise&gt;\n                        &lt;to uri=&quot;jms:queue:order:misc&quot;/&gt;\n                &lt;/otherwise&gt;\n        &lt;/choice&gt;\n&lt;/route&gt;\n</code></pre><p><strong>TIP:</strong> In Spring DSL you cannot invoke code, as opposed to the Java DSL that is 100% Java. To express the predicates for the choices we need to use a language. We will use simple language that uses a simple expression parser that supports a limited set of operators. You can use any of the more powerful languages supported in Camel such as: JavaScript, Groovy, Unified EL and many others.</p><p><strong>TIP:</strong> You can also use a method call to invoke a method on a bean to evaluate the predicate. Lets try that:</p><pre><code lang=\"text/x-java\">\n&lt;when&gt;\n        &lt;method bean=&quot;myBean&quot; method=&quot;isGadget&quot;/&gt;\n        ...\n&lt;/when&gt;\n\n&lt;bean id=&quot;myBean&quot; class=&quot;com.mycomapany.MyBean&quot;/&gt;\n\npublic boolean isGadget(@Header(name = &quot;type&quot;) String type) {\n        return type.equals(&quot;Gadget&quot;);\n}\n</code></pre><p>Notice how we use Bean Parameter Binding to instruct Camel to invoke this method and pass in the type header as the String parameter. This allows your code to be fully decoupled from any Camel API so its easy to read, write and unit test.</p></td>\n  </tr>\n </tbody>\n</table><h3>Message Translator</h3><table cellpadding=\"0\" cellspacing=\"0\">\n <tbody>\n  <tr>\n   <td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-7.jpg\" /></td>\n   <td class=\"light_cream\">How can systems using different data formats communicate with each other using messaging?</td>\n  </tr>\n  <tr>\n   <td colspan=\"2\"><img alt=\"Message Translator\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-8.jpg\" /></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Problem</td>\n   <td class=\"light_cream\">Each application uses its own data format, so we need to translate the message into the data format the application supports.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Solution</td>\n   <td class=\"light_cream\">Use a special filter, a messae translator, between filters or applications to translate one data format into another.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Camel</td>\n   <td class=\"light_cream\">Camel supports the message translator using the <strong>processor, bean</strong> or <strong>transform</strong> nodes. TIP: Camel routes the message as a chain of <strong>processor</strong> nodes.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Java DSL</td>\n   <td class=\"light_cream\"><h4>Processor</h4><pre><code lang=\"text/x-java\">\npublic class OrderTransformProcessor\n                implements Processor {\n        public void process(Exchange exchange)\n                        throws Exception {\n                // do message translation here\n        }\n}\nfrom(&quot;direct:transformOrder&quot;)\n        .process(new OrderTransformProcessor());\n</code></pre><h4>Bean</h4><p>Instead of the processor we can use Bean (POJO). An advantage of using a Bean over Processor is the fact that we do not have to implement or use any Camel specific interfaces or types. This allows you to fully decouple your beans from Camel.</p><pre><code lang=\"text/x-java\">\npublic class OrderTransformerBean {\n        public StringtransformOrder(String body) {\n                // do message translation here\n        }\n}\nObject transformer = new OrderTransformerBean();\nfrom(&quot;direct:transformOrder&quot;).bean(transformer);\n</code></pre><p><strong>TIP:</strong> Camel can create an instance of the bean automatically; you can just refer to the class type.</p><pre><code lang=\"text/x-java\">\nfrom(&quot;direct:transformOrder&quot;)\n        .bean(OrderTransformerBean.class);\n</code></pre><p><strong>TIP:</strong> Camel will try to figure out which method to invoke on the bean in case there are multiple methods. In case of ambiguity you can specify which methods to invoke by the method parameter:</p><pre><code lang=\"text/x-java\">\nfrom(&quot;direct:transformOrder&quot;)\n        .bean(OrderTransformerBean.class, &quot;transformOrder&quot;);\n</code></pre><h4>Transform</h4><p>Transform is a particular processor allowing you to set a response to be returned to the original caller. We use transform to return a constant ACK response to the TCP listener after we have copied the message to the JMS queue. Notice we use a constant to build an &quot;ACK&quot; string as response.</p><pre><code lang=\"text/x-java\">\nfrom(&quot;mina:tcp://localhost:8888?textline=true&quot;)\n        .to(&quot;jms:queue:order:in&quot;)\n        .transform(constant(&quot;ACK&quot;));\n</code></pre></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Spring DSL</td>\n   <td class=\"light_cream\"><h4>Processor</h4><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=&quot;direct:transformOrder&quot;/&gt;\n        &lt;process ref=&quot;transformer&quot;/&gt;\n&lt;/route&gt;\n\n&lt;bean id=&quot;transformer&quot; class=&quot;com.mycompany.\nOrderTransformProcessor&quot;/&gt;\n</code></pre><p>In Spring DSL Camel will look up the processor or POJO/Bean in the registry based on the id of the bean.</p><h4>Bean</h4><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n&lt;from uri=&quot;direct:transformOrder&quot;/&gt;\n&lt;bean ref=&quot;transformer&quot;/&gt;\n&lt;/route&gt;\n&lt;bean id=&quot;tramsformer&quot;\nclass=&quot;com.mycompany.OrderTransformBean&quot;/&gt;\n</code></pre><h4>Transform</h4><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n&lt;from uri=&quot;mina:tcp://localhost:8888?textline=true&quot;/&gt;\n&lt;to uri=&quot;jms:queue:order:in&quot;/&gt;\n&lt;transform&gt;\n&lt;constant&gt;ACK&lt;/constant&gt;\n&lt;/transform&gt;\n&lt;/route&gt;\n</code></pre></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Annotation DSL</td>\n   <td class=\"light_cream\"><p>You can also use the <strong>@Consume</strong> annotation for transformations. For example in the method below we consume from a JMS queue and do the transformation in regular Java code. Notice that the input and output parameters of the method is String. Camel will automatically coerce the payload to the expected type defined by the method. Since this is a JMS example the response will be sent back to the JMS reply-to destination.</p><pre><code lang=\"text/x-java\">\n@Consume(uri=&quot;jms:queue:order:transform&quot;)\npublic String transformOrder(String body) {\n        // do message translation\n}\n</code></pre><p><strong>TIP:</strong> You can use Bean Parameter Binding to help Camel coerce the Message into the method parameters. For instance you can use <strong>@Body, @Headers</strong> parameter annotations to bind parameters to the body and headers.</p></td>\n  </tr>\n </tbody>\n</table><h3>Message Filter</h3><table cellpadding=\"0\" cellspacing=\"0\">\n <tbody>\n  <tr>\n   <td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-9.jpg\" /></td>\n   <td class=\"light_cream\">How can a component avoid receiving unwanted messages?</td>\n  </tr>\n  <tr>\n   <td colspan=\"2\"><img alt=\"Message Filter\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-10.jpg\" /></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Problem</td>\n   <td class=\"light_cream\">How do you discard unwanted messages?</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Solution</td>\n   <td class=\"light_cream\">Use a special kind of Message Router, a Message Filter, to eliminate undesired messages from a channel based on a set of criteria.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Camel</td>\n   <td class=\"light_cream\">Camel has support for Message Filter using the filter node. The filter evaluates a predicate whether its true or false; only allowing the true condition to pass the filter, where as the false condition will silently be ignored.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Java DSL</td>\n   <td class=\"light_cream\">We want to discard any test messages so we only route non-test messages to the order queue. <pre><code lang=\"text/x-java\">\nfrom(&quot;jms:queue:inbox&quot;)\n        .filter(header(&quot;test&quot;).isNotEqualTo(&quot;true&quot;))\n        .to(&quot;jms:queue:order&quot;);</code></pre><br /><br /></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Spring DSL</td>\n   <td class=\"light_cream\">For the Spring DSL we use XPath to evaluate the predicate. The $test is a special shorthand in Camel to refer to the header with the given name. So even if the payload is not XML based we can still use XPath to evaluate predicates. <pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=&quot;jms:queue:inbox&quot;/&gt;\n        &lt;filter&gt;\n                &lt;xpath&gt;$test = 'false'&lt;/xpath&gt;\n                &lt;to uri=&quot;jms:queue:inbox&quot;/&gt;\n        &lt;/filter&gt;\n&lt;/route&gt;</code></pre><br /><br /></td>\n  </tr>\n </tbody>\n</table><h3>Dynamic Router</h3><table cellpadding=\"0\" cellspacing=\"0\">\n <tbody>\n  <tr>\n   <td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-11.jpg\" /></td>\n   <td class=\"light_cream\"></td>\n  </tr>\n  <tr>\n   <td colspan=\"2\"><img alt=\"Dynamic Router\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-12.jpg\" /></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Problem</td>\n   <td class=\"light_cream\">How can we route messages based on a dynamic list of destinations?</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Solution</td>\n   <td class=\"light_cream\">Use a Dynamic Router, a router that can self-configure based on special configuration messages from participating destinations.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Camel</td>\n   <td class=\"light_cream\">Camel has support for Dynamic Router using the Dynamic <strong>Recipient List</strong> combined with a data store holding the list of destinations.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Java DSL</td>\n   <td class=\"light_cream\">We use a Processor as the dynamic router to determine the destinations. We could also have used a Bean instead. <pre><code lang=\"text/x-java\">\nfrom(&quot;jms:queue:order&quot;)\n        .processRef(myDynamicRouter)\n        .recipientList(&quot;destinations&quot;);\n\npublic class MyDynamicRouter implements Processor {\n        public void process(Exchange exchange) {\n                // query a data store to find the best match of the\n                // endpoint and return the destination(s) in the\n                // header exchange.getIn()\n                // .setHeader(&quot;destinations&quot;, list);\n        }\n}</code></pre><br /><br /></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Spring DSL</td>\n   <td class=\"light_cream\"><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=&quot;jms:queue:order&quot;/&gt;\n        &lt;process ref=&quot;myDynamicRouter&quot;/&gt;\n        &lt;recipientList&gt;\n                &lt;header&gt;destinations&lt;/destinations&gt;\n        &lt;/recipientList&gt;\n&lt;/route&gt;</code></pre><br /><br /></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Annotation DSL</td>\n   <td class=\"light_cream\"><pre><code lang=\"text/x-java\">\npublic class MyDynamicRouter {\n        @Consume(uri = &quot;jms:queue:order&quot;)\n        @RecipientList\n        public List&lt;String&gt; route(@XPath(&quot;/customer/id&quot;)\nString customerId, @Header(&quot;location&quot;) String location,\nDocument body) {\n                // query data store, find best match for the\n                //endpoint and return destination (s)\n        }\n}\n</code></pre><p><strong>TIP:</strong> Notice how we used Bean Parameter Binding to bind the parameters to the route method based on an <strong>@XPath</strong> expression on the XML payload of the JMS message. This allows us to extract the customer id as a string parameter. <strong>@Header</strong> wil bind a JMS property with the key location. <strong>Document</strong> is the XML payload of the JMS message.</p><p><strong>TIP:</strong> Camel uses its strong type converter feature to convert the payload to the type of the method parameter. We could use String and Camel will convert the body to a String instead. You can register your own type converters as well using the <strong>@Converter</strong> annotation at the class and method level.</p></td>\n  </tr>\n </tbody>\n</table><h3>Recipient List</h3><table cellpadding=\"0\" cellspacing=\"0\">\n <tbody>\n  <tr>\n   <td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-13.jpg\" /></td>\n   <td class=\"light_cream\">How do we route a message to a list of statically or dynamically specified recipients?</td>\n  </tr>\n  <tr>\n   <td colspan=\"2\"><img alt=\"Recipient List\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-14.jpg\" /></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Problem</td>\n   <td class=\"light_cream\">How can we route messages based on a static or dynamic list of destinations?</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Solution</td>\n   <td class=\"light_cream\">Define a channel for each recipient. Then use a Recipient List to inspect an incoming message, determine the list of desired recipients and forward the message to all channels associated with the recipients in the list.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Camel</td>\n   <td class=\"light_cream\">Camel supports the static Recipient List using the <strong>multicast</strong> node, and the dynamic Recipient List using the <strong>recipientList</strong> node.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Java DSL</td>\n   <td class=\"light_cream\"><h4>Static</h4><p>In this route we route to a static list of two recipients, that will receive a copy of the same message simultaneously.</p><pre><code lang=\"text/x-java\">\nfrom(&quot;jms:queue:inbox&quot;)\n        .multicast().to(&quot;file://backup&quot;, &quot;seda:inbox&quot;);\n</code></pre><h4>Dynamic</h4><p>In this route we route to a dynamic list of recipients defined in the message header [mails] containing a list of recipients as endpoint URLs. The bean processMails is used to add the header[mails] to the message.</p><pre><code lang=\"text/x-java\">\nfrom(&quot;seda:confirmMails&quot;).beanRef(processMails)\n        .recipientList(&quot;destinations&quot;);\n</code></pre><p>And in the process mails bean we use <strong>@Headers</strong> Bean Parameter Binding to provide a <strong>java.util.Map</strong> to store the recipients.</p><pre><code lang=\"text/x-java\">\npublic void confirm(@Headers Map headers, @Body String body} {\n        String[] recipients = ...\n        headers.put(&quot;&quot;destinations&quot;, recipients);\n}\n</code></pre></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Spring DSL</td>\n   <td class=\"light_cream\"><h4>Static</h4><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=&quot;jms:queue:inbox&quot; /&gt;\n        &lt;multicast&gt;\n                &lt;to uri=&quot;file://backup&quot;/&gt;\n                &lt;to uri=&quot;seda:inbox&quot;/&gt;\n        &lt;/multicast&gt;\n&lt;/route&gt;\n</code></pre><h4>Dynamic</h4><p>In this example we invoke a method call on a Bean to provide the dynamic list of recipients.</p><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=&quot;jms:queue:inbox&quot; /&gt;\n        &lt;recipientList&gt;\n                &lt;method bean=&quot;myDynamicRouter&quot; method=&quot;route&quot;/&gt;\n        &lt;/recipientList&gt;\n&lt;/route&gt;\n\n&lt;bean id=&quot;myDynamicRouter&quot;\n        class=&quot;com.mycompany.MyDynamicRouter&quot;/&gt;\n\npublic class myDynamicRouter {\n        public String[] route(String body) {\n                return new String[] { &quot;file://backup&quot;, .... }\n        }\n}\n</code></pre></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Annotation DSL</td>\n   <td class=\"light_cream\"><p>In the CustomerService class we annoate the <strong>whereTo</strong> method with <strong>@RecipientList</strong>, and return a single destination based on the customer id. Notice the flexibility of Camel as it can adapt accordingly to how you define what your methods are returning: a single element, a list, an iterator, etc.</p><pre><code lang=\"text/x-java\">\npublic class CustomerService {\n        @RecipientList\n        public String whereTo(@Header(&quot;customerId&quot;) id) {\n                return &quot;jms:queue:customer:&quot; + id;\n        }\n}\n</code></pre><p>And then we can route to the bean and it will act as a dynamic recipient list.</p><pre><code lang=\"text/x-java\">\nfrom(&quot;jms:queue:inbox&quot;)\n        .bean(CustomerService.class, &quot;whereTo&quot;);\n</code></pre></td>\n  </tr>\n </tbody>\n</table><h3>Splitter</h3><table cellpadding=\"0\" cellspacing=\"0\">\n <tbody>\n  <tr>\n   <td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-15.jpg\" /></td>\n   <td class=\"light_cream\">How can we process a message if it contains multiple elements, each of which may have to be processed in a different way?</td>\n  </tr>\n  <tr>\n   <td colspan=\"2\"><img alt=\"Splitter\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-16.jpg\" /></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Problem</td>\n   <td class=\"light_cream\">How can we split a single message into pieces to be routed individually?</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Solution</td>\n   <td class=\"light_cream\">Use a Splitter to break out the composite message into a series of individual messages, each containing data related to one item.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Camel</td>\n   <td class=\"light_cream\">Camel has support for Splitter using the <strong>split</strong> node.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Java DSL</td>\n   <td class=\"light_cream\"><p>In this route we consume files from the inbox folder. Each file is then split into a new message. We use a tokenizer to split the file content line by line based on line breaks.</p><pre><code lang=\"text/x-java\">\nfrom(&quot;file://inbox&quot;)\n        .split(body().tokenize(&quot;\\n&quot;))\n        .to(&quot;seda:orderLines&quot;);\n</code></pre><p><strong>TIP:</strong> Camel also supports splitting streams using the streaming node. We can split the stream by using a comma:</p><pre><code lang=\"text/x-java\">\n.split(body().tokenize(&quot;,&quot;)).streaming().to(&quot;seda:parts&quot;);\n</code></pre><p><strong>TIP:</strong> In the routes above each individual split message will be executed in sequence. Camel also supports parallel execution using the parallelProcessing node.</p><pre><code lang=\"text/x-java\">\n.split(body().tokenize(&quot;,&quot;)).streaming()\n        .parallelProcessing().to(&quot;seda:parts&quot;);\n</code></pre></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Spring DSL</td>\n   <td class=\"light_cream\">In this route we use XPath to split XML payloads received on the JMS order queue. <pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=&quot;jms:queue:order&quot;/&gt;\n        &lt;split&gt;\n                &lt;xpath&gt;/invoice/lineItems&lt;/xpath&gt;\n                &lt;to uri=&quot;seda:processOrderLine&quot;/&gt;\n        &lt;/split&gt;\n&lt;/route&gt;\n</code></pre><p>And in this route we split the messages using a regular expression</p><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=&quot;jms:queue:order&quot;/&gt;\n        &lt;split&gt;\n                &lt;tokenizer token=&quot;([A-Z|0-9]*);&quot; regex=&quot;true&quot;/&gt;\n                &lt;to uri=&quot;seda:processOrderLine&quot;/&gt;\n        &lt;/split&gt;\n&lt;/route&gt;\n</code></pre><p><strong>TIP:</strong> Split evaluates an org.apahce.camel.Expression to provide something that is iterable to produce each individual new message. This allows you to provide any kind of expression such as a Bean invoked as a method call.</p><pre><code lang=\"text/x-java\">\n&lt;split&gt;\n        &lt;method bean=&quot;mySplitter&quot; method=&quot;splitMe&quot;/&gt;\n        &lt;to uri=&quot;seda:processOrderLine&quot;/&gt;\n&lt;/split&gt;\n\n&lt;bean id=&quot;mySplitter&quot; class=&quot;com.mycompany.MySplitter&quot;/&gt;\n\npublic List splitMe(String body) {\n        // split using java code and return a List\n        List parts = ...\n        return parts;\n}\n</code></pre></td>\n  </tr>\n </tbody>\n</table><h3>Aggregator</h3><table cellpadding=\"0\" cellspacing=\"0\">\n <tbody>\n  <tr>\n   <td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-17.jpg\" /></td>\n   <td class=\"light_cream\">How do we combine the results of individual, but related messages so that they can be processed as a whole?</td>\n  </tr>\n  <tr>\n   <td colspan=\"2\"><img alt=\"Message Router\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-18.jpg\" /></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Problem</td>\n   <td class=\"light_cream\">How do we combine multiple messages into a single combined message?</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Solution</td>\n   <td class=\"light_cream\">Use a stateful filter, an Aggregator, to collect and store individual messages until it receives a complete set of related messages to be published.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Camel</td>\n   <td class=\"light_cream\">Camel has support for the Aggregator using the aggregate node. Camel uses a stateful batch processor that is capable of aggregating related messaged into a single combined message. A correlation expression is used to determine which messages should be aggregated. An aggregation strategy is used to combine aggregated messages into the result message. Camel’s aggregator also supports a completion predicate allowing you to signal when the aggregation is complete. Camel also supports other completion signals based on timeout and/or a number of messages already aggregated.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Java DSL</td>\n   <td class=\"light_cream\"><h4>Stock quote example</h4><p>We want to update a website every five minutes with the latest stock quotes. The quotes are received on a JMS topic. As we can receive multiple quotes for the same stock within this time period we only want to keep the last one as its the most up to date. We can do this with the aggregator:</p><pre><code lang=\"text/x-java\">\nfrom(&quot;jms:topic:stock:quote&quot;)\n        .aggregate().xpath(&quot;/quote/@symbol&quot;)\n        .batchTimeout(5 * 60 * 1000).to(&quot;seda:quotes&quot;);\n</code></pre><p>As the correlation expression we use XPath to fetch the stock symbol from the message body. As the aggregation strategy we use the default provided by Camel that picks the latest message, and thus also the most up to date. The time period is set as a timeout value in milliseconds.</p><h4>Loan broker example</h4><p>We aggregate responses from various banks for their quote for a given loan request. We want to pick the bank with the best quote (the cheapest loan), therefore we need to base our aggregation strategy to pick the best quote.</p><pre><code lang=\"text/x-java\">\nfrom(&quot;jms:topic:loan:quote&quot;)\n        .aggregate().header(&quot;loanId&quot;)\n        .aggregationStrategy(bestQuote)\n        .completionPredicate(header(Exchange.AGGREGATED_SIZE)\n        .isGreaterThan(2))\n        .to(&quot;seda:bestLoanQuote&quot;);\n</code></pre><p>We use a completion predicate that signals when we have received more than 2 quotes for a given loan, giving us at least 3 quotes to pick among. The following shows the code snippet for the aggregation strategy we must implement to pick the best quote:</p><pre><code lang=\"text/x-java\">\npublic class BestQuoteStrategy implements AggregationStrategy {\n        public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {\n                double oldQuote = oldExchange.getIn().getBody(Double.class);\n                double newQuote = newExchange.getIn().getBody(Double.class);\n                // return the &quot;winner&quot; that has the lowest quote\n                return newQuote &lt; oldQuote ? newExchange : oldExchange;\n        }\n}\n</code></pre></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Spring DSL</td>\n   <td class=\"light_cream\"><h4>Loan Broker Example</h4><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=&quot;jms:topic:loan:qoute&quot;/&gt;\n        &lt;aggregate strategyRef=&quot;bestQuote&quot;&gt;\n                &lt;correlationExpression&gt;\n                        &lt;header&gt;loanId&lt;/header&gt;\n                &lt;/correlationExpression&gt;\n                &lt;completionPredicate&gt;\n                        &lt;simple&gt;${header.CamelAggregatedSize} &gt; 2&lt;/simple&gt;\n                &lt;/completionPredicate&gt;\n        &lt;/aggregate&gt;\n        &lt;to uri=&quot;seda:bestLoanQuote&quot;/&gt;\n&lt;/route&gt;\n\n&lt;bean id=&quot;bestQuote&quot;\n        class=&quot;com.mycompany.BestQuoteStrategy&quot;/&gt;\n</code></pre><p><strong>TIP:</strong> We use the simple language to declare the completion predicate. Simple is a basic language that supports a primitive set of operators. ${header. CamelAggregatedSize} will fetch a header holding the number of messages aggregated.</p><p><strong>TIP:</strong> If the completed predicate is more complex we can use a method call to invoke a Bean so we can do the evaluation in pure Java code:</p><pre><code lang=\"text/x-java\">\n&lt;completionPredicate&gt;\n        &lt;method bean=&quot;quoteService&quot; method=&quot;isComplete&quot;/&gt;\n&lt;/compledtionPrediacate&gt;\npublic boolean isComplete(@Header(Exchange.AGGREGATED_SIZE)\n        int count, String body) {\n        return body.equals(&quot;STOP&quot;);\n}\n</code></pre><p>Notice how we can use Bean Binding Parameter to get hold of the aggregation size as a parameter, instead of looking it up in the message.</p></td>\n  </tr>\n </tbody>\n</table><h3>Resequencer</h3><table cellpadding=\"0\" cellspacing=\"0\">\n <tbody>\n  <tr>\n   <td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-19.jpg\" /></td>\n   <td class=\"light_cream\">How can we get a stream of related but out-of-sequence messages back into the correct order?</td>\n  </tr>\n  <tr>\n   <td colspan=\"2\"><img alt=\"Resequencer\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-20.jpg\" /></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Problem</td>\n   <td class=\"light_cream\">How do we ensure ordering of messages?</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Solution</td>\n   <td class=\"light_cream\">Use a stateful filter, a Resequencer, to collect and reorder messages so that they can be published in a specified order.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Camel</td>\n   <td class=\"light_cream\"><p>Camel has support for the Resequencer using the resequence node. Camel uses a stateful batch processor that is capable of reordering related messages. Camel supports two resequencing algorithms:</p><p><strong>-batch</strong> = collects messages into a batch, sorts the messages and publish the messages</p><p><strong>-stream</strong> = re-orders, continuously, message streams based on detection of gaps between messages.</p><p>Batch is similar to the aggregator but with sorting. Stream is the traditional Resequencer pattern with gap detection. Stream requires usage of number (longs) as sequencer numbers, enforced by the gap detection, as it must be able to compute if gaps exist. A gap is detected if a number in a series is missing, e.g. 3, 4, 6 with number 5 missing. Camel will back off the messages until number 5 arrives.</p></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Java DSL</td>\n   <td class=\"light_cream\"><h4>Batch:</h4><p>We want to process received stock quotes, once a minute, ordered by their stock symbol. We use XPath as the expression to select the stock symbol, as the value used for sorting.</p><pre><code lang=\"text/x-java\">\nfrom(&quot;jms:topic:stock:quote&quot;)\n        .resequence().xpath(&quot;/quote/@symbol&quot;)\n        .timeout(60 * 1000)\n        .to(&quot;seda:quotes&quot;);\n</code></pre><p>Camel will default the order to ascending. You can provide your own comparison for sorting if needed.</p><h4>Stream:</h4><p>Suppose we continuously poll a file directory for inventory updates, and its important they are processed in sequence by their inventory id. To do this we enable streaming and use one hour as the timeout.</p><pre><code lang=\"text/x-java\">\nfrom(&quot;file://inventory&quot;)\n        .resequence().xpath(&quot;/inventory/@id&quot;)\n        .stream().timeout(60 * 60 * 1000)\n        .to(&quot;seda:inventoryUpdates&quot;);\n</code></pre></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Spring DSL</td>\n   <td class=\"light_cream\"><h4>Batch:</h4><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=&quot;jms:topic:stock:quote&quot;/&gt;\n        &lt;resequence&gt;\n                &lt;xpath&gt;/quote/@symbol&lt;/xpath&gt;\n                &lt;batch-config batchTimeout=&quot;60000&quot;/&gt;\n        &lt;/resequence&gt;\n        &lt;to uri=&quot;seda:quotes&quot;/&gt;\n&lt;/route&gt;\n</code></pre><h4>Stream:</h4><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=&quot;file://inventory&quot;/&gt;\n        &lt;resequence&gt;\n                &lt;xpath&gt;/inventory/@id&lt;xpath&gt;\n                &lt;stream-config timeout=&quot;3600000&quot;/&gt;\n        &lt;/resequence&gt;\n        &lt;to uri=&quot;seda:quotes&quot;/&gt;\n&lt;/route&gt;\n</code></pre><p>Notice that you can enable streaming by specifying &lt;stream-config&gt; instead of &lt;batch-config&gt;.</p></td>\n  </tr>\n </tbody>\n</table><h3>Dead Letter Channel</h3><table cellpadding=\"0\" cellspacing=\"0\">\n <tbody>\n  <tr>\n   <td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-21.jpg\" /></td>\n   <td class=\"light_cream\">What will the messaging system do with a message it cannot deliver?</td>\n  </tr>\n  <tr>\n   <td colspan=\"2\"><img alt=\"Message Router\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-22.jpg\" /></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Problem</td>\n   <td class=\"light_cream\">The messaging system cannot deliver a message</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Solution</td>\n   <td class=\"light_cream\">When a message cannot be delivered it should be moved to a Dead Letter Channel</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Camel</td>\n   <td class=\"light_cream\"><p>Camel has extensive support for Dead Letter Channel by its error handler and exception clauses. Error handler supports redelivery policies to decide how many times to try redelivering a message, before moving it to a Dead Letter Channel.</p><p>The default Dead Letter Channel will log the message at ERROR level and perform up to 6 redeliveries using a one second delay before each retry.</p><p>Error handler has two scopes: global and per route</p><p><strong>TIP:</strong> See Exception Clause in the Camel documentation for selective interception of thrown exception. This allows you to route certain exceptions differently or even reset the failure by marking it as handled.</p><p><strong>TIP:</strong> DeadLetterChannel supports processing the message before it gets redelivered using onRedelivery. This allows you to alter the message beforehand (i.e. to set any custom headers).</p></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Java DSL</td>\n   <td class=\"light_cream\"><h4>Global scope</h4><pre><code lang=\"text/x-java\">\nerrorHandler(deadLetterChannel(&quot;jms:queue:error&quot;)\n        .maximumRedeliveries(3));\n\nfrom(...)\n\nRoute scope\nfrom(&quot;jms:queue:event&quot;)\n        .errorHandler(deadLetterChannel()\n        .maximumRedeliveries(5))\n        .multicast().to(&quot;log:event&quot;, &quot;seda:handleEvent&quot;);\n</code></pre><p>In this route we override the global scope to use up to five redeliveries, where as the global only has three. You can of course also set a different error queue destination:</p><pre><code lang=\"text/x-java\">\ndeadLetterChannel(&quot;log:badEvent&quot;).maximumRedeliveries(5)\n</code></pre></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Spring DSL</td>\n   <td class=\"light_cream\"><p>The error handler is configured very differently in the Java DSL vs. the Spring DSL. The Spring DSL relies more on standard Spring bean configuration whereas the Java DSL uses fluent builders.</p><h4>Global scope</h4><p>The Global scope error handler is configured using the errorHandlerRef attribute on the camelContext tag.</p><pre><code lang=\"text/x-java\">\n&lt;camelContext errorHandlerRef=&quot;myDeadLetterChannel&quot;&gt;\n...\n&lt;/camelContext&gt;\n</code></pre><h4>Route scope</h4><p>Route scoped is configured using the errorHandlerRef attribute on the route tag.</p><pre><code lang=\"text/x-java\">\n&lt;route errorHandlerRef=&quot;myDeadLetterChannel&quot;&gt;\n...\n&lt;/route&gt;\n</code></pre><p>For both the error handler itself is configured using a regular Spring bean</p><pre><code lang=\"text/x-java\">\n&lt;bean id=&quot;myDeadLetterChannel&quot; class=&quot;org.apache.camel.\nbuilder.DeadLetterChannelBuilder&quot;&gt;\n        &lt;property name=&quot;deadLetterUri&quot; value=&quot;jms:queue:error&quot;/&gt;\n        &lt;property name=&quot;redeliveryPolicy&quot;\n                ref=&quot;myRedeliveryPolicy&quot;/&gt;\n&lt;/bean&gt;\n\n&lt;bean id=&quot;myRedeliverPolicy&quot;\n                class=&quot;org.apache.camel.processor.RedeliverPolicy&quot;&gt;\n        &lt;property name=&quot;maximumRedeliveries&quot; value=&quot;5&quot;/&gt;\n        &lt;property name=&quot;delay&quot; value=&quot;5000&quot;/&gt;\n&lt;/bean&gt;\n</code></pre></td>\n  </tr>\n </tbody>\n</table><h3>Wire Tap</h3><table cellpadding=\"0\" cellspacing=\"0\">\n <tbody>\n  <tr>\n   <td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" height=\"20\" src=\"images/rc047-010d-enterprise_integration_patterns-23.jpg\" width=\"34\" /></td>\n   <td class=\"light_cream\">How do you inspect messages that travel on a point-to-point channel?</td>\n  </tr>\n  <tr>\n   <td colspan=\"2\"><img alt=\"Wire Tap\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-24.jpg\" /></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Problem</td>\n   <td class=\"light_cream\">How do you tap messages while they are routed?</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Solution</td>\n   <td class=\"light_cream\">Insert a Wire Tap into the channel, that publishes each incoming message to the main channel as well as to a secondary channel.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Camel</td>\n   <td class=\"light_cream\">Camel has support for Wire Tap using the wireTap node, that supports two modes: traditional and new message. The traditional mode sends a copy of the original message, as opposed to sending a new message. All messages are sent as Event Message and runs in parallel with the original message.</td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Java DSL</td>\n   <td class=\"light_cream\"><h4>Traditional</h4><p>The route uses the traditional mode to send a copy of the original message to the seda tapped queue, while the original message is routed to its destination, the process order bean.</p><pre><code lang=\"text/x-java\">\nfrom(&quot;jms:queue:order&quot;)\n        .wireTap(&quot;seda:tappedOrder&quot;)\n        .to(&quot;bean:processOrder&quot;);\n</code></pre><h4>New message</h4><p>In this route we tap the high priority orders and send a new message containing a body with the from part of the order. Tip: As Camel uses an Expression for evaluation you can use other functions than xpath, for instance to send a fixed String you can use constant.</p><pre><code lang=\"text/x-java\">\nfrom(&quot;jms:queue:order&quot;)\n        .choice()\n                .when(&quot;/order/priority = ‘high’&quot;)\n                        .wireTap(&quot;seda:from&quot;, xpath(&quot;/order/from&quot;))\n                        .to(&quot;bean:processHighOrder&quot;);\n                .otherwise()\n                        .to(&quot;bean:processOrder&quot;);\n</code></pre></td>\n  </tr>\n  <tr>\n   <td class=\"light_blue\">Spring DSL</td>\n   <td class=\"light_cream\"><h4>Traditional</h4><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=&quot;jms:queue:order&quot;/&gt;\n        &lt;wireTap uri=&quot;seda:tappedOrder&quot;/&gt;\n        &lt;to uri=&quot;bean:processOrder&quot;/&gt;\n&lt;/route&gt;\n</code></pre><h4>New Message</h4><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;choice&gt;\n                &lt;when&gt;\n                        &lt;xpath&gt;/order/priority = 'high'&lt;/xpath&gt;\n                        &lt;wireTap uri=&quot;seda:from&quot;&gt;\n                                &lt;body&gt;&lt;xpath&gt;/order/from&lt;/xpath&gt;&lt;/body&gt;\n                        &lt;/wireTap&gt;\n                        &lt;to uri=&quot;bean:processHighOrder&quot;/&gt;\n                &lt;/when&gt;\n                &lt;otherwise&gt;\n                        &lt;to uri=&quot;bean:processOrder&quot;/&gt;\n                &lt;/otherwise&gt;\n        &lt;/choice&gt;\n&lt;/route&gt;\n</code></pre></td>\n  </tr>\n </tbody>\n</table>","creationDate":1523454468000,"creationDateFormatted":"04/11/2018 01:47 PM","title":"Essential Patterns","revision":4,"modificationDate":null,"id":2772526}}};
        WMODEL_DATA.chapters = null;
        WMODEL_DATA.refcard = {"isOld":false,"rawType":"refcard","author":"Ryan Little","description":"<p pid=\"1\" class=\"author_name\">By Claus Ibsen</p><h2>About Enterprise Integration Patterns</h2><p pid=\"2\">Integration is a hard problem. To help deal with the complexity of integration problems the Enterprise Integration Patterns (EIP) have become the standard way to describe, document and implement complex integration problems. Hohpe &amp; Woolf's book the Enterprise Integration Patterns has become the bible in the integration space - essential reading for any integration professional.</p><p pid=\"3\">Apache Camel is an open source project for implementing the EIP easily in a few lines of Java code or Spring XML configuration. This reference card, the first in a two card series, guides you through the most common Enterprise Integration Patterns and gives you examples of how to implement them either in Java code or using Spring XML. This Refcard is targeted for software developers and enterprise architects, but anyone in the integration space can benefit as well.</p><h2>About Apache Camel</h2><p pid=\"4\">Apache Camel is a powerful open source integration platform based on Enterprise Integration Patterns (EIP) with powerful Bean Integration. Camel lets you implementing EIP routing using Camels intuitive Domain Specific Language (DSL) based on Java (aka fluent builder) or XML. Camel uses URI for endpoint resolution so its very easy to work with any kind of transport such as HTTP, REST, JMS, web service, File, FTP, TCP, Mail, JBI, Bean (POJO) and many others. Camel also provides Data Formats for various popular formats such as: CSV, EDI, FIX, HL7, JAXB, Json, Xstream. Camel is an integration API that can be embedded in any server of choice such as: J2EE Server, ActiveMQ, Tomcat, OSGi, or as standalone. Camels Bean Integration let you define loose coupling allowing you to fully separate your business logic from the integration logic. Camel is based on a modular architecture allowing you to plugin your own component or data format, so they seamlessly blend in with existing modules. Camel provides a test kit for unit and integration testing with strong mock and assertion capabilities.</p><h2>Essential Patterns</h2><p pid=\"5\">This group consists of the most essential patterns that anyone working with integration must know.</p><h3>Pipes and Filters</h3><table cellpadding=\"0\" cellspacing=\"0\"><tbody><tr><td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-1.jpg\"></td><td class=\"light_cream\">How can we perform complex processing on a message while maintaining independence and flexibility?</td></tr><tr><td colspan=\"2\"><img alt=\"Pipes and Filters\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-2.jpg\"></td></tr></tbody></table><table cellpadding=\"0\" cellspacing=\"0\"><tbody><tr><td class=\"light_blue\">Problem</td><td class=\"light_cream\">A single event often triggers a sequence of processing steps</td></tr><tr><td class=\"light_blue\">Solution</td><td class=\"light_cream\">Use Pipes and Filters to divide a larger processing steps (filters) that are connected by channels (pipes)</td></tr><tr><td class=\"light_blue\">Camel</td><td class=\"light_cream\">Camel supports Pipes and Filters using the <strong>pipeline</strong> node.</td></tr><tr><td class=\"light_blue\">Java DSL</td><td class=\"light_cream\"><pre><code lang=\"text/x-java\">\nfrom(\"jms:queue:order:in\").pipeline(\"direct:transformOrder\", \"direct:validateOrder\", \"jms:queue:order:process\");\n</code></pre><p>Where jms represents the JMS component used for consuming JMS messages on the JMS broker. Direct is used for combining endpoints in a synchronous fashion, allow you to divide routes into sub routes and/or reuse common routes.</p><p><strong>Tip:</strong> Pipeline is the default mode of operation when you specify multiple outputs, so it can be omitted and replaced with the more common node:</p><pre><code lang=\"text/x-java\">\nfrom(\"jms:queue:order:in\").to(\"direct:transformOrder\",\n\"direct:validateOrder\", \"jms:queue:order:process\");\n</code></pre><p><strong>TIP:</strong> You can also separate each step as individual <strong>to</strong> nodes:</p><pre><code lang=\"text/x-java\">\nfrom(\"jms:queue:order:in\")\n        .to(\"direct:transformOrder\")\n        .to(\"direct:validateOrder\")\n        .to(\"jms:queue:order:process\");\n</code></pre></td></tr><tr><td class=\"light_blue\">Spring DSL</td><td class=\"light_cream\"><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=\"jms:queue:order:in\"/&gt;\n        &lt;pipeline&gt;\n                &lt;to uri=\"direct:transformOrder\"/&gt;\n                &lt;to uri=\"direct:validateOrder\"/&gt;\n                &lt;to uri=\"jms:queue:order:process\"/&gt;\n        &lt;/pipeline&gt;\n&lt;/route&gt;\n&lt;route&gt;\n        &lt;from uri=\"jms:queue:order:in\"/&gt;\n        &lt;to uri=\"direct:transformOrder\"/&gt;\n        &lt;to uri=\"direct:validateOrder\"/&gt;\n        &lt;to uri=\"jms:queue:order:process\"/&gt;\n&lt;/route&gt;</code></pre><br><br></td></tr></tbody></table><h3>Message Router</h3><table cellpadding=\"0\" cellspacing=\"0\"><tbody><tr><td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" height=\"23\" src=\"images/rc047-010d-enterprise_integration_patterns-3.jpg\" width=\"42\"></td><td class=\"light_cream\">How can you deouple indevidual processing steps so that messages can be passed to different filters depending on a set of conditions?</td></tr><tr><td colspan=\"2\"><img alt=\"Message Router\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-4.jpg\"></td></tr><tr><td class=\"light_blue\">Problem</td><td class=\"light_cream\">Pipes and Filters route each message in the same processing steps. How can we route messages differently?</td></tr><tr><td class=\"light_blue\">Solution</td><td class=\"light_cream\">Filter using predicates to choose the right output destination.</td></tr><tr><td class=\"light_blue\">Camel</td><td class=\"light_cream\">Camel supports Message Router using the <strong>choice</strong> node. For more details see the Content Based router pattern.</td></tr></tbody></table><h3>Content-Based Router</h3><table cellpadding=\"0\" cellspacing=\"0\"><tbody><tr><td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-5.jpg\"></td><td class=\"light_cream\">How do we handle a situation where the implementation of a single logical function (e.g., inventory check) is spread across multiple physical systems?</td></tr><tr><td colspan=\"2\"><img alt=\"Content-Based Router\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-6.jpg\"></td></tr><tr><td class=\"light_blue\">Problem</td><td class=\"light_cream\">How do we ensure a Message is sent to the correct recipient based on information from its content?</td></tr><tr><td class=\"light_blue\">Solution</td><td class=\"light_cream\">Use a Content-Based Router to route each message to the correct recipient based on the message content.</td></tr><tr><td class=\"light_blue\">Camel</td><td class=\"light_cream\">Camel has extensive support for Content-Based Routing. Camel supports content based routing based on <strong>choice, filter,</strong> or any other expression.</td></tr><tr><td class=\"light_blue\">Java DSL</td><td class=\"light_cream\"><h4>Choice</h4><pre><code lang=\"text/x-java\">\nfrom(\"jms:queue:order\")\n.choice()\n.when(header(\"type\").in(\"widget\",\"wiggy\"))\n.to(\"jms:queue:order:widget\")\n.when(header(\"type\").isEqualTo(\"gadget\"))\n.to(\"jms:queue:order:gadget\")\n.otherwise().to(\"jms:queue:order:misc\")\n.end();\n</code></pre><p><strong>TIP:</strong> In the route above end() can be omitted as its the last node and we do not route the message to a new destination after the choice.</p><p><strong>TIP:</strong> You can continue routing after the choice ends.</p></td></tr><tr><td class=\"light_blue\">Spring DSL</td><td class=\"light_cream\"><h4>Choice</h4><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=\"jms:queue:order\"/&gt;\n        &lt;choice&gt;\n                &lt;when&gt;\n                        &lt;simple&gt;${header.type} in 'widget,wiggy'&lt;/simple&gt;\n                        &lt;to uri=\"jms:queue:order:widget\"/&gt;\n                &lt;/when&gt;\n                &lt;when&gt;\n                        &lt;simple&gt;${header.type} == 'gadget'&lt;/simple&gt;\n                        &lt;to uri=\"jms:queue:order:gadget\"/&gt;\n                &lt;/when&gt;\n                &lt;otherwise&gt;\n                        &lt;to uri=\"jms:queue:order:misc\"/&gt;\n                &lt;/otherwise&gt;\n        &lt;/choice&gt;\n&lt;/route&gt;\n</code></pre><p><strong>TIP:</strong> In Spring DSL you cannot invoke code, as opposed to the Java DSL that is 100% Java. To express the predicates for the choices we need to use a language. We will use simple language that uses a simple expression parser that supports a limited set of operators. You can use any of the more powerful languages supported in Camel such as: JavaScript, Groovy, Unified EL and many others.</p><p><strong>TIP:</strong> You can also use a method call to invoke a method on a bean to evaluate the predicate. Lets try that:</p><pre><code lang=\"text/x-java\">\n&lt;when&gt;\n        &lt;method bean=\"myBean\" method=\"isGadget\"/&gt;\n        ...\n&lt;/when&gt;\n\n&lt;bean id=\"myBean\" class=\"com.mycomapany.MyBean\"/&gt;\n\npublic boolean isGadget(@Header(name = \"type\") String type) {\n        return type.equals(\"Gadget\");\n}\n</code></pre><p>Notice how we use Bean Parameter Binding to instruct Camel to invoke this method and pass in the type header as the String parameter. This allows your code to be fully decoupled from any Camel API so its easy to read, write and unit test.</p></td></tr></tbody></table><h3>Message Translator</h3><table cellpadding=\"0\" cellspacing=\"0\"><tbody><tr><td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-7.jpg\"></td><td class=\"light_cream\">How can systems using different data formats communicate with each other using messaging?</td></tr><tr><td colspan=\"2\"><img alt=\"Message Translator\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-8.jpg\"></td></tr><tr><td class=\"light_blue\">Problem</td><td class=\"light_cream\">Each application uses its own data format, so we need to translate the message into the data format the application supports.</td></tr><tr><td class=\"light_blue\">Solution</td><td class=\"light_cream\">Use a special filter, a messae translator, between filters or applications to translate one data format into another.</td></tr><tr><td class=\"light_blue\">Camel</td><td class=\"light_cream\">Camel supports the message translator using the <strong>processor, bean</strong> or <strong>transform</strong> nodes. TIP: Camel routes the message as a chain of <strong>processor</strong> nodes.</td></tr><tr><td class=\"light_blue\">Java DSL</td><td class=\"light_cream\"><h4>Processor</h4><pre><code lang=\"text/x-java\">\npublic class OrderTransformProcessor\n                implements Processor {\n        public void process(Exchange exchange)\n                        throws Exception {\n                // do message translation here\n        }\n}\nfrom(\"direct:transformOrder\")\n        .process(new OrderTransformProcessor());\n</code></pre><h4>Bean</h4><p>Instead of the processor we can use Bean (POJO). An advantage of using a Bean over Processor is the fact that we do not have to implement or use any Camel specific interfaces or types. This allows you to fully decouple your beans from Camel.</p><pre><code lang=\"text/x-java\">\npublic class OrderTransformerBean {\n        public StringtransformOrder(String body) {\n                // do message translation here\n        }\n}\nObject transformer = new OrderTransformerBean();\nfrom(\"direct:transformOrder\").bean(transformer);\n</code></pre><p><strong>TIP:</strong> Camel can create an instance of the bean automatically; you can just refer to the class type.</p><pre><code lang=\"text/x-java\">\nfrom(\"direct:transformOrder\")\n        .bean(OrderTransformerBean.class);\n</code></pre><p><strong>TIP:</strong> Camel will try to figure out which method to invoke on the bean in case there are multiple methods. In case of ambiguity you can specify which methods to invoke by the method parameter:</p><pre><code lang=\"text/x-java\">\nfrom(\"direct:transformOrder\")\n        .bean(OrderTransformerBean.class, \"transformOrder\");\n</code></pre><h4>Transform</h4><p>Transform is a particular processor allowing you to set a response to be returned to the original caller. We use transform to return a constant ACK response to the TCP listener after we have copied the message to the JMS queue. Notice we use a constant to build an \"ACK\" string as response.</p><pre><code lang=\"text/x-java\">\nfrom(\"mina:tcp://localhost:8888?textline=true\")\n        .to(\"jms:queue:order:in\")\n        .transform(constant(\"ACK\"));\n</code></pre></td></tr><tr><td class=\"light_blue\">Spring DSL</td><td class=\"light_cream\"><h4>Processor</h4><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=\"direct:transformOrder\"/&gt;\n        &lt;process ref=\"transformer\"/&gt;\n&lt;/route&gt;\n\n&lt;bean id=\"transformer\" class=\"com.mycompany.\nOrderTransformProcessor\"/&gt;\n</code></pre><p>In Spring DSL Camel will look up the processor or POJO/Bean in the registry based on the id of the bean.</p><h4>Bean</h4><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n&lt;from uri=\"direct:transformOrder\"/&gt;\n&lt;bean ref=\"transformer\"/&gt;\n&lt;/route&gt;\n&lt;bean id=\"tramsformer\"\nclass=\"com.mycompany.OrderTransformBean\"/&gt;\n</code></pre><h4>Transform</h4><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n&lt;from uri=\"mina:tcp://localhost:8888?textline=true\"/&gt;\n&lt;to uri=\"jms:queue:order:in\"/&gt;\n&lt;transform&gt;\n&lt;constant&gt;ACK&lt;/constant&gt;\n&lt;/transform&gt;\n&lt;/route&gt;\n</code></pre></td></tr><tr><td class=\"light_blue\">Annotation DSL</td><td class=\"light_cream\"><p>You can also use the <strong>@Consume</strong> annotation for transformations. For example in the method below we consume from a JMS queue and do the transformation in regular Java code. Notice that the input and output parameters of the method is String. Camel will automatically coerce the payload to the expected type defined by the method. Since this is a JMS example the response will be sent back to the JMS reply-to destination.</p><pre><code lang=\"text/x-java\">\n@Consume(uri=\"jms:queue:order:transform\")\npublic String transformOrder(String body) {\n        // do message translation\n}\n</code></pre><p><strong>TIP:</strong> You can use Bean Parameter Binding to help Camel coerce the Message into the method parameters. For instance you can use <strong>@Body, @Headers</strong> parameter annotations to bind parameters to the body and headers.</p></td></tr></tbody></table><h3>Message Filter</h3><table cellpadding=\"0\" cellspacing=\"0\"><tbody><tr><td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-9.jpg\"></td><td class=\"light_cream\">How can a component avoid receiving unwanted messages?</td></tr><tr><td colspan=\"2\"><img alt=\"Message Filter\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-10.jpg\"></td></tr><tr><td class=\"light_blue\">Problem</td><td class=\"light_cream\">How do you discard unwanted messages?</td></tr><tr><td class=\"light_blue\">Solution</td><td class=\"light_cream\">Use a special kind of Message Router, a Message Filter, to eliminate undesired messages from a channel based on a set of criteria.</td></tr><tr><td class=\"light_blue\">Camel</td><td class=\"light_cream\">Camel has support for Message Filter using the filter node. The filter evaluates a predicate whether its true or false; only allowing the true condition to pass the filter, where as the false condition will silently be ignored.</td></tr><tr><td class=\"light_blue\">Java DSL</td><td class=\"light_cream\">We want to discard any test messages so we only route non-test messages to the order queue.                <pre><code lang=\"text/x-java\">\nfrom(\"jms:queue:inbox\")\n        .filter(header(\"test\").isNotEqualTo(\"true\"))\n        .to(\"jms:queue:order\");</code></pre><br><br></td></tr><tr><td class=\"light_blue\">Spring DSL</td><td class=\"light_cream\">For the Spring DSL we use XPath to evaluate the predicate. The $test is a special shorthand in Camel to refer to the header with the given name. So even if the payload is not XML based we can still use XPath to evaluate predicates.                <pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=\"jms:queue:inbox\"/&gt;\n        &lt;filter&gt;\n                &lt;xpath&gt;$test = 'false'&lt;/xpath&gt;\n                &lt;to uri=\"jms:queue:inbox\"/&gt;\n        &lt;/filter&gt;\n&lt;/route&gt;</code></pre><br><br></td></tr></tbody></table><h3>Dynamic Router</h3><table cellpadding=\"0\" cellspacing=\"0\"><tbody><tr><td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-11.jpg\"></td><td class=\"light_cream\"></td></tr><tr><td colspan=\"2\"><img alt=\"Dynamic Router\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-12.jpg\"></td></tr><tr><td class=\"light_blue\">Problem</td><td class=\"light_cream\">How can we route messages based on a dynamic list of destinations?</td></tr><tr><td class=\"light_blue\">Solution</td><td class=\"light_cream\">Use a Dynamic Router, a router that can self-configure based on special configuration messages from participating destinations.</td></tr><tr><td class=\"light_blue\">Camel</td><td class=\"light_cream\">Camel has support for Dynamic Router using the Dynamic <strong>Recipient List</strong> combined with a data store holding the list of destinations.</td></tr><tr><td class=\"light_blue\">Java DSL</td><td class=\"light_cream\">We use a Processor as the dynamic router to determine the destinations. We could also have used a Bean instead.                <pre><code lang=\"text/x-java\">\nfrom(\"jms:queue:order\")\n        .processRef(myDynamicRouter)\n        .recipientList(\"destinations\");\n\npublic class MyDynamicRouter implements Processor {\n        public void process(Exchange exchange) {\n                // query a data store to find the best match of the\n                // endpoint and return the destination(s) in the\n                // header exchange.getIn()\n                // .setHeader(\"destinations\", list);\n        }\n}</code></pre><br><br></td></tr><tr><td class=\"light_blue\">Spring DSL</td><td class=\"light_cream\"><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=\"jms:queue:order\"/&gt;\n        &lt;process ref=\"myDynamicRouter\"/&gt;\n        &lt;recipientList&gt;\n                &lt;header&gt;destinations&lt;/destinations&gt;\n        &lt;/recipientList&gt;\n&lt;/route&gt;</code></pre><br><br></td></tr><tr><td class=\"light_blue\">Annotation DSL</td><td class=\"light_cream\"><pre><code lang=\"text/x-java\">\npublic class MyDynamicRouter {\n        @Consume(uri = \"jms:queue:order\")\n        @RecipientList\n        public List&lt;String&gt; route(@XPath(\"/customer/id\")\nString customerId, @Header(\"location\") String location,\nDocument body) {\n                // query data store, find best match for the\n                //endpoint and return destination (s)\n        }\n}\n</code></pre><p><strong>TIP:</strong> Notice how we used Bean Parameter Binding to bind the parameters to the route method based on an <strong>@XPath</strong> expression on the XML payload of the JMS message. This allows us to extract the customer id as a string parameter. <strong>@Header</strong> wil bind a JMS property with the key location. <strong>Document</strong> is the XML payload of the JMS message.</p><p><strong>TIP:</strong> Camel uses its strong type converter feature to convert the payload to the type of the method parameter. We could use String and Camel will convert the body to a String instead. You can register your own type converters as well using the <strong>@Converter</strong> annotation at the class and method level.</p></td></tr></tbody></table><h3>Recipient List</h3><table cellpadding=\"0\" cellspacing=\"0\"><tbody><tr><td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-13.jpg\"></td><td class=\"light_cream\">How do we route a message to a list of statically or dynamically specified recipients?</td></tr><tr><td colspan=\"2\"><img alt=\"Recipient List\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-14.jpg\"></td></tr><tr><td class=\"light_blue\">Problem</td><td class=\"light_cream\">How can we route messages based on a static or dynamic list of destinations?</td></tr><tr><td class=\"light_blue\">Solution</td><td class=\"light_cream\">Define a channel for each recipient. Then use a Recipient List to inspect an incoming message, determine the list of desired recipients and forward the message to all channels associated with the recipients in the list.</td></tr><tr><td class=\"light_blue\">Camel</td><td class=\"light_cream\">Camel supports the static Recipient List using the <strong>multicast</strong> node, and the dynamic Recipient List using the <strong>recipientList</strong> node.</td></tr><tr><td class=\"light_blue\">Java DSL</td><td class=\"light_cream\"><h4>Static</h4><p>In this route we route to a static list of two recipients, that will receive a copy of the same message simultaneously.</p><pre><code lang=\"text/x-java\">\nfrom(\"jms:queue:inbox\")\n        .multicast().to(\"file://backup\", \"seda:inbox\");\n</code></pre><h4>Dynamic</h4><p>In this route we route to a dynamic list of recipients defined in the message header [mails] containing a list of recipients as endpoint URLs. The bean processMails is used to add the header[mails] to the message.</p><pre><code lang=\"text/x-java\">\nfrom(\"seda:confirmMails\").beanRef(processMails)\n        .recipientList(\"destinations\");\n</code></pre><p>And in the process mails bean we use <strong>@Headers</strong> Bean Parameter Binding to provide a <strong>java.util.Map</strong> to store the recipients.</p><pre><code lang=\"text/x-java\">\npublic void confirm(@Headers Map headers, @Body String body} {\n        String[] recipients = ...\n        headers.put(\"\"destinations\", recipients);\n}\n</code></pre></td></tr><tr><td class=\"light_blue\">Spring DSL</td><td class=\"light_cream\"><h4>Static</h4><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=\"jms:queue:inbox\" /&gt;\n        &lt;multicast&gt;\n                &lt;to uri=\"file://backup\"/&gt;\n                &lt;to uri=\"seda:inbox\"/&gt;\n        &lt;/multicast&gt;\n&lt;/route&gt;\n</code></pre><h4>Dynamic</h4><p>In this example we invoke a method call on a Bean to provide the dynamic list of recipients.</p><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=\"jms:queue:inbox\" /&gt;\n        &lt;recipientList&gt;\n                &lt;method bean=\"myDynamicRouter\" method=\"route\"/&gt;\n        &lt;/recipientList&gt;\n&lt;/route&gt;\n\n&lt;bean id=\"myDynamicRouter\"\n        class=\"com.mycompany.MyDynamicRouter\"/&gt;\n\npublic class myDynamicRouter {\n        public String[] route(String body) {\n                return new String[] { \"file://backup\", .... }\n        }\n}\n</code></pre></td></tr><tr><td class=\"light_blue\">Annotation DSL</td><td class=\"light_cream\"><p>In the CustomerService class we annoate the <strong>whereTo</strong> method with <strong>@RecipientList</strong>, and return a single destination based on the customer id. Notice the flexibility of Camel as it can adapt accordingly to how you define what your methods are returning: a single element, a list, an iterator, etc.</p><pre><code lang=\"text/x-java\">\npublic class CustomerService {\n        @RecipientList\n        public String whereTo(@Header(\"customerId\") id) {\n                return \"jms:queue:customer:\" + id;\n        }\n}\n</code></pre><p>And then we can route to the bean and it will act as a dynamic recipient list.</p><pre><code lang=\"text/x-java\">\nfrom(\"jms:queue:inbox\")\n        .bean(CustomerService.class, \"whereTo\");\n</code></pre></td></tr></tbody></table><h3>Splitter</h3><table cellpadding=\"0\" cellspacing=\"0\"><tbody><tr><td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-15.jpg\"></td><td class=\"light_cream\">How can we process a message if it contains multiple elements, each of which may have to be processed in a different way?</td></tr><tr><td colspan=\"2\"><img alt=\"Splitter\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-16.jpg\"></td></tr><tr><td class=\"light_blue\">Problem</td><td class=\"light_cream\">How can we split a single message into pieces to be routed individually?</td></tr><tr><td class=\"light_blue\">Solution</td><td class=\"light_cream\">Use a Splitter to break out the composite message into a series of individual messages, each containing data related to one item.</td></tr><tr><td class=\"light_blue\">Camel</td><td class=\"light_cream\">Camel has support for Splitter using the <strong>split</strong> node.</td></tr><tr><td class=\"light_blue\">Java DSL</td><td class=\"light_cream\"><p>In this route we consume files from the inbox folder. Each file is then split into a new message. We use a tokenizer to split the file content line by line based on line breaks.</p><pre><code lang=\"text/x-java\">\nfrom(\"file://inbox\")\n        .split(body().tokenize(\"\\n\"))\n        .to(\"seda:orderLines\");\n</code></pre><p><strong>TIP:</strong> Camel also supports splitting streams using the streaming node. We can split the stream by using a comma:</p><pre><code lang=\"text/x-java\">\n.split(body().tokenize(\",\")).streaming().to(\"seda:parts\");\n</code></pre><p><strong>TIP:</strong> In the routes above each individual split message will be executed in sequence. Camel also supports parallel execution using the parallelProcessing node.</p><pre><code lang=\"text/x-java\">\n.split(body().tokenize(\",\")).streaming()\n        .parallelProcessing().to(\"seda:parts\");\n</code></pre></td></tr><tr><td class=\"light_blue\">Spring DSL</td><td class=\"light_cream\">In this route we use XPath to split XML payloads received on the JMS order queue.                <pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=\"jms:queue:order\"/&gt;\n        &lt;split&gt;\n                &lt;xpath&gt;/invoice/lineItems&lt;/xpath&gt;\n                &lt;to uri=\"seda:processOrderLine\"/&gt;\n        &lt;/split&gt;\n&lt;/route&gt;\n</code></pre><p>And in this route we split the messages using a regular expression</p><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=\"jms:queue:order\"/&gt;\n        &lt;split&gt;\n                &lt;tokenizer token=\"([A-Z|0-9]*);\" regex=\"true\"/&gt;\n                &lt;to uri=\"seda:processOrderLine\"/&gt;\n        &lt;/split&gt;\n&lt;/route&gt;\n</code></pre><p><strong>TIP:</strong> Split evaluates an org.apahce.camel.Expression to provide something that is iterable to produce each individual new message. This allows you to provide any kind of expression such as a Bean invoked as a method call.</p><pre><code lang=\"text/x-java\">\n&lt;split&gt;\n        &lt;method bean=\"mySplitter\" method=\"splitMe\"/&gt;\n        &lt;to uri=\"seda:processOrderLine\"/&gt;\n&lt;/split&gt;\n\n&lt;bean id=\"mySplitter\" class=\"com.mycompany.MySplitter\"/&gt;\n\npublic List splitMe(String body) {\n        // split using java code and return a List\n        List parts = ...\n        return parts;\n}\n</code></pre></td></tr></tbody></table><h3>Aggregator</h3><table cellpadding=\"0\" cellspacing=\"0\"><tbody><tr><td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-17.jpg\"></td><td class=\"light_cream\">How do we combine the results of individual, but related messages so that they can be processed as a whole?</td></tr><tr><td colspan=\"2\"><img alt=\"Message Router\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-18.jpg\"></td></tr><tr><td class=\"light_blue\">Problem</td><td class=\"light_cream\">How do we combine multiple messages into a single combined message?</td></tr><tr><td class=\"light_blue\">Solution</td><td class=\"light_cream\">Use a stateful filter, an Aggregator, to collect and store individual messages until it receives a complete set of related messages to be published.</td></tr><tr><td class=\"light_blue\">Camel</td><td class=\"light_cream\">Camel has support for the Aggregator using the aggregate node. Camel uses a stateful batch processor that is capable of aggregating related messaged into a single combined message. A correlation expression is used to determine which messages should be aggregated. An aggregation strategy is used to combine aggregated messages into the result message. Camel’s aggregator also supports a completion predicate allowing you to signal when the aggregation is complete. Camel also supports other completion signals based on timeout and/or a number of messages already aggregated.</td></tr><tr><td class=\"light_blue\">Java DSL</td><td class=\"light_cream\"><h4>Stock quote example</h4><p>We want to update a website every five minutes with the latest stock quotes. The quotes are received on a JMS topic. As we can receive multiple quotes for the same stock within this time period we only want to keep the last one as its the most up to date. We can do this with the aggregator:</p><pre><code lang=\"text/x-java\">\nfrom(\"jms:topic:stock:quote\")\n        .aggregate().xpath(\"/quote/@symbol\")\n        .batchTimeout(5 * 60 * 1000).to(\"seda:quotes\");\n</code></pre><p>As the correlation expression we use XPath to fetch the stock symbol from the message body. As the aggregation strategy we use the default provided by Camel that picks the latest message, and thus also the most up to date. The time period is set as a timeout value in milliseconds.</p><h4>Loan broker example</h4><p>We aggregate responses from various banks for their quote for a given loan request. We want to pick the bank with the best quote (the cheapest loan), therefore we need to base our aggregation strategy to pick the best quote.</p><pre><code lang=\"text/x-java\">\nfrom(\"jms:topic:loan:quote\")\n        .aggregate().header(\"loanId\")\n        .aggregationStrategy(bestQuote)\n        .completionPredicate(header(Exchange.AGGREGATED_SIZE)\n        .isGreaterThan(2))\n        .to(\"seda:bestLoanQuote\");\n</code></pre><p>We use a completion predicate that signals when we have received more than 2 quotes for a given loan, giving us at least 3 quotes to pick among. The following shows the code snippet for the aggregation strategy we must implement to pick the best quote:</p><pre><code lang=\"text/x-java\">\npublic class BestQuoteStrategy implements AggregationStrategy {\n        public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {\n                double oldQuote = oldExchange.getIn().getBody(Double.class);\n                double newQuote = newExchange.getIn().getBody(Double.class);\n                // return the \"winner\" that has the lowest quote\n                return newQuote &lt; oldQuote ? newExchange : oldExchange;\n        }\n}\n</code></pre></td></tr><tr><td class=\"light_blue\">Spring DSL</td><td class=\"light_cream\"><h4>Loan Broker Example</h4><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=\"jms:topic:loan:qoute\"/&gt;\n        &lt;aggregate strategyRef=\"bestQuote\"&gt;\n                &lt;correlationExpression&gt;\n                        &lt;header&gt;loanId&lt;/header&gt;\n                &lt;/correlationExpression&gt;\n                &lt;completionPredicate&gt;\n                        &lt;simple&gt;${header.CamelAggregatedSize} &gt; 2&lt;/simple&gt;\n                &lt;/completionPredicate&gt;\n        &lt;/aggregate&gt;\n        &lt;to uri=\"seda:bestLoanQuote\"/&gt;\n&lt;/route&gt;\n\n&lt;bean id=\"bestQuote\"\n        class=\"com.mycompany.BestQuoteStrategy\"/&gt;\n</code></pre><p><strong>TIP:</strong> We use the simple language to declare the completion predicate. Simple is a basic language that supports a primitive set of operators. ${header. CamelAggregatedSize} will fetch a header holding the number of messages aggregated.</p><p><strong>TIP:</strong> If the completed predicate is more complex we can use a method call to invoke a Bean so we can do the evaluation in pure Java code:</p><pre><code lang=\"text/x-java\">\n&lt;completionPredicate&gt;\n        &lt;method bean=\"quoteService\" method=\"isComplete\"/&gt;\n&lt;/compledtionPrediacate&gt;\npublic boolean isComplete(@Header(Exchange.AGGREGATED_SIZE)\n        int count, String body) {\n        return body.equals(\"STOP\");\n}\n</code></pre><p>Notice how we can use Bean Binding Parameter to get hold of the aggregation size as a parameter, instead of looking it up in the message.</p></td></tr></tbody></table><h3>Resequencer</h3><table cellpadding=\"0\" cellspacing=\"0\"><tbody><tr><td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-19.jpg\"></td><td class=\"light_cream\">How can we get a stream of related but out-of-sequence messages back into the correct order?</td></tr><tr><td colspan=\"2\"><img alt=\"Resequencer\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-20.jpg\"></td></tr><tr><td class=\"light_blue\">Problem</td><td class=\"light_cream\">How do we ensure ordering of messages?</td></tr><tr><td class=\"light_blue\">Solution</td><td class=\"light_cream\">Use a stateful filter, a Resequencer, to collect and reorder messages so that they can be published in a specified order.</td></tr><tr><td class=\"light_blue\">Camel</td><td class=\"light_cream\"><p>Camel has support for the Resequencer using the resequence node. Camel uses a stateful batch processor that is capable of reordering related messages. Camel supports two resequencing algorithms:</p><p><strong>-batch</strong> = collects messages into a batch, sorts the messages and publish the messages</p><p><strong>-stream</strong> = re-orders, continuously, message streams based on detection of gaps between messages.</p><p>Batch is similar to the aggregator but with sorting. Stream is the traditional Resequencer pattern with gap detection. Stream requires usage of number (longs) as sequencer numbers, enforced by the gap detection, as it must be able to compute if gaps exist. A gap is detected if a number in a series is missing, e.g. 3, 4, 6 with number 5 missing. Camel will back off the messages until number 5 arrives.</p></td></tr><tr><td class=\"light_blue\">Java DSL</td><td class=\"light_cream\"><h4>Batch:</h4><p>We want to process received stock quotes, once a minute, ordered by their stock symbol. We use XPath as the expression to select the stock symbol, as the value used for sorting.</p><pre><code lang=\"text/x-java\">\nfrom(\"jms:topic:stock:quote\")\n        .resequence().xpath(\"/quote/@symbol\")\n        .timeout(60 * 1000)\n        .to(\"seda:quotes\");\n</code></pre><p>Camel will default the order to ascending. You can provide your own comparison for sorting if needed.</p><h4>Stream:</h4><p>Suppose we continuously poll a file directory for inventory updates, and its important they are processed in sequence by their inventory id. To do this we enable streaming and use one hour as the timeout.</p><pre><code lang=\"text/x-java\">\nfrom(\"file://inventory\")\n        .resequence().xpath(\"/inventory/@id\")\n        .stream().timeout(60 * 60 * 1000)\n        .to(\"seda:inventoryUpdates\");\n</code></pre></td></tr><tr><td class=\"light_blue\">Spring DSL</td><td class=\"light_cream\"><h4>Batch:</h4><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=\"jms:topic:stock:quote\"/&gt;\n        &lt;resequence&gt;\n                &lt;xpath&gt;/quote/@symbol&lt;/xpath&gt;\n                &lt;batch-config batchTimeout=\"60000\"/&gt;\n        &lt;/resequence&gt;\n        &lt;to uri=\"seda:quotes\"/&gt;\n&lt;/route&gt;\n</code></pre><h4>Stream:</h4><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=\"file://inventory\"/&gt;\n        &lt;resequence&gt;\n                &lt;xpath&gt;/inventory/@id&lt;xpath&gt;\n                &lt;stream-config timeout=\"3600000\"/&gt;\n        &lt;/resequence&gt;\n        &lt;to uri=\"seda:quotes\"/&gt;\n&lt;/route&gt;\n</code></pre><p>Notice that you can enable streaming by specifying &lt;stream-config&gt; instead of &lt;batch-config&gt;.</p></td></tr></tbody></table><h3>Dead Letter Channel</h3><table cellpadding=\"0\" cellspacing=\"0\"><tbody><tr><td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-21.jpg\"></td><td class=\"light_cream\">What will the messaging system do with a message it cannot deliver?</td></tr><tr><td colspan=\"2\"><img alt=\"Message Router\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-22.jpg\"></td></tr><tr><td class=\"light_blue\">Problem</td><td class=\"light_cream\">The messaging system cannot deliver a message</td></tr><tr><td class=\"light_blue\">Solution</td><td class=\"light_cream\">When a message cannot be delivered it should be moved to a Dead Letter Channel</td></tr><tr><td class=\"light_blue\">Camel</td><td class=\"light_cream\"><p>Camel has extensive support for Dead Letter Channel by its error handler and exception clauses. Error handler supports redelivery policies to decide how many times to try redelivering a message, before moving it to a Dead Letter Channel.</p><p>The default Dead Letter Channel will log the message at ERROR level and perform up to 6 redeliveries using a one second delay before each retry.</p><p>Error handler has two scopes: global and per route</p><p><strong>TIP:</strong> See Exception Clause in the Camel documentation for selective interception of thrown exception. This allows you to route certain exceptions differently or even reset the failure by marking it as handled.</p><p><strong>TIP:</strong> DeadLetterChannel supports processing the message before it gets redelivered using onRedelivery. This allows you to alter the message beforehand (i.e. to set any custom headers).</p></td></tr><tr><td class=\"light_blue\">Java DSL</td><td class=\"light_cream\"><h4>Global scope</h4><pre><code lang=\"text/x-java\">\nerrorHandler(deadLetterChannel(\"jms:queue:error\")\n        .maximumRedeliveries(3));\n\nfrom(...)\n\nRoute scope\nfrom(\"jms:queue:event\")\n        .errorHandler(deadLetterChannel()\n        .maximumRedeliveries(5))\n        .multicast().to(\"log:event\", \"seda:handleEvent\");\n</code></pre><p>In this route we override the global scope to use up to five redeliveries, where as the global only has three. You can of course also set a different error queue destination:</p><pre><code lang=\"text/x-java\">\ndeadLetterChannel(\"log:badEvent\").maximumRedeliveries(5)\n</code></pre></td></tr><tr><td class=\"light_blue\">Spring DSL</td><td class=\"light_cream\"><p>The error handler is configured very differently in the Java DSL vs. the Spring DSL. The Spring DSL relies more on standard Spring bean configuration whereas the Java DSL uses fluent builders.</p><h4>Global scope</h4><p>The Global scope error handler is configured using the errorHandlerRef attribute on the camelContext tag.</p><pre><code lang=\"text/x-java\">\n&lt;camelContext errorHandlerRef=\"myDeadLetterChannel\"&gt;\n...\n&lt;/camelContext&gt;\n</code></pre><h4>Route scope</h4><p>Route scoped is configured using the errorHandlerRef attribute on the route tag.</p><pre><code lang=\"text/x-java\">\n&lt;route errorHandlerRef=\"myDeadLetterChannel\"&gt;\n...\n&lt;/route&gt;\n</code></pre><p>For both the error handler itself is configured using a regular Spring bean</p><pre><code lang=\"text/x-java\">\n&lt;bean id=\"myDeadLetterChannel\" class=\"org.apache.camel.\nbuilder.DeadLetterChannelBuilder\"&gt;\n        &lt;property name=\"deadLetterUri\" value=\"jms:queue:error\"/&gt;\n        &lt;property name=\"redeliveryPolicy\"\n                ref=\"myRedeliveryPolicy\"/&gt;\n&lt;/bean&gt;\n\n&lt;bean id=\"myRedeliverPolicy\"\n                class=\"org.apache.camel.processor.RedeliverPolicy\"&gt;\n        &lt;property name=\"maximumRedeliveries\" value=\"5\"/&gt;\n        &lt;property name=\"delay\" value=\"5000\"/&gt;\n&lt;/bean&gt;\n</code></pre></td></tr></tbody></table><h3>Wire Tap</h3><table cellpadding=\"0\" cellspacing=\"0\"><tbody><tr><td><img alt=\"Diagram\" class=\"fr-dii fr-fil\" height=\"20\" src=\"images/rc047-010d-enterprise_integration_patterns-23.jpg\" width=\"34\"></td><td class=\"light_cream\">How do you inspect messages that travel on a point-to-point channel?</td></tr><tr><td colspan=\"2\"><img alt=\"Wire Tap\" class=\"fr-dii fr-fil\" src=\"images/rc047-010d-enterprise_integration_patterns-24.jpg\"></td></tr><tr><td class=\"light_blue\">Problem</td><td class=\"light_cream\">How do you tap messages while they are routed?</td></tr><tr><td class=\"light_blue\">Solution</td><td class=\"light_cream\">Insert a Wire Tap into the channel, that publishes each incoming message to the main channel as well as to a secondary channel.</td></tr><tr><td class=\"light_blue\">Camel</td><td class=\"light_cream\">Camel has support for Wire Tap using the wireTap node, that supports two modes: traditional and new message. The traditional mode sends a copy of the original message, as opposed to sending a new message. All messages are sent as Event Message and runs in parallel with the original message.</td></tr><tr><td class=\"light_blue\">Java DSL</td><td class=\"light_cream\"><h4>Traditional</h4><p>The route uses the traditional mode to send a copy of the original message to the seda tapped queue, while the original message is routed to its destination, the process order bean.</p><pre><code lang=\"text/x-java\">\nfrom(\"jms:queue:order\")\n        .wireTap(\"seda:tappedOrder\")\n        .to(\"bean:processOrder\");\n</code></pre><h4>New message</h4><p>In this route we tap the high priority orders and send a new message containing a body with the from part of the order. Tip: As Camel uses an Expression for evaluation you can use other functions than xpath, for instance to send a fixed String you can use constant.</p><pre><code lang=\"text/x-java\">\nfrom(\"jms:queue:order\")\n        .choice()\n                .when(\"/order/priority = ‘high’\")\n                        .wireTap(\"seda:from\", xpath(\"/order/from\"))\n                        .to(\"bean:processHighOrder\");\n                .otherwise()\n                        .to(\"bean:processOrder\");\n</code></pre></td></tr><tr><td class=\"light_blue\">Spring DSL</td><td class=\"light_cream\"><h4>Traditional</h4><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;from uri=\"jms:queue:order\"/&gt;\n        &lt;wireTap uri=\"seda:tappedOrder\"/&gt;\n        &lt;to uri=\"bean:processOrder\"/&gt;\n&lt;/route&gt;\n</code></pre><h4>New Message</h4><pre><code lang=\"text/x-java\">\n&lt;route&gt;\n        &lt;choice&gt;\n                &lt;when&gt;\n                        &lt;xpath&gt;/order/priority = 'high'&lt;/xpath&gt;\n                        &lt;wireTap uri=\"seda:from\"&gt;\n                                &lt;body&gt;&lt;xpath&gt;/order/from&lt;/xpath&gt;&lt;/body&gt;\n                        &lt;/wireTap&gt;\n                        &lt;to uri=\"bean:processHighOrder\"/&gt;\n                &lt;/when&gt;\n                &lt;otherwise&gt;\n                        &lt;to uri=\"bean:processOrder\"/&gt;\n                &lt;/otherwise&gt;\n        &lt;/choice&gt;\n&lt;/route&gt;\n</code></pre></td></tr></tbody></table><h2>Conclusion</h2><p pid=\"6\">The twelve patterns in this Refcard cover the most used patterns in the integration space, together with two of the most complex such as the Aggregator and the Dead Letter Channel. In the second part of this series we will take a further look at common patterns and transations.</p><h3>Get More Information</h3><table cellpadding=\"0\" cellspacing=\"0\"><tbody><tr><td class=\"light_blue\">Camel Website <a href=\"http://camel.apache.org\">http://camel.apache.org</a></td><td class=\"light_cream\">The home of the Apache Camel project. Find downloads, tutorials, examples, getting started guides, issue tracker, roadmap, mailing lists, irc chat rooms, and how to get help.</td></tr><tr><td class=\"light_blue\">FuseSource Website <a href=\"http://fusesource.com\">http://fusesource.com</a></td><td class=\"light_cream\">The home of the FuseSource company, the professional company behind Apache Camel with enterprise offerings, support, consulting and training.</td></tr><tr><td class=\"light_blue\">About Author <a href=\"http://davsclaus.blogspot.com\">http://davsclaus.blogspot.com</a></td><td class=\"light_cream\">The personal blog of the author of this reference card.</td></tr></tbody></table>","section":"Integration","title":"The Top Twelve Integration Patterns for Apache Camel","authorId":360761,"creationDate":1238363662000,"url":"/refcardz/enterprise-integration","tags":["apache","integration"],"cover":"//dz2cdn3.dzone.com/storage/rc-covers/4378-dzone_refcard_47.png","publishYear":"2018","pdf":"/asset/download/232","topicNames":["apache","integration"],"subtitle":"Implement in Java or Spring XML","authorUrl":"/users/360761/RyanLittle.html","publishMonth":"04","id":520156,"nComments":0,"portal":{"id":7,"code":"integration","title":"Integration","shortTitle":"enterprise-integration-training-tools-news","blurb":"Enterprise Integration news, design patterns and training resources from DZone, the trusted source for advanced software design and devops best practices."},"views":175828,"authors":[{"name":"davsclaus","reputation":590,"id":354055}]};
        WMODEL_DATA.daysOldTitle = "Heads up...this #type is old!";
        WMODEL_DATA.OPTIONS = {};
        TH.installWidgetController('assets.content.chapters', 'assetsContentChapters5', WMODEL_DATA, typeof controller == 'function' ? controller : null, null, ' oUhbcgvMlhqMSsfboUhM', null);
        })();
        (function() {
            
            var WMODEL_DATA = {};
            WMODEL_DATA.authenticated = false;
        WMODEL_DATA.OPTIONS = {};
        TH.installWidgetController('footer.footerV2', 'footerFooterV28', WMODEL_DATA, typeof controller == 'function' ? controller : null, null, ' oUhbdrfPmhwBdrfXM', null);
        })();
        (function() {
            function controller($scope,  shareThis, TH$Dialog, TH$Service, $location) {
    $scope.getEditUrl = function(id, type) {
        if (!type || type == 'article') {
            return '/content/' + id + '/edit.html';
        } else {
            return '/dzone/staff/' + type + (type == 'refcard' ? 'z' : 's') + '/' + id + '/edit.html';
        }
    };

    $scope.share = function(socialNet, url, title){
        shareThis.shareThis(socialNet, url, title);
    };

    $scope.canDelete = function(article) {
        return article.canDelete;
    };

    $scope.canPublish = function(article) {
        return article.canPublish;
    };

    $scope.canEdit = function(article) {
        return article.canEdit;
    };

    $scope.toggleComments = function(article) {
        if(!article.isLocked) {
            TH$Service.action('articles.lockNode', {type: 'node', id: article.id}).then(function(result) {
                if(result){
                    article.isLocked = true;
                    TH$Dialog.success('You have disabled all comments for this Article');
                }else{
                    TH$Dialog.error('error','Your requested was denied')
                }
            });
        }else {
            TH$Service.action('articles.unlockNode', {type: 'node', id: article.id}).then(function(result) {
                if(result){
                    article.isLocked = false;
                    TH$Dialog.success('You have enabled all comments for this Article');
                }else{
                    TH$Dialog.error('error','Your requested was denied')
                }
            });
        }
    };

    $scope.toggleLimitComments = function (article) {
        if (!article.isLimited) {
            TH$Service.action('articles.limitNode', {type: 'node', id: article.id}).then(function (result) {
                if (result) {
                    article.isLimited = true;
                    TH$Dialog.success('You have limited comments for this Article. Now all comments will go through moderation.');
                } else {
                    TH$Dialog.error('error', 'Your requested was denied')
                }
            });
        } else {
            TH$Service.action('articles.unlimitNode', {type: 'node', id: article.id}).then(function (result) {
                if (result) {
                    article.isLimited = false;
                    TH$Dialog.success('You removed the limits for comments on this Article');
                } else {
                    TH$Dialog.error('error', 'Your requested was denied')
                }
            });
        }
    };

    $scope.shareTwitter = function($event, title, url){

        $event.preventDefault();
        $event.stopPropagation();
        var twitter = 'https://twitter.com/intent/tweet';
        var link = $location.protocol() + '://' + location.host + url;
        var ref = location.host;
        var params = '?text=' + encodeURIComponent(title) + '&url=' + link + '&ref=dzone.com&via=DZoneInc';
        var win = window.open(twitter + params, '_blank');
        win.focus();
    };

    $scope.edit = function(link) {
        TH$Dialog.open({
            loadWidget: 'links.postPreview',
            widgetArgs: {
                edit: link.id
            },
            size: 'xbig'
        }).then(function (result) {
            $scope.link.title = result.title;
            $scope.link.linkDescription = result.content;
            $scope.link.thumb = result.thumb;
            $scope.link.tags = result.topics;
        });
    };

    $scope.deleteLink = function(article) {
        var title = article.title;
        var type = 'link';
        if(article.header){
            title = (article.header.type == 'article') ? article.header.title : article.title;
            type = (article.header.type == 'article') ? 'article' : 'link';
        }
        TH$Dialog.confirm('Do you want to delete "' + title + '"?').then(function() {
            return TH$Service.action('delete', {type: type, id: article.id});
        }).then(function() {
            article.deleted = true;
        });
    };
}


            var WMODEL_DATA = {};
            WMODEL_DATA.OPTIONS = {};
        TH.installWidgetController('content.commentsSlider', 'contentCommentsSlider7', WMODEL_DATA, typeof controller == 'function' ? controller : null, null, ' oUhbaqbcaibvnWffWVcC', null);
        })();
        (function() {
            
            var WMODEL_DATA = {};
            WMODEL_DATA.name = "commentsSlider";
        WMODEL_DATA.slot = null;
        WMODEL_DATA.OPTIONS = {"name":"commentsSlider"};
        TH.installWidgetController('components.slider', 'componentsSlider6', WMODEL_DATA, typeof controller == 'function' ? controller : null, null, ' oUhballbvbdSaoUhM', null);
        })();
        </script>
    <script type="text/javascript">

        TH.installWidgetDirective('users.profile.mini', 'usersProfileMini', {"service":{"user":"="},"extra":null}, 'widget.html', '/widgets/users/profile/mini/widget.js', [{name: 'DEFAULT', data: true}], ' oUhbwfbqddOeffWVcC', null, ['widget.less']);
        
        TH.installWidgetDirective('header.sections', 'headerSections', {"service":null,"extra":null}, 'widget.html', '/widgets/header/sections/widget.js', null, ' oUhbWOfbRllbgfgpM', null, ['sections.less']);
        
        TH.installWidgetDirective('loading', 'loading', {"service":null,"extra":null}, 'widget.html', '/widgets/loading/widget.js', null, ' oUhbjOfQoUhM', null, ['widget.less']);
        
        TH.installWidgetDirective('refcardz.mini', 'refcardzMini', {"service":{"asset":"="},"extra":null}, 'widget.html', '', [{name: 'DEFAULT', data: true}], ' oUhbfSbmWfSoUhM', null, ['widget.less']);
        
        TH.installWidgetDirective('users.registration', 'usersRegistration', {"service":null,"extra":null}, 'widget.html', '/widgets/users/registration/widget.js', [{name: 'validateMail', data: false},{name: 'validateUsername', data: false}], ' oUhbwfbfZvbllfWVcC', ['/scripts/utilities/tools.js'], ['widget.less']);
        
        TH.installWidgetDirective('links.listV2', 'linksListV2', {"service":null,"extra":null}, 'widget.ftl', '/widgets/links/listV2/widget.js', [{name: 'linkData', data: true},{name: 'parseLink', data: true},{name: 'list', data: true}], ' oUhbdhbdvXVkyBC', ['directives.js','filters.js'], ['listV2.less']);
        
        TH.installWidgetDirective('errors.recaptcha', 'errorsRecaptcha', {"service":null,"extra":null}, 'widget.html', '/widgets/errors/recaptcha/widget.js', null, ' oUhbfptaR_fSfWVcC', null, ['widget.less']);
        
        TH.installWidgetDirective('users.uiPrefs', 'usersUiPrefs', {"service":null,"extra":null}, 'widget.html', '/widgets/users/uiPrefs/widget.js', null, '', null, null);
        
        TH.installWidgetDirective('users.loginForm', 'usersLoginForm', {"service":null,"extra":null}, 'widget.html', '/widgets/users/loginForm/widget.js', null, ' oUhbwfbjZcpWoUhM', null, ['widget.less']);
        
        TH.installWidgetDirective('links.sources.mini', 'linksSourcesMini', {"service":{"link":"="},"extra":null}, 'widget.html', '', [{name: 'DEFAULT', data: true}], ' oUhbdhbqvRbefWfSC', null, ['mini.less']);
        
        TH.installWidgetDirective('users.noMembership', 'usersNoMembership', {"service":null,"extra":null}, 'widget.html', '/widgets/users/noMembership/widget.js', null, ' oUhbwfblaYfjhfWVcC', null, ['widget.less']);
        
        TH.installWidgetDirective('errors.general', 'errorsGeneral', {"service":null,"extra":null}, 'widget.html', '/widgets/errors/general/widget.js', null, ' oUhbfptQbfWfWVcC', null, ['widget.less']);
        
        TH.installWidgetDirective('manage.customNotifications.preview', 'manageCustomNotificationsPreview', {"service":null,"extra":null}, 'widget.html', '/widgets/manage/customNotifications/preview/widget.js', null, ' oUhbXYVMwrjrYVdgpZfnkZfnkM dLgZWBLPpWkKeXB', null, ['preview.less','/lib/froala-2/css/froala_style.min.css']);
        
        TH.installWidgetDirective('assets.mini', 'assetsMini', {"service":{"asset":"="},"extra":null}, 'widget.html', '', [{name: 'DEFAULT', data: true}], ' oUhbcgvWfSoUhM', null, ['widget.less']);
        
        TH.installWidgetDirective('links.postPreview', 'linksPostPreview', {"service":{"url":"=","edit":"="},"extra":null}, 'widget.html', '/widgets/links/postPreview/widget.js', [{name: 'topics', data: true},{name: 'DEFAULT', data: true}], ' oUhbdhbnvqjXfoUhM', null, ['widget.less']);
        
        TH.installWidgetDirective('header.zonesDropdown', 'headerZonesDropdown', {"service":{"portal":"="},"extra":{"hover":"="}}, 'widget.html', '/widgets/header/zonesDropdown/widget.js', [{name: 'DEFAULT', data: true}], '', null, null);
        
        TH.installWidgetDirective('manage.customNotifications.test', 'manageCustomNotificationsTest', {"service":{"customNotification":"="},"extra":null}, 'widget.html', '/widgets/manage/customNotifications/test/widget.js', [{name: 'searchGroups', data: true},{name: 'DEFAULT', data: true},{name: 'searchUsers', data: true}], ' oUhbXYVMwrjrYVdgpcgcoUhM', null, ['widget.less']);
        
        TH.installWidgetDirective('manage.revisions', 'manageRevisions', {"service":{"node":"=","body":"=","masterTemplate":"=","format":"=","mode":"="},"extra":null}, 'widget.html', '/widgets/manage/revisions/widget.js', [{name: 'DEFAULT', data: true},{name: 'revision', data: true}], ' oUhbXYVajkgpfWVcC', null, ['widget.less']);
        
        TH.installWidgetDirective('content.commentBox', 'contentCommentBox', {"service":{"parent":"="},"extra":{"count":"=","limited":"="}}, 'widget.html', '/widgets/content/commentBox/widget.js', [{name: 'post', data: false},{name: 'edit', data: false},{name: 'DEFAULT', data: true}], ' oUhbaqbcaibevMkaqbC', null, ['comments.less']);
        
        TH.installWidgetDirective('article.listV2', 'articleListV2', {"service":null,"extra":null}, 'widget.html', '/widgets/article/listV2/widget.js', [{name: 'list', data: true},{name: 'sortCount', data: true}], ' oUhbblYOdvXKuV_VkcC', ['directives.js'], ['article-list.less']);
        
        TH.installWidgetDirective('leads.addCRM', 'leadsAddCRM', {"service":null,"extra":null}, 'widget.html', '/widgets/leads/addCRM/widget.js', [{name: 'DEFAULT', data: true}], ' oUhb_ObOQnKRMnM oUhbcgvKRcgcONfPC', ['/scripts/utilities/tools.js'], ['add-crm.less','add-ref.less']);
        
        TH.installWidgetDirective('users.questionForm', 'usersQuestionForm', {"service":null,"extra":null}, 'widget.html', '/widgets/users/questionForm/widget.js', null, ' oUhbwfbuglldnfWVcC', null, ['widget.less']);
            </script>
</body>